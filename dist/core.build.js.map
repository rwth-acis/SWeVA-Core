{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/core/compilers/assemblyScriptCompiler.js","app/core/compilers/compiler.js","app/core/composables/composable.js","app/core/composables/composition.js","app/core/composables/module.js","app/core/core.js","app/core/errors/ExecutionError.js","app/core/errors/compileError.js","app/core/errors/definitionError.js","app/core/errors/errorManager.js","app/core/errors/swevaError.js","app/core/execution/composableLoader.js","app/core/execution/executionManager.js","app/core/execution/supportLibrary.js","app/core/network/potentialOffloadingTarget.js","app/core/offloading/offloadingDecision.js","app/core/offloading/offloadingResources.js","app/core/runners/assemblyScriptRunner.js","app/core/runners/runner.js","app/core/swevaScript/swevaScript.js","node_modules/ajv/lib/ajv.js","node_modules/ajv/lib/cache.js","node_modules/ajv/lib/compile/_rules.js","node_modules/ajv/lib/compile/equal.js","node_modules/ajv/lib/compile/formats.js","node_modules/ajv/lib/compile/index.js","node_modules/ajv/lib/compile/resolve.js","node_modules/ajv/lib/compile/rules.js","node_modules/ajv/lib/compile/schema_obj.js","node_modules/ajv/lib/compile/util.js","node_modules/ajv/lib/dotjs/allOf.js","node_modules/ajv/lib/dotjs/anyOf.js","node_modules/ajv/lib/dotjs/dependencies.js","node_modules/ajv/lib/dotjs/enum.js","node_modules/ajv/lib/dotjs/format.js","node_modules/ajv/lib/dotjs/items.js","node_modules/ajv/lib/dotjs/maxItems.js","node_modules/ajv/lib/dotjs/maxLength.js","node_modules/ajv/lib/dotjs/maxProperties.js","node_modules/ajv/lib/dotjs/maximum.js","node_modules/ajv/lib/dotjs/minItems.js","node_modules/ajv/lib/dotjs/minLength.js","node_modules/ajv/lib/dotjs/minProperties.js","node_modules/ajv/lib/dotjs/minimum.js","node_modules/ajv/lib/dotjs/multipleOf.js","node_modules/ajv/lib/dotjs/not.js","node_modules/ajv/lib/dotjs/oneOf.js","node_modules/ajv/lib/dotjs/pattern.js","node_modules/ajv/lib/dotjs/properties.js","node_modules/ajv/lib/dotjs/ref.js","node_modules/ajv/lib/dotjs/required.js","node_modules/ajv/lib/dotjs/uniqueItems.js","node_modules/ajv/lib/dotjs/validate.js","node_modules/ajv/lib/refs/json-schema-draft-04.json","node_modules/as-bind/dist/as-bind.cjs.js","node_modules/async-mqtt/index.js","node_modules/available-typed-arrays/index.js","node_modules/base64-js/index.js","node_modules/bl/bl.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/builtin-status-codes/browser.js","node_modules/call-bind/callBound.js","node_modules/call-bind/index.js","node_modules/clone/clone.js","node_modules/core-util-is/lib/util.js","node_modules/d/auto-bind.js","node_modules/d/index.js","node_modules/duplexify/index.js","node_modules/end-of-stream/index.js","node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js","node_modules/es5-ext/array/#/clear.js","node_modules/es5-ext/array/#/e-index-of.js","node_modules/es5-ext/array/from/index.js","node_modules/es5-ext/array/from/is-implemented.js","node_modules/es5-ext/array/from/shim.js","node_modules/es5-ext/function/is-arguments.js","node_modules/es5-ext/function/is-function.js","node_modules/es5-ext/function/noop.js","node_modules/es5-ext/math/sign/index.js","node_modules/es5-ext/math/sign/is-implemented.js","node_modules/es5-ext/math/sign/shim.js","node_modules/es5-ext/number/is-nan/index.js","node_modules/es5-ext/number/is-nan/is-implemented.js","node_modules/es5-ext/number/is-nan/shim.js","node_modules/es5-ext/number/to-integer.js","node_modules/es5-ext/number/to-pos-integer.js","node_modules/es5-ext/object/_iterate.js","node_modules/es5-ext/object/assign/index.js","node_modules/es5-ext/object/assign/is-implemented.js","node_modules/es5-ext/object/assign/shim.js","node_modules/es5-ext/object/copy.js","node_modules/es5-ext/object/create.js","node_modules/es5-ext/object/for-each.js","node_modules/es5-ext/object/is-object.js","node_modules/es5-ext/object/is-value.js","node_modules/es5-ext/object/keys/index.js","node_modules/es5-ext/object/keys/is-implemented.js","node_modules/es5-ext/object/keys/shim.js","node_modules/es5-ext/object/map.js","node_modules/es5-ext/object/normalize-options.js","node_modules/es5-ext/object/primitive-set.js","node_modules/es5-ext/object/set-prototype-of/index.js","node_modules/es5-ext/object/set-prototype-of/is-implemented.js","node_modules/es5-ext/object/set-prototype-of/shim.js","node_modules/es5-ext/object/valid-callable.js","node_modules/es5-ext/object/valid-value.js","node_modules/es5-ext/string/#/contains/index.js","node_modules/es5-ext/string/#/contains/is-implemented.js","node_modules/es5-ext/string/#/contains/shim.js","node_modules/es5-ext/string/is-string.js","node_modules/es6-iterator/array.js","node_modules/es6-iterator/for-of.js","node_modules/es6-iterator/get.js","node_modules/es6-iterator/index.js","node_modules/es6-iterator/is-iterable.js","node_modules/es6-iterator/string.js","node_modules/es6-iterator/valid-iterable.js","node_modules/es6-map/index.js","node_modules/es6-map/is-implemented.js","node_modules/es6-map/is-native-implemented.js","node_modules/es6-map/lib/iterator-kinds.js","node_modules/es6-map/lib/iterator.js","node_modules/es6-map/polyfill.js","node_modules/es6-symbol/index.js","node_modules/es6-symbol/is-implemented.js","node_modules/es6-symbol/is-symbol.js","node_modules/es6-symbol/lib/private/generate-name.js","node_modules/es6-symbol/lib/private/setup/standard-symbols.js","node_modules/es6-symbol/lib/private/setup/symbol-registry.js","node_modules/es6-symbol/polyfill.js","node_modules/es6-symbol/validate-symbol.js","node_modules/event-emitter/index.js","node_modules/events/events.js","node_modules/ext/global-this/implementation.js","node_modules/ext/global-this/index.js","node_modules/ext/global-this/is-implemented.js","node_modules/foreach/index.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/get-intrinsic/index.js","node_modules/has-symbols/index.js","node_modules/has-symbols/shams.js","node_modules/has-tostringtag/shams.js","node_modules/has/src/index.js","node_modules/https-browserify/index.js","node_modules/ieee754/index.js","node_modules/in-array/index.js","node_modules/inherits/inherits_browser.js","node_modules/is-arguments/index.js","node_modules/is-generator-function/index.js","node_modules/is-typed-array/index.js","node_modules/isarray/index.js","node_modules/js-tokens/index.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/mqtt-packet/constants.js","node_modules/mqtt-packet/generate.js","node_modules/mqtt-packet/mqtt.js","node_modules/mqtt-packet/numbers.js","node_modules/mqtt-packet/packet.js","node_modules/mqtt-packet/parser.js","node_modules/mqtt-packet/writeToStream.js","node_modules/mqtt/lib/client.js","node_modules/mqtt/lib/connect/index.js","node_modules/mqtt/lib/connect/tcp.js","node_modules/mqtt/lib/connect/tls.js","node_modules/mqtt/lib/connect/ws.js","node_modules/mqtt/lib/connect/wx.js","node_modules/mqtt/lib/store.js","node_modules/mqtt/lib/validations.js","node_modules/once/once.js","node_modules/os-browserify/browser.js","node_modules/path-browserify/index.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/node_modules/safe-buffer/index.js","node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","node_modules/readable-stream/readable-browser.js","node_modules/reinterval/index.js","node_modules/safe-buffer/index.js","node_modules/stream-http/index.js","node_modules/stream-http/lib/capability.js","node_modules/stream-http/lib/request.js","node_modules/stream-http/lib/response.js","node_modules/stream-http/node_modules/readable-stream/errors-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_transform.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/from-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/state.js","node_modules/stream-http/node_modules/readable-stream/readable-browser.js","node_modules/stream-shift/index.js","node_modules/systeminformation/lib/audio.js","node_modules/systeminformation/lib/battery.js","node_modules/systeminformation/lib/bluetooth.js","node_modules/systeminformation/lib/cpu.js","node_modules/systeminformation/lib/docker.js","node_modules/systeminformation/lib/dockerSocket.js","node_modules/systeminformation/lib/filesystem.js","node_modules/systeminformation/lib/graphics.js","node_modules/systeminformation/lib/index.js","node_modules/systeminformation/lib/internet.js","node_modules/systeminformation/lib/memory.js","node_modules/systeminformation/lib/network.js","node_modules/systeminformation/lib/osinfo.js","node_modules/systeminformation/lib/printer.js","node_modules/systeminformation/lib/processes.js","node_modules/systeminformation/lib/system.js","node_modules/systeminformation/lib/usb.js","node_modules/systeminformation/lib/users.js","node_modules/systeminformation/lib/util.js","node_modules/systeminformation/lib/virtualbox.js","node_modules/systeminformation/lib/wifi.js","node_modules/systeminformation/package.json","node_modules/timers-browserify/main.js","node_modules/type/function/is.js","node_modules/type/lib/resolve-exception.js","node_modules/type/lib/safe-to-string.js","node_modules/type/lib/to-short-string.js","node_modules/type/object/is.js","node_modules/type/plain-function/ensure.js","node_modules/type/plain-function/is.js","node_modules/type/prototype/is.js","node_modules/type/string/coerce.js","node_modules/type/value/ensure.js","node_modules/type/value/is.js","node_modules/url/url.js","node_modules/url/util.js","node_modules/util-deprecate/browser.js","node_modules/util/support/isBufferBrowser.js","node_modules/util/support/types.js","node_modules/util/util.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_readable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_writable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/websocket-stream/stream.js","node_modules/websocket-stream/ws-fallback.js","node_modules/which-typed-array/index.js","node_modules/wrappy/wrappy.js","node_modules/xtend/immutable.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1qDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC58CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC/kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"core.build.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\r\n\r\n//var {asc, assemblyscript} = require('../../../node_modules/assemblyscript/dist/sdk.js');\r\n//var AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\r\n//var AsBindTransform = require('../../../node_modules/as-bind/dist/transform.cjs');\r\nvar Runner = require('../../core/runners/runner.js');\r\nvar Compiler = require('../../core/compilers/compiler.js');\r\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\r\nvar Composable = require('../../core/composables/composable.js');\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\nvar CompileError = require('../../core/errors/compileError.js');\r\nconst DefinitionError = require(\"../../core/errors/ExecutionError.js\");\r\nconst offloadingDecision = require(\"../offloading/offloadingDecision\");\r\n\r\n//var AssemblyScriptGetterTransform = require('./assemblyScriptGetterTransform.js');\r\n\r\n/** include web-worker library for Nodejs **/\r\n\r\nif(typeof Worker === 'undefined') {\r\n    console.log(\"Loading Node worker module\");\r\n    var WorkerNodeJS = require('../../../node_modules/web-worker/cjs/node');\r\n}\r\n\r\n\r\n/**\r\n * The AssemblyScriptCompiler supports strict TypeScript\r\n *\r\n * @constructor\r\n * @extends Compiler\r\n *\r\n */\r\nfunction AssemblyScriptCompiler(supportLib) {\r\n    this.worker = null;\r\n    this.internalGetterPrefix = \"_internal_get_\";\r\n    this.supportLibraryDeclares = this.generateSupportLibraryDeclares(supportLib);\r\n    this.supportLibraryDocumentation = \"The lib namespace contains all function from the support library.\\n\" +\r\n        \"synchronous functions return their result immediately, while the callback for asynchronous functions is called after all currently running AssemblyScript code is finished.\\n\" +\r\n        \"Callback functions can have less parameters than the listed parameters, in which case only the first parameters are passed.\\n\" +\r\n        \"Functions:\\n\";\r\n    this.resolveCompile = null;\r\n}\r\n\r\n//inherit properties\r\nAssemblyScriptCompiler.prototype = Object.create(Compiler.prototype);\r\nAssemblyScriptCompiler.prototype.constructor = AssemblyScriptCompiler;\r\n\r\n/**\r\n * generates declare statements necessary, to access JavaScript functions from AssemblyScript\r\n * additionally the documentation is generated\r\n * @param supportLib\r\n */\r\nAssemblyScriptCompiler.prototype.generateSupportLibraryDeclares = function (supportLib) {\r\n    let docs = \"\";\r\n    let declares = \"namespace lib {\\n\";\r\n    for(let funcName in supportLib.functions) {\r\n        let returnSig = supportLib.functions[funcName].languageSpecific.typescript.returnSig || \"void\";\r\n        let paramSig = supportLib.functions[funcName].languageSpecific.typescript.parameterSig;\r\n        //callback function name is first parameter for asynchronous functions\r\n        if(supportLib.functions[funcName].async) {\r\n            paramSig = \"callback: string | null\" + (typeof paramSig !== undefined ? \", \"+paramSig : \"\");\r\n            returnSig = \"void\";\r\n        }\r\n        docs += funcName+\":\\n\"+\r\n            \"  Description: \"+supportLib.functions[funcName].description+\"\\n\"+\r\n            \"  Parameters: \\\"\"+paramSig+\"\\\"\\n\"+\r\n            \"  \"+(supportLib.functions[funcName].async?\r\n                \"Async function: callback with signature \\\"\"+supportLib.functions[funcName].languageSpecific.typescript.returnSig+\"\\\" required\":\r\n                \"Sync function: returns \\\"\"+returnSig+\"\\\"\")+\r\n            \"\\n\";\r\n        declares += \"export declare function \" + funcName + \"(\" + paramSig + \"):\" + returnSig + \";\\n\";\r\n    }\r\n    declares += \"}\";\r\n    this.supportLibraryDocumentation = docs;\r\n    console.log(\"Support functions:\");\r\n    console.log(this.supportLibraryDocumentation);\r\n    console.log(declares)\r\n    return declares;\r\n}\r\n\r\nAssemblyScriptCompiler.prototype.setup = async function () {\r\n    var self = this;\r\n\r\n    if(!this.setupCompleted) {\r\n        return new Promise((resolve) => {\r\n            console.log(\"Loading AssemblyScript compiler\");\r\n\r\n            this.initWorker();\r\n\r\n            this.worker.onmessage = function (e) {\r\n                console.log('msg to worker');\r\n                console.log(e.data);\r\n                switch (e.data.type) {\r\n                    case \"setupComplete\":\r\n                        console.log(\"setup complete\")\r\n                        self.setupCompleted = true;\r\n                        resolve();\r\n                        break;\r\n                    case \"compileError\":\r\n                    case \"compileResult\":\r\n                        if(self.resolveCompile != null) {\r\n                            self.resolveCompile(e.data);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nAssemblyScriptCompiler.prototype.initWorker = function() {\r\n    if(typeof this.worker != 'undefined' && this.worker != null) {\r\n        this.worker.terminate();\r\n    }\r\n\r\n    //different path for NodeJS\r\n    if(sweva.inBrowser) {\r\n        console.log(\"Load worker for webbrowser\");\r\n        this.worker = new Worker('/node_modules/sweva-core/app/core/compilers/assemblyScriptCompilerWorker.js');\r\n    } else {\r\n        console.log(\"Load worker for NodeJS\");\r\n        this.worker = new WorkerNodeJS('app/core/compilers/assemblyScriptCompilerWorker.js');\r\n    }\r\n}\r\n// MA\r\nAssemblyScriptCompiler.prototype.compile = async function (module) {\r\n\r\n    const self = this;\r\n    while (this.currentlyCompiling) {\r\n        new Promise(resolveWait => setTimeout(resolveWait, 1));\r\n    }\r\n    this.currentlyCompiling = true;\r\n\r\n    //load compiler\r\n    await this.setup();\r\n\r\n    let doneCompiling = false;\r\n    let offloading = false;\r\n    let intervalID;\r\n    let odList =[1,1,70]; //todo: user input\r\n    let startCPU =performance.now();\r\n    let endCPU = 0;\r\n    let cpuMonitor=0;\r\n    // initial mem / battery check\r\n    offloading = await offloadingDecision(odList);\r\n    console.log('initial offloading decision = ',offloading);\r\n    if (offloading) {\r\n        // optimization: speed is key we do this after resolving promise\r\n        //clearInterval(intervalID);\r\n        //abort running compilation\r\n        return ('offloading');\r\n    }\r\n    return await Promise.race([\r\n        //monitoring the compilation process\r\n        new Promise( async (resolve) => {\r\n            console.log('Begin periodic monitoring execution...');\r\n            // interval check\r\n            intervalID = setInterval(async () => {\r\n                endCPU = performance.now();\r\n                cpuMonitor = ((endCPU - startCPU)/5000)*100;\r\n                console.log('CPU TIME= ', cpuMonitor);\r\n                if (cpuMonitor > odList[0]) {\r\n                    console.log(\"Monitoring = CPU limit exceeded\");\r\n                    resolve('offloading');\r\n                }\r\n                offloading = await offloadingDecision(odList);\r\n                console.log('periodic offloading decision = ', offloading);\r\n                if (offloading) {\r\n                    // optimization: speed is key we do this after resolving promise\r\n                    //clearInterval(intervalID);\r\n                    //abort running compilation\r\n                    resolve('offloading');\r\n                }\r\n            }, 1);\r\n        }),\r\n\r\n        // compiling the module\r\n        new Promise((resolve) => {\r\n\r\n            this.resolveCompile = resolve;\r\n            doneCompiling = true;\r\n            this.worker.postMessage({type: \"compile\", source: self.prepareSourceCode(module.source)});\r\n\r\n        })\r\n\r\n\r\n\r\n    ]).\r\n    then((wr) => {\r\n\r\n        let workerResult = wr;\r\n\r\n        clearInterval(intervalID); //clear monitoring interval if no offloading necessary\r\n        console.log('workerResult');\r\n        console.log(workerResult);\r\n        this.currentlyCompiling = false;\r\n\r\n        this.resolveCompile = null;\r\n\r\n        if (workerResult.type === \"compileResult\") {\r\n            console.log('Offloading not needed. Proceed as normal');\r\n            return workerResult;\r\n        } else if (workerResult === 'offloading') {\r\n            //todo: offloading callback\r\n            this.initWorker();\r\n            console.log(\"Offloading necessary. Callback triggered\");\r\n            return 'offloading'; //todo: is String a good DT for return ?\r\n        } else\r\n            throw new CompileError(workerResult.message, module.context);  // Compiler Error handling\r\n\r\n    });\r\n\r\n}\r\n\r\n\r\nAssemblyScriptCompiler.prototype.prepareSourceCode = function(source) {\r\n    let getters = this.generateGlobalGetters(source);\r\n    let sourceStr = source.join(\"\\n\");\r\n    return this.supportLibraryDeclares + sourceStr + getters;\r\n}\r\n\r\nAssemblyScriptCompiler.prototype.generateGlobalGetters = function(source) {\r\n    let getters = \"\";\r\n    for(let line in source) {\r\n        if(source.includes(this.internalGetterPrefix)) {\r\n            throw new CompileError(\"Do not use \"+this.internalGetterPrefix+\" for names in your source, as it is reserved for internal use.\", \"compileError\");\r\n        }\r\n        else if(source[line].indexOf(\"export var\") === 0) {\r\n            let tmp = source[line].split('=')[0].split(':');\r\n            let type = \"anyref\";\r\n            if(tmp.length >= 2)\r\n                type = tmp[1].split(/[\\s=]+/).filter(x => x !== \"\")[0];\r\n            else\r\n                throw new CompileError(\"Exported variables require an explicit type! \\n\\\"\"+source[line]+\"\\\" does not contain a type.\", \"compileError\");\r\n            tmp = tmp[0].split(/[\\s=]+/).filter(x => x !== \"\");\r\n            let name = tmp[tmp.length-1];\r\n            getters += \"export function \"+this.internalGetterPrefix+name+\"():\"+type+\" { return \"+name+\"; }\\n\";\r\n        }\r\n    }\r\n\r\n    return getters;\r\n}\r\n\r\nmodule.exports = AssemblyScriptCompiler;","'use strict';\r\n\r\n/**\r\n * The compiler loads the necessary resources for compilation of a language, compiles code and returns the resulting binary.\r\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\r\n * \r\n * The setup needs to be done only once, while the execution can be repeated on different data.\r\n * Additionally the setup should only be called, when the compiler is needed, because some dependencies for compiling can be very large\r\n * \r\n * This is a default implementation, returning the input source as the compiled code. It can be used for interpreted languages.\r\n *\r\n * @param {SupportLibrary} supportLibrary - source code to compile\r\n * @constructor\r\n */\r\nfunction Compiler(supportLibrary) {\r\n    /**\r\n     * Determines, if dependencies are loaded.\r\n     * @name Compiler#setupCompleted\r\n     * @type {boolean}\r\n     */\r\n    this.setupCompleted = false;\r\n\r\n    /**\r\n     * Documentation for functions in support library - should include specifics on language syntax\r\n     * Available after Compiler#setup() has been called.\r\n     * @name Compiler#setupCompleted\r\n     * @type {string}\r\n     */\r\n    this.supportLibraryDocumentation = \"\";\r\n}\r\n\r\n/**\r\n * Compile the provided source code\r\n * @param {module} source - source code to compile\r\n * @return {object} containing binaryData and optionally other properties of specific compilers\r\n */\r\nCompiler.prototype.compile = function (source) {\r\n    return source;\r\n}\r\n   \r\n/**\r\n * Loads dependencies\r\n */\r\nCompiler.prototype.setup = async function () {\r\n    if(!this.setupCompleted) {\r\n        this.setupCompleted = true;\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = Compiler","'use strict';\r\n\r\nvar DefinitionError = require('../../core/errors/definitionError.js');\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\nvar Clone = require('../../../node_modules/clone/clone.js');\r\n\r\n/**\r\n * Composables process data. They can be linked into networks.\r\n * @abstract\r\n * @constructor\r\n */\r\nfunction Composable() {\r\n}\r\n/**\r\n * A definition of a JSON object.\r\n * @see {@link http://json-schema.org/documentation.html}\r\n * @typedef {Object} JSONSchema\r\n */\r\n\r\n/**\r\n * The initalization object with optional properties to initialize composables.\r\n * @typedef {Object} composableInitalizer\r\n * @property {string} [name=someComposable] - The name of the composable.\r\n * @property {string} [type=module] - The type of the composable: 'module' or 'composition'.\r\n * @property {JSONSchema} [dataInSchema=null] - The schema of the expected data object received from other composables.\r\n * @property {JSONSchema} [dataOutSchema=null] - The schema of the data object passed on to later composables.\r\n * @property {JSONSchema} [inputSchema=null] - The schema of the input object received at the beginning of exection.\r\n * @property {Array.<string>} [dataInNames=['data']] - The names of the expected properties of the received data object.\r\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\r\n * Multiple properties are needed, if you want to receive data from multiple other composables.\r\n *\r\n * @property {Array.<string>} [dataOutNames=['result']] - The names of the expected properties of the produced data object.\r\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\r\n * Multiple properties are needed, if you want to send data to multiple other composables.\r\n *\r\n * @property {Array.<string>} [inputNames=[]] - The names of the expected properties of the input object.\r\n * If there is only one element, the array is ignored and the whole input object is taken (no property names needed).\r\n */\r\n\r\n/** Initializes the object with a property object.\r\n  * Not defined Properties will get a default value.\r\n *  @protected\r\n *  @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\r\n */\r\nComposable.prototype.initialize = function (initializationObject) {\r\n    this.initializeProperty(initializationObject, 'name', 'someComposable');\r\n    this.initializeProperty(initializationObject, 'type', 'module');\r\n    this.initializeProperty(initializationObject, 'dataInSchema', null);\r\n    this.initializeProperty(initializationObject, 'dataOutSchema', null);\r\n    this.initializeProperty(initializationObject, 'inputSchema', null);\r\n\r\n    this.initializeProperty(initializationObject, 'dataInNames', []);\r\n    this.initializeProperty(initializationObject, 'dataOutNames', []);\r\n    this.initializeProperty(initializationObject, 'inputNames', []);\r\n\r\n    /**\r\n     * Amount of expected properties for the received data object.\r\n     * @name Composable#dataIn\r\n     * @type {number}\r\n     */\r\n    this.dataIn = this.dataInNames.length;\r\n\r\n    /**\r\n    * Amount of expected properties for the produced data object.\r\n    * @name Composable#dataOut\r\n    * @type {number}\r\n    */\r\n    this.dataOut = this.dataOutNames.length;\r\n\r\n    /**\r\n    * Amount of expected properties for the received input object\r\n    * @name Composable#inputIn\r\n    * @type {number}\r\n    */\r\n    this.inputIn = this.inputNames.length;\r\n\r\n    /**\r\n    * The context of the composable used for error messages.\r\n    * @name Composable#context\r\n    * @type {number}\r\n    */\r\n    this.context = this.constructor.name + '[' + this.name + ']';\r\n}\r\n\r\n/**\r\n * Helper function to initialize internal variables. Sets also default values.\r\n * @protected\r\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\r\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\r\n * @param {string} defaultValue - A default value is set, if initializationObject does not contain such a property key.\r\n */\r\nComposable.prototype.initializeProperty = function (initializationObject,\r\n    property, defaultValue) {\r\n    if (initializationObject.hasOwnProperty(property)) {\r\n        var obj = initializationObject[property];\r\n        if (typeof obj === 'object') {\r\n            if (Array.isArray(obj)) {\r\n                if (obj.length == 0) {\r\n                    this[property] = defaultValue;\r\n                    return;\r\n                }\r\n            }\r\n            else if (Object.keys(obj).length == 0){\r\n                this[property] = defaultValue;\r\n                return;\r\n            }\r\n        }\r\n        this[property] = initializationObject[property];\r\n    } else {\r\n        this[property] = defaultValue;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to initialize internal functions. Sets also default values.\r\n * @protected\r\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\r\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\r\n * @param {number} expectedArgumentsCount - The amount of arguments the expected function needs to have. On mismatch an error is thrown.\r\n * @param {function} defaultValue - A default value is set, if initializationObject does not contain such a property key.\r\n */\r\nComposable.prototype.initializeFunction = function (initializationObject,\r\n    property, expectedArgumentsCount, defaultValue) {\r\n    if (initializationObject.hasOwnProperty(property)) {\r\n        //check if it is really a function\r\n        if (typeof initializationObject[property] === 'function') {\r\n            //the expected functions (which can be defined by the composable creators) have a fixed signature (arguments),\r\n            //so check here for validation.\r\n            if (initializationObject[property].length >= expectedArgumentsCount) {\r\n                this[property] = initializationObject[property];\r\n            }\r\n            else {\r\n                sweva.ErrorManager.error(\r\n                    new DefinitionError('function \"' + property + '\" requires at least ' +\r\n                    expectedArgumentsCount + ' arguments, but provides only ' +\r\n                    initializationObject[property].length,\r\n                    this.context, initializationObject[property]));\r\n            }\r\n        }\r\n        else if (initializationObject[property] == null) {\r\n            // for now ignore, as some functions are optional\r\n        }\r\n        else {\r\n            sweva.ErrorManager.error(\r\n                   new DefinitionError('\"' + property + '\" is reserved for functions, but not defined as one',\r\n                   this.context, initializationObject[property]));\r\n        }\r\n    }\r\n    else {\r\n        this[property] = defaultValue;\r\n    }\r\n}\r\n/**\r\n * Clones the current composable and overwrites/adds all the properties specified in an extender object.\r\n * This allows some sort of composable inheritance.\r\n * @this Composable\r\n * @param {Composable} extender - The partial composable from which to take the new values.\r\n * @returns {Composable} The cloned and extended composable object.\r\n */\r\nComposable.prototype.extendWith = function (extender) {\r\n    var cloned = Clone(this);\r\n    for (var key in extender) {\r\n        //we don't want to clone 'extends' as it is an indicator, that a composable wants to extend another. I.e. What we are doing here :)\r\n        if (extender.hasOwnProperty(key) && key != 'extends') {\r\n            cloned[key] = extender[key];\r\n        }\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * Updates the context during the execution. It uses the parent's context and the alias, the parent has given this composable.\r\n * looks like: Composition[composition1].Module[module1]\r\n * @protected\r\n * @param {string} context - The context of the parent.\r\n * @param {string} alias - The alias (name) used in the parent for this composable.\r\n * @returns {string} Updated context.\r\n */\r\nComposable.prototype.getNewContext = function (context, alias) {\r\n    if (typeof context === 'string') {\r\n        //alias is optional, so check if it is defined\r\n        if (typeof alias !== 'string') {\r\n            alias = '';\r\n        }\r\n        else {\r\n            alias = ': ' + alias;\r\n        }\r\n        return context + '.' + this.constructor.name + '[' + this.name + alias + ']';\r\n    }\r\n    return this.context;\r\n}\r\n/**\r\n * Validates, if a given object has the expected structure (typecheck) compatible to this composable.\r\n * If available, it uses the provided JSON schema, otherwise (noch schmema available) it only checks, if the object has all required property keys. Defined by the *Names arrays (see {@link composableInitalizer}).\r\n * \r\n * @param {string} type - Type of object, needed to select the correct type definition. Use 'dataIn', 'dataOut' , 'input' respectively.\r\n * @param {Object} obj - Object, that should be validated.\r\n * @returns {boolean} - True, if the object is compatible to this composable regarding the given type.\r\n */\r\nComposable.prototype.validateTypes = function (type, obj) {\r\n    var typeNames = this[type + 'Names'];\r\n    var typeSchema = this[type + 'Schema'];\r\n    \r\n    //if properties are all present and a schema is provided, we can perform a more detailed check\r\n    if (typeSchema !== null) {\r\n        //use the validator library on the object\r\n        try {\r\n            var valid = sweva.Ajv.validate(typeSchema, obj);\r\n            if (!valid) {\r\n                sweva.ErrorManager.error(new ExecutionError('Object does not match the given ' + type + 'Schema: ' + sweva.Ajv.errorsText(sweva.Ajv.errors),\r\n                    this.context, obj));\r\n                return false;\r\n            }\r\n        } catch(err) {\r\n            /*\r\n            ignore, because an invalid schema like generated by AssemblyScript is generated from the source and\r\n            already matches the input/output data. Consider adding the custom types to the validator, if this is not the\r\n            case for future added languages.\r\n             */\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n/**\r\n * Function to start the data processing. Here only a dummy is defined.\r\n * @param {Object} data - Tha data object received.\r\n * @param {Object} input - The input object received.\r\n * @return {Promise<number>} - The processed data.\r\n */\r\nComposable.prototype.execute = function (data, input) {\r\n    return new Promise(function (resolve, reject) {\r\n        resolve(0);\r\n    });\r\n}\r\nmodule.exports = Composable;","'use strict';\r\n\r\nvar Composable = require('../../core/composables/composable.js');\r\nvar Module = require('../../core/composables/module.js');\r\nvar DefinitionError = require('../../core/errors/definitionError.js');\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\n\r\n/**\r\n * Represents how a composable is linked to another\r\n * @typedef {Object} linkType\r\n * @property {string} to - The alias/name of the target composable (i.e. under which key it is defined in the composables dictionary of the composition)\r\n * @property {string|Object.<string,string>} mapping - How dataOut and dataIn of two composables are mapped to each other.\r\n * If no mapping is specified, the whole dataOut object is taken as the dataIn object.\r\n * If a string is specified as a value, it is mapped to the appropriate dataIn property.\r\n * If a dictionary is specified, the key represents the dataOut property and thevalue the dataIn property it is mapped to.\r\n * All string values must be using the given values of the dataInNames and dataOutNames arrays defined in the composable.\r\n */\r\n\r\n/**\r\n * A user defineable function to map the input object of the composition to the input object of individual composables.\r\n * Basically the function is called for each composable and the return value is then used as its input object.\r\n * For example you can use an input object, where you specify in detail for every composable the value, then you could simply\r\n * return input[composableName];\r\n * \r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n * \r\n * @callback Composition~mapInputFunction\r\n * @param {Object} input - The input object given to the composition.\r\n * @param {string} composableName - The name of the composable requesting an input object.\r\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\r\n * @param {Object} libs - A library object provides access to libs from within the function.\r\n * @returns {Object} A value to use for the requesting composable as the input object.\r\n */\r\n\r\n/**\r\n * A user defineable function to map the data object of the composition to the data object of individual composables.\r\n * Basically the function is called for each composable and the return value is then used as its data object.\r\n * For example you can use a data object, where you specify in detail for every composable the value, then you could simply\r\n * return data[composableName];\r\n * \r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n * \r\n * @callback Composition~mapDataInFunction\r\n * @param {Object} data - The data object given to the composition.\r\n * @param {string} composableName - The name of the composable requesting a data object.\r\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\r\n * @param {Object} libs - A library object provides access to libs from within the function.\r\n * @returns {Object} A value to use for the requesting composable as the data object.\r\n */\r\n\r\n/**\r\n * A user defineable function to transform the resulting data object of the data processing pipeline.\r\n * You could for example add additional properties or remove some, convert values etc.\r\n * \r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n * \r\n * @callback Composition~mapDataOutFunction\r\n * @param {Object} output - The data object produced by the composables without outgoing links (end of data processing).\r\n * @returns {Object} A value the composition returns as the dataprocessing result.\r\n */\r\n\r\n\r\n/**\r\n * The initalization object with optional properties to initialize composables.\r\n * @typedef {composableInitalizer} compositionInitalizer\r\n * @property {Object.<string,string>} [composables={}] - A dictionary of all composables used by the composition. \r\n * The key represents the internal alias, the value represents \r\n * the composable name, which is used to load the composable information.\r\n * \r\n * @property {Object.<string, Array.<linkType>>} [links={}] - A dictionary describing an edge list of how the composables are linked.\r\n * The key describes the origin composable, the value describes an array of target composables with mapping information of the data properties.\r\n * @property {Composition~mapInputFunction} [mapInput] - A function to map the input object of the composition to the input object of individual composables.\r\n * The default requires an input object, where each property corresponds to a composable alias/name and maps the value of the property to this composable input.\r\n * @property {Composition~mapDataInFunction} [mapDataIn] - A function to map the data object of the composition to the data object of individual composables.\r\n * The default requires a data object, where each property corresponds to a composable alias/name and maps the value of the property to this composable data.\r\n * @property {Composition~mapDataOutFunction} [mapDataOut] - A function to transform the resulting data object of the composition, before making it available.\r\n * The default does not change the output object.\r\n */\r\n\r\n/**\r\n * A composition can consist of multiple other compositions or composables.\r\n * It orchistrates the execution of the composables.\r\n * @constructor\r\n * @extends Composable\r\n * @param {compositionInitalizer} initializationObject - The object with optional properties for the composition.\r\n * \r\n */\r\nfunction Composition(initializationObject, manager) {\r\n    this.manager = manager;\r\n\r\n    this.initializeProperty(initializationObject, 'composables', {});\r\n    this.initializeProperty(initializationObject, 'links', {});\r\n\r\n    this.initializeFunction(initializationObject, 'mapInput', 4, function (input, composableName, composables, libs) {\r\n        if (input.hasOwnProperty(composableName)) {\r\n            return input[composableName];\r\n        }\r\n        return null;\r\n    });\r\n\r\n    this.initializeFunction(initializationObject, 'mapDataIn', 4, function (data, composableName, composables, libs) {\r\n        if (data.hasOwnProperty(composableName)) {\r\n            return data[composableName];\r\n        }\r\n        return null;\r\n    });\r\n\r\n    this.initializeFunction(initializationObject, 'mapDataOut', 2, function (output, libs) {\r\n        return output;\r\n    });\r\n    //call to the parent class initalization function\r\n    this.initialize(initializationObject);\r\n\r\n    /**\r\n    * Indicates, if the composition is ready to use. This is important, as required composables might need to be loaded first.\r\n    * @protected\r\n    * @name Composition#isReady\r\n    * @type {boolean}\r\n    */\r\n    this.isReady = false;\r\n}\r\n//inherit properties\r\nComposition.prototype = Object.create(Composable.prototype);\r\n\r\n/**\r\n * This function starts to recursively load composables required by this composition.\r\n * See {@link ComposableLoader} for more details on he loading process.\r\n * When finished all required composables are in memory and can be used.\r\n * As loading is async it returns a promise. \r\n * @returns {Promise<void>} An empty promise, signaling that everything was loaded.\r\n */\r\nComposition.prototype.loadComposables = function () {\r\n    var self = this;\r\n    return new Promise(function (resolve, reject) {\r\n        //collects an array of loading promises, which is then filled\r\n        var promises = [];\r\n        for (var key in self.composables) {\r\n            if (self.composables.hasOwnProperty(key)) {\r\n                //for each required composable the composable is loaded using the specified name of it\r\n                //the name itself acts as a part of a URL\r\n                //a reference to the composables dictionary of the composition is passed, so the\r\n                //string values (names) of the required compositions are later replaced with the comosition objects,\r\n                //which can then be used\r\n                if (typeof self.composables[key] === 'string') {\r\n                    promises.push(sweva.ComposableLoader.load(self.composables[key], self.composables, key));\r\n                }\r\n                else { //otherwise create from given object directly\r\n                    var type = self.composables[key].type;\r\n                    if(type=='module'){\r\n                        self.composables[key] = new Module(self.composables[key], self.manager);\r\n                    }\r\n                    else {\r\n                        self.composables[key] = new Composition(self.composables[key], self.manager);\r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n        }\r\n        //invoke all promises and wait for them to finish\r\n        Promise.all(promises).then(function () {\r\n            //when all promises are finished, all components are loaded, so the composition is ready to be used\r\n            self.isReady = true;\r\n\r\n            //important: as we are dealing here with async operations, one might try to execute the composition, before\r\n            //it is ready to be used. In this case the execution is delayed and indicated (wantsToExecute=true)\r\n            //now if the loading is finished, it can directly start the execution directly itself, using the provided callback\r\n            //no polling needed :)\r\n            if (self.wantsToExecute) {\r\n                self.wantsToExecute = false;\r\n                self.executeStarterCallback();\r\n            }\r\n            \r\n           \r\n            //ok all loaded, now we can analyze graph and check for compatibility\r\n            self.analyzeLinkGraph();\r\n           \r\n            //indicate to the outside, that we are done with everything and the composition can be used\r\n            resolve();\r\n        })\r\n        .catch(function (error) {\r\n            sweva.ErrorManager.error(\r\n                       new ExecutionError('Could not load all composables: ' + error,\r\n                       self.context, self.composables));\r\n            \r\n        });\r\n    });\r\n}\r\n/**\r\n * Checks, if all the data a composable requires is already available.\r\n * As composables are executed in a graph, some composables depend on the calculations of others and have to wait for the data.\r\n * \r\n * For this purpose, the {@link Composable#dataIn} property is used as a count, that has to be reached\r\n * by the amount of properties stored for this composable in {@links Composition#parameters}.\r\n * @protected\r\n * @param {string} composableName - The alias of the composable object, for which the check should be performed.\r\n * @returns {boolean} true, if all data required for the composable is available.\r\n */\r\nComposition.prototype.hasParameters = function (composableName) {\r\n    //how many parameters does the composable need?\r\n    \r\n    var parametersNeeded = [];\r\n    if(typeof this.composables[composableName].dataInConnected !== 'undefined') {\r\n        parametersNeeded = Object.keys(this.composables[composableName].dataInConnected);\r\n    }\r\n    \r\n    \r\n    //if it does not need any, we are good here\r\n    if (parametersNeeded.length === 0) {\r\n        return true;\r\n    }\r\n    \r\n    //if we are still here, it needs at least one\r\n    if (this.parameters.hasOwnProperty(composableName)) {\r\n       \r\n        \r\n        //not enough\r\n        for (var i = 0; i < parametersNeeded.length; i++) {\r\n            var parameter = parametersNeeded[i];\r\n            \r\n            if (typeof this.parameters[composableName][parameter] === 'undefined') {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n        \r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Adds new data to the available pool other composables use.\r\n * This allows dependant composables to fetch the data and start execution.\r\n * It saves the data as a subkey of a subkey of {@links Composition#parameters}:\r\n * this.parameters[composable][property] = value\r\n * @protected\r\n * @param {string} composableName - The alias of the composable object for which the data is intended.\r\n * @param {string} property - The property name to save the data as, the value must correspond to a value defined\r\n * in {@links Composable#dataInNames} (we need correct mapping).\r\n * @param {Object|boolean|string|number} value - The value of the data to add.\r\n */\r\nComposition.prototype.addParameter = function (composableName, property, value) {\r\n    //if no key for composable present, create one\r\n    if (!this.parameters.hasOwnProperty(composableName)) {\r\n        this.parameters[composableName] = {};\r\n    }\r\n\r\n    this.parameters[composableName][property] = value;\r\n}\r\n\r\n/**\r\n * Resets the composition, so it can be executed again.\r\n * @protected\r\n */\r\nComposition.prototype.reset = function () {\r\n    this.parameters = {};    \r\n    this.output = {};\r\n    this.unlcearedComposables = [];\r\n    for (var key in this.composables) {\r\n        if (this.composables.hasOwnProperty(key)) {\r\n            this.unlcearedComposables.push({\r\n                composable: key,\r\n                cleared: false\r\n            });\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * Checks, if the composable graph of the composition contains cycles (end therefore is not a DAG).\r\n * @protected\r\n * @param {Array.<string>} startingNodeArray - An array with the aliases of all composables, that do not have an incoming edge/link.\r\n * They are considered as the first nodes, that get executed.\r\n * @returns {boolean} True, if the graph contains cycles.\r\n */\r\nComposition.prototype.hasCycles = function (startingNodeArray) {\r\n    var nodes = {};\r\n    var edges = {};\r\n\r\n    //first create a copy of the composables in the composition (nodes)\r\n    for (var key in this.composables) {\r\n        if (this.composables.hasOwnProperty(key)) {\r\n            nodes[key] = {}\r\n        }\r\n    }\r\n    //create a copy of the links without mapping information (edges)\r\n    for (var fromNode in this.links) {\r\n        if (this.links.hasOwnProperty(fromNode)) {\r\n            edges[fromNode] = [];\r\n\r\n            for (var fromEndpoint in this.links[fromNode]) {\r\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\r\n                    \r\n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\r\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\r\n\r\n                            edges[fromNode].push(toNode);\r\n\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n            /*for (var i = 0; i < this.links[key].length; i++) {\r\n                edges[key].push(this.links[key][i].to);\r\n            }*/\r\n        }\r\n    }\r\n\r\n    \r\n    //Kahn's algorithm\r\n    //https://en.wikipedia.org/wiki/Topological_sorting\r\n    var L = [];\r\n    var S = startingNodeArray.slice();\r\n    var uniqueL = true;\r\n    while (S.length > 0) {\r\n        var n = S.pop();\r\n\r\n        //sorting only works, if all elements are unique!\r\n        if (L.indexOf(n) >= 0) {\r\n            uniqueL = false;\r\n            break;\r\n        }\r\n        L.push(n);\r\n        if (edges.hasOwnProperty(n)) {\r\n            for (var i = 0; i < edges[n].length; i++) {\r\n                var m = edges[n][i];\r\n                edges[n].splice(i, 1);\r\n\r\n                i--;\r\n\r\n                var hasIncoming = false;\r\n                for (var key in edges) {\r\n                    if (edges.hasOwnProperty(key)) {\r\n                        for (var k = 0; k < edges[key].length; k++) {\r\n                            if (edges[key][k] === m) {\r\n                                hasIncoming = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (hasIncoming) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (!hasIncoming) {\r\n                    S.push(m);\r\n                }\r\n                if (edges[n].length === 0) {\r\n                    delete edges[n];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //if edges exist, or L has non unique elements: there is a cycle\r\n    if (Object.keys(edges).length > 0 || !uniqueL) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Checks, if the schemas of two objects are compatible.\r\n * Two objects are compatible, if one of them has no schema definition, or if the first schema is identical to the second one in a recursive comparison.\r\n * @protected\r\n * @param {string} obj1Name - The name of the first object (from). Only used for error output.\r\n * @param {string} obj2Name - The name of the second object (to). Only used for error output.\r\n * @param {JSONSchema} obj1Schema - The schema ofthe first object.\r\n * @param {JSONSchema} obj2Schema - The schema ofthe second object.\r\n * @param {string} [mappingFrom] - The relevant property name of the first object (source/from).\r\n * @param {string} [mappingTo] - The relevant property name of the second object (target/to).\r\n * @returns {boolean} True, if the object with obj1Schema can be used, where obj2Schema is required. \r\n */\r\nComposition.prototype.checkSchemaCompatibility = function (obj1Name, obj2Name, obj1Schema, obj2Schema, mappingFrom, mappingTo) {\r\n    //schemas are optional (null), so give the benefit of the doubt\r\n    if (obj1Schema == null || obj2Schema == null) { \r\n        return true;\r\n    }\r\n    //use to store error messages\r\n    var error = null;\r\n\r\n    //function for recursion, deals with the meta information level (type, properties, required, etc) of the JSONSchema\r\n    //level indicates the poperty chain and is used for error messages\r\n    function metaLevel(level, from, to) {\r\n        //iterate over the target keys (obj2Schema)\r\n        for (var key in to) {\r\n            //the source (obj1Schema) must have all keys the target has\r\n            if (key !== 'items' && key !== 'required' && !from.hasOwnProperty(key)) {\r\n                error = {\r\n                    level: level,\r\n                    message: 'missing property \"' + key + '\"'\r\n                }\r\n                return false;\r\n            }\r\n            //if we are dealing with an array, proceed to the meta-level\r\n            if (key === 'items' && from.hasOwnProperty(key)) {\r\n                if (!metaLevel(level + '.' + key, from[key], to[key])) {\r\n                    return false;\r\n                }\r\n            }\r\n            //if properties are defined, proceed with the recursion using the propertyLevel\r\n            else if (key === 'properties' && from.hasOwnProperty(key)) {\r\n                if (!propertyLevel(level + '.' + key, from[key], to[key])) {\r\n                    return false;\r\n                }\r\n            }\r\n            //if we get to the required array...\r\n            else if (key === 'required' && from.hasOwnProperty(key)) {\r\n                //special: required array order should be ignored\r\n                from[key].sort();\r\n                to[key].sort();\r\n\r\n                //first check if the length is the same\r\n                if (from[key].length !== to[key].length) {\r\n                    error = {\r\n                        level: level,\r\n                        message: 'array length different for \"' + key + '\" ' + from[key].toString() + ' != ' + to[key].toString()\r\n                    }\r\n                    return false;\r\n                }\r\n                //otherwise we need to compare each element\r\n                for (var i = 0; i < from[key].length; i++) {\r\n                    if (from[key][i] !== to[key][i]) {\r\n                        error = {\r\n                            level: level,\r\n                            message: 'array element difference for \"' + key + '\" ( ' + from[key][i] + ' != ' + to[key][i]\r\n                                + ' ) ' + from[key].toString() + ' != ' + to[key].toString()\r\n                        }\r\n\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            //if we get something else, we compare the values\r\n            //this should be all primitive types, but I'm not sure if I didn't miss any possible non-primitive\r\n            //in the above if-else\r\n            else if (from.hasOwnProperty(key)){\r\n                if (from[key] !== to[key]) {\r\n                    error = {\r\n                        level: level,\r\n                        message: 'inequal property value \"' + key + '\" ( ' + from[key] + ' != ' + to[key] + ' )'\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //function for recursion, dealing with the enumeration of property keys of a schema\r\n    function propertyLevel(level, from, to) {\r\n        for (var key in to) {\r\n            //from must have at least all keys to has\r\n            if (!from.hasOwnProperty(key)) {\r\n                error = {\r\n                    level: level,\r\n                    message: 'missing property \"' + key + '\"'\r\n                }\r\n                return false;\r\n            }\r\n            //continue, by checking the meta-level of each property\r\n            if (!metaLevel(level + '.' + key, from[key], to[key])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    var result = true;\r\n    //helper function, that helps to narrow the scope, if a mappingTo/mappingFrom is given\r\n    //it basically traverses the schema to the desired mapping property and returns it as the new schema\r\n    function scopeOnMapping(schema, mapping) {\r\n        var hasSchema = true;\r\n\r\n        if (schema.hasOwnProperty('properties')) {\r\n            if (schema.properties.hasOwnProperty(mapping)) {\r\n                return schema.properties[mapping];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return schema;\r\n    }\r\n\r\n    //copy the original schemas for error output (we might modify our reference later to narrow the scope, but \r\n    //we still want to show the full schema for the error message\r\n    var OriginalObj1Schema = obj1Schema; \r\n    var OriginalObj2Schema = obj2Schema;\r\n\r\n    //mappings are optional, so scheck if they are defined and narrow the scopes\r\n    if (typeof mappingTo === 'string') {\r\n        var temp = scopeOnMapping(obj2Schema, mappingTo);\r\n        if (temp) {\r\n            obj2Schema = temp;\r\n        }\r\n        else {\r\n            error = {\r\n                level: '',\r\n                message: 'Composable \"' + obj2Name + '\" has no schema for property \"' + mappingTo + '\" provided by composable \"' + obj1Name + '\"'\r\n            }\r\n        }\r\n    }\r\n\r\n    if (typeof mappingFrom === 'string') {\r\n        var temp = scopeOnMapping(obj1Schema, mappingFrom);\r\n        if (temp) {\r\n            obj1Schema = temp;\r\n        }\r\n        else {\r\n            error = {\r\n                level: '',\r\n                message: 'Composable \"' + obj1Name + '\" has no schema for property \"' + mappingFrom + '\" required by composable \"' + obj2Name + '\"'\r\n            }\r\n        }\r\n    }\r\n\r\n    //if we didn't have an error yet, we can start the recursion\r\n    \r\n    if (!error) {\r\n        result = metaLevel('', obj1Schema, obj2Schema);\r\n    }\r\n\r\n    //output an error message\r\n    if (error) {\r\n        var relevantMapping = '';\r\n        if (typeof mappingFrom === 'string' && typeof mappingTo === 'string') {\r\n            relevantMapping = ' for the mapping \"' + mappingFrom + '\" -> \"' + mappingTo + '\"';\r\n        } else if (typeof mappingTo === 'string') {\r\n            relevantMapping = ' for the mapping \"' + mappingTo + '\"';\r\n        }\r\n\r\n        var faultyObject = {};\r\n        faultyObject[obj1Name] = OriginalObj1Schema;\r\n        faultyObject[obj2Name] = OriginalObj2Schema;\r\n        \r\n\r\n        sweva.ErrorManager.error(\r\n                      new DefinitionError('Schemas of \"' + obj1Name + '\" and \"' + obj2Name + '\" incompatible' + relevantMapping + ': '\r\n            + error.level + ': ' + error.message,\r\n                      this.context, faultyObject));\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Statically analyzes the graph before execution.\r\n * Checks for compatability of composables, absence of cycles in the linkage definition etc.\r\n * @protected\r\n */\r\nComposition.prototype.analyzeLinkGraph = function () {\r\n    /**\r\n     * False, if no errors in the link graph definition were detected.\r\n     * @protected\r\n     * @name Composition#invalidLinkGraph\r\n     * @type {boolean}\r\n     */\r\n    this.invalidLinkGraph = false;\r\n    /**\r\n     * Array of all the aliases of the composables, that have no ingoing link, i.e. the 'start'\r\n     * @protected\r\n     * @name Composition#startingComposables\r\n     * @type {Array.<string>}\r\n     */\r\n    this.startingComposables = Object.keys(this.composables);\r\n    /**\r\n    * Dictionary of all the aliases of the composables, that have no outgoing link, i.e. the 'end'\r\n    * Dictionary, because there will be some lookups of the key values later on.\r\n    * @protected\r\n    * @name Composition#startingComposables\r\n    * @type {Object.<string,string>}\r\n    */\r\n    this.endingComposables = {};\r\n    for (var key in this.composables) {\r\n        if (this.composables.hasOwnProperty(key)) {\r\n            this.endingComposables[key] = true;\r\n        }\r\n    }\r\n\r\n    //find startingComposables that have no ingoing edges\r\n    //find endingComposables that have no outgoing edges\r\n   \r\n\r\n    for (var fromNode in this.links) {\r\n        if (this.links.hasOwnProperty(fromNode)) {\r\n           \r\n\r\n            for (var fromEndpoint in this.links[fromNode]) {\r\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\r\n\r\n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\r\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\r\n                            var toEndpoint = this.links[fromNode][fromEndpoint][toNode];\r\n                            //check if linking to existing composable!\r\n                            if (!this.composables.hasOwnProperty(toNode)) {\r\n                                sweva.ErrorManager.error(\r\n                                  new DefinitionError('Composable \"' + fromNode + '\" links to undefined composable \"' + toNode + '\"!',\r\n                                  this.context, Object.keys(this.composables)));\r\n                                this.invalidLinkGraph = true;\r\n                            }\r\n                            else {    \r\n                                //composable has no such dataOut, it tries to map to another composable\r\n                                if (this.composables[fromNode].dataOutNames.indexOf(fromEndpoint) < 0) {\r\n                                    sweva.ErrorManager.error(\r\n                                         new DefinitionError('Composable \"' + fromNode + '\" maps undefined dataOut \"' + fromEndpoint + '\" to composable \"' + toNode + '\"!',\r\n                                         this.context, this.composables[fromNode].dataOutNames));\r\n                                    this.invalidLinkGraph = true;\r\n                                    break;\r\n                                }\r\n\r\n                                //composable has no such dataIn\r\n                                if (this.composables[toNode].dataInNames.indexOf(toEndpoint) < 0) {\r\n                                    sweva.ErrorManager.error(\r\n                                         new DefinitionError('Composable \"' + fromNode + '\" links to undefined dataIn \"' + toEndpoint + '\" of composable \"' + toNode + '\"!',\r\n                                         this.context, this.composables[toNode].dataInNames));\r\n                                    this.invalidLinkGraph = true;\r\n                                    break;\r\n                                }\r\n                                //additionally check for schema compatibility (optional)\r\n                                if (this.composables[fromNode].dataOutSchema && this.composables[toNode].dataInSchema != null) {//schemas are optional, so only check if available\r\n                                    var compatibleSchemas = this.checkSchemaCompatibility(fromNode, toNode, this.composables[fromNode].dataOutSchema, this.composables[toNode].dataInSchema,fromEndpoint, toEndpoint);\r\n                                    if (!compatibleSchemas) {\r\n                                        this.invalidLinkGraph = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (typeof this.composables[toNode].dataInConnected === 'undefined') {\r\n                                    this.composables[toNode].dataInConnected = {};\r\n                                }\r\n                                this.composables[toNode].dataInConnected[toEndpoint] = true;\r\n\r\n                            }\r\n                            //if one composable A points to composable B, then B cannot be startingComposable\r\n                            var propIndex = this.startingComposables.indexOf(toNode);\r\n                            if (propIndex >= 0) {\r\n                                this.startingComposables.splice(propIndex, 1);\r\n                            }\r\n                            //if one composable A points to composable B, then A cannot be endingComposable\r\n                            \r\n                            if (this.endingComposables.hasOwnProperty(fromNode)) {\r\n                                delete this.endingComposables[fromNode]\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }           \r\n        }\r\n    }\r\n\r\n\r\n    \r\n\r\n    //check for cycles\r\n    var hasCycles = this.hasCycles(this.startingComposables);\r\n    if (hasCycles) {\r\n        sweva.ErrorManager.error(\r\n                       new DefinitionError('There are cycles in the linkage of composables!',\r\n                       this.context, this.links));\r\n        this.invalidLinkGraph = true;\r\n    }\r\n\r\n    //extract implicit information\r\n    this.dataIn = this.startingComposables.length;\r\n    this.dataOut = Object.keys(this.endingComposables).length;\r\n\r\n    this.dataInNames = [];\r\n    this.dataOutNames = [];\r\n\r\n    for (var i = 0; i < this.startingComposables.length; i++) {\r\n       \r\n        if (this.composables[this.startingComposables[i]].dataInNames.length>0) {\r\n            this.dataInNames.push(this.startingComposables[i]);\r\n        }        \r\n    }\r\n    for (var key in this.endingComposables) {\r\n        if (this.endingComposables.hasOwnProperty(key)) {\r\n            this.dataOutNames.push(key);\r\n        }\r\n    }\r\n    \r\n}\r\n/**\r\n * Recursive function that executes all composables, as soon as they can be executed (have all required data available)\r\n * @param {string} context - Information about the execution context, see {@link Composable#context}\r\n * @protected\r\n */\r\nComposition.prototype.composableQueueExecution = function (context) {\r\n    \r\n    //keep an array of all composables\r\n    //executed composables get marked\r\n    /*\r\n    console.log(\"CQE : context =\");\r\n    console.log(context);\r\n    console.log(\"CQE : this =\");\r\n    console.log(this);\r\n    console.log(\"CQE : unclearedComposables =\");\r\n    console.log(this.unlcearedComposables);\r\n    */\r\n\r\n    for (var i = 0; i < this.unlcearedComposables.length; i++) {\r\n\r\n        //skip already executed composables\r\n        if (this.unlcearedComposables[i].cleared) {\r\n            continue;\r\n        }\r\n        \r\n        var composableName = this.unlcearedComposables[i].composable;\r\n\r\n        \r\n       \r\n        var data = null;\r\n        var input = null;\r\n        \r\n        //check if composable has all data it depends on available\r\n        \r\n        if (this.hasParameters(composableName)) {\r\n            \r\n            //fill data and input for next composable call\r\n            data = this.parameters[composableName];\r\n           \r\n            input = this.mapInput(this.input, composableName, this.composables, sweva.libs);\r\n          \r\n        }\r\n        else {\r\n            continue;\r\n        }\r\n\r\n        //not continued = composableName can be executed (has data vailable)\r\n        var self = this;\r\n        //closure function, to get the current composable for each function\r\n        var func = function (composableName) {\r\n            return function (output) {\r\n                //check if composable does not provide data to other composables (end of execution chain)\r\n                if (self.endingComposables.hasOwnProperty(composableName)) {\r\n                    \r\n                    var allCleared = true;\r\n                    //if we have only one output composable, we do not need a named property,\r\n                    //otherwise create a property using the ending-composable alias\r\n                    if (Object.keys(self.endingComposables).length > 1) {\r\n                        self.output[composableName] = output;\r\n                    }\r\n                    else {\r\n                        self.output = output;\r\n                    }\r\n\r\n                    //check if this was the last composable (all have been executed)\r\n                    for (var k = 0; k < self.unlcearedComposables.length; k++) {\r\n                        if (!self.unlcearedComposables[k].cleared) {\r\n                            allCleared = false;\r\n                        }\r\n                    }\r\n                    //if this was the last endingComposable, finish\r\n                    if (allCleared) {\r\n                        self.executeFinishedCallback();\r\n                    }                    \r\n                }\r\n                //if composable provides data to other composables \r\n                else {\r\n                    if (self.links[composableName]) {\r\n\r\n                        for (var fromEndpoint in self.links[composableName]) {\r\n                            if (self.links[composableName].hasOwnProperty(fromEndpoint)) {\r\n\r\n                                for (var toNode in self.links[composableName][fromEndpoint]) {\r\n                                    if (self.links[composableName][fromEndpoint].hasOwnProperty(toNode)) {\r\n                                        var toEndpoint = self.links[composableName][fromEndpoint][toNode];\r\n                                            self.addParameter(toNode, toEndpoint, output[fromEndpoint]);                                            \r\n                                    }\r\n                                }\r\n                            }\r\n                        }                            \r\n                    }\r\n                }\r\n                //recursive execution of the next composables, as this one just finished and probably resolved some data dependencies\r\n                //console.log(self.parameters)\r\n\r\n                self.manager.addReexecutionListener(function(result) {\r\n                    self.needsReloadingVisualization = true;\r\n                    self.progress = result.mqtt_sweva_parameters.data.progress;\r\n                    self.context = result.mqtt_sweva_parameters.context;\r\n                    self.parameters = result.mqtt_sweva_parameters.data.parameters;\r\n                    self.output = result.mqtt_sweva_parameters.data.output;\r\n                    self.mqtt_client = result.mqtt_sweva_parameters.data.client;\r\n                    // if(result.lastReturnedData){\r\n                    //     for (var key in self.composables) {\r\n                    //       if(self.composables[key].name == result.name){\r\n                    //           var output =  self.composables[key].dataOutNames[0];\r\n                    //           for (var i in self.composables[key].dataInNames){\r\n                    //             self.parameters[key][self.composables[key].dataInNames[i]] = result.lastReturnedData[output];\r\n                    //           }\r\n                    //       }\r\n                    //     }\r\n                    // }\r\n                    self.unlcearedComposables = JSON.parse(JSON.stringify(result.mqtt_sweva_parameters.data.unclearedComposablesClone));\r\n                    self.composableQueueExecution.apply(self, [self.context]);\r\n                    console.log('recomputing demo result');\r\n                }, self.mqtt_module_name);\r\n                self.composableQueueExecution.apply(self, [context]);\r\n\r\n\r\n            }\r\n\r\n        };\r\n        //mark composable as cleared\r\n        if (!this.unlcearedComposables[i].cleared) {\r\n\r\n            //Retrieve Data needed for the ASYNC calls of the MQTT nodes\r\n            //Check if the current node about to be cleared is an MQTT node\r\n          var mqtt_sweva_parameters = false;\r\n          if (typeof this.composables[this.unlcearedComposables[i].composable].subscribe === 'function'){\r\n            self.mqtt_module_name = this.composables[this.unlcearedComposables[i].composable].name;\r\n            mqtt_sweva_parameters = {\r\n              module_name: this.composables[this.unlcearedComposables[i].composable].name,\r\n              context: context,\r\n              data: {\r\n                parameters: this.parameters,\r\n                output: this.output,\r\n                unclearedComposablesClone: JSON.parse(JSON.stringify(this.unlcearedComposables)),\r\n                process: this.progress,\r\n                client: this.mqtt_client\r\n              }\r\n            };\r\n          } else {\r\n            self.mqtt_module_name = false;\r\n          }\r\n\r\n\r\n            this.unlcearedComposables[i].cleared = true;\r\n           \r\n            //execute composable\r\n            this.composables[composableName].execute(data, input, context, composableName, mqtt_sweva_parameters, this.progress)\r\n                .then(\r\n                    //a => console.log(a))\r\n                    func(composableName))\r\n                .catch(function (error) {\r\n                    //error is logged earlier, but how to handle?\r\n                });\r\n        }\r\n\r\n       \r\n    }\r\n}\r\n/**\r\n * Starts execution of the composable, initializes required data. Use this function if you want to execute a composable!\r\n * @param {Object} data - The data relevant to the processing.\r\n * @param {Object} input - Input information on how to process the data.\r\n * @param {string} context - Execution context. See {@link Composable#context}.\r\n * @param {string} [alias] - Name, under which the composable is known to its parent.\r\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\r\n */\r\nComposition.prototype.execute = function (data, input, context, alias, progress) {\r\n    \r\n    var self = this;\r\n    this.data = data;\r\n    this.input = input;\r\n    context = this.getNewContext(context, alias);\r\n    this.reset();\r\n    \r\n    this.progress = progress;\r\n    \r\n    //return a promise, since execution is async\r\n    return new Promise(function (resolve, reject) {\r\n        //do not bother executing, if link graph definition is invalid, or the provided data or input object do not match the provided schema definitions\r\n        if (!self.invalidLinkGraph && self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\r\n            //each starting composable has an own data part\r\n            //use user-definable {@link Composition~mapDataInFunction} to map the data to the starting composables\r\n            for (var i = 0; i < self.startingComposables.length; i++) {\r\n                var composableName = self.startingComposables[i];               \r\n                self.parameters[composableName] = self.mapDataIn(self.data, composableName, self.composables, sweva.libs);\r\n            }\r\n            \r\n            //define callback for when execution is finished\r\n            self.executeFinishedCallback = function (error) {\r\n                if (error) {\r\n                    sweva.ErrorManager.error(\r\n                       new ExecutionError('Something unexpected happened: ' + error,\r\n                       context, error));\r\n                    reject(sweva.ErrorManager.getLastError());\r\n                }\r\n                //if there is no error\r\n                else {\r\n                    //use user-definable {@link Composition~mapDataOutFunction} to create the final output object\r\n                    var result = self.mapDataOut(self.output, sweva.libs);\r\n                    //validate output using provided schema\r\n                    if (self.validateTypes('dataOut', result)) {\r\n                        if(self.needsReloadingVisualization === true) {\r\n                            self.manager.sendDataToVisualization(result);\r\n                        }\r\n                        resolve(result);\r\n                    }\r\n                    else {\r\n                        reject(sweva.ErrorManager.getLastError());\r\n                    }\r\n                }\r\n            }\r\n            //all composables are loaded, so execution can start directly\r\n            if (self.isReady) {\r\n                self.composableQueueExecution.apply(self, [context]);\r\n            }\r\n                //delay execution to {@link Composition#loadComposables}\r\n            else {\r\n                //we want to execute, but cannot: tell so the initialization/loading part\r\n                self.wantsToExecute = true;\r\n                //execute via callback, as soon as loading finished\r\n                self.executeStarterCallback = function () { \r\n                    self.composableQueueExecution.apply(self, [context]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            reject(sweva.ErrorManager.getLastError());\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = Composition;","'use strict';\r\n\r\nvar Composable = require('../../core/composables/composable.js');\r\n//var Composition = require('../../core/composables/composition.js');\r\nvar DefinitionError = require('../../core/errors/definitionError.js');\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\n\r\n/**\r\n * A user defineable function to create a HTTP request as a promise. It is used to call a remote service using its API.\r\n *\r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n *\r\n * @callback Module~requestFunction\r\n * @param {Object} data - The data object given to the module.\r\n * @param {Object} input - The input object given to the module.\r\n * @param {Object} libs - An object allowing access to libraries inside the function.\r\n */\r\n\r\n/**\r\n * A user defineable function to handle errors from failed service calls.\r\n *\r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n *\r\n * @callback Module~requestErrorFunction\r\n * @param {Object} response - The response object from the service call.\r\n * @param {Object} input - The input object given to the module.\r\n * @param {Object} libs - An object allowing access to libraries inside the function.\r\n */\r\n\r\n\r\n/**\r\n * A user defineable function to transform the response of the service.\r\n *\r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n *\r\n * @callback Module~requestErrorFunction\r\n * @param {Object} response - The response object from the service call.\r\n * @param {Object} input - The input object given to the module.\r\n * @param {Object} libs - An object allowing access to libraries inside the function.\r\n */\r\n\r\n/**\r\n * A user defineable function to do all computation locally, no service is called.\r\n *\r\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\r\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\r\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\r\n * acts as [].\r\n * See {@link SwevaScript} for more details.\r\n *\r\n * @callback Module~computeFunction\r\n * @param {Object} data - The data object given to the module.\r\n * @param {Object} input - The input object given to the module.\r\n * @param {Object} libs - An object allowing access to libraries inside the function.\r\n */\r\n\r\n\r\n/**\r\n * The initalization object with optional properties to initialize modules.\r\n * @typedef {composableInitalizer} moduleInitalizer\r\n * @property {Module~requestFunction} [request] - Creates a HTTP request to call the appropriate service.\r\n * @property {Module~requestErrorFunction} [request] - If this function is provided, it is used to handle errors, if the service call was unsuccessful.\r\n * @property {Module~responseFunction} [request] - Function to transform the the service response to be used later on.\r\n * @property {Module~computeFunction} [request] - If provided, no service is called, but all computation is performed locally in this function.\r\n *\r\n */\r\n\r\n/**\r\n * A module is the smallest unit of execution.\r\n * It serves as an envelope to a service call and can optionally do all computations locally wihtout a remote service.\r\n * @constructor\r\n * @extends Composable\r\n * @param {moduleInitalizer} initializationObject - The object with optional properties for the composition.\r\n *\r\n */\r\nfunction Module(initializationObject, manager) {\r\n    this.manager = manager;\r\n\r\n    this.initialize(initializationObject);\r\n\r\n    // general node type\r\n\r\n    this.initializeFunction(initializationObject, 'run', 3, null);\r\n    this.initializeProperty(initializationObject, 'language', 'typescript');\r\n\r\n    this.initializeProperty(initializationObject, 'source', null);\r\n    this.initializeProperty(initializationObject, 'binary', null);\r\n    this.initializeProperty(initializationObject, 'binaryHash', null);\r\n\r\n    /*this.initializeFunction(initializationObject, 'requestError', 3, null);\r\n\r\n    this.initializeFunction(initializationObject, 'response', 3,\r\n      function (response, input, libs) {\r\n        var obj = {};\r\n        obj[this.dataOutNames[0]] = response.data;\r\n        return obj;\r\n      });*/\r\n\r\n    // now the asynchronous node type\r\n\r\n    this.initializeFunction(initializationObject, 'subscribe', 3, null);\r\n    this.initializeFunction(initializationObject, 'onConnect', 3, null);\r\n    this.initializeFunction(initializationObject, 'onSubscription', 3, null);\r\n    this.initializeFunction(initializationObject, 'onMessageReceived', 4, null);\r\n}\r\n\r\n//inherit properties\r\nModule.prototype = Object.create(Composable.prototype);\r\nModule.prototype.constructor = Module;\r\n\r\nModule.prototype.lastReturnedData = null;\r\n\r\n/**\r\n * Calls the service using the created HTTP request received from {@link Module~requestFunction}.\r\n *\r\n * @protected\r\n * @param {Promise} request - The async service call.\r\n * @param {Object} input - The data input object given to the module.\r\n * @returns {Promise} - A promise with the response object.\r\n */\r\nModule.prototype.callService = function (request, input) {\r\n    var self = this;\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        request\r\n            .then(function (response) {\r\n                resolve(self.response(response, input, sweva.libs));\r\n            })\r\n            .catch(function (response) {\r\n                //if we have a function to deal with errors from service directly...\r\n                if (typeof self.requestError === 'function') {\r\n                    resolve(self.requestError(response, input, sweva.libs));\r\n                } else {\r\n                    reject(response);\r\n                }\r\n            });\r\n    });\r\n};\r\n\r\n/**\r\n * This one subscribes to a topic on a message queue.\r\n *\r\n * @param subscribe\r\n * @param input\r\n */\r\nModule.prototype.callSubscription = function (subscribe, data, mqtt_sweva_parameters, input) {\r\n    var self = this;\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        if (subscribe !== false) {\r\n            var client = subscribe;\r\n            mqtt_sweva_parameters.data.client = client;\r\n            client.on('connect', function () {\r\n                self.onConnect(client, input, sweva.libs);\r\n            });\r\n            if (self.lastReturnedData === null) {\r\n                self.lastReturnedData = data;\r\n            }\r\n            client.on('message', function (topic, message) {\r\n                if (mqtt_sweva_parameters != false) {\r\n                    self.mqtt_sweva_parameters = mqtt_sweva_parameters;\r\n                } else {\r\n                    reject(error);\r\n                }\r\n                self.lastReturnedData = self.onMessageReceived(self.lastReturnedData, topic, message, sweva.libs);\r\n                // now notify the execution manager\r\n                self.manager.onModuleUpdate(self);\r\n            });\r\n        }\r\n\r\n\r\n        resolve(self.onSubscription(data, input, sweva.libs)).catch(function (error) {\r\n            // if we have a function to deal with errors from service directly...\r\n            if (typeof self.requestError === 'function') {\r\n                resolve(self.requestError(response, input, sweva.libs));\r\n            } else {\r\n                reject(error);\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * Executes the module, i.e. performs the computation either by calling a service or locally.\r\n * @param {Object} data - The data relevant to the processing.\r\n * @param {Object} input - Input information on how to process the data.\r\n * @param {string} context - Execution context. See {@link Composable#context}.\r\n * @param {string} [alias] - Name, under which the composable is known to its parent.\r\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\r\n */\r\nModule.prototype.execute = function (data, input, context, alias, mqtt_sweva_parameters, progress) {\r\n    var self = this;\r\n    console.log(\"context ===\");\r\n    console.log(context);\r\n    console.log(\"Module to be executed =\");\r\n    console.log(self);\r\n    context = this.getNewContext(context, alias);\r\n\r\n    if (input == null) {\r\n        input = {};\r\n    }\r\n\r\n\r\n    // Promise to abort if offloading is necessary\r\n    return new Promise(function (resolve, reject) {\r\n        //begin promise\r\n        //only execute, if data and input objects are valid according to the optional schamas\r\n        if (self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\r\n\r\n            console.log(\"Input data for \" + alias + \": \");\r\n            console.log(data);\r\n\r\n            if (self.source != null) { //TODO: typeof self.run === 'function')\r\n                // if a computation function is defined, then skip service calls and compute locally\r\n                console.log(\"EXECUTE \" + self.name + \"[\" + alias + \"] USING: \" + sweva.runners[self.language].name);\r\n                //const result = await sweva.runners[self.language].exec(self, data, input, {signal});\r\n\r\n                //=== OFFLOADING === MODULE EXECUTION BEGINS HERE\r\n                sweva.runners[self.language].exec(self, data, input).then((result) => {\r\n\r\n                    console.log(\"Result data for \" + alias + \": \");\r\n                    console.log(result);\r\n\r\n                    if (result ==='offloading'){\r\n                     resolve('offloading') //todo: resolve or reject here ?\r\n                    }\r\n                    //TODO: MAP correctly\r\n                    //var result = self.run(data, input, sweva.libs);\r\n                    if (self.validateTypes('dataOut', result)) {\r\n                        //report progress, if callback is defined\r\n                        if (typeof progress !== 'undefined') {\r\n                            progress(alias, self.name, context,result);\r\n                        }\r\n                        // resolve module execution promise\r\n                        resolve(result);\r\n                    } else {\r\n                        // offloading callback here\r\n                        reject(sweva.ErrorManager.getLastError());\r\n                    }\r\n                });\r\n            }\r\n\r\n        } else if (typeof self.subscribe === 'function') {\r\n            // this is subscribing to an asynchronous message queue\r\n            var client;\r\n            if (typeof mqtt_sweva_parameters.data.client === 'undefined') {\r\n                client = self.subscribe(data, input, sweva.libs);\r\n            } else {\r\n                client = false;\r\n            }\r\n            self.callSubscription(client, data, mqtt_sweva_parameters, input).then(function (output) {\r\n                //validate output\r\n                if (self.validateTypes('dataOut', output)) {\r\n                    //report progress, if callback is defined\r\n                    if (typeof progress !== 'undefined') {\r\n\r\n                        progress(alias, self.name, context);\r\n                    }\r\n\r\n                    self.lastReturnedData = output;\r\n                    resolve(output);\r\n                } else {\r\n                    reject(sweva.ErrorManager.getLastError());\r\n                }\r\n            }).catch(function (error) {\r\n                sweva.ErrorManager.error(\r\n                    new ExecutionError('Something unexpected happened: ' + error,\r\n                        context, error));\r\n                reject(sweva.ErrorManager.getLastError());\r\n            });\r\n        } else if (typeof self.request === 'function') {\r\n            // this is an HTTP request node, call service using an HTTP request\r\n\r\n            self.callService(self.request(data, input, sweva.libs), input).then(function (output) {\r\n                // the output is already the HTTP response\r\n\r\n                //validate output\r\n                if (self.validateTypes('dataOut', output)) {\r\n                    //report progress, if callback is defined\r\n                    if (typeof progress !== 'undefined') {\r\n\r\n                        progress(alias, self.name, context);\r\n                    }\r\n\r\n                    resolve(output);\r\n                } else {\r\n                    reject(sweva.ErrorManager.getLastError());\r\n                }\r\n            }).catch(function (error) {\r\n                sweva.ErrorManager.error(\r\n                    new ExecutionError('Something unexpected happened: ' + error,\r\n                        context, error));\r\n                reject(sweva.ErrorManager.getLastError());\r\n            });\r\n\r\n        } else {\r\n            reject(sweva.ErrorManager.getLastError());\r\n        }\r\n\r\n    });\r\n}\r\n\r\nmodule.exports = Module;","//global object initialization\r\nvar globalObject;\r\n\r\nvar inBrowser = false;\r\n\r\ntry {\r\n    if (window) {\r\n        globalObject = window;\r\n        inBrowser = true;\r\n    }\r\n}\r\ncatch (e) {\r\n    globalObject = global;\r\n}\r\n\r\n//prevent loading everything twice on editor-page\r\nif(!globalObject.sweva) {\r\n    globalObject.sweva = {};\r\n\r\n    globalObject.sweva.inBrowser = inBrowser;\r\n\r\n    globalObject.sweva.asyncmqtt = require('../../node_modules/async-mqtt');\r\n\r\n    var Ajv = require('../../node_modules/ajv/lib/ajv.js');\r\n    globalObject.sweva.Ajv = new Ajv();\r\n\r\n    var ComposableLoader = require('../../app/core/execution/composableLoader.js');\r\n    globalObject.sweva.ComposableLoader = new ComposableLoader('');\r\n\r\n    globalObject.sweva.ExecutionManager = require('../../app/core/execution/executionManager.js');\r\n\r\n    var ErrorManager = require('../../app/core/errors/errorManager.js');\r\n    globalObject.sweva.ErrorManager = new ErrorManager();\r\n\r\n    var SwevaScript = require('../../app/core/swevaScript/swevaScript.js');\r\n    globalObject.sweva.SwevaScript = new SwevaScript();\r\n\r\n    var AssemblyScriptRunner = require('../../app/core/runners/assemblyScriptRunner.js');\r\n\r\n    /*\r\n    globalObject.sweva.axios = require('../../node_modules/axios/dist/axios.min.js');\r\n    globalObject.sweva.libs = {\r\n        axios: globalObject.sweva.axios,\r\n        mqtt: globalObject.sweva.asyncmqtt,\r\n        get: globalObject.sweva.SwevaScript.get,\r\n        set: globalObject.sweva.SwevaScript.set,\r\n        //mqttclient: globalObject.sweva.SwevaScript.client,\r\n        //mqttsubscribe: globalObject.sweva.SwevaScript.subscribe,\r\n        adddata: globalObject.sweva.SwevaScript.adddata\r\n    }*/\r\n\r\n    globalObject.sweva.runners = {};\r\n\r\n    var typescript = new AssemblyScriptRunner();\r\n    globalObject.sweva.runners[typescript.id] = typescript;\r\n}\r\n\r\nmodule.exports = globalObject.sweva;","'use strict';\r\n\r\nvar SwevaError = require('../../core/errors/swevaError.js');\r\n/**\r\n * An execution error should be used, if the error occured during execution.\r\n * @constructor\r\n * @extends SwevaError\r\n */\r\nfunction ExecutionError(message, context, faultyObject) {\r\n    SwevaError.call(this, message, context, faultyObject);\r\n    this.name = 'ExecutionError';\r\n}\r\nExecutionError.prototype = Object.create(SwevaError.prototype);\r\n\r\nmodule.exports = ExecutionError","'use strict';\r\n\r\nvar DefinitionError = require('../../core/errors/definitionError.js');\r\n/**\r\n * A compile error should be used, if  the error was thrown by the compiler, before actual execution and validation.\r\n * @constructor\r\n * @extends DefinitionError\r\n */\r\nfunction CompileError(message, context, faultyObject) {\r\n    DefinitionError.call(this, message, context, faultyObject);\r\n    this.name = 'CompileError';\r\n}\r\nCompileError.prototype = Object.create(DefinitionError.prototype);\r\n\r\nmodule.exports = CompileError;","'use strict';\r\n\r\nvar SwevaError = require('../../core/errors/swevaError.js');\r\n/**\r\n * A definition error should be used, if  the error occured because of incompatible definitions of composables, i.e. before actual execution.\r\n * @constructor\r\n * @extends SwevaError\r\n */\r\nfunction DefinitionError(message, context, faultyObject) {\r\n    SwevaError.call(this, message, context, faultyObject);\r\n    this.name = 'DefinitionError';\r\n}\r\nDefinitionError.prototype = Object.create(SwevaError.prototype);\r\n\r\nmodule.exports = DefinitionError;","'use strict';\r\n/**\r\n * Aggregates {@link SwevaError} messages.\r\n * @constructor\r\n */\r\nfunction ErrorManager() {\r\n    /**\r\n    * An array storing the error messages.\r\n    * @name ErrorManager#queue\r\n    * @type {Array.<Error>}\r\n    */\r\n    this.queue = [];\r\n}\r\n/**\r\n * Resets the ErrorManager.\r\n */\r\nErrorManager.prototype.clear = function () {\r\n    this.queue = [];\r\n}\r\n/**\r\n * Appends errors to the internal queue, logs them and returns the error object\r\n * @param {Error} error - The error object.\r\n * @returns {Error} - The error object.\r\n */\r\nErrorManager.prototype.error = function (error) {\r\n    this.queue.push(error);\r\n    console.log(error.toString());\r\n    console.log(error);\r\n    return error;\r\n}\r\n/**\r\n * Gets a string representation of all stored errors.\r\n * @returns {string} - All stored errors separated by a linebreak.\r\n */\r\nErrorManager.prototype.getLog = function () {\r\n    var result = '';\r\n    for (var i = 0; i < this.queue.length; i++) {\r\n        result += this.queue[i].toString() + '\\n';\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @returns {Error} - The last error that was recorded.\r\n */\r\nErrorManager.prototype.getLastError = function () {\r\n    if (this.queue.length > 0) {\r\n        return this.queue[this.queue.length - 1];\r\n    }\r\n    return null;\r\n}\r\n\r\nmodule.exports = ErrorManager;","'use strict';\r\n\r\n/**\r\n * An error object with some additional information.\r\n * @constructor\r\n * @extends Error\r\n * @param {string} message - The error message: What went wrong?\r\n * @param {string} context - The execution context, in what composable did the error occur?\r\n * @param {Object} [faultyObject] - Additional information about the error cause.\r\n */\r\nfunction SwevaError(message, context, faultyObject) {\r\n    /**\r\n    * The name of the error object.\r\n    * @name SwevaError#name\r\n    * @type {string}\r\n    */\r\n    this.name = 'SwevaError';\r\n\r\n    /**\r\n    * The error message.\r\n    * @name SwevaError#message\r\n    * @type {string}\r\n    */\r\n    this.message = message || 'Default Message';\r\n\r\n    /**\r\n    * The callstack of the error.\r\n    * @name SwevaError#stack\r\n    * @type {Object}\r\n    */\r\n    this.stack = (new Error()).stack;\r\n\r\n    /**\r\n    * The execution context of the error (in which composable it occured).\r\n    * @name SwevaError#context\r\n    * @type {string}\r\n    */\r\n    this.context = context;\r\n\r\n   \r\n    if (faultyObject !== 'undefined') {\r\n        //shallow copy: should provide enough information and save RAM\r\n        //copy is needed, as we need the object exactly at the time the error occurred\r\n        this.faultyObject = faultyObject;\r\n\r\n        if (typeof faultyObject === 'function') {\r\n            //make functions to strings            \r\n            this.faultyObject = faultyObject.toString();\r\n        }\r\n        else if (typeof faultyObject === 'object') {\r\n            for (var key in faultyObject) {\r\n                if (faultyObject.hasOwnProperty(key)) {\r\n                    this.faultyObject[key] = faultyObject[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        this.faultyObject = null;\r\n    }\r\n    /**\r\n    * The timestamp of the error.\r\n    * @name SwevaError#time\r\n    * @type {number}\r\n    */\r\n    this.time = Date.now();\r\n\r\n    console.error(\"Error in \"+context+\" created! Stacktrace:\");\r\n    console.trace();\r\n}\r\n//inherit properties\r\nSwevaError.prototype = Object.create(Error.prototype, {\r\n    constructor: {\r\n        value: this.constructor,\r\n        writable: true,\r\n        configurable: true\r\n    }\r\n});\r\n/**\r\n * @returns {string} - A string representation of the error timestamp.\r\n */\r\nSwevaError.prototype.getTime = function () {\r\n    return new Date(this.time).toLocaleTimeString();\r\n}\r\n\r\n/**\r\n * Converts error object to string including relevant information (timestamp, name, context, message, additional information).\r\n * @returns {string} - String representation of the error.\r\n */\r\nSwevaError.prototype.toString = function () {\r\n    var faultyObject = '';\r\n    if (typeof this.faultyObject === 'object') {\r\n        //transform object to pretty printed string (with identation).\r\n        faultyObject = JSON.stringify(this.faultyObject, null, 4);\r\n    }\r\n    else {\r\n        faultyObject = this.faultyObject.toString();\r\n    }\r\n    //construct string\r\n    return '[' + this.getTime() + '] SwevaError ' + this.name + ' in ' + this.context + ': ' + this.message + '\\n'\r\n        + faultyObject;\r\n}\r\nmodule.exports = SwevaError;","'use strict';\r\n\r\nvar Module = require('../../core/composables/module.js');\r\nvar Composition = require('../../core/composables/composition.js');\r\nvar DefinitionError = require('../../core/errors/definitionError.js');\r\n\r\n/**\r\n * Responsible for dynamically loading composables from a web address.\r\n * Loaded composables are stored in an internal dictionary, so they only need to be downloaded once.\r\n * @constructor\r\n * @param {string} [basePath=''] - The base address from which to download the composable. Gets prepended to the composable name.\r\n * @param {string} [suffix=.json] - The suffix that gets appended to the composable name.\r\n */\r\nfunction ComposableLoader(basePath, suffix) {\r\n    /**\r\n    * The base address from which to download the composable. Gets prepended to the composable name.\r\n    * @name ComposableLoader#basePath\r\n    * @type {string}\r\n    */\r\n    this.basePath = basePath || '';\r\n    /**\r\n    * The suffix that gets appended to the composable name.\r\n    * @name ComposableLoader#suffix\r\n    * @type {string}\r\n    */\r\n    this.suffix = suffix || '';\r\n    /**\r\n    * Dictionary of the composable names and the corresponding composable objects.\r\n    * @name ComposableLoader#composables\r\n    * @type {Object.<string, Composable>}\r\n    */\r\n    this.composables = {};\r\n    /**\r\n    * Dictionary of a waiting list, where loaded composables can be assigned to external objects\r\n    * @name ComposableLoader#waitingList\r\n    * @type {Object.<string, Object>}\r\n    */\r\n    this.waitingList = {};\r\n}\r\n\r\n/**\r\n * @returns {number} - The number of stored composables.\r\n */\r\nComposableLoader.prototype.size = function () {\r\n    return Object.keys(this.composables).length;\r\n}\r\n/**\r\n * @param {string} name - The name of the composable to return.\r\n * @returns {Composable} - The composable object.\r\n */\r\nComposableLoader.prototype.get = function (name) {\r\n    return this.composables[name];\r\n}\r\n/**\r\n * Composable objects can be directly added, without having to download them.\r\n * This can be used e.g. for rapid prototyping.\r\n * @param {string} name - The name of the composable to add.\r\n * @paranm {Composable} composable - The composable to add.\r\n */\r\nComposableLoader.prototype.add = function (name, composable) {\r\n    this.composables[name] = composable;\r\n}\r\n/**\r\n * Converts a JSON representation of a composable into a full composable object.\r\n * Since composables can have custom functions defined, and JSON does not support functions, we cannot use JSON.parse.\r\n * Instead functions are encoded as string arrays in JSON and then assembled.\r\n * {@link SwevaScript} is used to sanitize the functions.\r\n *\r\n * @protected\r\n * @param {Object} json - The JSON object of the composable.\r\n * @param {string} context - The context of execution (for error messages).\r\n * @returns {composableInitalizer} - Composable initalization object.\r\n */\r\nComposableLoader.prototype.convertToObject = function (json, context) {\r\n    var result = json;\r\n    var self = this;\r\n    for (var key in json) {\r\n        if (json.hasOwnProperty(key)) {\r\n           //decode base64 encoded binaries\r\n            if(key === 'binary' && !(json[key] instanceof Uint8Array)) {\r\n                /*console.log(json)\r\n                console.log(context)\r\n                console.log(json[key]);\r\n                console.log(typeof json[key])*/\r\n                let binaryList = atob(json[key]);\r\n               json[key] = new Uint8Array(binaryList.split(\"\").map(function(c) {\r\n                   return c.charCodeAt(0);\r\n               }));\r\n            }\r\n\r\n            //TODO: consider removing mapping functions\r\n            if (key !== 'source' && (json[key] !== null && typeof json[key][0] === 'string')) {\r\n                var str = String(json[key][0]);\r\n                //check if string array starts with 'function' -> assemble function into object\r\n                if (str.trim().indexOf('function') === 0) {\r\n                    //first sanitize the script to prevent malicious code execution\r\n\r\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\r\n                        function (error) {\r\n                            sweva.ErrorManager.error(\r\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\r\n                                    context, self.convertJsonToCode(json)));\r\n                        });\r\n                }\r\n            }\r\n\r\n            /*//TODO: consider removing mapping functions\r\n            if (key !== 'source' && typeof json[key][0] === 'string') {\r\n                var str = String(json[key][0]);\r\n                //check if string array starts with 'function' -> assemble function into object\r\n                if (str.trim().indexOf('function') === 0) {\r\n                    //first sanitize the script to prevent malicious code execution\r\n\r\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\r\n                        function (error) {\r\n                            sweva.ErrorManager.error(\r\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\r\n                                    context, self.convertJsonToCode(json)));\r\n                        });\r\n                }\r\n            }*/\r\n\r\n            if (typeof json[key] === 'object') {\r\n                json[key] = this.convertToObject(json[key], context);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n//TODO: replace default modules\r\nComposableLoader.prototype.getDefaultModule = function () {\r\n    return \"{\\n    type: \\'module\\',\\n    name: \\'module1\\',\\n    description: \\'A simple module template.\\',\\n    dataInNames: ['in'],\\n    dataInSchema: {},\\n    dataOutNames:[\\'result\\'],\\n    dataOutSchema: {},\\n    inputNames: ['input'],\\n    inputSchema: {},\\n    request: function (data, input, libs) {\\n        return libs.axios.get(\\'http:\\/\\/localhost:8080\\/example\\/calc\\/add\\/\\');\\n    },\\n    response: function (response, input, libs) {\\n        return { result:response.data }\\n    }    \\n}\";\r\n}\r\nComposableLoader.prototype.getDefaultComposition = function () {\r\n    return \"{\\n    type: \\'composition\\',\\n    name: \\'composition1\\',\\n    dataInNames: [],\\n    dataInSchema: {},\\n    dataOutNames:[\\'result\\'],\\n    dataOutSchema: {},\\n    inputNames: [],\\n    inputSchema: {},\\n    mapDataIn: function (data, composableName, composables, libs) {\\n        if (data.hasOwnProperty(composableName)) {\\n            return libs.get(data, composableName);\\n        }\\n        return null;\\n    },\\n    mapDataOut: function (output, libs) {\\n        return output;\\n    },\\n    mapInput: function (input, moduleName, modules, libs) {\\n        if (input.hasOwnProperty(moduleName)) {\\n            return libs.get(input, moduleName);\\n        }\\n        return null;\\n    }\\n}\";\r\n}\r\n\r\nComposableLoader.prototype.convertCodeToJson = function (string) {\r\n    \r\n    var result = ''\r\n    var lines = string.split(/\\r?\\n/);\r\n   \r\n    var regexFunction = new RegExp(/^\\s*(\\w)+\\s*:\\s*function/);\r\n    var regexProperty = new RegExp(/^\\s*(\\w)+\\s*/);\r\n\r\n    var funcLines = false;\r\n    var funcLinesFirst = false;\r\n    var braceCount = 0;\r\n    var funcLinesJustFinished= false;\r\n    for (var i = 0; i < lines.length; i++) {\r\n        var line = lines[i].trim();        \r\n        if (!funcLines) {\r\n            if (funcLinesJustFinished && line.indexOf(':') >= 0) {\r\n                funcLinesJustFinished = false;\r\n                result += ',\\n';\r\n            }\r\n            if (regexFunction.test(line)) {\r\n                funcLines = true;\r\n\r\n                var index = line.indexOf('function');\r\n\r\n                var linePart = line.slice(0, index);\r\n                var match = regexProperty.exec(linePart);\r\n                if (match != null) {\r\n                    linePart = linePart.slice(0, match.index) + '\"' + linePart.slice(match.index, match.index + match[0].length) + '\"' + linePart.slice(match.index + match[0].length);\r\n                }\r\n                linePart = linePart.replace(/'/g, '\"');\r\n\r\n                result += linePart;\r\n\r\n                result += '[\"' + line.slice(index) + '\",\\n';\r\n                funcLinesFirst = true;\r\n            }\r\n            else {\r\n                var match = regexProperty.exec(line);\r\n                if (match != null) {\r\n                    line = line.slice(0, match.index) + '\"' + line.slice(match.index, match.index + match[0].length) + '\"' + line.slice(match.index + match[0].length);\r\n                }\r\n                line = line.replace(/'/g, '\"');                \r\n                result += line + '\\n';\r\n            }\r\n        }\r\n        if (funcLines) {\r\n            var inQuotes = false;\r\n            var inSingleQuotes = false;\r\n            for (var k = 0; k < line.length; k++) {\r\n                var c = line[k];\r\n\r\n                if (c == '\"' && !inSingleQuotes) {\r\n                    inQuotes = !inQuotes;\r\n                    line = line.slice(0, k) + '\\\\' + line.slice(k);\r\n                    k++;\r\n                }\r\n                else if (c == '\\'' && !inQuotes) {\r\n                    inQuotes = !inSingleQuotes;\r\n                }\r\n                else if (c == '{' && !inQuotes && !inSingleQuotes) {\r\n                    braceCount++;\r\n                }\r\n                else if (c == '}' && !inQuotes && !inSingleQuotes) {\r\n                    braceCount--;\r\n                }\r\n            }\r\n            if (funcLinesFirst) {\r\n                funcLinesFirst = false;\r\n            }\r\n            else {\r\n                line = line.replace('\\\\n', '\\\\\\\\n');\r\n                if (braceCount == 0) {\r\n                    if (line.length > 0 && line.indexOf(',') >= line.length - 1) {\r\n                        line = line.slice(0, line.length - 1);\r\n                    }\r\n                    result += '\"' + line + '\"' + '\\n';\r\n                }\r\n                else {\r\n                    result += '\"' + line + '\"' + ',' + '\\n';\r\n                }\r\n            }\r\n\r\n            if (braceCount == 0) {\r\n                funcLines = false;\r\n                funcLinesFirst = false;\r\n                result += ']\\n';\r\n                funcLinesJustFinished=true;\r\n               \r\n            }\r\n        }\r\n    }\r\n\r\n    if (result.indexOf('{') !== 0) {\r\n        return '{' + result + '}';\r\n    }\r\n\r\n    return result;\r\n}\r\nComposableLoader.prototype.convertJsonToCode = function (obj) {\r\n    function getSpaces(spaces) {\r\n        var result = '';\r\n        for (var i = 0; i < spaces; i++) {\r\n            result += ' ';\r\n        }\r\n        return result;\r\n    }\r\n    function stringify(object, level, spaces) {\r\n        var result = '';\r\n\r\n        var ident = getSpaces(level * spaces);\r\n\r\n        var keys = Object.keys(object);\r\n\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            var keyString = (key.indexOf(' ') >= 0) ? ('\\'' + key + '\\'') : key;\r\n            result += ident + keyString + ': ';\r\n            if (typeof object[key] === 'string') {\r\n                result += '\\'' + object[key] + '\\'';\r\n            }\r\n            else if (typeof object[key] === 'object') {\r\n                if (Array.isArray(object[key])) {\r\n                    var arrayContent = '';\r\n\r\n                    if (object[key].length > 0 && typeof object[key][0] === 'string' && object[key][0].trim().indexOf('function') == 0) {\r\n                        //decode function\r\n                        var internalLevel = 0;\r\n                        for (var k = 0; k < object[key].length; k++) {\r\n                            var line = object[key][k].trim();\r\n                            if (line.indexOf('}') == 0) {\r\n                                internalLevel--;\r\n                                if (internalLevel < 0) {\r\n                                    internalLevel = 0;\r\n                                }\r\n                            }\r\n                            arrayContent += (k == 0 ? '' : ident) + getSpaces(spaces * internalLevel) + line + (k >= object[key].length - 1 ? '' : '\\n');\r\n                            if (line.length > 0 && line.indexOf('{') == line.length - 1) {\r\n                                internalLevel++;\r\n                            }\r\n                        }\r\n                        result += arrayContent + ident;\r\n                    }\r\n                    else {\r\n                        for (var k = 0; k < object[key].length; k++) {\r\n                            var element = object[key][k];\r\n                            arrayContent += ident + getSpaces(spaces);\r\n                            if (typeof element === 'string') {\r\n                                arrayContent += '\\'' + element + '\\'';\r\n                            }\r\n                            else if (typeof element === 'object') {\r\n                                arrayContent += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\r\n                            }\r\n                            else {\r\n                                arrayContent += element;\r\n                            }\r\n                            if (k < object[key].length - 1) {\r\n                                arrayContent += ',';\r\n                            }\r\n                            arrayContent += '\\n';\r\n                        }\r\n                        result += '[\\n' + arrayContent + ident + ']';\r\n                    }\r\n                }\r\n                else {\r\n                    result += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\r\n                }\r\n            }\r\n\r\n            else {\r\n                result += '\\'' + object[key] + '\\'';\r\n            }\r\n\r\n            if (i < keys.length - 1) {\r\n                result += ',';\r\n            }\r\n            result += '\\n';\r\n        }\r\n        return result;\r\n    }\r\n    return '{\\n'+stringify(obj, 1, 4)+'}';\r\n}\r\n\r\n/**\r\n * Helper function, that assigns the composables to the internal dictionary and optionally to external objects with a specified property.\r\n * This can be used to directly fill another external dictionary of composables, like the {@link Composition} composable dictionary.\r\n * @protected\r\n * @param {string} name - The name of the composable.\r\n * @param {Composable} composable - The composable object.\r\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\r\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\r\n */\r\nComposableLoader.prototype.assignLoadedComposables = function (name, composable, assignToObject, property) {\r\n    this.composables[name] = composable;\r\n\r\n    //check if the optional assignToObject is given\r\n    if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\r\n        assignToObject[property] = composable;\r\n    }\r\n\r\n    //deal with waitinglist: as the caller has to wait for 'then' we, can set the required values now with some delay\r\n    if (this.waitingList.hasOwnProperty(name)) {\r\n        //for each object, that waits for the composable to be assigned to\r\n        for (var i = 0; i < this.waitingList[name].length; i++) {\r\n            var assignTo = this.waitingList[name][i].assignTo;\r\n            var prop = this.waitingList[name][i].prop;\r\n\r\n            assignTo[prop] = composable;\r\n        }\r\n        //remove element from the waitingList\r\n        delete this.waitingList[name];\r\n    }\r\n}\r\n/**\r\n * Loads a composable by the given name from a web resource.\r\n * If no basePath was given in the constructor, use the full web address as the name.\r\n * @param {string} name - The name of the composable.\r\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\r\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\r\n * @returns {Promise<Composable>} - The loaded composable object.\r\n */\r\nComposableLoader.prototype.load = function (name, assignToObject, property) {\r\n    var self = this;\r\n\r\n    //return a promise, since loading is ansynchronuous\r\n    return new Promise(function (resolve, reject) {\r\n        //check if the name was already loaded or is currently being loaded\r\n        if (self.composables.hasOwnProperty(name)) {\r\n            //we have only our placeholder, no real value yet\r\n            //this means the composable is currently requested, but not loaded\r\n            if (self.composables[name] === true) {\r\n                //put in waitinglist, which is checked after each load\r\n                //but only, if it needs to be assigned externally\r\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\r\n                    if (!self.waitingList.hasOwnProperty(name)) {\r\n                        self.waitingList[name] = [];\r\n                    }\r\n                    self.waitingList[name].push({\r\n                        assignTo: assignToObject,\r\n                        prop: property\r\n                    });\r\n                }\r\n                //load from dictionary\r\n                resolve(self.composables[name]);\r\n            }\r\n            else {\r\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null) {\r\n                    assignToObject[property] = self.composables[name];\r\n                }\r\n                resolve(self.composables[name]);\r\n            }\r\n        }\r\n            //not already in dictionary, needs to be loaded\r\n        else {\r\n            //set key and prevent unnecessary loads, while loading is already in progress\r\n            self.composables[name] = true;\r\n            //construct url\r\n            var url = self.basePath + name + self.suffix;\r\n\r\n            sweva.axios.get(url)\r\n            .then(function (response) {\r\n                //convert the response JSON to an actual composable\r\n                var composable = self.convertToObject(response.data, url);\r\n                //closue function, dummy\r\n                var func = function (comp) {\r\n                    return function (res, rej) {\r\n                        res(comp);\r\n                    }\r\n                }\r\n                var internalPromise = new Promise(func(composable));\r\n\r\n                //check if composable just extends existing one\r\n                if (composable.hasOwnProperty('extends')) {\r\n                    var baseComposableName = composable.extends;\r\n                    //create a closure to load the base composable\r\n                    var func2 = function (baseComposableName, composable) {\r\n                        return function (res, rej) {\r\n                            self.load(baseComposableName).then(function (comp) {\r\n                                //extend loaded composable with extension\r\n                                res(comp.extendWith(composable));\r\n                            });\r\n                        }\r\n                    };\r\n                    //adjust internal promise to load the base composable first, before extending it.\r\n                    internalPromise = new Promise(func2(baseComposableName, composable));\r\n                }\r\n\r\n                internalPromise.then(function (composable) {\r\n                    //log as loaded\r\n                    console.log('loaded ' + composable.name);\r\n                    //if the loaded composable is a module\r\n                    if (composable.type == 'module') {\r\n                        //construct Module\r\n                        composable = new Module(composable);\r\n\r\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\r\n\r\n                        resolve(composable);\r\n                    }\r\n                        //if the loaded composable is a composition\r\n                    else {\r\n                        //construct Composition\r\n                        composable = new Composition(composable);\r\n\r\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\r\n                        //load composables required for the composition\r\n                        composable.loadComposables().then(function () {\r\n                            resolve(composable);\r\n                        });\r\n                    }\r\n                });\r\n            })\r\n            .catch(function (response) {\r\n                reject(self.basePath + name + self.suffix); //could not load\r\n            });\r\n        }\r\n    });\r\n}\r\n/**\r\n * Clears the internal dictionaries.\r\n */\r\nComposableLoader.prototype.clear = function () {\r\n    this.composables = {};\r\n    this.waitingList = {};\r\n}\r\nmodule.exports = ComposableLoader;","'use strict';\r\n\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\nvar Module = require('../../core/composables/module.js');\r\nvar Composition = require('../../core/composables/composition.js');\r\n\r\n//MA\r\n//+++++++++ Global Variables +++++++++\r\n//for P2P networking\r\n// TOdO: do we require this ?\r\nconst EventEmitter = require('events');\r\nconst emitter = new EventEmitter();\r\nconst potentialOffloadingTarget = require(\"../network/potentialOffloadingTarget.js\");\r\n\r\n// **** P2P network ****\r\n\r\n\r\n/**\r\n let peer = new Peer({ //needs bib import in frontend !\r\n    host:\"localhost\",\r\n    port:9000,\r\n    path:\"/discovery\"\r\n});\r\n\r\n //Event-based script\r\n //+++++++++ DEVICE is POT +++++++++\r\n peer.on('connection', (connection) => {\r\n        connection.on('data', (data) => {\r\n            if (data === 'peer){\r\n             emitter.emit('isPeer');\r\n            console.log('Received ROLE: ' + data+' from device: ' + connection.peer);\r\n            }\r\n                   });\r\n});\r\n\r\n emitter.on('isPeer',potentialOffloadingTarget());\r\n **/\r\n//+++++++++ DEVICE is DPD +++++++++\r\nfunction listOfPeers() { // used to broadcast roles and for frontend !\r\n    let list = [];\r\n    peer.listAllPeers((peerIds) => {\r\n        peerIds\r\n            .filter((peerId) => peerId !== peer.id) // Filter out device ID\r\n            .forEach((peerId) => {\r\n                list.push(peerId);\r\n            });\r\n    });\r\n    return list;\r\n}\r\n\r\nfunction broadcastToDiscoveryNetwork() {\r\n    peer.listAllPeers((peerIds) => {\r\n        peerIds\r\n            .filter((peerId) => peerId !== peer.id) // Filter out device ID\r\n            .forEach((peerId) => {\r\n                const conn = peer.connect(peerId);\r\n                conn.on('open', () => {\r\n                    console.log('Discovered Peer: ' + peerId);\r\n                    conn.send('peer');\r\n                });\r\n                conn.on('error', (err) => {\r\n                    console.error('Error discovering Peer : ' + peerId);\r\n                })\r\n            });\r\n    });\r\n}\r\n\r\n// **** END P2P network ****\r\n\r\n\r\n/**\r\n * An ExecutionManager is responsible for managing the execution process of compositions and modules.\r\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an execution phase,\r\n * that executes the composables by providing data and input objects to them.\r\n *\r\n * The setup needs to be done only once, while the execution can be repeated on different data.\r\n * @constructor\r\n * @param {string} [name] - Name of the execution manager.\r\n */\r\nfunction ExecutionManager(name) {\r\n    if (typeof name === 'string') {\r\n        this.name = name;\r\n    } else {\r\n        this.name = 'ExecutionManager';\r\n    }\r\n    /**\r\n     * Amount of how many modules are used currently.\r\n     * @name ExecutionManager#modulesTotal\r\n     * @type {number}\r\n     */\r\n    this.modulesTotal = 1;\r\n    /**\r\n     * Amount of how many modules have finished execution.\r\n     * @name ExecutionManager#modulesDone\r\n     * @type {number}\r\n     */\r\n    this.modulesDone = 0;\r\n    /**\r\n     * Callback to track progress, gets called everytime a module finishes.\r\n     * @name ExecutionManager#progressCallback\r\n     * @type {function}\r\n     */\r\n    this.progressCallback = null;\r\n    this.updateVisualizationNotifier = null;\r\n\r\n    this.reexecutionListeners = [];\r\n}\r\n\r\n/**\r\n * Registers the callback function to track progress.\r\n * @param callback\r\n */\r\nExecutionManager.prototype.onProgress = function (callback) {\r\n    this.progressCallback = callback;\r\n};\r\n\r\n/**\r\n * Registers the callback function to update visualization on MQTT data received after reexecuting the sweva-graph.\r\n * @param {function} - Callback function for updating the visualization.\r\n */\r\nExecutionManager.prototype.onMQTTDataRecieved = function (callback) {\r\n    this.updateVisualizationNotifier = callback;\r\n};\r\n\r\nExecutionManager.prototype.sendDataToVisualization = function (result) {\r\n    if (this.updateVisualizationNotifier !== null) {\r\n        this.updateVisualizationNotifier(result);\r\n    }\r\n}\r\n\r\n/**\r\n * Registers a callback function that gets called whenever any asynchronous node re-executes parts of the composition.\r\n *\r\n * @param callback\r\n */\r\nExecutionManager.prototype.addReexecutionListener = function (callback, module_name) {\r\n    if (this.reexecutionListeners.length !== 0) {\r\n        for (var key in this.reexecutionListeners) {\r\n            if (this.reexecutionListeners[key].module_name === module_name) {\r\n                this.reexecutionListeners.splice(key, 1);\r\n            }\r\n        }\r\n        this.reexecutionListeners.push({\r\n            callback: callback,\r\n            module_name: module_name\r\n        });\r\n\r\n    } else if (module_name !== false) {\r\n        this.reexecutionListeners.push({\r\n            callback: callback,\r\n            module_name: module_name\r\n        });\r\n    }\r\n\r\n};\r\n\r\nExecutionManager.prototype.onModuleUpdate = function (module) {\r\n    for (var i in this.reexecutionListeners) {\r\n        if (this.reexecutionListeners[i].module_name === module.mqtt_sweva_parameters.module_name) this.reexecutionListeners[i].callback(module);\r\n    }\r\n};\r\n\r\n/**\r\n * Initializes all required composables, loads dependencies, validates.\r\n *\r\n * (IF) PARSE pipeline to JS object self gloabl to the executionManager !\r\n *\r\n * @param {Array.<string|Composable>} executionArray - Array of composables that will be executed.\r\n * @param {boolean} [isPureObject=false] - Set this to true, if passing pure JavaScript Objects and not just JSON.\r\n */\r\n//Global variable names\r\n\r\nlet intermediatePipeline;\r\nlet intermediatePipelineResults;\r\nExecutionManager.prototype.setup = function (executionArray, isPureObject) {\r\n    intermediatePipeline = executionArray;\r\n    /*console.log('///// Exec. manager setup inputs //////');\r\n    console.log('executionArray');\r\n    console.log(executionArray);\r\n    console.log('isPureObject');\r\n    console.log(isPureObject);\r\n    console.log('intermed. pip');\r\n    console.log(intermediatePipeline);*/\r\n\r\n    //internal recursive function to count how many modules are currently used\r\n    function countModules(composable) {\r\n        if (typeof composable.composables === 'undefined') {\r\n            return 1;\r\n        } else {\r\n            var count = 0;\r\n\r\n            for (var key in composable.composables) {\r\n                if (composable.composables.hasOwnProperty(key)) {\r\n                    //console.log(key, composable.composables[key]);\r\n                    count += countModules(composable.composables[key]);\r\n                }\r\n            }\r\n            //console.log('UPDATED Composable =', composable);\r\n            //console.log(\"Number of set up nodes in Composable: \" + count);\r\n            return count;\r\n        }\r\n    }\r\n\r\n    var needsLoading = [];\r\n    this.composables = {};\r\n    this.isReady = false;\r\n\r\n    this.wantsToExecute = false;\r\n    //if it is not an array, make it one\r\n    if (!Array.isArray(executionArray)) {\r\n        executionArray = [executionArray];\r\n    }\r\n    var names = [];\r\n    //for each composable, that will be executed\r\n    for (var i = 0; i < executionArray.length; i++) {\r\n        var composable = executionArray[i];\r\n        //if composable is provided as string, i.e. name it needs to be loaded\r\n        if (typeof composable === 'string') {\r\n            names.push(composable);\r\n            needsLoading.push(sweva.ComposableLoader.load(composable, this.composables, composable));\r\n        }\r\n        //otherwise a composable object is given\r\n        else {\r\n            if (typeof isPureObject === 'undefined' || !isPureObject) {\r\n                composable = sweva.ComposableLoader.convertToObject(composable, 'JSON');\r\n            }\r\n\r\n            if (composable.type === 'module') {\r\n                this.composables[composable.name] = new Module(composable, this);\r\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\r\n            } else {\r\n                this.composables[composable.name] = new Composition(composable, this);\r\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\r\n                //composables of a composition need also to be loaded\r\n                needsLoading.push(this.composables[composable.name].loadComposables());\r\n            }\r\n            names.push(composable.name);\r\n        }\r\n    }\r\n    var self = this;\r\n\r\n    //now wait for everything to load\r\n    Promise.all(needsLoading).then(function () {\r\n        //console.log('RAW Pipline / User Input=', composable);\r\n        //let's check, how many modules are used in total to have a rough estimate for progress tracking\r\n        var moduleCount = 0;\r\n        for (var i = 0; i < executionArray.length; i++) {\r\n            moduleCount += countModules(sweva.ComposableLoader.get(names[i]));\r\n\r\n        }\r\n        self.modulesTotal = moduleCount;\r\n        self.modulesDone = 0;\r\n\r\n        //composables should now contain everything\r\n        self.isReady = true;\r\n        console.log('all loaded');\r\n        //if we want to execute, before setup is ready, it is delayed and continued from here\r\n        if (self.wantsToExecute) {\r\n            self.wantsToExecute = false;\r\n            self.executeCallback();\r\n        }\r\n    })\r\n        .catch(function (error) {\r\n            sweva.ErrorManager.error(\r\n                new ExecutionError('Could not load all modules: ' + error,\r\n                    self.name, error));\r\n        });\r\n}\r\n/**\r\n * Calculates the current progress state and calls the optionally registered progressCallback.\r\n * It counts the percentage of the modules that have finished execution.\r\n *\r\n * (IF) TODO: update it to modules done locally and ofloaded modules\r\n *\r\n * @param {string} alias - The alias of the module, under which it is known to the parent composition.\r\n * @param {string} name - The name of the module.\r\n * @param {string} context - The context under which the module is executed (its parents).\r\n */\r\nExecutionManager.prototype.progressUpdate = function (alias, name, context,result) {\r\n    if (result==='offloading')\r\n        {\r\n            console.log('OFFLOADING flag catched in Exec manager !')\r\n            console.log('alias:')\r\n            console.log(alias); // node 1\r\n            console.log('name:')\r\n            console.log(name); //module 1\r\n            console.log(intermediatePipelineResults);\r\n            console.log(intermediatePipeline);\r\n            console.log('SEND THIS Pipeline to ')\r\n        }\r\n    else {\r\n        //consider result as linked nodes input\r\n        let nodeLinks = intermediatePipeline.links;\r\n        let moduleResult = result.out;\r\n\r\n        if (nodeLinks.hasOwnProperty(alias)){\r\n            console.log('YESSSSSSSSSSSSSSSSSSSSSSSSS')\r\n            let linksArray =Object.entries(nodeLinks[alias].out)[0];\r\n            console.log(linksArray);\r\n\r\n            intermediatePipelineResults[linksArray[0]]={\r\n                \"num\":moduleResult\r\n            };\r\n            console.log(intermediatePipelineResults);\r\n        }else {\r\n\r\n            //consider result as node output\r\n            console.log('FUCKKKKKKKKKKKKKKKKKK')\r\n            intermediatePipelineResults[alias]={\r\n                \"out\":moduleResult\r\n            };\r\n        }\r\n        /*console.log('/////////////');\r\n        let formattedAlias = '\"' + alias + '\"';\r\n        console.log( alias); // node 1\r\n        console.log(intermediatePipeline.links); // node\r\n        console.log('/////////////');\r\n        ///.alias.out;\r\n        //console.log(nodeOutputLink);\r\n        let formattedObj = {\r\n            \"Node2\": {\r\n                [obj[\"Node2\"]]:\r\n            }\r\n        }*/\r\n        //delete intermediatePipeline.composables.alias;\r\n        console.log('progress bar result =');\r\n        console.log(result.out);\r\n        console.log('intermediate pipeline =');\r\n        console.log(intermediatePipeline);\r\n        console.log('intermediate pipeline results =');\r\n        console.log(intermediatePipelineResults);\r\n        //todo:update intermediate pipeline with result\r\n\r\n    if (this.progressCallback !== null) {\r\n        this.modulesDone++;\r\n\r\n        var progress = this.modulesDone / +this.modulesTotal;\r\n\r\n        //make a value 0-100 and cut off decimal places\r\n        this.progressCallback((progress * 100).toFixed(0));\r\n        //TODO send this to frontend\r\n    }}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Executes the composables that were initalized during {@link ExecutionManager#setup}.\r\n * @param {Object} data - The data to use for the execution. If multiple composables will be executed,\r\n * the data property names must correspond to the composable names for a correct mapping of the data.\r\n * @param {Object} input - The input object for the execution. If multiple composables will be executed,\r\n * the input property names must correspond to the composable names for a correct mapping of the input.\r\n */\r\n\r\n\r\nExecutionManager.prototype.execute = function (data, input) {\r\n    /**\r\n     * An Array of executions, which are representing Modules (nodes).\r\n     * @type {Array}\r\n     */\r\n    var executions = [];\r\n    var self = this;\r\n    intermediatePipelineResults=data;\r\n    //for aborting the execution of JS promise\r\n\r\n    console.log(\"///////////// Exec Manager inputs //////////////\");\r\n    console.log(\"data\");\r\n    console.log(data);\r\n    console.log(\"input\");\r\n    console.log(input);\r\n    console.log('self');\r\n    console.log(self);\r\n    console.log('intermediate Pipeline');\r\n    console.log(intermediatePipeline);\r\n    console.log(\"///////////////////////////\");\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        //closure function\r\n        //composables is the pipeline\r\n        //executions is the list of promises Module to be executed\r\n        var func = function (composables, executions, resolve, reject) {\r\n            /*\r\n            console.log(\"///////////// func inputs //////////////\");\r\n            console.log('Composables= ');\r\n            console.log(composables);\r\n            console.log('Executions= ');\r\n            console.log(executions);\r\n            console.log(\"///////////////////////////\");\r\n            */\r\n            return function () {\r\n\r\n                var onlyOneComposable = false;\r\n                // check if only one composable will be executed, because then you don't go into the loop.\r\n                if (Object.keys(composables).length === 1) {\r\n                    onlyOneComposable = true;\r\n                }\r\n\r\n                for (var key in composables) {\r\n                    if (composables.hasOwnProperty(key)) {\r\n                        /*\r\n                        console.log(\"///////////// if condition //////////////\");\r\n                        console.log('composables[key]= ');\r\n                        console.log(composables[key]);\r\n                        console.log('input[key] ');\r\n                        console.log(input[key]);\r\n                        console.log('key= ');\r\n                        console.log(key);\r\n                        console.log('self.progressUpdate.bind(self)= ');\r\n                        console.log(self.progressUpdate.bind(self));\r\n                        console.log(\"///////////////////////////\");\r\n                        */\r\n                        if (onlyOneComposable) {\r\n                            //execute function is defined in module.js\r\n                            executions.push(composables[key].execute(data, input, '', key, self.progressUpdate.bind(self)));\r\n                            //console.log(\" ====== Only One Composable ==== \");\r\n                        } else {\r\n                            //=== OFFLOADING === MODULE EXECUTION IS INITIALIZED !\r\n                            executions.push(composables[key].execute(data[key], input[key] || {}, '', key, self.progressUpdate.bind(self)));\r\n                            //console.log(\" ====== More than 1 composable ==== \");\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                // while loop to monitor the execution of the pipeline and update the offloading pipeline\r\n\r\n                //todo: implement a loop that updates a copy of the original pipeline each time a module is executed\r\n                // ( promise is fullfilled) and stops and returns the updated pipeline if one promise is rejected\r\n                //monitorPromises(executions);\r\n\r\n                // ELSE NO OFFLOADING ...\r\n                // when all the execution Promises have resolved...\r\n                Promise.all(executions).then(function (results) {\r\n                    console.log('all promises resolved');\r\n                    if (onlyOneComposable) {\r\n                        return resolve(results[0]);\r\n                    }\r\n                    resolve(results);\r\n                }).catch(function (results) {\r\n                    if (onlyOneComposable) {\r\n                        return resolve(results);\r\n                    }\r\n                    sweva.ErrorManager.error(\r\n                        new ExecutionError('Something unexpected happened: ' + results,\r\n                            this.name, results));\r\n                    reject(results);\r\n                });\r\n            }\r\n\r\n        };\r\n\r\n        if (self.isReady) {\r\n            func(self.composables, executions, resolve, reject)();\r\n        } else {\r\n            self.wantsToExecute = true;\r\n            self.executeCallback = func(self.composables, executions, resolve, reject);\r\n        }\r\n    });\r\n}\r\n//alias\r\nExecutionManager.prototype.run = ExecutionManager.prototype.execute;\r\nmodule.exports = ExecutionManager\r\n\r\n\r\n/*\r\n\r\n//////////////  EXPERT MODE  //////////////\r\n\r\n// inputs are extracted from device\r\nExecutionManager.prototype.deviceMonitoringIndex = async function () {\r\n    async function deviceMonitoringIndex() {\r\n        return new Promise((resolve, reject) => {\r\n            //this.window = window;\r\n            let metrics = [];\r\n\r\n            //Hardware metrics in Linux environments:\r\n            let cpu = await currentCPUusage()\r\n            let mem = await currentMemoryusage()\r\n            let storage = await availableStorage()\r\n            let battery = await availableBattery()\r\n            let charging = await isCharging()\r\n\r\n            console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\r\n            resolve(metrics.push(cpu, mem, storage,battery,charging));\r\n\r\n\r\n            //for windows testing purposes\r\n            let cpu = 60; //avg free cpu value for 3 measurements in %\r\n            let mem = 100000; // avilable free mem value in bytes\r\n            let storage = 2000000; // avilable free storage value in bytes\r\n            let battery = 80;\r\n            let charging = true;\r\n            //console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\r\n            metrics.push(cpu, mem, storage, battery, charging)\r\n            resolve(metrics);\r\n\r\n        })\r\n    }\r\n\r\n    return await deviceMonitoringIndex();\r\n\r\n}\r\n*/\r\n\r\n/*\r\n//inputs are extracted from frontend -> user input in backend\r\nExecutionManager.prototype.offloadingDecision = async function (od_CPU, od_mem, od_battery) {\r\n    async function offloadingDecission(wpn, od_CPU, od_mem, od_battery) {\r\n        return new Promise(async (resolve, reject) => {\r\n            const dmi = await ExecutionManager.prototype.deviceMonitoringIndex();\r\n            let decision = false;\r\n            //[0]:cpu\r\n            //[1]: memory\r\n            //[2]: storage\r\n            //dmi[3]: battery\r\n            //dmi[4]: is charging\r\n            if (od_CPU === 0 || od_mem === 0 || od_battery === 0) {\r\n                decision = true;\r\n            } else if (wpn[0] > (dmi[0] * od_CPU) || wpn[1] > (dmi[1] * od_mem) || dmi[3] < od_battery) {\r\n                decision = true;\r\n            }\r\n            resolve(decision);\r\n        });\r\n    }\r\n\r\n    return await offloadingDecission([sweva.ComposableLoader['totalCPUReq'], sweva.ComposableLoader['totalMemReq']], od_CPU, od_mem, od_battery);\r\n\r\n}\r\n*/\r\n\r\n//////////////  END  EXPERT MODE  //////////////\r\n","/**\r\n * Creates instance of support library\r\n *\r\n * Allow loading functionality separately, depending on what is needed for a specific runner\r\n *\r\n * @constructor\r\n */\r\n\r\nfunction SupportLibrary() {\r\n    this.functions = {};\r\n}\r\n\r\nSupportLibrary.prototype.loadTestSync = function() {\r\n    this.functions.test = {\r\n        async: false,\r\n        languageSpecific: {\r\n            typescript: {\r\n                parameterSig: \"url: string\",\r\n                returnSig: \"string\"\r\n            }\r\n        },\r\n        func: function (url) {\r\n            return url + url;\r\n        }\r\n    };\r\n}\r\n\r\nSupportLibrary.prototype.loadLogger = function() {\r\n    this.functions.log = {\r\n        description: \"Log the text to the browser console\",\r\n        async: false,\r\n        languageSpecific: {\r\n            typescript: {\r\n                parameterSig: \"text: string\",\r\n                returnSig: \"void\"\r\n            }},\r\n        func: function (text) {\r\n            console.log(text);\r\n        }};\r\n}\r\nSupportLibrary.prototype.loadHTTP = function() {\r\n    this.functions.httpRequest = {\r\n        description: \"Send a HTTP(S) request using the fetch api. Returns status=-1 on timeout!\",\r\n        async: true,\r\n        languageSpecific:{\r\n            typescript: {\r\n                parameterSig: \"url: string, headers:string = null | null, method:string = 'GET' | null, body:string = null | null, cache:string = 'no-store' | null, timeout:i32 = 5000\",\r\n                returnSig: \"text: string, status: int\"\r\n        }},\r\n        func: async function (url, headers, method, body, cache, timeout) {\r\n            let init = {};\r\n\r\n            if(headers != null)\r\n                init.headers = headers;\r\n            if(method != null)\r\n                init.method = method;\r\n            if(body != null)\r\n                init.body = body;\r\n            if(cache != null)\r\n                init.cache = cache;\r\n            else\r\n                init.cache = \"no-store\";\r\n\r\n            let controller = new AbortController();\r\n            let timeoutTimer = setTimeout(() => controller.abort(), timeout);\r\n            init.signal = controller.signal;\r\n\r\n            try{\r\n                let response = await fetch(url, init);\r\n                clearTimeout(timeoutTimer);\r\n                console.log(\"RESPONSE:\")\r\n                console.log(response);\r\n                let text = await response.text();\r\n                return [text, response.status];\r\n            } catch (e) {\r\n                return [\"TIMEOUT\", -1];\r\n            }\r\n        }};\r\n}\r\n\r\nmodule.exports = SupportLibrary;","\r\nconst availableOffloadingResources = require(\"../offloading/offloadingResources.js\");\r\n\r\nfunction createPeer(id, callback = () => {\r\n}) {\r\n    let peer = new Peer(id, {\r\n        host: \"localhost\",\r\n        port: 9000,\r\n        path: \"/myapp\",\r\n    });\r\n    peer.on('open', function (ID) {\r\n        console.log('My peer ID is: ' + ID);\r\n        callback();\r\n    });\r\n    peer.on(\"error\", function (err) {\r\n        console.log(\"Error: \" + err);\r\n    });\r\n    peer.on('disconnected', function (ID) {\r\n        console.log('peer ID ' + ID+' disconnected');\r\n        callback();\r\n    });\r\n\r\n    return peer;\r\n}\r\n\r\nfunction potentialOffloadingTarget() {\r\n    let peer = createPeer('', () => {\r\n        peer.on('connection', (co)=>{\r\n            // Peer is chosen !\r\n            co.on('data', (data)=>{\r\n                // Process Pipeline and send result\r\n                console.log(data);\r\n                //TODO: is there a way to check if received date is really a pipeline ? yes\r\n                //TODO: user input ?\r\n\r\n                // setup and process the pipeline\r\n                processPipeline().then((result)=>{\r\n                    //send pipeline result\r\n                    co.send(result);\r\n                }).catch(error => {\r\n                    console.error(error);\r\n                });\r\n            });\r\n        });\r\n\r\n        const connection = peer.connect('source');\r\n        connection.on('open', () => {\r\n            console.log('connected to peer: '+connection.peer);\r\n\r\n            //TODO: get input from execution manager GET frontend.\r\n            //input offloading resources limits MUST be global value from user input (frontend)\r\n            availableOffloadingResources(orList).then(result => {\r\n                if(!isNaN(result)){\r\n                    //push string 'dmi' as last entry in the array\r\n                    result.push('dmi');\r\n                    console.log(result);\r\n                    //send dmi as array\r\n                    connection.send(result);}\r\n                else{\r\n                    //Todo : close connection\r\n                }\r\n            }).catch(error => {\r\n                console.error(error);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n//TODO: process pipeline in exe\r\nasync function processPipeline(receivedPipeline){\r\n    //TODO: extract intermediate result from pipeline with a new key in the object\r\n    //input = receivedPipeline.\r\n    let manager = new sweva.ExecutionManager();\r\n    manager.setup(receivedPipeline);\r\n    return await manager.execute(input,{});\r\n}\r\n\r\nmodule.exports = potentialOffloadingTarget","\r\n\r\n//Question: should i declare si outside or in the function?\r\n/*\r\n// output format DMI = [cpu %,mem %,battery %]\r\n\r\nasync function deviceMonitoringIndex() {\r\n        let listOfMetrics = [];\r\n\r\n\r\n        const cpu = await si.currentLoad().catch((err) => {\r\n            console.log('Error getting memory');\r\n            console.error(err);\r\n            reject();\r\n        });\r\n\r\n        const mem = await si.mem().catch((err) => {\r\n            console.log('Error getting memory');\r\n            console.error(err);\r\n            reject();\r\n        });\r\n\r\n        const memRSS = process.memoryUsage();\r\n\r\n        //Optional: const storage = await si.fsSize();\r\n        const battery = await si.battery().catch((err) => {\r\n            console.log('Error getting memory');\r\n            console.error(err);\r\n            reject();\r\n        });\r\n        listOfMetrics.push(cpu.avgLoad.toFixed(2), ((memRSS.rss/mem.available)*100).toFixed(2),battery.percent);\r\n        //Optional: const status = battery.ischarging\r\n        return listOfMetrics;\r\n\r\n    //todo: error handling\r\n    }\r\n\r\n//while false continue executing pipeline\r\n// if od = TRUE, aboard execution of promise and offload\r\n\r\n//input offloadingDecisionList = [cpu %, mem %, battery %]\r\n\r\nasync function offloadingDecision2(odList) {\r\n    if (odList[0] === 0 || odList[1] === 0 || odList[2] === 0) {\r\n        return true\r\n    } // case 1\r\n    let dmiList = await deviceMonitoringIndex();\r\n        console.log(dmiList);\r\n        return (dmiList[0] < odList[0] ||\r\n            dmiList[1] < odList[1] ||\r\n            dmiList[2] < odList[2]); //case 2\r\n\r\n\r\n\r\n}\r\n*/\r\n\r\n// Optimized DMI function:\r\n// TODO : require not working in WEB environment !\r\n\r\n\r\n\r\n\r\n\r\nasync function offloadingDecision(odList) {\r\n    if (odList[0] === 0 || odList[1] === 0 || odList[2] === 0) {\r\n        return true;\r\n    }\r\n    let cpuLoad = 0;\r\n    let memUsage = 0;\r\n    let batteryPercent = 0;\r\n    let offloading = false;\r\n    if (typeof window !== 'undefined') {\r\n        //Browser environment\r\n\r\n        memUsage = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100;\r\n        let battery = await navigator.getBattery();\r\n        batteryPercent = battery.level * 100;\r\n    } else {\r\n        //NodeJS environment\r\n        let si = require('systeminformation');\r\n\r\n        await ([\r\n            si.currentLoad(),\r\n            si.mem(),\r\n            si.battery()\r\n        ]).then(([cpu, mem, battery]) => {\r\n            let memRSS = process.memoryUsage();\r\n            memUsage = (memRSS.rss / mem.available) * 100;\r\n            cpuLoad = cpu.avgLoad;\r\n            batteryPercent = battery.percent;\r\n            console.log('cpu = ',cpuLoad, 'mem = ',memUsage,'battery = ',batteryPercent);\r\n        }).catch((err) => {\r\n            console.log('Error occurred while monitoring device: ' + err);\r\n        });\r\n    }\r\n            if (cpuLoad > odList[0]) {\r\n                console.log('Monitoring = CPU limit exceeded');\r\n                offloading = true;\r\n            } else if (memUsage > odList[1]) {\r\n                console.log('Monitoring = Memory limit exceeded');\r\n                offloading = true;\r\n            } else if (batteryPercent < odList[2]) {\r\n                console.log('Monitoring = Battery limit exceeded');\r\n                offloading = true;\r\n            }\r\n\r\n    return offloading;\r\n}\r\nmodule.exports = offloadingDecision\r\n\r\n\r\n\r\n//for testing purposes\r\n\r\n// USER Input odList = [Limit_cpu %, Limit_mem %, Limit_battery %]\r\n\r\n//let time =0;\r\nlet i=0;\r\nlet odList =[10,10,60];\r\nlet startTime = null;\r\nlet endTime =null;\r\nlet avgList=[] ;\r\n\r\n\r\nsetInterval(()=>{\r\n       startTime = process.hrtime();\r\n       offloadingDecision(odList).then ((result)=>{\r\n       endTime = process.hrtime(startTime);\r\n\r\n       console.log('Monitoring Round #'+i);\r\n       i++;\r\n       console.log(result);\r\n       console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\r\n   });\r\n\r\n\r\n},1500);\r\n\r\n\r\n\r\n","\r\n\r\n//input orl: offloading Resources Limits = [ORcpu % ,ORmem % ,ORbattery %, isCharging (binary)]\r\n\r\nconst si = require(\"systeminformation\");\r\n\r\nasync function availableOffloadingResources(orList) {\r\n    if (orList[0] === 0 || orList[1] === 0 || orList[2] === 0) {\r\n        return NaN;\r\n    }\r\n    let listOfMetrics =[];\r\n\r\n\r\n    const [cpu, mem, battery] = await Promise.all([\r\n        si.currentLoad(),\r\n        si.mem(),\r\n        si.battery()\r\n    ]).catch((err) => {\r\n        console.log('Error occurred while monitoring device with package systeminformation: ' + err);\r\n    });\r\n\r\n    const cpuLoad = cpu.avgLoad;\r\n\r\n    const freeMem =  (1-(mem.available/mem.total))*100; //free memory in percent\r\n    const batteryUsage = battery.percent; // battery usage in percent\r\n    const batteryIsCharging = battery.acConnected; //battery is charging when TRUE\r\n\r\n    if ( cpuLoad < orList[0] || //current cpu load is less than user input\r\n        freeMem >=orList[1] || // current free memory is bigger than user input\r\n        batteryUsage >= orList[2] || // current battery is bigger than user input\r\n        batteryIsCharging === orList[3]\r\n    )\r\n    {\r\n        //Output metrics in percent %\r\n        listOfMetrics.push(cpuLoad,freeMem,batteryUsage,batteryIsCharging);\r\n        return(listOfMetrics);\r\n    }else{\r\n        return NaN\r\n    }\r\n\r\n\r\n}\r\n\r\n//for testing purposes\r\n\r\n// USAGE example: input is odList\r\n\r\n/*\r\n\r\nconst startTime = process.hrtime;\r\navailableOffloadingResources([10,10,10,true]).then((result) => {\r\n    const endTime = process.hrtime(startTime);\r\n    console.log(result);\r\n    console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\r\n\r\n});\r\n\r\n*/\r\nmodule.exports = availableOffloadingResources","'use strict';\r\n\r\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\r\nvar Runner = require('../../core/runners/runner.js');\r\nvar Compiler = require('../../core/compilers/assemblyScriptCompiler.js');\r\nvar Composable = require('../../core/composables/composable.js');\r\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\r\nvar DefinitionError = require('../../core/errors/ExecutionError.js');\r\nvar SupportLibrary = require('../../core/execution/supportLibrary.js');\r\n\r\n\r\n/**\r\n * Parameters in the AssemblyScript run function starting with this string are used for the user inputs.\r\n */\r\nconst userInputSeparator = \"input_\";\r\n\r\n/**\r\n * The AssemblyScript runner supports strict TypeScript\r\n *\r\n * @constructor\r\n * @extends Runner\r\n *\r\n */\r\nfunction AssemblyScriptRunner() {\r\n    this.supportLib = new SupportLibrary();\r\n    this.supportLib.loadHTTP();\r\n    this.supportLib.loadLogger();\r\n    this.supportLib.loadTestSync();\r\n    this.compiler = new Compiler(this.supportLib);\r\n}\r\n\r\nAssemblyScriptRunner.prototype.getHTMLDescription = function () {\r\n    let description = \"Find the official AssemblyScript documentation on <a href='https://www.assemblyscript.org/introduction.html' target='_blank'>assemblyscript.org</a>.\\n\" +\r\n        \"The exported <b>run</b> function will be called with the parameters as data inputs and returned data as an output called <b>out</b>. User inputs have to be prefixed with <b>input_</b> and be the first parameters.\\n\" +\r\n        \"Additional outputs are generated for exported global variables. This allows returning values resulting from asynchronous callbacks.\\n\" +\r\n        \"If the <b>run</b> function has the return type \\\"void\\\" no default output is generated.\\n\";\r\n    description += \"\\n\" + this.compiler.supportLibraryDocumentation;\r\n\r\n    //HTML new lines\r\n    description.replaceAll(\"\\n\", \"<br>\");\r\n    return description;\r\n};\r\n\r\n//inherit properties\r\nAssemblyScriptRunner.prototype = Object.create(Runner.prototype);\r\nAssemblyScriptRunner.prototype.constructor = AssemblyScriptRunner;\r\n\r\nAssemblyScriptRunner.prototype.name = \"TypeScript (using AssemblyScript)\";\r\nAssemblyScriptRunner.prototype.id = \"typescript\";\r\n\r\n//=== OFFLOADING === Module => ASC code to WASM binary\r\nAssemblyScriptRunner.prototype.prepare = async function (module, callbackList = []) {\r\n    let definitionData = null;\r\n\r\n    if (!module.binary || module.binary.length === 0 || module.binaryHash !== this.calculateBinaryHash(module.binary)) {\r\n        module.binaryHash = null;\r\n        // monitored compilation in ASCcompiler.js\r\n        let compilerResult = await this.compiler.compile(module);\r\n            console.log('compilerResult');\r\n            console.log(compilerResult);\r\n            if (compilerResult === 'offloading') {\r\n                //todo: Offloading needed\r\n                console.log(\"offloading intercepted in ASCRunner.prepare()\")\r\n                return 'offloading';\r\n            } else {\r\n                module.binary = compilerResult.binaryData;\r\n                module.binaryHash = this.calculateBinaryHash(module.binary);\r\n                definitionData = compilerResult.definitionData;\r\n            }\r\n        }\r\n\r\n    const moduleInstance = await AsBind.instantiate(module.binary, {\r\n        module: this.generateFunctionDescription(callbackList)\r\n    });\r\n\r\n    if (definitionData != null)\r\n        this.createDataSchema(module, moduleInstance, definitionData);\r\n\r\n    return moduleInstance;\r\n}\r\n\r\n\r\n/**\r\n *  wrapper for\r\n */\r\nAssemblyScriptRunner.prototype.generateFunctionDescription = function (callbackList) {\r\n    let functions = {};\r\n\r\n    for (let funcName in this.supportLib.functions) {\r\n        let funcDesc = this.supportLib.functions[funcName];\r\n        let functionReference;\r\n\r\n        if (funcDesc.async) {\r\n            //params has callback name as first argument followed by regular parameters\r\n            functionReference = function (...params) {\r\n                let callbackName = params[0];\r\n                params.shift();\r\n\r\n                callbackList.push({\r\n                    promise: funcDesc.func(...params),\r\n                    params: params,\r\n                    funcName: funcName,\r\n                    callbackName: callbackName\r\n                });\r\n            }\r\n        } else {\r\n            functionReference = funcDesc.func;\r\n        }\r\n\r\n        functions[\"lib.\" + funcName] = functionReference;\r\n    }\r\n    return functions;\r\n}\r\n\r\nAssemblyScriptRunner.prototype.exec = async function (module, data, input) {\r\n\r\n    let callbackList = [];\r\n    /*\r\n    console.log(\"///////////// ASC runner inputs //////////////\");\r\n    console.log(\"module\");\r\n    console.log(module);\r\n    console.log(\"data\");\r\n    console.log(data);\r\n    console.log(\"input\");\r\n    console.log(input);\r\n    console.log(\"///////////////////////////\");\r\n     */\r\n    //compile and update schema\r\n    let instance = await this.prepare(module, callbackList);\r\n    console.log('instance');\r\n    console.log(instance);\r\n    if (instance === 'offloading') {\r\n        console.log('offloading intercepted in ASCRunner.exec()');\r\n        return 'offloading';\r\n\r\n    }\r\n    console.log('module prepared= ');\r\n    console.log(module);\r\n\r\n    let preparedParams = [];\r\n    if (module.inputNames.length > 0)\r\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.inputNames, input, module.context));\r\n    if (module.dataInNames.length > 0)\r\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.dataInNames, data, module.context));\r\n\r\n    //Module input\r\n    console.log('Module source code input');\r\n    console.log(preparedParams);\r\n\r\n    // returnValue returns the result from the binary execution of the WASM module\r\n    //todo execute this after checking DMI ! if() else ...\r\n    // TODO Promise.Race here!!!!!!!!\r\n    let returnValue = instance.exports.run(...preparedParams);\r\n    console.log('returnValue = ');\r\n    console.log(returnValue);\r\n\r\n    //finish executing all asynchronous functions ( if callback functions are needed by the module )\r\n    while (callbackList.length > 0) {\r\n        console.log(\"Remaining Callback: \");\r\n        console.log(callbackList[0]);\r\n        let result = null;\r\n        try {\r\n            //todo: monitor this?\r\n            result = await callbackList[0].promise;\r\n\r\n        } catch (err) {\r\n            throw new ExecutionError(\"Error in support function \" + callbackList[0].funcName + \" with parameters \" + callbackList[0].params + \"!\", module.context);\r\n        }\r\n\r\n        if (result !== null) {\r\n\r\n            let callbackDescriptor = instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName];\r\n            if (!callbackDescriptor)\r\n                throw new DefinitionError(\"Callback function with name \" + callbackList[0].callbackName + \" not found!\", module.context);\r\n\r\n            try {\r\n                if (callbackList[0].callbackName != null && callbackList[0].callbackName !== \"\") {\r\n                    //match number of parameters of callback\r\n                    let callbackParamCount = callbackDescriptor.parameters.length;\r\n                    let preparedResult = result.slice(0, callbackParamCount);\r\n                    console.log(instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName]);\r\n\r\n                    //Todo: do something with callback returns?\r\n                    let returnValue = instance.exports[callbackList[0].callbackName](...preparedResult);\r\n\r\n                    if (returnValue)\r\n                        console.log(\"Callback return: \" + returnValue);\r\n                }\r\n            } catch (err) {\r\n                throw new ExecutionError(\"Error while calling callback function \" + callbackList[0].callbackName + \" with parameters '\" + result + \"'!\", module.context);\r\n            }\r\n        }\r\n        callbackList.shift();\r\n    }\r\n    return this.collectOutputData(instance, returnValue);\r\n}\r\n\r\nAssemblyScriptRunner.prototype.collectOutputData = function (moduleInstance, returnValue) {\r\n    let result = {};\r\n\r\n    if (returnValue !== undefined) {\r\n        result.out = returnValue;\r\n    }\r\n    console.log('AsBind');\r\n    console.log(AsBind);\r\n    console.log('moduleInstance');\r\n    console.log(moduleInstance);\r\n\r\n\r\n    for (let exportedObj in moduleInstance.exports) {\r\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\r\n            result[exportedObj] = moduleInstance.exports[this.compiler.internalGetterPrefix + exportedObj]();\r\n        }\r\n    }\r\n    console.log('result');\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\nAssemblyScriptRunner.prototype.findParamAssignment = function (names, values, context) {\r\n    let preparedParams = [];\r\n    for (let i in names) {\r\n        let matchFound = false;\r\n        if (values !== undefined && values != null) {\r\n            for (let inputName in values) {\r\n                if (names[i] === inputName) {\r\n                    preparedParams.push(values[inputName]);\r\n                    matchFound = true;\r\n                }\r\n            }\r\n        }\r\n        if (!matchFound)\r\n            throw new DefinitionError(\"Mismatch between received and expected parameters!\\nExpected \\\"\" + names[i] + \"\\\", but not contained in received parameters: \" + JSON.stringify(values), context);\r\n    }\r\n    return preparedParams;\r\n}\r\n\r\n\r\nAssemblyScriptRunner.prototype.parseAssemblyScriptVariableNames = function (definitionData) {\r\n    let paramNames = Array();\r\n    let lines = definitionData.split(\"\\n\");\r\n    for (let line in lines) {\r\n        if (lines[line].indexOf(\"export function run\") === 0) {\r\n            let params = lines[line].substring(lines[line].indexOf('(') + 1, lines[line].indexOf(')')).split(', ');\r\n            for (let i in params) {\r\n                let paramName = params[i].substring(0, params[i].indexOf(\":\"));\r\n                if (paramName.length > 0)\r\n                    paramNames.push(paramName);\r\n            }\r\n        }\r\n    }\r\n    return paramNames;\r\n}\r\n\r\nAssemblyScriptRunner.prototype.createDataSchema = function (module, moduleInstance, definitionData) {\r\n    let run = moduleInstance.typeDescriptor.exportedFunctions.run;\r\n\r\n    //verify entrypoint exists\r\n    if (run === undefined)\r\n        throw new DefinitionError(\"Missing entrypoint: exported function named run is required, as an entrypoint.\", module.context);\r\n\r\n    //inputs\r\n    //parse parameter names of run function - replace, if AssemblyScript API, to access parameter names becomes available\r\n    let paramNames = this.parseAssemblyScriptVariableNames(definitionData);\r\n\r\n    if (run.parameters.length !== paramNames.length)\r\n        throw new DefinitionError(\"Parameter length mismatch! Parameters could not be parsed fully!\", module.context);\r\n\r\n    module.dataInNames = [];\r\n    module.inputNames = [];\r\n    module.dataInSchema = {type: \"object\", properties: {}};\r\n    module.inputSchema = {type: \"object\", properties: {}};\r\n\r\n    for (let i in run.parameters) {\r\n        if (paramNames[i].startsWith(userInputSeparator)) {\r\n            module.inputNames.push(paramNames[i]);\r\n\r\n            module.inputSchema.properties[paramNames[i]] = {type: run.parameters[i]};\r\n        } else {\r\n            module.dataInNames.push(paramNames[i]);\r\n\r\n            module.dataInSchema.properties[paramNames[i]] = {type: run.parameters[i]};\r\n        }\r\n    }\r\n\r\n    //outputs\r\n    module.dataOutNames = [];\r\n    module.dataOutSchema = {type: \"object\", properties: {}};\r\n    for (let exportedObj in moduleInstance.exports) {\r\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\r\n            module.dataOutNames.push(exportedObj);\r\n            module.dataOutSchema.properties[exportedObj] = {type: moduleInstance.typeDescriptor.exportedFunctions[this.compiler.internalGetterPrefix + exportedObj]}\r\n        }\r\n    }\r\n    if (run.returnType !== 'void') {\r\n        if (!module.dataOutNames.includes('out')) {\r\n            module.dataOutNames.push('out');\r\n            module.dataOutSchema.properties['out'] = {type: run.returnType}\r\n        } else {\r\n            throw new DefinitionError(\"Duplicate parameter called 'out'! Do not use 'out' as a name for exported variables!\", module.context);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = AssemblyScriptRunner;","'use strict';\r\n\r\n\r\n/**\r\n * The runner executes the compiled code made available by the compiler and contains a reference to the matching compiler\r\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\r\n * The setup needs to be done only once, while the execution can be repeated on different data.\r\n * \r\n * This is a default implementation, which should be subclassed for each supported language\r\n * \r\n * @constructor\r\n * @abstract\r\n */\r\nfunction Runner() {\r\n    /**\r\n    * Determines, if dependencies are loaded.\r\n    * @name ExecutionManager#modulesTotal\r\n    * @type {boolean}\r\n    */\r\n    this.setupCompleted = false;\r\n}\r\n\r\n/**\r\n * Run the provided binary or source code\r\n * @param {module} module - module containing source code/binary to run\r\n * @param {Object} data - data passed to the processing node\r\n * @param {Object} input - inputs passed to the processing node\r\n * @abstract\r\n */\r\nRunner.prototype.exec = function (module, data, input) {\r\n}\r\n\r\n/**\r\n * Prepare the provided module for execution:\r\n * - compile, if not already compiled\r\n * - update references to binary/hash\r\n * - update data schemes\r\n * This is also used to validate new source code while editing\r\n *\r\n * @param {module} module - module containing source code/binary to run\r\n * @return {Object} instance ready to execute\r\n * @throws CompileError\r\n *\r\n * @abstract\r\n */\r\nRunner.prototype.prepare = function (module) {}\r\n\r\n/**\r\n * End user friendly Name\r\n */\r\nRunner.prototype.name = \"Abstract Runner\"\r\n\r\n/**\r\n * ID used internally, to identify runners\r\n */\r\nRunner.prototype.id = \"abstract_runner\"\r\n\r\n/**\r\n * @return Description of the runner including a link to the official documentation and support library explanation as html.\r\n * @abstract\r\n */\r\nRunner.prototype.getHTMLDescription = function () {}\r\n\r\n\r\n/**\r\n * Calculates Hash used to compare binaries\r\n *\r\n * @param {Uint8Array} binary - binary to hash\r\n * @return hash\r\n *\r\n */\r\nRunner.prototype.calculateBinaryHash = function (binary) {\r\n    let hash = 0;\r\n    for(let i in binary) {\r\n        hash = ((hash << 8)-hash)+binary[i];\r\n    }\r\n    return hash;\r\n}\r\n\r\n/**\r\n * Determine data schema based on source/binary and write results to the module\r\n * The properties dataInSchema, dataOutSchema, inputSchema, dataInNames, dataOutNames, inputNames of the module can be written\r\n * Called automatically, when new source is compiled, but can be used to manually regenerate data schema\r\n *\r\n * @param {module} module - module containing source code/binary\r\n *\r\n * @abstract\r\n */\r\nRunner.prototype.createDataSchema = function (module) {\r\n}\r\n\r\nmodule.exports = Runner","'use strict';\r\nvar JsTokens = require('../../../node_modules/js-tokens/index.js');\r\n/**\r\n * Responsible to verify if a string complies to a safe  JavaScript subset.\r\n * A blacklist used to ensure no harmful operation can be performed by user defined scripts.\r\n * Currently the following tokens are forbidden:\r\n * arguments, callee, caller, constructor, eval, prototype, stack, unwatch, valueOf, watch, __proto__, __parent__, 'this', window, document, '[', ']', Function, 'with', uneval, toSource, setTimeout, setInterval\r\n * Use {@link SwevaScript#get} as a replacement for [].\r\n * \r\n * Additionally global variables are masked.\r\n * @constructor \r\n */\r\nfunction SwevaScript() {\r\n    /**\r\n    * List of forbidden tokens, that are not allowed in this JavaScript subset.\r\n    * @name SwevaScript#forbiddenList\r\n    * @type {Object.<string, boolean>}\r\n    */\r\n    this.forbiddenList = {\r\n        arguments: true,\r\n        callee: true,\r\n        caller: true,\r\n        constructor: true,\r\n        eval: true,\r\n        prototype: true,\r\n        stack: true,\r\n        unwatch: true,\r\n        valueOf: true,\r\n        watch: true,\r\n\r\n        __proto__: true,\r\n        __parent__: true,\r\n        'this': true,\r\n        window: true,\r\n        document: true,\r\n        '[': true,\r\n        ']': true,\r\n        Function: true,\r\n        'with': true,\r\n        uneval: true,\r\n        toSource: true,\r\n        setTimeout: true,\r\n        setInterval: true\r\n    }\r\n    /**\r\n    * List of allowed global variables, that should not be masked.\r\n    * This is currently: Math, console \r\n    * @name SwevaScript#allowedGlobals\r\n    * @type {Object.<string, boolean>}\r\n    */\r\n    this.allowedGlobals = {\r\n        Math: true,\r\n        console: true,\r\n        'true': true,\r\n        'false': true\r\n    }\r\n}\r\n\r\n/**\r\n * Verifies if a JavaScript code complies to the safer JavaScript subset.\r\n * Does not rewrite or change the code, therefor you should DENY anything, that is considered harmful by this function.\r\n * \r\n * @param {string} code - The JavaScript code to verify for safety.\r\n * @returns {boolean} True, if the code does not contain forbidden tokens.\r\n */\r\nSwevaScript.prototype.verify = function (code) {\r\n    try {\r\n        //get an array of tokens using the tokenizer (external library)\r\n        var tokens = code.match(JsTokens);\r\n    } catch (e) {\r\n        return {\r\n            valid: false,\r\n            error: e.message\r\n        }\r\n    }\r\n   \r\n    //check for each token\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i].trim();\r\n        if (token.length > 0) {\r\n            //if token non empty: is it in the blacklist?\r\n            if (this.forbiddenList.hasOwnProperty(token)) {\r\n                return {\r\n                    valid: false,\r\n                    error: 'Invalid usage of ' + token\r\n                };\r\n            }\r\n        }\r\n\r\n        \r\n    }\r\n\r\n    //if no return reached before, we can assume there was no forbidden token present\r\n    return {\r\n        valid: true,\r\n        error: ''\r\n    }\r\n};\r\n\r\n/**\r\n * Replaces the forbidden [] accessor, by checking the property name during runtime.\r\n * If a forbidden property (see {@link SwevaScript}) is used, the property is not accessed.\r\n * \r\n * @param {Object} object - The object from which the property value is required.\r\n * @param {string|number} property - The name of the property to retrieve the value from.\r\n * returns {Object|boolean|string|number} - The value of the property, if an illegal property name is used null.\r\n */\r\nSwevaScript.prototype.get = function (object, property) {\r\n    var forbiddenList = {\r\n        arguments: true,\r\n        callee: true,\r\n        caller: true,\r\n        constructor: true,\r\n        eval: true,\r\n        prototype: true,\r\n        stack: true,\r\n        unwatch: true,\r\n        valueOf: true,\r\n        watch: true,\r\n\r\n        __proto__: true,\r\n        __parent__: true,\r\n        'this': true,\r\n        window: true,\r\n        document: true,\r\n        '[': true,\r\n        ']': true,\r\n        Function: true,\r\n        'with': true,\r\n        uneval: true,\r\n        toSource: true,\r\n        setTimeout: true,\r\n        setInterval: true\r\n    }\r\n    //if a string is provided, check for being in the blacklist\r\n    if (typeof property === 'string') {\r\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\r\n            return object[property];\r\n        }\r\n    }\r\n    //numbers are not checked for being in the blacklist\r\n    else if (typeof property === 'number') {\r\n        return object[property];\r\n    }\r\n\r\n    console.error('Illegal property name: ' + property);\r\n    return null;\r\n}\r\n\r\nSwevaScript.prototype.set = function (object, property, value) {\r\n    var forbiddenList = {\r\n        arguments: true,\r\n        callee: true,\r\n        caller: true,\r\n        constructor: true,\r\n        eval: true,\r\n        prototype: true,\r\n        stack: true,\r\n        unwatch: true,\r\n        valueOf: true,\r\n        watch: true,\r\n\r\n        __proto__: true,\r\n        __parent__: true,\r\n        'this': true,\r\n        window: true,\r\n        document: true,\r\n        '[': true,\r\n        ']': true,\r\n        Function: true,\r\n        'with': true,\r\n        uneval: true,\r\n        toSource: true,\r\n        setTimeout: true,\r\n        setInterval: true\r\n    }\r\n    //if a string is provided, check for being in the blacklist\r\n    if (typeof property === 'string') {\r\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\r\n            object[property] = value;\r\n        }\r\n        else {\r\n            console.error('Illegal property name: ' + property);\r\n        }\r\n    }\r\n    //numbers are not checked for being in the blacklist\r\n    else if (typeof property === 'number') {\r\n        object[property] = value;\r\n    }\r\n};\r\n\r\n/**\r\n * Sanitizes given Javascript code by verifying if it is a safer subset of JavaScript and masking global variables.\r\n * {@link SwevaScript#verify} is performed internally, so you do not need to verify explicitly beforehand.\r\n * @param {string} code - The JavaScript function to sanitize.\r\n * @param {function} errorCallback - A callback called, when an error occurs, has a string as a parameter with the error message.\r\n * @returns{function} - A function, that can be executed\r\n */\r\nSwevaScript.prototype.sanitize = function (code, errorCallback) {\r\n    //all in one line\r\n    //code = code.replace(/(\\r\\n|\\n|\\r)/gm, \"\"); \r\n   \r\n    var error = '';\r\n    //first make sure it is valid SwevaScript\r\n    var validation = this.verify(code);    \r\n    if (validation.valid) {        \r\n        var allowedGlobals = this.allowedGlobals;\r\n        //get all global variables except the exceptions we defined in {@link SwevaScript#allowedGlobals}\r\n        var globals = Object.keys(window).filter(function (obj) {\r\n            return !allowedGlobals.hasOwnProperty(obj)\r\n        }).join(',');\r\n        //we want to shadow all global variables except the ones we allow, by declaring them as local variables\r\n        //https://stackoverflow.com/posts/26917938/revisions\r\n        //var funcReg = /function *\\(([^()]*)\\)[ \\n\\t]*{(.*)}/gmi;\r\n        var funcReg = /function\\s*\\(([^()]*)\\)\\s\\{((.|\\n)*)\\}/gmi;\r\n        var match = funcReg.exec(code);\r\n       \r\n        //we extract funtion header (decrlaration with parameters) and body\r\n        if (match) {\r\n            \r\n            //enforce strict behavior, shadow globals, append verified code\r\n            var fn_text = '\"use strict\"; var ' + globals + ';' + match[2] + ';';\r\n            \r\n            var fn = new Function(match[1].split(','), fn_text);//generate sanitized function\r\n\r\n            return fn;\r\n        }\r\n        else {\r\n            error = 'Not a valid JS function';\r\n        }\r\n    }\r\n    else {\r\n        error = validation.error;\r\n    }\r\n    if (typeof errorCallback === 'function') {\r\n        errorCallback(error);\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\nmodule.exports = SwevaScript;","'use strict';\n\nvar compileSchema = require('./compile')\n    , resolve = require('./compile/resolve')\n    , Cache = require('./cache')\n    , SchemaObject = require('./compile/schema_obj')\n    , stableStringify = require('json-stable-stringify')\n    , formats = require('./compile/formats');\n\nmodule.exports = Ajv;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';\nvar SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i;\nfunction SCHEMA_URI_FORMAT_FUNC(str) {\n    return SCHEMA_URI_FORMAT.test(str);\n}\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n    if (!(this instanceof Ajv)) return new Ajv(opts);\n    var self = this;\n\n    this.opts = opts || {};\n    this._schemas = {};\n    this._refs = {};\n    this._formats = formats(this.opts.format);\n    this._cache = this.opts.cache || new Cache;\n    this._loadingSchemas = {};\n\n    // this is done on purpose, so that methods are bound to the instance\n    // (without using bind) so that they can be used without the instance\n    this.validate = validate;\n    this.compile = compile;\n    this.compileAsync = compileAsync;\n    this.addSchema = addSchema;\n    this.addMetaSchema = addMetaSchema;\n    this.validateSchema = validateSchema;\n    this.getSchema = getSchema;\n    this.removeSchema = removeSchema;\n    this.addFormat = addFormat;\n    this.errorsText = errorsText;\n\n    this._compile = _compile;\n\n    addInitialSchemas();\n    if (this.opts.formats) addInitialFormats();\n\n\n    /**\n     * Validate data using schema\n     * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     * @param  {Any} data to be validated\n     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n     */\n    function validate(schemaKeyRef, data) {\n        var v;\n        if (typeof schemaKeyRef == 'string') {\n            v = getSchema(schemaKeyRef);\n            if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n        } else {\n            var schemaObj = _addSchema(schemaKeyRef);\n            v = schemaObj.validate || _compile(schemaObj);\n        }\n\n        var valid = v(data);\n        self.errors = v.errors;\n        return valid;\n    }\n\n\n    /**\n     * Create validating function for passed schema.\n     * @param  {String|Object} schema\n     * @return {Function} validating function\n     */\n    function compile(schema) {\n        var schemaObj = _addSchema(schema);\n        return schemaObj.validate || _compile(schemaObj);\n    }\n\n\n    /**\n     * Create validating function for passed schema with asynchronous loading of missing schemas.\n     * `loadSchema` option should be a function that accepts schema uri and node-style callback.\n     * @param  {String|Object} schema\n     * @param  {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.\n     */\n    function compileAsync(schema, callback) {\n        var schemaObj;\n        try {\n            schemaObj = _addSchema(schema);\n        } catch(e) {\n            setTimeout(function() { callback(e); });\n            return;\n        }\n        if (schemaObj.validate)\n            setTimeout(function() { callback(null, schemaObj.validate); });\n        else {\n            if (typeof self.opts.loadSchema != 'function')\n                throw new Error('options.loadSchema should be a function');\n            _compileAsync(schema, callback, true);\n        }\n    }\n\n\n    function _compileAsync(schema, callback, firstCall) {\n        var validate;\n        try { validate = compile(schema); }\n        catch(e) {\n            if (e.missingSchema) loadMissingSchema(e);\n            else deferCallback(e);\n            return;\n        }\n        deferCallback(null, validate);\n\n        function loadMissingSchema(e) {\n            var ref = e.missingSchema;\n            if (self._refs[ref] || self._schemas[ref])\n                return callback(new Error('Schema ' + ref + ' is loaded but' + e.missingRef + 'cannot be resolved'));\n            var _callbacks = self._loadingSchemas[ref];\n            if (_callbacks) {\n                if (typeof _callbacks == 'function')\n                    self._loadingSchemas[ref] = [_callbacks, schemaLoaded];\n                else\n                    _callbacks[_callbacks.length] = schemaLoaded;\n            } else {\n                self._loadingSchemas[ref] = schemaLoaded;\n                self.opts.loadSchema(ref, function (err, sch) {\n                    var _callbacks = self._loadingSchemas[ref];\n                    delete self._loadingSchemas[ref];\n                    if (typeof _callbacks == 'function')\n                        _callbacks(err, sch);\n                    else\n                        for (var i=0; i<_callbacks.length; i++)\n                            _callbacks[i](err, sch);\n                });\n            }\n\n            function schemaLoaded(err, sch) {\n                if (err) callback(err);\n                else {\n                    if (!(self._refs[ref] || self._schemas[ref])) {\n                        try {\n                            addSchema(sch, ref);\n                        } catch(e) {\n                            callback(e);\n                            return;\n                        }\n                    }\n                    _compileAsync(schema, callback);\n                }\n            }\n        }\n\n        function deferCallback(err, validate) {\n            if (firstCall) setTimeout(function() { callback(err, validate); });\n            else callback(err, validate);\n        }\n    }\n\n\n    /**\n     * Adds schema to the instance.\n     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` will be ignored.\n     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n     */\n    function addSchema(schema, key, _skipValidation, _meta) {\n        if (Array.isArray(schema)){\n            for (var i=0; i<schema.length; i++) addSchema(schema[i]);\n            return;\n        }\n        // can key/id have # inside?\n        key = resolve.normalizeId(key || schema.id);\n        checkUnique(key);\n        var schemaObj = self._schemas[key] = _addSchema(schema, _skipValidation);\n        schemaObj.meta = _meta;\n    }\n\n\n    /**\n     * Add schema that will be used to validate other schemas\n     * removeAdditional option is alway set to false\n     * @param {Object} schema\n     * @param {String} key optional schema key\n     */\n    function addMetaSchema(schema, key, _skipValidation) {\n        addSchema(schema, key, _skipValidation, true);\n    }\n\n\n    /**\n     * Validate schema\n     * @param  {Object} schema schema to validate\n     * @return {Boolean}\n     */\n    function validateSchema(schema) {\n        var $schema = schema.$schema || META_SCHEMA_ID;\n        var currentUriFormat = self._formats.uri;\n        self._formats.uri = typeof currentUriFormat == 'function'\n                            ? SCHEMA_URI_FORMAT_FUNC\n                            : SCHEMA_URI_FORMAT;\n        var valid = validate($schema, schema);\n        self._formats.uri = currentUriFormat;\n        return valid;\n    }\n\n\n    /**\n     * Get compiled schema from the instance by `key` or `ref`.\n     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n     * @return {Function} schema validating function (with property `schema`).\n     */\n    function getSchema(keyRef) {\n        var schemaObj = _getSchemaObj(keyRef);\n        switch (typeof schemaObj) {\n            case 'object': return schemaObj.validate || _compile(schemaObj);\n            case 'string': return getSchema(schemaObj);\n        }\n    }\n\n\n    function _getSchemaObj(keyRef) {\n        keyRef = resolve.normalizeId(keyRef);\n        return self._schemas[keyRef] || self._refs[keyRef];\n    }\n\n\n    /**\n     * Remove cached schema\n     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     */\n    function removeSchema(schemaKeyRef) {\n        switch (typeof schemaKeyRef) {\n            case 'string':\n                var schemaObj = _getSchemaObj(schemaKeyRef);\n                self._cache.del(schemaObj.jsonStr);\n                delete self._schemas[schemaKeyRef];\n                delete self._refs[schemaKeyRef];\n                break;\n            case 'object':\n                var jsonStr = stableStringify(schemaKeyRef);\n                self._cache.del(jsonStr);\n                var id = schemaKeyRef.id;\n                if (id) {\n                    id = resolve.normalizeId(id);\n                    delete self._refs[id];\n                }\n        }\n    }\n\n\n    function _addSchema(schema, skipValidation) {\n        if (typeof schema != 'object') throw new Error('schema should be object');\n        var jsonStr = stableStringify(schema);\n        var cached = self._cache.get(jsonStr);\n        if (cached) return cached;\n\n        var id = resolve.normalizeId(schema.id);\n        if (id) checkUnique(id);\n\n        var ok = skipValidation || self.opts.validateSchema === false\n                 || validateSchema(schema);\n        if (!ok) {\n            var message = 'schema is invalid:' + errorsText();\n            if (self.opts.validateSchema == 'log') console.error(message);\n            else throw new Error(message);\n        }\n\n        var localRefs = resolve.ids.call(self, schema);\n\n        var schemaObj = new SchemaObject({\n            id: id,\n            schema: schema,\n            localRefs: localRefs,\n            jsonStr: jsonStr,\n        });\n\n        if (id[0] != '#') self._refs[id] = schemaObj;\n        self._cache.put(jsonStr, schemaObj);\n\n        return schemaObj;\n    }\n\n\n    function _compile(schemaObj, root) {\n        if (schemaObj.compiling) {\n            schemaObj.validate = callValidate;\n            callValidate.schema = schemaObj.schema;\n            callValidate.errors = null;\n            callValidate.root = root ? root : callValidate;\n            return callValidate;\n        }\n        schemaObj.compiling = true;\n\n        var currentRA = self.opts.removeAdditional;\n        if (currentRA && schemaObj.meta) self.opts.removeAdditional = false;\n        var v;\n        try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }\n        finally {\n            schemaObj.compiling = false;\n            if (currentRA) self.opts.removeAdditional = currentRA;\n        }\n\n        schemaObj.validate = v;\n        schemaObj.refs = v.refs;\n        schemaObj.refVal = v.refVal;\n        schemaObj.root = v.root;\n        return v;\n\n\n        function callValidate() {\n            var v = schemaObj.validate;\n            var result = v.apply(null, arguments);\n            callValidate.errors = v.errors;\n            return result;\n        }\n    }\n\n\n    function errorsText(errors, opts) {\n        errors = errors || self.errors;\n        if (!errors) return 'No errors';\n        opts = opts || {};\n        var separator = opts.separator || ', ';\n        var dataVar = opts.dataVar || 'data';\n\n        var text = errors.reduce(function(txt, e) {\n            return e ? txt + dataVar + e.dataPath + ' ' + e.message + separator : txt;\n        }, '');\n        return text.slice(0, -separator.length);\n    }\n\n\n    function addFormat(name, format) {\n        if (typeof format == 'string') format = new RegExp(format);\n        self._formats[name] = format;\n    }\n\n\n    function addInitialSchemas() {\n        if (self.opts.meta !== false) {\n            var metaSchema = require('./refs/json-schema-draft-04.json');\n            addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n            self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n        }\n\n        var optsSchemas = self.opts.schemas;\n        if (!optsSchemas) return;\n        if (Array.isArray(optsSchemas)) addSchema(optsSchemas);\n        else for (var key in optsSchemas) addSchema(optsSchemas[key], key);\n    }\n\n\n    function addInitialFormats() {\n        for (var name in self.opts.formats) {\n            var format = self.opts.formats[name];\n            addFormat(name, format);\n        }\n    }\n\n\n    function checkUnique(id) {\n        if (self._schemas[id] || self._refs[id])\n            throw new Error('schema with key or id \"' + id + '\" already exists');\n    }\n}\n","'use strict';\n\n\nvar Cache = module.exports = function Cache() {\n    this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n    this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n    return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n    delete this._cache[key];\n};\n","'use strict';\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': require('../dotjs/ref'),\n  anyOf: require('../dotjs/anyOf'),\n  format: require('../dotjs/format'),\n  maxLength: require('../dotjs/maxLength'),\n  minItems: require('../dotjs/minItems'),\n  minimum: require('../dotjs/minimum'),\n  oneOf: require('../dotjs/oneOf'),\n  required: require('../dotjs/required'),\n  dependencies: require('../dotjs/dependencies'),\n  items: require('../dotjs/items'),\n  maxProperties: require('../dotjs/maxProperties'),\n  minLength: require('../dotjs/minLength'),\n  multipleOf: require('../dotjs/multipleOf'),\n  pattern: require('../dotjs/pattern'),\n  uniqueItems: require('../dotjs/uniqueItems'),\n  allOf: require('../dotjs/allOf'),\n  enum: require('../dotjs/enum'),\n  maxItems: require('../dotjs/maxItems'),\n  maximum: require('../dotjs/maximum'),\n  minProperties: require('../dotjs/minProperties'),\n  not: require('../dotjs/not'),\n  properties: require('../dotjs/properties'),\n  validate: require('../dotjs/validate')\n};\n","'use strict';\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  var arrA = Array.isArray(a)\n    , arrB = Array.isArray(b)\n    , i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n    for (i = 0; i < a.length; i++)\n      if (!equal(a[i], b[i])) return false;\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    var keys = Object.keys(a);\n\n    if (keys.length !== Object.keys(b).length) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if (b[keys[i]] === undefined) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if(!equal(a[keys[i]], b[keys[i]])) return false;\n\n    return true;\n  }\n\n  return false;\n};\n","'use strict';\n\nvar util = require('./util');\n\nvar DATE = /^\\d\\d\\d\\d-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/;\nvar HOSTNAME = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?(?:\\#(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?$/i;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t ][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nformats.full = {\n  date: date,\n  'date-time': date_time,\n  uri: uri,\n  email: /^[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&''*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: hostname,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var month = +matches[1];\n  var day = +matches[2];\n  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];\n}\n\n\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.toLowerCase().split('t');\n  if (!date(dateTime[0])) return false;\n\n  var matches = dateTime[1].match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  return hour <= 23 && minute <= 59 && second <= 59;\n}\n\n\nfunction hostname(str) {\n  // http://tools.ietf.org/html/rfc1034#section-3.5\n  return str.length <= 255 && HOSTNAME.test(str);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|\\:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nfunction regex(str) {\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n","'use strict';\n\nvar resolve = require('./resolve')\n  , util = require('./util')\n  , equal = require('./equal');\n\ntry { var beautify = require('' + 'js-beautify').js_beautify; } catch(e) {}\n\nvar RULES = require('./rules')\n  , validateGenerator = require('../dotjs/validate');\n\nmodule.exports = compile;\n\n\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  var self = this\n    , refVal = [ undefined ] \n    , refs = {}\n    , patterns = []\n    , patternsHash = {};\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var formats = this._formats;\n\n  return localCompile(schema, root, localRefs, baseId);\n\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var validateCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errorPath: '\"\"',\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      opts: self.opts,\n      formats: formats\n    });\n\n    validateCode = refsCode(refVal) + patternsCode(patterns) + validateCode;\n\n    if (self.opts.beautify) {\n      var opts = self.opts.beautify === true ? { indent_size: 2 } : self.opts.beautify;\n      if (beautify) validateCode = beautify(validateCode, opts);\n      else console.error('\"npm install js-beautify\" to use beautify option');\n    }\n    // console.log('\\n\\n\\n *** \\n', validateCode);\n    var validate;\n    // try {\n      eval(validateCode);\n      refVal[0] = validate;\n    // } catch(e) {\n    //   console.log('Error compiling schema, function code:', validateCode);\n    //   throw e;\n    // }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (!v) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, self.opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v) {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(schema, code) {\n    return typeof schema == 'object'\n            ? { schema: schema, code: code }\n            : code;\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n}\n\n\nfunction patternsCode(patterns) {\n  return _arrCode(patterns, patternCode);\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction refsCode(refVal) {\n  return _arrCode(refVal, refCode);\n}\n\n\nfunction refCode(i, refVal) {\n  return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';\n}\n\n\nfunction _arrCode(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\n","'use strict';\n\nvar url = require('url')\n  , equal = require('./equal')\n  , util = require('./util')\n  , SchemaObject = require('./schema_obj');\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\n\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n  \n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject)\n    return inlineRef(refVal.schema, this.opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n\n  var res = _resolve.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject)\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  else if (schema)\n    v = inlineRef(schema, this.opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n\n  return v;\n}\n\n\nfunction _resolve(root, ref) {\n  /* jshint validthis: true */\n  var p = url.parse(ref, false, true)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(root.schema.id);\n  if (refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(root.schema.id);\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = _resolve.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    if (schema.id) baseId = resolveUrl(baseId, schema.id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum']);\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.hash = parsedRef.hash || '';\n  if (parsedRef.hash.slice(0,2) != '#/') return;\n  var parts = parsedRef.hash.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = unescapeFragment(part);\n      schema = schema[part];\n      if (!schema) break;\n      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);\n      if (schema.$ref) {\n        var $ref = resolveUrl(baseId, schema.$ref);\n        var res = _resolve.call(this, root, $ref);\n        if (res) {\n          schema = res.schema;\n          root = res.root;\n        }\n      }\n    }\n  }\n  if (schema && schema != root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum' \n]);\nfunction inlineRef(schema, limit) {\n  if (limit === undefined) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      else {\n        item = schema[key];\n        if (typeof item == 'object' && !checkNoRef(item)) return false;\n      }\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) count++;\n      else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction unescapeFragment(str) {\n  return decodeURIComponent(str)\n          .replace(/~1/g, '/')\n          .replace(/~0/g, '~');\n}\n\n\nfunction escapeFragment(str) {\n  str = str.replace(/~/g, '~0').replace(/\\//g, '~1');\n  return encodeURIComponent(str);\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = url.parse(id, false, true);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return (p.protocol||'') + (p.protocol?'//':'') + (p.host||'') + (p.path||'')  + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return url.resolve(baseId, id);\n}\n\n\nfunction resolveIds(schema) {\n  /* jshint validthis: true */\n  var id = normalizeId(schema.id);\n  var localRefs = {};\n  _resolveIds.call(this, schema, getFullPath(id, false), id);\n  return localRefs;\n\n  function _resolveIds(schema, fullPath, baseId) {\n    /* jshint validthis: true */\n    if (Array.isArray(schema))\n      for (var i=0; i<schema.length; i++)\n        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);\n    else if (schema && typeof schema == 'object') {\n      if (typeof schema.id == 'string') {\n        var id = baseId = baseId\n                          ? url.resolve(baseId, schema.id)\n                          : normalizeId(schema.id);\n\n        var refVal = this._refs[id];\n        if (typeof refVal == 'string') refVal = this._refs[refVal];\n        if (refVal && refVal.schema) {\n          if (!equal(schema, refVal.schema))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n        } else if (id != normalizeId(fullPath)) {\n          if (id[0] == '#') {\n            if (localRefs[id] && !equal(schema, localRefs[id]))\n              throw new Error('id \"' + id + '\" resolves to more than one schema');\n            localRefs[id] = schema;\n          } else\n            this._refs[id] = fullPath;\n        }\n      }\n      for (var key in schema)\n        _resolveIds.call(this, schema[key], fullPath+'/'+escapeFragment(key), baseId);\n    }\n  }\n}\n","'use strict';\n\nvar ruleModules = require('./_rules')\n  , util = require('./util');\n\nvar RULES = module.exports = [\n  { type: 'number',\n    rules: [ 'maximum', 'minimum', 'multipleOf'] },\n  { type: 'string',\n    rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n  { type: 'array',\n    rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },\n  { type: 'object',\n    rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },\n  { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }\n];\n\nRULES.all = [ 'type', 'additionalProperties', 'patternProperties' ];\n\n\nRULES.forEach(function (group) {\n  group.rules = group.rules.map(function (keyword) {\n    RULES.all.push(keyword);\n    return {\n      keyword: keyword,\n      code: ruleModules[keyword]\n    };\n  });\n});\n\nRULES.all = util.toHash(RULES.all);\n","'use strict';\n\nvar util = require('./util');\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n    util.copy(obj, this);\n}\n","'use strict';\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  ucs2length: ucs2length,\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  cleanUpCode: cleanUpCode,\n  cleanUpVarErrors: cleanUpVarErrors,\n  schemaHasRules: schemaHasRules,\n  stableStringify: require('json-stable-stringify'),\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1))';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);\n\n      return code;\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return IDENTIFIER.test(key)\n          ? '.' + key\n          : \"['\" + key.replace(SINGLE_QUOTE, '\\\\$&') + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&');\n}\n\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nvar EMPTY_ELSE = /else\\s*{\\s*}/g\n  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g\n  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;\nfunction cleanUpCode(out) {\n  return out.replace(EMPTY_ELSE, '')\n            .replace(EMPTY_IF_NO_ELSE, '')\n            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');\n}\n\n\nvar ERRORS_REGEXP = /[^v\\.]errors/g\n  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g\n  , RETURN_VALID = 'return errors === 0;'\n  , RETURN_TRUE = 'validate.errors = null; return true;';\n\nfunction cleanUpVarErrors(out) {\n  var matches = out.match(ERRORS_REGEXP);\n  if (matches && matches.length === 2)\n    return out.replace(REMOVE_ERRORS, '')\n              .replace(RETURN_VALID, RETURN_TRUE);\n  else\n    return out;\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction toQuotedString (str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr (currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath (currentPath, prop, jsonPointers) {\n  var path = jsonPointers\n              ? toQuotedString('/' + prop.replace(/~/g, '~0').replace(/\\//g, '~1'))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/' \\+ '/g, '');\n}\n","'use strict';\nmodule.exports = function generate_allOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['allOf'],\n    $schemaPath = it.schemaPath + '.' + 'allOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces.slice(0, -1));\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_anyOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['anyOf'],\n    $schemaPath = it.schemaPath + '.' + 'anyOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return it.util.schemaHasRules($sch, it.RULES.all);\n  });\n  if ($noEmptySchema) {\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ' + ($valid) + ' = ' + ($valid) + ' || valid' + ($it.level) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   { keyword: \\'' + ('anyOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match some schema in anyOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n    out = it.util.cleanUpCode(out);\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_dependencies(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['dependencies'],\n    $schemaPath = it.schemaPath + '.' + 'dependencies',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $schemaDeps = {},\n    $propertyDeps = {};\n  for ($property in $schema) {\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  for (var $property in $propertyDeps) {\n    out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined) { ';\n    $deps = $propertyDeps[$property];\n    out += ' if ( ';\n    var arr1 = $deps;\n    if (arr1) {\n      var $dep, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $dep = arr1[$i += 1];\n        if ($i) {\n          out += ' || ';\n        }\n        out += ' ' + ($data) + (it.util.getProperty($dep)) + ' === undefined ';\n      }\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      $closingBraces += '}';\n      out += ' else { ';\n    }\n    out += ' }';\n  }\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if (it.util.schemaHasRules($sch, it.RULES.all)) {\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '[\\'' + ($property) + '\\'] !== undefined) { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      out += ' ' + (it.validate($it)) + ' }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_enum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['enum'],\n    $schemaPath = it.schemaPath + '.' + 'enum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $i = 'i' + $lvl;\n  out += 'var enumSchema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ' , ' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<enumSchema' + ($lvl) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', enumSchema' + ($lvl) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; } if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_format(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['format'],\n    $schemaPath = it.schemaPath + '.' + 'format',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $format = it.formats[$schema];\n  if (it.opts.format !== false && $format) {\n    out += ' if (!   ';\n    if (typeof $format == 'function') {\n      out += ' formats' + (it.util.getProperty($schema)) + ' (' + ($data) + ') ';\n    } else {\n      out += ' formats' + (it.util.getProperty($schema)) + ' .test(' + ($data) + ') ';\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_items(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['items'],\n    $schemaPath = it.schemaPath + '.' + 'items',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + ';  if (!' + ($valid) + ') {  ';\n      if (!it.compositeRule && $breakOnError) {\n        out += ' validate.errors = [ { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }]; return false; ';\n      } else {\n        out += '  var err =   { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' }  ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          var $passData = $data + '[' + $i + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (valid' + ($it.level) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var i' + ($lvl) + ' = ' + ($schema.length) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n      var $passData = $data + '[i' + $lvl + ']';\n      var $code = it.validate($it);\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!valid' + ($it.level) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += '  for (var i' + ($lvl) + ' = ' + (0) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n    var $passData = $data + '[i' + $lvl + ']';\n    var $code = it.validate($it);\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!valid' + ($it.level) + ') break; ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxItems'],\n    $schemaPath = it.schemaPath + '.' + 'maxItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxLength'],\n    $schemaPath = it.schemaPath + '.' + 'maxLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxProperties'],\n    $schemaPath = it.schemaPath + '.' + 'maxProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maximum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maximum'],\n    $schemaPath = it.schemaPath + '.' + 'maximum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMaximum === true,\n    $op = $exclusive ? '<' : '<=',\n    $notOp = $exclusive ? '>=' : '>';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minItems'],\n    $schemaPath = it.schemaPath + '.' + 'minItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minLength'],\n    $schemaPath = it.schemaPath + '.' + 'minLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minProperties'],\n    $schemaPath = it.schemaPath + '.' + 'minProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minimum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minimum'],\n    $schemaPath = it.schemaPath + '.' + 'minimum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMinimum === true,\n    $op = $exclusive ? '>' : '>=',\n    $notOp = $exclusive ? '<=' : '<';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_multipleOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['multipleOf'],\n    $schemaPath = it.schemaPath + '.' + 'multipleOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'var division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schema) + ';if (' + ($data) + ' / ' + ($schema) + ' !== parseInt(division' + ($lvl) + ')) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_not(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['not'],\n    $schemaPath = it.schemaPath + '.' + 'not',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += ' ' + (it.validate($it)) + '  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (valid' + ($it.level) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be valid\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_oneOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['oneOf'],\n    $schemaPath = it.schemaPath + '.' + 'oneOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n      } else {\n        out += ' var valid' + ($it.level) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (valid' + ($it.level) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (valid' + ($it.level) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_pattern(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['pattern'],\n    $schemaPath = it.schemaPath + '.' + 'pattern',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  new RegExp($schema);\n  out += 'if (! ' + (it.usePattern($schema)) + '.test(' + ($data) + ') ) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_properties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['properties'],\n    $schemaPath = it.schemaPath + '.' + 'properties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  var $schemaKeys = Object.keys($schema || {}),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $requiredProperties = it.util.toHash(it.schema.required || []);\n  out += 'var ' + ($errs) + ' = errors;var valid' + ($it.level) + ' = true;';\n  if ($checkAdditional) {\n    out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { ';\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 5) {\n          out += ' || validate.schema' + ($schemaPath) + '[key' + ($lvl) + '] ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || key' + ($lvl) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n        } else {\n          out += ' valid' + ($it.level) + ' = false;  ';\n          if (!it.compositeRule && $breakOnError) {\n            out += ' validate.errors = [ { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }]; return false; ';\n          } else {\n            out += '  var err =   { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!valid' + ($it.level) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[key' + ($lvl) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!valid' + ($it.level) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          $it.schema = $sch;\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($requiredProperties[$propertyKey]) {\n            out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = false; ';\n            var $currentErrorPath = it.errorPath,\n              $missingProperty = it.util.escapeQuotes($propertyKey);\n            it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            it.errorPath = $currentErrorPath;\n            out += ' } else { ';\n          } else {\n            if ($breakOnError) {\n              out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = true; } else { ';\n            } else {\n              out += ' if (' + ($useData) + ' !== undefined) { ';\n            }\n          }\n          out += ' ' + ($code) + ' } ';\n        }\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  var arr4 = $pPropertyKeys;\n  if (arr4) {\n    var $pProperty, i4 = -1,\n      l4 = arr4.length - 1;\n    while (i4 < l4) {\n      $pProperty = arr4[i4 += 1];\n      var $sch = $pProperties[$pProperty];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n        out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { if (' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ')) { ';\n        $it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n        var $passData = $data + '[key' + $lvl + ']';\n        var $code = it.validate($it);\n        if (it.util.varOccurences($code, $nextData) < 2) {\n          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n        } else {\n          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n        }\n        if ($breakOnError) {\n          out += ' if (!valid' + ($it.level) + ') break; ';\n        }\n        out += ' } ';\n        if ($breakOnError) {\n          out += ' else valid' + ($it.level) + ' = true; ';\n        }\n        out += ' }  ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_ref(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['$ref'],\n    $schemaPath = it.schemaPath + '.' + '$ref',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      out += '  if (! ' + ('validate') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('validate') + '.errors; else vErrors = vErrors.concat(' + ('validate') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      out += '  if (! ' + ('root.refVal[0]') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('root.refVal[0]') + '.errors; else vErrors = vErrors.concat(' + ('root.refVal[0]') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = 'can\\'t resolve reference ' + $schema + ' from id ' + it.baseId;\n      if (it.opts.missingRefs == 'fail') {\n        console.log($message);\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        console.log($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        var $error = new Error($message);\n        $error.missingRef = it.resolve.url(it.baseId, $schema);\n        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));\n        throw $error;\n      }\n    } else if (typeof $refVal == 'string') {\n      out += '  if (! ' + ($refVal) + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ($refVal) + '.errors; else vErrors = vErrors.concat(' + ($refVal) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      var $it = it.util.copy(it),\n        $closingBraces = '';\n      $it.level++;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      var $code = it.validate($it);\n      if (/validate\\.schema/.test($code)) {\n        out += ' var rootSchema' + ($it.level) + ' = validate.schema; validate.schema = ' + ($refVal.code) + '; ' + ($code) + ' validate.schema = rootSchema' + ($it.level) + '; ';\n      } else {\n        out += ' ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n      }\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_required(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['required'],\n    $schemaPath = it.schemaPath + '.' + 'required',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if (it.schema.properties && Object.keys(it.schema.properties).length) {\n    var $required = [];\n    var arr1 = $schema;\n    if (arr1) {\n      var $property, i1 = -1,\n        l1 = arr1.length - 1;\n      while (i1 < l1) {\n        $property = arr1[i1 += 1];\n        var $propertySch = it.schema.properties[$property];\n        if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {\n          $required[$required.length] = $property;\n        }\n      }\n    }\n  } else {\n    var $required = $schema;\n  }\n  if ($required.length) {\n    var $currentErrorPath = it.errorPath;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($required.length <= 20) {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $property, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $property = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($property);\n            out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $property : $prop)) + ') ) ';\n          }\n        }\n        out += ') { ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { var ' + ($valid) + ' = ' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; }  if (!' + ($valid) + ') {  ';\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($required.length <= 20) {\n        var arr3 = $required;\n        if (arr3) {\n          var $property, $i = -1,\n            l3 = arr3.length - 1;\n          while ($i < l3) {\n            $property = arr3[$i += 1];\n            var $prop = it.util.getProperty($property),\n              $missingProperty = it.util.escapeQuotes($prop);\n            it.errorPath = it.util.getPath($currentErrorPath, $property, it.opts.jsonPointers);\n            out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'is a required property\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            if (it.opts.i18n) {\n              out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n            }\n            out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { if (' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'is a required property\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        if (it.opts.i18n) {\n          out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n        }\n        out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_uniqueItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['uniqueItems'],\n    $schemaPath = it.schemaPath + '.' + 'uniqueItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema && it.opts.uniqueItems !== false) {\n    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } if (!' + ($valid) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_validate(it) {\n  var out = '';\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.root.schema.id);\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    out += ' validate = function (data, dataPath) { \\'use strict\\'; var vErrors = null; ';\n    out += ' var errors = 0;     ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $typeSchema = it.schema.type;\n  var arr1 = it.RULES;\n  if (arr1) {\n    var $rulesGroup, i1 = -1,\n      l1 = arr1.length - 1;\n    while (i1 < l1) {\n      $rulesGroup = arr1[i1 += 1];\n      if ($shouldUseGroup($rulesGroup)) {\n        if ($rulesGroup.type) {\n          out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';\n        }\n        var arr2 = $rulesGroup.rules;\n        if (arr2) {\n          var $rule, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $rule = arr2[i2 += 1];\n            if ($shouldUseRule($rule)) {\n              out += ' ' + ($rule.code(it)) + ' ';\n              if ($breakOnError) {\n                $closingBraces1 += '}';\n              }\n            }\n          }\n        }\n        if ($breakOnError) {\n          out += ' ' + ($closingBraces1) + ' ';\n          $closingBraces1 = '';\n        }\n        if ($rulesGroup.type) {\n          out += ' } ';\n          if ($typeSchema && $typeSchema === $rulesGroup.type) {\n            var $typeChecked = true;\n            out += ' else {  ';\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            out += ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (errors === ';\n          if ($top) {\n            out += '0';\n          } else {\n            out += 'errs_' + ($lvl);\n          }\n          out += ') { ';\n          $closingBraces2 += '}';\n        }\n      }\n    }\n  }\n  if ($typeSchema && !$typeChecked) {\n    var $schemaPath = it.schemaPath + '.type',\n      $isArray = Array.isArray($typeSchema),\n      $method = $isArray ? 'checkDataTypes' : 'checkDataType';\n    out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    out += ' validate.errors = vErrors; ';\n    out += ' return errors === 0;       ';\n    out += ' }';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n  out = it.util.cleanUpCode(out);\n  if ($top && $breakOnError) {\n    out = it.util.cleanUpVarErrors(out);\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    for (var i = 0; i < $rulesGroup.rules.length; i++)\n      if ($shouldUseRule($rulesGroup.rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length)));\n  }\n  return out;\n}\n","module.exports={\n    \"id\": \"http://json-schema.org/draft-04/schema#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"description\": \"Core schema meta-schema\",\n    \"definitions\": {\n        \"schemaArray\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"items\": { \"$ref\": \"#\" }\n        },\n        \"positiveInteger\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n        },\n        \"positiveIntegerDefault0\": {\n            \"allOf\": [ { \"$ref\": \"#/definitions/positiveInteger\" }, { \"default\": 0 } ]\n        },\n        \"simpleTypes\": {\n            \"enum\": [ \"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\" ]\n        },\n        \"stringArray\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" },\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": {},\n        \"multipleOf\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"exclusiveMinimum\": true\n        },\n        \"maximum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"minimum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxLength\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minLength\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"pattern\": {\n            \"type\": \"string\",\n            \"format\": \"regex\"\n        },\n        \"additionalItems\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"items\": {\n            \"anyOf\": [\n                { \"$ref\": \"#\" },\n                { \"$ref\": \"#/definitions/schemaArray\" }\n            ],\n            \"default\": {}\n        },\n        \"maxItems\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minItems\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"uniqueItems\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxProperties\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minProperties\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\n        \"additionalProperties\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"definitions\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"properties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"patternProperties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"dependencies\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"anyOf\": [\n                    { \"$ref\": \"#\" },\n                    { \"$ref\": \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        \"enum\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        },\n        \"type\": {\n            \"anyOf\": [\n                { \"$ref\": \"#/definitions/simpleTypes\" },\n                {\n                    \"type\": \"array\",\n                    \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\n                    \"minItems\": 1,\n                    \"uniqueItems\": true\n                }\n            ]\n        },\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"not\": { \"$ref\": \"#\" }\n    },\n    \"dependencies\": {\n        \"exclusiveMaximum\": [ \"maximum\" ],\n        \"exclusiveMinimum\": [ \"minimum\" ]\n    },\n    \"default\": {}\n}\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});const t=\"undefined\"!=typeof BigUint64Array,e=Symbol(),r=new TextDecoder(\"utf-16le\",{fatal:!0});function n(t,e){let n=new Uint32Array(t)[e+-4>>>2]>>>1;const s=new Uint16Array(t,e,n);if(n<=192)return String.fromCharCode(...s);try{return r.decode(s)}catch{let t=\"\",e=0;for(;n-e>1024;)t+=String.fromCharCode(...s.subarray(e,e+=1024));return t+String.fromCharCode(...s.subarray(e))}}function s(t){const e={};function r(t,e){return t?n(t.buffer,e):\"<yet unknown>\"}const s=t.env=t.env||{};return s.abort=s.abort||function(t,n,o,i){const a=e.memory||s.memory;throw Error(`abort: ${r(a,t)} at ${r(a,n)}:${o}:${i}`)},s.trace=s.trace||function(t,n,...o){const i=e.memory||s.memory;console.log(`trace: ${r(i,t)}${n?\" \":\"\"}${o.slice(0,n).join(\", \")}`)},s.seed=s.seed||Date.now,t.Math=t.Math||Math,t.Date=t.Date||Date,e}const o=function(){throw Error(\"Operation requires compiling with --exportRuntime\")};function i(e,r){const s=r.exports,i=s.memory,a=s.table,c=s.__new||o,u=s.__pin||o,y=s.__unpin||o,l=s.__collect||o,p=s.__rtti_base,d=p?function(t){return t[p>>>2]}:o;function b(t){const e=function(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t]}(t);if(!(7&e))throw Error(`not an array: ${t}, flags=${e}`);return e}function h(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t+1]}function m(t){return 31-Math.clz32(t>>>6&31)}function g(t,e,r){const n=i.buffer;if(r)switch(t){case 2:return new Float32Array(n);case 3:return new Float64Array(n)}else switch(t){case 0:return new(e?Int8Array:Uint8Array)(n);case 1:return new(e?Int16Array:Uint16Array)(n);case 2:return new(e?Int32Array:Uint32Array)(n);case 3:return new(e?BigInt64Array:BigUint64Array)(n)}throw Error(`unsupported align: ${t}`)}function A(t){const e=new Uint32Array(i.buffer),r=b(e[t+-8>>>2]),n=m(r);let s=4&r?t:e[t+4>>>2];const o=2&r?e[t+12>>>2]:e[s+-4>>>2]>>>n;return g(n,2048&r,4096&r).subarray(s>>>=n,s+o)}function w(t,e,r){return new t(_(t,e,r))}function _(t,e,r){const n=i.buffer,s=new Uint32Array(n),o=s[r+4>>>2];return new t(n,o,s[o+-4>>>2]>>>e)}function T(t,r,n){e[`__get${r}`]=w.bind(null,t,n),e[`__get${r}View`]=_.bind(null,t,n)}return e.__new=c,e.__pin=u,e.__unpin=y,e.__collect=l,e.__newString=function(t){if(null==t)return 0;const e=t.length,r=c(e<<1,1),n=new Uint16Array(i.buffer);for(var s=0,o=r>>>1;s<e;++s)n[o+s]=t.charCodeAt(s);return r},e.__newArrayBuffer=function(t){if(null==t)return 0;const e=new Uint8Array(t),r=c(e.length,0);return new Uint8Array(i.buffer).set(e,r),r},e.__getString=function(t){if(!t)return null;const e=i.buffer;if(1!==new Uint32Array(e)[t+-8>>>2])throw Error(`not a string: ${t}`);return n(e,t)},e.__newArray=function(t,e){const r=b(t),n=m(r),s=e.length,o=c(s<<n,4&r?t:0);let a;if(4&r)a=o;else{u(o);const e=c(2&r?16:12,t);y(o);const f=new Uint32Array(i.buffer);f[e+0>>>2]=o,f[e+4>>>2]=o,f[e+8>>>2]=s<<n,2&r&&(f[e+12>>>2]=s),a=e}const f=g(n,2048&r,4096&r);if(16384&r)for(let t=0;t<s;++t){const r=e[t];f[(o>>>n)+t]=r}else f.set(e,o>>>n);return a},e.__getArrayView=A,e.__getArray=function(t){const e=A(t),r=e.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n},e.__getArrayBuffer=function(t){const e=i.buffer,r=new Uint32Array(e)[t+-4>>>2];return e.slice(t,t+r)},[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array].forEach((t=>{T(t,t.name,31-Math.clz32(t.BYTES_PER_ELEMENT))})),t&&[BigUint64Array,BigInt64Array].forEach((t=>{T(t,t.name.slice(3),3)})),e.__instanceof=function(t,e){const r=new Uint32Array(i.buffer);let n=r[t+-8>>>2];if(n<=d(r))do{if(n==e)return!0;n=h(n)}while(n);return!1},e.memory=e.memory||i,e.table=e.table||a,f(s,e)}function a(t){return\"undefined\"!=typeof Response&&t instanceof Response}function c(t){return t instanceof WebAssembly.Module}async function u(t,e={}){if(a(t=await t))return y(t,e);const r=c(t)?t:await WebAssembly.compile(t),n=s(e),o=await WebAssembly.instantiate(r,e);return{module:r,instance:o,exports:i(n,o)}}async function y(t,e={}){if(!WebAssembly.instantiateStreaming)return u(a(t=await t)?t.arrayBuffer():t,e);const r=s(e),n=await WebAssembly.instantiateStreaming(t,e),o=i(r,n.instance);return{...n,exports:o}}function f(t,r={}){const n=t.__argumentsLength?e=>{t.__argumentsLength.value=e}:t.__setArgumentsLength||t.__setargc||(()=>{});for(let s in t){if(!Object.prototype.hasOwnProperty.call(t,s))continue;const o=t[s];let i=s.split(\".\"),a=r;for(;i.length>1;){let t=i.shift();Object.prototype.hasOwnProperty.call(a,t)||(a[t]={}),a=a[t]}let c=i[0],u=c.indexOf(\"#\");if(u>=0){const r=c.substring(0,u),i=a[r];if(void 0===i||!i.prototype){const t=function(...e){return t.wrap(t.prototype.constructor(0,...e))};t.prototype={valueOf(){return this[e]}},t.wrap=function(r){return Object.create(t.prototype,{[e]:{value:r,writable:!1}})},i&&Object.getOwnPropertyNames(i).forEach((e=>Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e)))),a[r]=t}if(c=c.substring(u+1),a=a[r].prototype,/^(get|set):/.test(c)){if(!Object.prototype.hasOwnProperty.call(a,c=c.substring(4))){let r=t[s.replace(\"set:\",\"get:\")],n=t[s.replace(\"get:\",\"set:\")];Object.defineProperty(a,c,{get(){return r(this[e])},set(t){n(this[e],t)},enumerable:!0})}}else\"constructor\"===c?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:(a[c]=function(...t){return n(t.length),o(this[e],...t)}).original=o}else/^(get|set):/.test(c)?Object.prototype.hasOwnProperty.call(a,c=c.substring(4))||Object.defineProperty(a,c,{get:t[s.replace(\"set:\",\"get:\")],set:t[s.replace(\"get:\",\"set:\")],enumerable:!0}):\"function\"==typeof o&&o!==n?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:a[c]=o}return r}var l={instantiate:u,instantiateSync:function(t,e={}){const r=c(t)?t:new WebAssembly.Module(t),n=s(e),o=new WebAssembly.Instance(r,e);return{module:r,instance:o,exports:i(n,o)}},instantiateStreaming:y,demangle:f};function p(t,e,r){return e}function d(t,e,r){return t.exports[`__get${function(t){return t.startsWith(\"~lib/typedarray/\")?((t=t.slice(\"~lib/typedarray/\".length)).startsWith(\"Big\")&&(t=t.slice(3)),t):t}(r)}View`](e)}function b(t,e,r){return t.exports.__newArray(t.getTypeId(r),e)}function h(t){if(!t.startsWith(\"~lib/array/Array\"))throw Error(`${JSON.stringify(t)} is not an array type`);return t.slice(\"~lib/array/Array<\".length,-1)}const m=new Map([[\"void\",{ascToJs:p,jsToAsc:p}],[/^(i|u|f)(8|16|32|64)|[ui]size|bool|externref$/,{ascToJs:p,jsToAsc:p}],[\"~lib/string/String\",{ascToJs:function(t,e,r){return t.exports.__getString(e)},jsToAsc:function(t,e,r){return t.exports.__newString(e)}}],[\"~lib/typedarray/Int8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8ClampedArray\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/arraybuffer/ArrayBuffer\",{ascToJs:function(t,e,r){return t.exports.__getArrayBuffer(e)},jsToAsc:function(t,e,r){const n=t.exports.__new(e.byteLength,t.getTypeId(r));return new Uint8Array(t.exports.memory.buffer,n,e.byteLength).set(new Uint8Array(e)),n}}],[/^~lib\\/array\\/Array<.+>$/,{ascToJs:function(t,e,r){const n=h(r),s=A(n);return t.exports.__getArray(e).map((e=>s.ascToJs(t,e,n)))},jsToAsc:function(t,e,r){const n=h(r),s=A(n),o=e.map((e=>s.jsToAsc(t,e,n)));return t.exports.__newArray(t.getTypeId(r),o)}}]]),g=new Set;function A(t){for(const[e,r]of m)if(\"string\"!=typeof e){if(e.test(t))return r}else if(e===t)return r;return g.has(t)||(console.warn(`No converter for ${JSON.stringify(t)}, using pass-through`),g.add(t)),{ascToJs:p,jsToAsc:p}}function w(t){var e;return null===(e=A(t))||void 0===e?void 0:e.ascToJs}function _(t){var e;return null===(e=A(t))||void 0===e?void 0:e.jsToAsc}function T(t,e,r){const n=r.parameters.map(w),s=_(r.returnType);return function(...o){if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=o.map(((e,s)=>n[s](t,e,r.parameters[s]))),a=e(...i);return s(t,a,r.returnType)}}function j(t,e,r){const n=r.parameters.map(_),s=w(r.returnType);return(...o)=>{if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=[],a=o.map(((e,s)=>{const o=n[s](t,e,r.parameters[s]);return o!==e&&(t.exports.__pin(o),i.push(o)),o})),c=e(...a);return i.forEach((e=>t.exports.__unpin(e))),s(t,c,r.returnType)}}function x(t,{depth:e=Number.POSITIVE_INFINITY}={}){return e<=0||!t||\"object\"!=typeof t?t:Object.fromEntries(Object.entries(t).map((([t,r])=>[t,x(r,{depth:e-1})])))}function O(t){const e=WebAssembly.Module.customSections(t,\"as-bind_bindings\"),r=new TextDecoder(\"utf8\").decode(new Uint8Array(e[0]));try{return JSON.parse(r)}catch(t){throw Error(`Couldnt decode type descriptor: ${t.message}`)}}class U{constructor(){this.unboundExports={},this.exports={},this.importObject={}}getTypeId(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].id;throw Error(`Unknown type ${JSON.stringify(t)}`)}getTypeSize(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].byteSize;throw Error(`Unknown type ${JSON.stringify(t)}`)}_validate(){if(!WebAssembly.Module.exports(this.module).find((t=>\"__new\"===t.name)))throw Error(\"The AssemblyScript wasm module was not built with --exportRuntime, which is required.\");if(1!==WebAssembly.Module.customSections(this.module,\"as-bind_bindings\").length)throw new Error(\"The AssemblyScript wasm module was not built with the as-bind transform.\")}async _instantiate(t,e){this.module=await async function(t){if(t=await Promise.resolve(t),\"undefined\"!=typeof Response&&t instanceof Response){if(WebAssembly.compileStreaming)return WebAssembly.compileStreaming(t);t=await t.arrayBuffer()}return WebAssembly.compile(t)}(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=await async function(t,e){return l.instantiate(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateSync(t,e){this.module=new WebAssembly.Module(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=function(t,e){return l.instantiateSync(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateBindImportFunctions(t){this.importObject=x(t,{depth:2});for(const[e,r]of Object.entries(this.typeDescriptor.importedFunctions))for(const[n,s]of Object.entries(r))this.importObject[e][`__asbind_unbound_${n}`]=t[e][n],this.importObject[e][n]=T(this,t[e][n],s)}_instantiateBindUnboundExports(){const t=this.loadedModule.exports;this.exports=x(t,{depth:1});for(const[e,r]of Object.entries(this.typeDescriptor.exportedFunctions))this.exports[e]=j(this,t[e],r)}}exports.converters=m,exports.instantiate=async function(t,e){let r=new U;return await r._instantiate(t,e),r},exports.instantiateSync=function(t,e){let r=new U;return r._instantiateSync(t,e),r},exports.version=\"0.8.1\";\n","\"use strict\";\r\nvar mqtt = require(\"mqtt\");\r\nvar inArray = require(\"in-array\");\r\n\r\nvar RegularClientPrototype = mqtt.MqttClient.prototype;\r\n\r\nvar ASYNC_METHODS = [\"publish\",\r\n\t\"subscribe\",\r\n\t\"unsubscribe\",\r\n\t\"unsubscribe\",\r\n\t\"end\"\r\n];\r\n\r\nvar SYNC_METHODS = [\r\n\t\"emit\",\r\n\t\"addListener\",\r\n\t\"on\",\r\n\t\"once\",\r\n\t\"removeListener\",\r\n\t\"removeAllListeners\",\r\n\t\"setMaxListeners\",\r\n\t\"getMaxListeners\",\r\n\t\"listeners\",\r\n\t\"listenerCount\"\r\n];\r\n\r\nmodule.exports = {\r\n\tconnect: connect,\r\n\tAsyncClient: AsyncClient\r\n};\r\n\r\nfunction connect(brokerURL, opts) {\r\n\tvar client = mqtt.connect(brokerURL, opts);\r\n\r\n\tvar asyncClient = new AsyncClient(client);\r\n\r\n\treturn asyncClient;\r\n}\r\n\r\nfunction AsyncClient(client) {\r\n\tthis._client = client;\r\n}\r\n\r\nAsyncClient.prototype = {\r\n\tset handleMessage(newHandler) {\r\n\t\tthis._client.handleMessage = newHandler;\r\n\t},\r\n\tget handleMessage() {\r\n\t\treturn this._client.handleMessage;\r\n\t}\r\n};\r\n\r\nASYNC_METHODS.forEach(defineAsync);\r\nSYNC_METHODS.forEach(definePassthrough);\r\n\r\nfunction definePassthrough(name) {\r\n\tAsyncClient.prototype[name] = function() {\r\n\t\tvar client = this._client;\r\n\t\treturn client[name].apply(client, arguments);\r\n\t};\r\n}\r\n\r\nfunction defineAsync(name) {\r\n\tAsyncClient.prototype[name] = function asyncMethod() {\r\n\t\tvar client = this._client;\r\n\t\tvar args = [];\r\n\t\tvar length = arguments.length;\r\n\t\tvar i = 0;\r\n\t\tfor (i; i < length; i++)\r\n\t\t\targs.push(arguments[i]);\r\n\r\n\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\targs.push(makeCallback(resolve, reject));\r\n\t\t\tclient[name].apply(client, args);\r\n\t\t});\r\n\t};\r\n}\r\n\r\nfunction makeCallback(resolve, reject) {\r\n\treturn function(err, data) {\r\n\t\tif (err)\r\n\t\t\treject(err);\r\n\t\telse resolve(data);\r\n\t};\r\n}\r\n","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n  , Buffer       = require('safe-buffer').Buffer\n\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n  } else {\n    this.append(callback)\n  }\n\n  DuplexStream.call(this)\n}\n\n\nutil.inherits(BufferList, DuplexStream)\n\n\nBufferList.prototype._offset = function _offset (offset) {\n  var tot = 0, i = 0, _t\n  if (offset === 0) return [ 0, 0 ]\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t || i == this._bufs.length - 1)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\n\nBufferList.prototype.append = function append (buf) {\n  var i = 0\n\n  if (Buffer.isBuffer(buf)) {\n    this._appendBuffer(buf);\n  } else if (Array.isArray(buf)) {\n    for (; i < buf.length; i++)\n      this.append(buf[i])\n  } else if (buf instanceof BufferList) {\n    // unwrap argument into individual BufferLists\n    for (; i < buf._bufs.length; i++)\n      this.append(buf._bufs[i])\n  } else if (buf != null) {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf == 'number')\n      buf = buf.toString()\n\n    this._appendBuffer(Buffer.from(buf));\n  }\n\n  return this\n}\n\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\n\nBufferList.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback == 'function')\n    callback()\n}\n\n\nBufferList.prototype._read = function _read (size) {\n  if (!this.length)\n    return this.push(null)\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\n\nBufferList.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\n\nBufferList.prototype.get = function get (index) {\n  return this.slice(index, index + 1)[0]\n}\n\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start == 'number' && start < 0)\n    start += this.length\n  if (typeof end == 'number' && end < 0)\n    end += this.length\n  return this.copy(null, 0, start, end)\n}\n\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || Buffer.alloc(0)\n  if (srcEnd <= 0)\n    return dst || Buffer.alloc(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) { // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = end || this.length\n\n  if (start < 0)\n    start += this.length\n  if (end < 0)\n    end += this.length\n\n  var startOffset = this._offset(start)\n    , endOffset = this._offset(end)\n    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] == 0)\n    buffers.pop()\n  else\n    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])\n\n  if (startOffset[1] != 0)\n    buffers[0] = buffers[0].slice(startOffset[1])\n\n  return new BufferList(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\n\nBufferList.prototype.duplicate = function duplicate () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\n\nBufferList.prototype.destroy = function destroy () {\n  this._bufs.length = 0\n  this.length = 0\n  this.push(null)\n}\n\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\n\nmodule.exports = BufferList\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","\"use strict\";\n\nvar isValue             = require(\"type/value/is\")\n  , ensureValue         = require(\"type/value/ensure\")\n  , ensurePlainFunction = require(\"type/plain-function/ensure\")\n  , copy                = require(\"es5-ext/object/copy\")\n  , normalizeOptions    = require(\"es5-ext/object/normalize-options\")\n  , map                 = require(\"es5-ext/object/map\");\n\nvar bind = Function.prototype.bind\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n","\"use strict\";\n\nvar isValue         = require(\"type/value/is\")\n  , isPlainFunction = require(\"type/plain-function/is\")\n  , assign          = require(\"es5-ext/object/assign\")\n  , normalizeOpts   = require(\"es5-ext/object/normalize-options\")\n  , contains        = require(\"es5-ext/string/#/contains\");\n\nvar d = (module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif (arguments.length < 2 || typeof dscr !== \"string\") {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t\tw = contains.call(dscr, \"w\");\n\t} else {\n\t\tc = w = true;\n\t\te = false;\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n});\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== \"string\") {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (!isValue(get)) {\n\t\tget = undefined;\n\t} else if (!isPlainFunction(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (!isValue(set)) {\n\t\tset = undefined;\n\t} else if (!isPlainFunction(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t} else {\n\t\tc = true;\n\t\te = false;\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","var stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n\"use strict\";\n\nvar value = require(\"../../object/valid-value\");\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n","\"use strict\";\n\nvar numberIsNaN       = require(\"../../number/is-nan\")\n  , toPosInt          = require(\"../../number/to-pos-integer\")\n  , value             = require(\"../../object/valid-value\")\n  , indexOf           = Array.prototype.indexOf\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , abs               = Math.abs\n  , floor             = Math.floor;\n\nmodule.exports = function (searchElement/*, fromIndex*/) {\n\tvar i, length, fromIndex, val;\n\tif (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n\tlength = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < length; ++i) {\n\t\tif (objHasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (numberIsNaN(val)) return i; // Jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Array.from : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== \"function\") return false;\n\tarr = [\"raz\", \"dwa\"];\n\tresult = from(arr);\n\treturn Boolean(result && result !== arr && result[1] === \"dwa\");\n};\n","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArguments    = require(\"../../function/is-arguments\")\n  , isFunction     = require(\"../../function/is-function\")\n  , toPosInt       = require(\"../../number/to-pos-integer\")\n  , callable       = require(\"../../object/valid-callable\")\n  , validValue     = require(\"../../object/valid-value\")\n  , isValue        = require(\"../../object/is-value\")\n  , isString       = require(\"../../string/is-string\")\n  , isArray        = Array.isArray\n  , call           = Function.prototype.call\n  , desc           = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\n// eslint-disable-next-line complexity, max-lines-per-function\nmodule.exports = function (arrayLike/*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1]\n\t  , thisArg = arguments[2]\n\t  , Context\n\t  , i\n\t  , j\n\t  , arr\n\t  , length\n\t  , code\n\t  , iterator\n\t  , result\n\t  , getIterator\n\t  , value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (isValue(mapFn)) callable(mapFn);\n\tif (!this || this === Array || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tlength = arrayLike.length;\n\t\t\t\tif (length !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array((length = arrayLike.length));\n\t\t\t\tfor (i = 0; i < length; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tContext = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Context) arr = new Context();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tlength = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tlength = arrayLike.length;\n\t\t\tif (Context) arr = new Context();\n\t\t\tfor (i = 0, j = 0; i < length; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlength = j;\n\t\t}\n\t}\n\tif (length === undefined) {\n\t\t// Source: array or array-like\n\t\tlength = toPosInt(arrayLike.length);\n\t\tif (Context) arr = new Context(length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (Context) {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t} else {\n\t\t\t\tarr[i] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (Context) {\n\t\tdesc.value = null;\n\t\tarr.length = length;\n\t}\n\treturn arr;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , id = objToString.call((function () { return arguments; })());\n\nmodule.exports = function (value) { return objToString.call(value) === id; };\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);\n\nmodule.exports = function (value) {\n\treturn typeof value === \"function\" && isFunctionStringTag(objToString.call(value));\n};\n","\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Math.sign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== \"function\") return false;\n\treturn sign(10) === 1 && sign(-20) === -1;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || value === 0) return value;\n\treturn value > 0 ? 1 : -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Number.isNaN : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar numberIsNaN = Number.isNaN;\n\tif (typeof numberIsNaN !== \"function\") return false;\n\treturn !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\t// eslint-disable-next-line no-self-compare\n\treturn value !== value;\n};\n","\"use strict\";\n\nvar sign  = require(\"../math/sign\")\n  , abs   = Math.abs\n  , floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif (value === 0 || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n","\"use strict\";\n\nvar toInteger = require(\"./to-integer\")\n  , max       = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n\"use strict\";\n\nvar callable                = require(\"./valid-callable\")\n  , value                   = require(\"./valid-value\")\n  , bind                    = Function.prototype.bind\n  , call                    = Function.prototype.call\n  , keys                    = Object.keys\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb/*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== \"function\") method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n","\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src/*, srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","\"use strict\";\n\nvar aFrom  = require(\"../array/from\")\n  , assign = require(\"./assign\")\n  , value  = require(\"./valid-value\");\n\nmodule.exports = function (obj/*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n\"use strict\";\n\nvar create = Object.create, shim;\n\nif (!require(\"./set-prototype-of/is-implemented\")()) {\n\tshim = require(\"./set-prototype-of/shim\");\n}\n\nmodule.exports = (function () {\n\tvar nullObject, polyProps, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tpolyProps = {};\n\tdesc = { configurable: false, enumerable: false, writable: true, value: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === \"__proto__\") {\n\t\t\tpolyProps[name] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: undefined\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tpolyProps[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, polyProps);\n\n\tObject.defineProperty(shim, \"nullPolyfill\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: nullObject\n\t});\n\n\treturn function (prototype, props) {\n\t\treturn create(prototype === null ? nullObject : prototype, props);\n\t};\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./_iterate\")(\"forEach\");\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };\n","\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) { return val !== _undefined && val !== null; };\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };\n","\"use strict\";\n\nvar callable = require(\"./valid-callable\")\n  , forEach  = require(\"./for-each\")\n  , call     = Function.prototype.call;\n\nmodule.exports = function (obj, cb/*, thisArg*/) {\n\tvar result = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, targetObj, index) {\n\t\tresult[key] = call.call(cb, thisArg, value, key, targetObj, index);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1/*, options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (arg/*, args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) { set[name] = true; });\n\treturn set;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.setPrototypeOf : require(\"./shim\");\n","\"use strict\";\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};\n\nmodule.exports = function (/* CustomCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== \"function\") return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n};\n","/* eslint no-proto: \"off\" */\n\n// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n\"use strict\";\n\nvar isObject         = require(\"../is-object\")\n  , value            = require(\"../valid-value\")\n  , objIsPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty   = Object.defineProperty\n  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif (prototype === null || isObject(prototype)) return obj;\n\tthrow new TypeError(\"Prototype must be null or an object\");\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, \"level\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: status.level\n\t});\n})(\n\t(function () {\n\t\tvar tmpObj1 = Object.create(null)\n\t\t  , tmpObj2 = {}\n\t\t  , set\n\t\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n\t\tif (desc) {\n\t\t\ttry {\n\t\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\t\tset.call(tmpObj1, tmpObj2);\n\t\t\t} catch (ignore) {}\n\t\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n\t\t}\n\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n\t\ttmpObj1 = {};\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n\t\treturn false;\n\t})()\n);\n\nrequire(\"../create\");\n","\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n","\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n","\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(\"\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\ttypeof value === \"string\" ||\n\t\t(value &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\t(value instanceof String || objToString.call(value) === id)) ||\n\t\tfalse\n\t);\n};\n","\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , contains       = require(\"es5-ext/string/#/contains\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tIterator.call(this, arr);\n\tif (!kind) kind = \"value\";\n\telse if (contains.call(kind, \"key+value\")) kind = \"key+value\";\n\telse if (contains.call(kind, \"key\")) kind = \"key\";\n\telse kind = \"value\";\n\tdefineProperty(this, \"__kind__\", d(\"\", kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete ArrayIterator.prototype.constructor;\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === \"value\") return this.__list__[i];\n\t\tif (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n\t\treturn i;\n\t})\n});\ndefineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , callable    = require(\"es5-ext/object/valid-callable\")\n  , isString    = require(\"es5-ext/string/is-string\")\n  , get         = require(\"./get\");\n\nvar isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb /*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = \"array\";\n\telse if (isString(iterable)) mode = \"string\";\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () {\n\t\tbroken = true;\n\t};\n\tif (mode === \"array\") {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\treturn broken;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === \"string\") {\n\t\tlength = iterable.length;\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif (i + 1 < length) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n","\"use strict\";\n\nvar isArguments    = require(\"es5-ext/function/is-arguments\")\n  , isString       = require(\"es5-ext/string/is-string\")\n  , ArrayIterator  = require(\"./array\")\n  , StringIterator = require(\"./string\")\n  , iterable       = require(\"./valid-iterable\")\n  , iteratorSymbol = require(\"es6-symbol\").iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n","\"use strict\";\n\nvar clear    = require(\"es5-ext/array/#/clear\")\n  , assign   = require(\"es5-ext/object/assign\")\n  , callable = require(\"es5-ext/object/valid-callable\")\n  , value    = require(\"es5-ext/object/valid-value\")\n  , d        = require(\"d\")\n  , autoBind = require(\"d/auto-bind\")\n  , Symbol   = require(\"es6-symbol\");\n\nvar defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tdefineProperties(this, {\n\t\t__list__: d(\"w\", value(list)),\n\t\t__context__: d(\"w\", context),\n\t\t__nextIndex__: d(\"w\", 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on(\"_add\", this._onAdd);\n\tcontext.on(\"_delete\", this._onDelete);\n\tcontext.on(\"_clear\", this._onClear);\n};\n\n// Internal %IteratorPrototype% doesn't expose its constructor\ndelete Iterator.prototype.constructor;\n\ndefineProperties(\n\tIterator.prototype,\n\tassign(\n\t\t{\n\t\t\t_next: d(function () {\n\t\t\t\tvar i;\n\t\t\t\tif (!this.__list__) return undefined;\n\t\t\t\tif (this.__redo__) {\n\t\t\t\t\ti = this.__redo__.shift();\n\t\t\t\t\tif (i !== undefined) return i;\n\t\t\t\t}\n\t\t\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\t\t\tthis._unBind();\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t\tnext: d(function () {\n\t\t\t\treturn this._createResult(this._next());\n\t\t\t}),\n\t\t\t_createResult: d(function (i) {\n\t\t\t\tif (i === undefined) return { done: true, value: undefined };\n\t\t\t\treturn { done: false, value: this._resolve(i) };\n\t\t\t}),\n\t\t\t_resolve: d(function (i) {\n\t\t\t\treturn this.__list__[i];\n\t\t\t}),\n\t\t\t_unBind: d(function () {\n\t\t\t\tthis.__list__ = null;\n\t\t\t\tdelete this.__redo__;\n\t\t\t\tif (!this.__context__) return;\n\t\t\t\tthis.__context__.off(\"_add\", this._onAdd);\n\t\t\t\tthis.__context__.off(\"_delete\", this._onDelete);\n\t\t\t\tthis.__context__.off(\"_clear\", this._onClear);\n\t\t\t\tthis.__context__ = null;\n\t\t\t}),\n\t\t\ttoString: d(function () {\n\t\t\t\treturn \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n\t\t\t})\n\t\t},\n\t\tautoBind({\n\t\t\t_onAdd: d(function (index) {\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t++this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) {\n\t\t\t\t\tdefineProperty(this, \"__redo__\", d(\"c\", [index]));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t\t\t}, this);\n\t\t\t\tthis.__redo__.push(index);\n\t\t\t}),\n\t\t\t_onDelete: d(function (index) {\n\t\t\t\tvar i;\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t--this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) return;\n\t\t\t\ti = this.__redo__.indexOf(index);\n\t\t\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\t\t\tthis.__redo__.forEach(function (redo, j) {\n\t\t\t\t\tif (redo > index) this.__redo__[j] = --redo;\n\t\t\t\t}, this);\n\t\t\t}),\n\t\t\t_onClear: d(function () {\n\t\t\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\t\t\tthis.__nextIndex__ = 0;\n\t\t\t})\n\t\t})\n\t)\n);\n\ndefineProperty(\n\tIterator.prototype,\n\tSymbol.iterator,\n\td(function () {\n\t\treturn this;\n\t})\n);\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , isValue     = require(\"es5-ext/object/is-value\")\n  , isString    = require(\"es5-ext/string/is-string\");\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArray        = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn typeof value[iteratorSymbol] === \"function\";\n};\n","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, \"__length__\", d(\"\", str.length));\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete StringIterator.prototype.constructor;\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\t_next: d(function () {\n\t\tif (!this.__list__) return undefined;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t\treturn undefined;\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t})\n});\ndefineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n","\"use strict\";\n\nvar isIterable = require(\"./is-iterable\");\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Map : require('./polyfill');\n","'use strict';\n\nmodule.exports = function () {\n\tvar map, iterator, result;\n\tif (typeof Map !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tmap = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(map) !== '[object Map]') return false;\n\tif (map.size !== 3) return false;\n\tif (typeof map.clear !== 'function') return false;\n\tif (typeof map.delete !== 'function') return false;\n\tif (typeof map.entries !== 'function') return false;\n\tif (typeof map.forEach !== 'function') return false;\n\tif (typeof map.get !== 'function') return false;\n\tif (typeof map.has !== 'function') return false;\n\tif (typeof map.keys !== 'function') return false;\n\tif (typeof map.set !== 'function') return false;\n\tif (typeof map.values !== 'function') return false;\n\n\titerator = map.entries();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (!result.value) return false;\n\tif (result.value[0] !== 'raz') return false;\n\tif (result.value[1] !== 'one') return false;\n\n\treturn true;\n};\n","// Exports true if environment provides native `Map` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Map === 'undefined') return false;\n\treturn (Object.prototype.toString.call(new Map()) === '[object Map]');\n}());\n","'use strict';\n\nmodule.exports = require('es5-ext/object/primitive-set')('key',\n\t'value', 'key+value');\n","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , d                 = require('d')\n  , Iterator          = require('es6-iterator')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n  , kinds             = require('./iterator-kinds')\n\n  , defineProperties = Object.defineProperties\n  , unBind = Iterator.prototype._unBind\n  , MapIterator;\n\nMapIterator = module.exports = function (map, kind) {\n\tif (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n\tIterator.call(this, map.__mapKeysData__, map);\n\tif (!kind || !kinds[kind]) kind = 'key+value';\n\tdefineProperties(this, {\n\t\t__kind__: d('', kind),\n\t\t__values__: d('w', map.__mapValuesData__)\n\t});\n};\nif (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\nMapIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(MapIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__values__[i];\n\t\tif (this.__kind__ === 'key') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__values__[i]];\n\t}),\n\t_unBind: d(function () {\n\t\tthis.__values__ = null;\n\t\tunBind.call(this);\n\t}),\n\ttoString: d(function () { return '[object Map Iterator]'; })\n});\nObject.defineProperty(MapIterator.prototype, toStringTagSymbol,\n\td('c', 'Map Iterator'));\n","'use strict';\n\nvar clear          = require('es5-ext/array/#/clear')\n  , eIndexOf       = require('es5-ext/array/#/e-index-of')\n  , setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , callable       = require('es5-ext/object/valid-callable')\n  , validValue     = require('es5-ext/object/valid-value')\n  , d              = require('d')\n  , ee             = require('event-emitter')\n  , Symbol         = require('es6-symbol')\n  , iterator       = require('es6-iterator/valid-iterable')\n  , forOf          = require('es6-iterator/for-of')\n  , Iterator       = require('./lib/iterator')\n  , isNative       = require('./is-native-implemented')\n\n  , call = Function.prototype.call\n  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf\n  , MapPoly;\n\nmodule.exports = MapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], keys, values, self;\n\tif (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (Map !== MapPoly)) {\n\t\tself = setPrototypeOf(new Map(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) iterator(iterable);\n\tdefineProperties(self, {\n\t\t__mapKeysData__: d('c', keys = []),\n\t\t__mapValuesData__: d('c', values = [])\n\t});\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tvar key = validValue(value)[0];\n\t\tvalue = value[1];\n\t\tif (eIndexOf.call(keys, key) !== -1) return;\n\t\tkeys.push(key);\n\t\tvalues.push(value);\n\t}, self);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(MapPoly, Map);\n\tMapPoly.prototype = Object.create(Map.prototype, {\n\t\tconstructor: d(MapPoly)\n\t});\n}\n\nee(defineProperties(MapPoly.prototype, {\n\tclear: d(function () {\n\t\tif (!this.__mapKeysData__.length) return;\n\t\tclear.call(this.__mapKeysData__);\n\t\tclear.call(this.__mapValuesData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return false;\n\t\tthis.__mapKeysData__.splice(index, 1);\n\t\tthis.__mapValuesData__.splice(index, 1);\n\t\tthis.emit('_delete', index, key);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result;\n\t\tcallable(cb);\n\t\titerator = this.entries();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tcall.call(cb, thisArg, this.__mapValuesData__[result],\n\t\t\t\tthis.__mapKeysData__[result], this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\tget: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return;\n\t\treturn this.__mapValuesData__[index];\n\t}),\n\thas: d(function (key) {\n\t\treturn (eIndexOf.call(this.__mapKeysData__, key) !== -1);\n\t}),\n\tkeys: d(function () { return new Iterator(this, 'key'); }),\n\tset: d(function (key, value) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key), emit;\n\t\tif (index === -1) {\n\t\t\tindex = this.__mapKeysData__.push(key) - 1;\n\t\t\temit = true;\n\t\t}\n\t\tthis.__mapValuesData__[index] = value;\n\t\tif (emit) this.emit('_add', index, key);\n\t\treturn this;\n\t}),\n\tsize: d.gs(function () { return this.__mapKeysData__.length; }),\n\tvalues: d(function () { return new Iterator(this, 'value'); }),\n\ttoString: d(function () { return '[object Map]'; })\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {\n\treturn this.entries();\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? require(\"ext/global-this\").Symbol\n\t: require(\"./polyfill\");\n","\"use strict\";\n\nvar global     = require(\"ext/global-this\")\n  , validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar Symbol = global.Symbol;\n\tvar symbol;\n\tif (typeof Symbol !== \"function\") return false;\n\tsymbol = Symbol(\"test symbol\");\n\ttry { String(symbol); }\n\tcatch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\tif (typeof value === \"symbol\") return true;\n\tif (!value.constructor) return false;\n\tif (value.constructor.name !== \"Symbol\") return false;\n\treturn value[value.constructor.toStringTag] === \"Symbol\";\n};\n","\"use strict\";\n\nvar d = require(\"d\");\n\nvar create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;\n\nvar created = create(null);\nmodule.exports = function (desc) {\n\tvar postfix = 0, name, ie11BugWorkaround;\n\twhile (created[desc + (postfix || \"\")]) ++postfix;\n\tdesc += postfix || \"\";\n\tcreated[desc] = true;\n\tname = \"@@\" + desc;\n\tdefineProperty(\n\t\tobjPrototype,\n\t\tname,\n\t\td.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t})\n\t);\n\treturn name;\n};\n","\"use strict\";\n\nvar d            = require(\"d\")\n  , NativeSymbol = require(\"ext/global-this\").Symbol;\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t\t// fallback to eventual native implementation of given symbol\n\t\thasInstance: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill(\"hasInstance\")\n\t\t),\n\t\tisConcatSpreadable: d(\n\t\t\t\"\",\n\t\t\t(NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\t\t\tSymbolPolyfill(\"isConcatSpreadable\")\n\t\t),\n\t\titerator: d(\"\", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill(\"iterator\")),\n\t\tmatch: d(\"\", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill(\"match\")),\n\t\treplace: d(\"\", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill(\"replace\")),\n\t\tsearch: d(\"\", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill(\"search\")),\n\t\tspecies: d(\"\", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill(\"species\")),\n\t\tsplit: d(\"\", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill(\"split\")),\n\t\ttoPrimitive: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill(\"toPrimitive\")\n\t\t),\n\t\ttoStringTag: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill(\"toStringTag\")\n\t\t),\n\t\tunscopables: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill(\"unscopables\")\n\t\t)\n\t});\n};\n","\"use strict\";\n\nvar d              = require(\"d\")\n  , validateSymbol = require(\"../../../validate-symbol\");\n\nvar registry = Object.create(null);\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\tfor: d(function (key) {\n\t\t\tif (registry[key]) return registry[key];\n\t\t\treturn (registry[key] = SymbolPolyfill(String(key)));\n\t\t}),\n\t\tkeyFor: d(function (symbol) {\n\t\t\tvar key;\n\t\t\tvalidateSymbol(symbol);\n\t\t\tfor (key in registry) {\n\t\t\t\tif (registry[key] === symbol) return key;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t})\n\t});\n};\n","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d                    = require(\"d\")\n  , validateSymbol       = require(\"./validate-symbol\")\n  , NativeSymbol         = require(\"ext/global-this\").Symbol\n  , generateName         = require(\"./lib/private/generate-name\")\n  , setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\")\n  , setupSymbolRegistry  = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create\n  , defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty;\n\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n} else {\n\tNativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = description === undefined ? \"\" : String(description);\n\treturn defineProperties(symbol, {\n\t\t__description__: d(\"\", description),\n\t\t__name__: d(\"\", generateName(description))\n\t});\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d(\"\", function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return \"Symbol (\" + validateSymbol(this).__description__ + \")\"; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(\n\tSymbolPolyfill.prototype,\n\tSymbolPolyfill.toPrimitive,\n\td(\"\", function () {\n\t\tvar symbol = validateSymbol(this);\n\t\tif (typeof symbol === \"symbol\") return symbol;\n\t\treturn symbol.toString();\n\t})\n);\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])\n);\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])\n);\n","\"use strict\";\n\nvar isSymbol = require(\"./is-symbol\");\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ is resolved with global context, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? globalThis : require(\"./implementation\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tif (typeof globalThis !== \"object\") return false;\n\tif (!globalThis) return false;\n\treturn globalThis.Array === Array;\n};\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * in-array <https://github.com/jonschlinkert/in-array>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\nmodule.exports = function inArray (arr, val) {\n  arr = arr || [];\n  var len = arr.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    if (arr[i] === val) {\n      return true;\n    }\n  }\n  return false;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// Copyright 2014, 2015 Simon Lydell\n// X11 (MIT) Licensed. (See LICENSE.)\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nmodule.exports = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyu]{1,5}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|((?:0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?))|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]{1,6}\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-*\\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nmodule.exports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0]}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\n\n/* Protocol - protocol constants */\nvar protocol = module.exports\n\n/* Command code => mnemonic */\nprotocol.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'reserved'\n}\n\n/* Mnemonic => Command code */\nprotocol.codes = {}\nfor (var k in protocol.types) {\n  var v = protocol.types[k]\n  protocol.codes[v] = k\n}\n\n/* Header */\nprotocol.CMD_SHIFT = 4\nprotocol.CMD_MASK = 0xF0\nprotocol.DUP_MASK = 0x08\nprotocol.QOS_MASK = 0x03\nprotocol.QOS_SHIFT = 1\nprotocol.RETAIN_MASK = 0x01\n\n/* Length */\nprotocol.LENGTH_MASK = 0x7F\nprotocol.LENGTH_FIN_MASK = 0x80\n\n/* Connack */\nprotocol.SESSIONPRESENT_MASK = 0x01\nprotocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])\nprotocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT])\n\n/* Connect */\nprotocol.USERNAME_MASK = 0x80\nprotocol.PASSWORD_MASK = 0x40\nprotocol.WILL_RETAIN_MASK = 0x20\nprotocol.WILL_QOS_MASK = 0x18\nprotocol.WILL_QOS_SHIFT = 3\nprotocol.WILL_FLAG_MASK = 0x04\nprotocol.CLEAN_SESSION_MASK = 0x02\nprotocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT])\n\nfunction genHeader (type) {\n  return [0, 1, 2].map(function (qos) {\n    return [0, 1].map(function (dup) {\n      return [0, 1].map(function (retain) {\n        var buf = new Buffer(1)\n        buf.writeUInt8(\n          protocol.codes[type] << protocol.CMD_SHIFT |\n          (dup ? protocol.DUP_MASK : 0) |\n          qos << protocol.QOS_SHIFT | retain, 0, true)\n        return buf\n      })\n    })\n  })\n}\n\n/* Publish */\nprotocol.PUBLISH_HEADER = genHeader('publish')\n\n/* Subscribe */\nprotocol.SUBSCRIBE_HEADER = genHeader('subscribe')\n\n/* Unsubscribe */\nprotocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')\n\n/* Confirmations */\nprotocol.ACKS = {\n  unsuback: genHeader('unsuback'),\n  puback: genHeader('puback'),\n  pubcomp: genHeader('pubcomp'),\n  pubrel: genHeader('pubrel'),\n  pubrec: genHeader('pubrec')\n}\n\nprotocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT])\n\n/* Protocol versions */\nprotocol.VERSION3 = Buffer.from([3])\nprotocol.VERSION4 = Buffer.from([4])\n\n/* QoS */\nprotocol.QOS = [0, 1, 2].map(function (qos) {\n  return Buffer.from([qos])\n})\n\n/* Empty packets */\nprotocol.EMPTY = {\n  pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n  pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n  disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0])\n}\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar writeToStream = require('./writeToStream')\nvar EE = require('events').EventEmitter\nvar inherits = require('inherits')\n\nfunction generate (packet) {\n  var stream = new Accumulator()\n  writeToStream(packet, stream)\n  return stream.concat()\n}\n\nfunction Accumulator () {\n  this._array = new Array(20)\n  this._i = 0\n}\n\ninherits(Accumulator, EE)\n\nAccumulator.prototype.write = function (chunk) {\n  this._array[this._i++] = chunk\n  return true\n}\n\nAccumulator.prototype.concat = function () {\n  var length = 0\n  var lengths = new Array(this._array.length)\n  var list = this._array\n  var pos = 0\n  var i\n  var result\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') lengths[i] = list[i].length\n    else lengths[i] = Buffer.byteLength(list[i])\n\n    length += lengths[i]\n  }\n\n  result = Buffer.allocUnsafe(length)\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') {\n      list[i].copy(result, pos)\n      pos += lengths[i]\n    } else {\n      result.write(list[i], pos)\n      pos += lengths[i]\n    }\n  }\n\n  return result\n}\n\nmodule.exports = generate\n","'use strict'\n\nexports.parser = require('./parser')\nexports.generate = require('./generate')\nexports.writeToStream = require('./writeToStream')\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar max = 65536\nvar cache = {}\n\nfunction generateBuffer (i) {\n  var buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer\n}\n","\nfunction Packet () {\n  this.cmd = null\n  this.retain = false\n  this.qos = 0\n  this.dup = false\n  this.length = -1\n  this.topic = null\n  this.payload = null\n}\n\nmodule.exports = Packet\n","'use strict'\n\nvar bl = require('bl')\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar Packet = require('./packet')\nvar constants = require('./constants')\n\nfunction Parser () {\n  if (!(this instanceof Parser)) return new Parser()\n\n  this._states = [\n    '_parseHeader',\n    '_parseLength',\n    '_parsePayload',\n    '_newPacket'\n  ]\n\n  this._resetState()\n}\n\ninherits(Parser, EE)\n\nParser.prototype._resetState = function () {\n  this.packet = new Packet()\n  this.error = null\n  this._list = bl()\n  this._stateCounter = 0\n}\n\nParser.prototype.parse = function (buf) {\n  if (this.error) this._resetState()\n\n  this._list.append(buf)\n\n  while ((this.packet.length !== -1 || this._list.length > 0) &&\n         this[this._states[this._stateCounter]]() &&\n         !this.error) {\n    this._stateCounter++\n\n    if (this._stateCounter >= this._states.length) this._stateCounter = 0\n  }\n\n  return this._list.length\n}\n\nParser.prototype._parseHeader = function () {\n  // There is at least one byte in the buffer\n  var zero = this._list.readUInt8(0)\n  this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n  this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n  this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n  this.packet.dup = (zero & constants.DUP_MASK) !== 0\n\n  this._list.consume(1)\n\n  return true\n}\n\nParser.prototype._parseLength = function () {\n  // There is at least one byte in the list\n  var bytes = 0\n  var mul = 1\n  var length = 0\n  var result = true\n  var current\n\n  while (bytes < 5) {\n    current = this._list.readUInt8(bytes++)\n    length += mul * (current & constants.LENGTH_MASK)\n    mul *= 0x80\n\n    if ((current & constants.LENGTH_FIN_MASK) === 0) break\n    if (this._list.length <= bytes) {\n      result = false\n      break\n    }\n  }\n\n  if (result) {\n    this.packet.length = length\n    this._list.consume(bytes)\n  }\n\n  return result\n}\n\nParser.prototype._parsePayload = function () {\n  var result = false\n\n  // Do we have a payload? Do we have enough data to complete the payload?\n  // PINGs have no payload\n  if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n    this._pos = 0\n\n    switch (this.packet.cmd) {\n      case 'connect':\n        this._parseConnect()\n        break\n      case 'connack':\n        this._parseConnack()\n        break\n      case 'publish':\n        this._parsePublish()\n        break\n      case 'puback':\n      case 'pubrec':\n      case 'pubrel':\n      case 'pubcomp':\n        this._parseMessageId()\n        break\n      case 'subscribe':\n        this._parseSubscribe()\n        break\n      case 'suback':\n        this._parseSuback()\n        break\n      case 'unsubscribe':\n        this._parseUnsubscribe()\n        break\n      case 'unsuback':\n        this._parseUnsuback()\n        break\n      case 'pingreq':\n      case 'pingresp':\n      case 'disconnect':\n        // These are empty, nothing to do\n        break\n      default:\n        this._emitError(new Error('Not supported'))\n    }\n\n    result = true\n  }\n\n  return result\n}\n\nParser.prototype._parseConnect = function () {\n  var protocolId // Protocol ID\n  var clientId // Client ID\n  var topic // Will topic\n  var payload // Will payload\n  var password // Password\n  var username // Username\n  var flags = {}\n  var packet = this.packet\n\n  // Parse protocolId\n  protocolId = this._parseString()\n\n  if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n  if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n    return this._emitError(new Error('Invalid protocolId'))\n  }\n\n  packet.protocolId = protocolId\n\n  // Parse constants version number\n  if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n  packet.protocolVersion = this._list.readUInt8(this._pos)\n\n  if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4) {\n    return this._emitError(new Error('Invalid protocol version'))\n  }\n\n  this._pos++\n\n  if (this._pos >= this._list.length) {\n    return this._emitError(new Error('Packet too short'))\n  }\n\n  // Parse connect flags\n  flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n  flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n  flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n  if (flags.will) {\n    packet.will = {}\n    packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n    packet.will.qos = (this._list.readUInt8(this._pos) &\n                          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n  }\n\n  packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n  this._pos++\n\n  // Parse keepalive\n  packet.keepalive = this._parseNum()\n  if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n  // Parse clientId\n  clientId = this._parseString()\n  if (clientId === null) return this._emitError(new Error('Packet too short'))\n  packet.clientId = clientId\n\n  if (flags.will) {\n    // Parse will topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n    packet.will.topic = topic\n\n    // Parse will payload\n    payload = this._parseBuffer()\n    if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n    packet.will.payload = payload\n  }\n\n  // Parse username\n  if (flags.username) {\n    username = this._parseString()\n    if (username === null) return this._emitError(new Error('Cannot parse username'))\n    packet.username = username\n  }\n\n  // Parse password\n  if (flags.password) {\n    password = this._parseBuffer()\n    if (password === null) return this._emitError(new Error('Cannot parse password'))\n    packet.password = password\n  }\n\n  return packet\n}\n\nParser.prototype._parseConnack = function () {\n  var packet = this.packet\n\n  if (this._list.length < 2) return null\n\n  packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n  packet.returnCode = this._list.readUInt8(this._pos)\n\n  if (packet.returnCode === -1) return this._emitError(new Error('Cannot parse return code'))\n}\n\nParser.prototype._parsePublish = function () {\n  var packet = this.packet\n  packet.topic = this._parseString()\n\n  if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n  // Parse messageId\n  if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n  packet.payload = this._list.slice(this._pos, packet.length)\n}\n\nParser.prototype._parseSubscribe = function () {\n  var packet = this.packet\n  var topic\n  var qos\n\n  if (packet.qos !== 1) {\n    return this._emitError(new Error('Wrong subscribe header'))\n  }\n\n  packet.subscriptions = []\n\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n    qos = this._list.readUInt8(this._pos++)\n\n    // Push pair to subscriptions\n    packet.subscriptions.push({ topic: topic, qos: qos })\n  }\n}\n\nParser.prototype._parseSuback = function () {\n  this.packet.granted = []\n\n  if (!this._parseMessageId()) { return }\n\n  // Parse granted QoSes\n  while (this._pos < this.packet.length) {\n    this.packet.granted.push(this._list.readUInt8(this._pos++))\n  }\n}\n\nParser.prototype._parseUnsubscribe = function () {\n  var packet = this.packet\n\n  packet.unsubscriptions = []\n\n  // Parse messageId\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    var topic\n\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Push topic to unsubscriptions\n    packet.unsubscriptions.push(topic)\n  }\n}\n\nParser.prototype._parseUnsuback = function () {\n  if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n}\n\nParser.prototype._parseMessageId = function () {\n  var packet = this.packet\n\n  packet.messageId = this._parseNum()\n\n  if (packet.messageId === null) {\n    this._emitError(new Error('Cannot parse messageId'))\n    return false\n  }\n\n  return true\n}\n\nParser.prototype._parseString = function (maybeBuffer) {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.toString('utf8', this._pos, end)\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseBuffer = function () {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.slice(this._pos, end)\n\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseNum = function () {\n  if (this._list.length - this._pos < 2) return -1\n\n  var result = this._list.readUInt16BE(this._pos)\n  this._pos += 2\n\n  return result\n}\n\nParser.prototype._newPacket = function () {\n  if (this.packet) {\n    this._list.consume(this.packet.length)\n    this.emit('packet', this.packet)\n  }\n\n  this.packet = new Packet()\n\n  return true\n}\n\nParser.prototype._emitError = function (err) {\n  this.error = err\n  this.emit('error', err)\n}\n\nmodule.exports = Parser\n","'use strict'\n\nvar protocol = require('./constants')\nvar Buffer = require('safe-buffer').Buffer\nvar empty = Buffer.allocUnsafe(0)\nvar zeroBuf = Buffer.from([0])\nvar numbers = require('./numbers')\nvar nextTick = require('process-nextick-args').nextTick\n\nvar numCache = numbers.cache\nvar generateNumber = numbers.generateNumber\nvar generateCache = numbers.generateCache\nvar writeNumber = writeNumberCached\nvar toGenerate = true\n\nfunction generate (packet, stream) {\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream)\n    case 'connack':\n      return connack(packet, stream)\n    case 'publish':\n      return publish(packet, stream)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n    case 'unsuback':\n      return confirmation(packet, stream)\n    case 'subscribe':\n      return subscribe(packet, stream)\n    case 'suback':\n      return suback(packet, stream)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream)\n    case 'pingreq':\n    case 'pingresp':\n    case 'disconnect':\n      return emptyPacket(packet, stream)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get: function () {\n    return writeNumber === writeNumberCached\n  },\n  set: function (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (opts, stream) {\n  var settings = opts || {}\n  var protocolId = settings.protocolId || 'MQTT'\n  var protocolVersion = settings.protocolVersion || 4\n  var will = settings.will\n  var clean = settings.clean\n  var keepalive = settings.keepalive || 0\n  var clientId = settings.clientId || ''\n  var username = settings.username\n  var password = settings.password\n\n  if (clean === undefined) clean = true\n\n  var length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4\n  if (protocolVersion !== 3 && protocolVersion !== 4) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion === 4) && (clientId || clean)) {\n    length += clientId.length + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    if (will.payload && will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload) + 2\n        } else {\n          length += will.payload.length + 2\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    } else {\n      length += 2\n    }\n  }\n\n  // Username\n  var providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n  stream.write(\n    protocolVersion === 4 ? protocol.VERSION4 : protocol.VERSION3\n  )\n\n  // Connect flags\n  var flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (opts, stream) {\n  var settings = opts || {}\n  var rc = settings.returnCode\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  writeLength(stream, 2)\n  stream.write(opts.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  return stream.write(Buffer.from([rc]))\n}\n\nfunction publish (opts, stream) {\n  var settings = opts || {}\n  var qos = settings.qos || 0\n  var retain = settings.retain ? protocol.RETAIN_MASK : 0\n  var topic = settings.topic\n  var payload = settings.payload || empty\n  var id = settings.messageId\n\n  var length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][opts.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeLength(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Payload\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (opts, stream) {\n  var settings = opts || {}\n  var type = settings.cmd || 'puback'\n  var id = settings.messageId\n  var dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  var qos = 0\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeLength(stream, 2)\n\n  // Message ID\n  return writeNumber(stream, id)\n}\n\nfunction subscribe (opts, stream) {\n  var settings = opts || {}\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var id = settings.messageId\n  var subs = settings.subscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (var i = 0; i < subs.length; i += 1) {\n      var itopic = subs[i].topic\n      var iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  var result = true\n\n  // Generate subs\n  for (var j = 0; j < subs.length; j++) {\n    var sub = subs[j]\n    var jtopic = sub.topic\n    var jqos = sub.qos\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // Write qos\n    result = stream.write(protocol.QOS[jqos])\n  }\n\n  return result\n}\n\nfunction suback (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var granted = settings.granted\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (var i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var unsubs = settings.unsubscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (var i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // Unsubs\n  var result = true\n  for (var j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction emptyPacket (opts, stream) {\n  return stream.write(protocol.EMPTY[opts.cmd])\n}\n\n/**\n * calcLengthLength - calculate the length of the remaining\n * length field\n *\n * @api private\n */\nfunction calcLengthLength (length) {\n  if (length >= 0 && length < 128) return 1\n  else if (length >= 128 && length < 16384) return 2\n  else if (length >= 16384 && length < 2097152) return 3\n  else if (length >= 2097152 && length < 268435456) return 4\n  else return 0\n}\n\nfunction genBufLength (length) {\n  var digit = 0\n  var pos = 0\n  var buffer = Buffer.allocUnsafe(calcLengthLength(length))\n\n  do {\n    digit = length % 128 | 0\n    length = length / 128 | 0\n    if (length > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (length > 0)\n\n  return buffer\n}\n\n/**\n * writeLength - write an MQTT style length field to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nvar lengthCache = {}\nfunction writeLength (stream, length) {\n  var buffer = lengthCache[length]\n\n  if (!buffer) {\n    buffer = genBufLength(length)\n    if (length < 16384) lengthCache[length] = buffer\n  }\n\n  stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  var strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  stream.write(string, 'utf8')\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  return stream.write(generateNumber(number))\n}\n\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n","'use strict'\r\n\r\n/**\r\n * Module dependencies\r\n */\r\nvar events = require('events')\r\nvar Store = require('./store')\r\nvar eos = require('end-of-stream')\r\nvar mqttPacket = require('mqtt-packet')\r\nvar Writable = require('readable-stream').Writable\r\nvar inherits = require('inherits')\r\nvar reInterval = require('reinterval')\r\nvar validations = require('./validations')\r\nvar xtend = require('xtend')\r\nvar setImmediate = global.setImmediate || function (callback) {\r\n  // works in node v0.8\r\n  process.nextTick(callback)\r\n}\r\nvar defaultConnectOptions = {\r\n  keepalive: 60,\r\n  reschedulePings: true,\r\n  protocolId: 'MQTT',\r\n  protocolVersion: 4,\r\n  reconnectPeriod: 1000,\r\n  connectTimeout: 30 * 1000,\r\n  clean: true,\r\n  resubscribe: true\r\n}\r\n\r\nfunction defaultId () {\r\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\r\n}\r\n\r\nfunction sendPacket (client, packet, cb) {\r\n  client.emit('packetsend', packet)\r\n\r\n  var result = mqttPacket.writeToStream(packet, client.stream)\r\n\r\n  if (!result && cb) {\r\n    client.stream.once('drain', cb)\r\n  } else if (cb) {\r\n    cb()\r\n  }\r\n}\r\n\r\nfunction flush (queue) {\r\n  if (queue) {\r\n    Object.keys(queue).forEach(function (messageId) {\r\n      if (typeof queue[messageId] === 'function') {\r\n        queue[messageId](new Error('Connection closed'))\r\n        delete queue[messageId]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction storeAndSend (client, packet, cb) {\r\n  client.outgoingStore.put(packet, function storedPacket (err) {\r\n    if (err) {\r\n      return cb && cb(err)\r\n    }\r\n    sendPacket(client, packet, cb)\r\n  })\r\n}\r\n\r\nfunction nop () {}\r\n\r\n/**\r\n * MqttClient constructor\r\n *\r\n * @param {Stream} stream - stream\r\n * @param {Object} [options] - connection options\r\n * (see Connection#connect)\r\n */\r\nfunction MqttClient (streamBuilder, options) {\r\n  var k\r\n  var that = this\r\n\r\n  if (!(this instanceof MqttClient)) {\r\n    return new MqttClient(streamBuilder, options)\r\n  }\r\n\r\n  this.options = options || {}\r\n\r\n  // Defaults\r\n  for (k in defaultConnectOptions) {\r\n    if (typeof this.options[k] === 'undefined') {\r\n      this.options[k] = defaultConnectOptions[k]\r\n    } else {\r\n      this.options[k] = options[k]\r\n    }\r\n  }\r\n\r\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\r\n\r\n  this.streamBuilder = streamBuilder\r\n\r\n  // Inflight message storages\r\n  this.outgoingStore = this.options.outgoingStore || new Store()\r\n  this.incomingStore = this.options.incomingStore || new Store()\r\n\r\n  // Should QoS zero messages be queued when the connection is broken?\r\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\r\n\r\n  // map of subscribed topics to support reconnection\r\n  this._resubscribeTopics = {}\r\n\r\n  // map of a subscribe messageId and a topic\r\n  this.messageIdToTopic = {}\r\n\r\n  // Ping timer, setup in _setupPingTimer\r\n  this.pingTimer = null\r\n  // Is the client connected?\r\n  this.connected = false\r\n  // Are we disconnecting?\r\n  this.disconnecting = false\r\n  // Packet queue\r\n  this.queue = []\r\n  // connack timer\r\n  this.connackTimer = null\r\n  // Reconnect timer\r\n  this.reconnectTimer = null\r\n  /**\r\n   * MessageIDs starting with 1\r\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\r\n   */\r\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\r\n\r\n  // Inflight callbacks\r\n  this.outgoing = {}\r\n\r\n  // Mark connected on connect\r\n  this.on('connect', function () {\r\n    if (this.disconnected) {\r\n      return\r\n    }\r\n\r\n    this.connected = true\r\n    var outStore = this.outgoingStore.createStream()\r\n\r\n    this.once('close', remove)\r\n    outStore.on('end', function () {\r\n      that.removeListener('close', remove)\r\n    })\r\n    outStore.on('error', function (err) {\r\n      that.removeListener('close', remove)\r\n      that.emit('error', err)\r\n    })\r\n\r\n    function remove () {\r\n      outStore.destroy()\r\n      outStore = null\r\n    }\r\n\r\n    function storeDeliver () {\r\n      // edge case, we wrapped this twice\r\n      if (!outStore) {\r\n        return\r\n      }\r\n\r\n      var packet = outStore.read(1)\r\n      var cb\r\n\r\n      if (!packet) {\r\n        // read when data is available in the future\r\n        outStore.once('readable', storeDeliver)\r\n        return\r\n      }\r\n\r\n      // Avoid unnecessary stream read operations when disconnected\r\n      if (!that.disconnecting && !that.reconnectTimer) {\r\n        cb = that.outgoing[packet.messageId]\r\n        that.outgoing[packet.messageId] = function (err, status) {\r\n          // Ensure that the original callback passed in to publish gets invoked\r\n          if (cb) {\r\n            cb(err, status)\r\n          }\r\n\r\n          storeDeliver()\r\n        }\r\n        that._sendPacket(packet)\r\n      } else if (outStore.destroy) {\r\n        outStore.destroy()\r\n      }\r\n    }\r\n\r\n    // start flowing\r\n    storeDeliver()\r\n  })\r\n\r\n  // Mark disconnected on stream close\r\n  this.on('close', function () {\r\n    this.connected = false\r\n    clearTimeout(this.connackTimer)\r\n  })\r\n\r\n  // Setup ping timer\r\n  this.on('connect', this._setupPingTimer)\r\n\r\n  // Send queued packets\r\n  this.on('connect', function () {\r\n    var queue = this.queue\r\n\r\n    function deliver () {\r\n      var entry = queue.shift()\r\n      var packet = null\r\n\r\n      if (!entry) {\r\n        return\r\n      }\r\n\r\n      packet = entry.packet\r\n\r\n      that._sendPacket(\r\n        packet,\r\n        function (err) {\r\n          if (entry.cb) {\r\n            entry.cb(err)\r\n          }\r\n          deliver()\r\n        }\r\n      )\r\n    }\r\n\r\n    deliver()\r\n  })\r\n\r\n  var firstConnection = true\r\n  // resubscribe\r\n  this.on('connect', function () {\r\n    if (!firstConnection &&\r\n        this.options.clean &&\r\n        Object.keys(this._resubscribeTopics).length > 0) {\r\n      if (this.options.resubscribe) {\r\n        this._resubscribeTopics.resubscribe = true\r\n        this.subscribe(this._resubscribeTopics)\r\n      } else {\r\n        this._resubscribeTopics = {}\r\n      }\r\n    }\r\n\r\n    firstConnection = false\r\n  })\r\n\r\n  // Clear ping timer\r\n  this.on('close', function () {\r\n    if (that.pingTimer !== null) {\r\n      that.pingTimer.clear()\r\n      that.pingTimer = null\r\n    }\r\n  })\r\n\r\n  // Setup reconnect timer on disconnect\r\n  this.on('close', this._setupReconnect)\r\n\r\n  events.EventEmitter.call(this)\r\n\r\n  this._setupStream()\r\n}\r\ninherits(MqttClient, events.EventEmitter)\r\n\r\n/**\r\n * setup the event handlers in the inner stream.\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupStream = function () {\r\n  var connectPacket\r\n  var that = this\r\n  var writable = new Writable()\r\n  var parser = mqttPacket.parser(this.options)\r\n  var completeParse = null\r\n  var packets = []\r\n\r\n  this._clearReconnect()\r\n\r\n  this.stream = this.streamBuilder(this)\r\n\r\n  parser.on('packet', function (packet) {\r\n    packets.push(packet)\r\n  })\r\n\r\n  function nextTickWork () {\r\n    process.nextTick(work)\r\n  }\r\n\r\n  function work () {\r\n    var packet = packets.shift()\r\n    var done = completeParse\r\n\r\n    if (packet) {\r\n      that._handlePacket(packet, nextTickWork)\r\n    } else {\r\n      completeParse = null\r\n      done()\r\n    }\r\n  }\r\n\r\n  writable._write = function (buf, enc, done) {\r\n    completeParse = done\r\n    parser.parse(buf)\r\n    work()\r\n  }\r\n\r\n  this.stream.pipe(writable)\r\n\r\n  // Suppress connection errors\r\n  this.stream.on('error', nop)\r\n\r\n  // Echo stream close\r\n  eos(this.stream, this.emit.bind(this, 'close'))\r\n\r\n  // Send a connect packet\r\n  connectPacket = Object.create(this.options)\r\n  connectPacket.cmd = 'connect'\r\n  // avoid message queue\r\n  sendPacket(this, connectPacket)\r\n\r\n  // Echo connection errors\r\n  parser.on('error', this.emit.bind(this, 'error'))\r\n\r\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\r\n  this.stream.setMaxListeners(1000)\r\n\r\n  clearTimeout(this.connackTimer)\r\n  this.connackTimer = setTimeout(function () {\r\n    that._cleanUp(true)\r\n  }, this.options.connectTimeout)\r\n}\r\n\r\nMqttClient.prototype._handlePacket = function (packet, done) {\r\n  this.emit('packetreceive', packet)\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      this._handlePublish(packet, done)\r\n      break\r\n    case 'puback':\r\n    case 'pubrec':\r\n    case 'pubcomp':\r\n    case 'suback':\r\n    case 'unsuback':\r\n      this._handleAck(packet)\r\n      done()\r\n      break\r\n    case 'pubrel':\r\n      this._handlePubrel(packet, done)\r\n      break\r\n    case 'connack':\r\n      this._handleConnack(packet)\r\n      done()\r\n      break\r\n    case 'pingresp':\r\n      this._handlePingresp(packet)\r\n      done()\r\n      break\r\n    default:\r\n      // do nothing\r\n      // maybe we should do an error handling\r\n      // or just log it\r\n      break\r\n  }\r\n}\r\n\r\nMqttClient.prototype._checkDisconnecting = function (callback) {\r\n  if (this.disconnecting) {\r\n    if (callback) {\r\n      callback(new Error('client disconnecting'))\r\n    } else {\r\n      this.emit('error', new Error('client disconnecting'))\r\n    }\r\n  }\r\n  return this.disconnecting\r\n}\r\n\r\n/**\r\n * publish - publish <message> to <topic>\r\n *\r\n * @param {String} topic - topic to publish to\r\n * @param {String, Buffer} message - message to publish\r\n * @param {Object} [opts] - publish options, includes:\r\n *    {Number} qos - qos level to publish on\r\n *    {Boolean} retain - whether or not to retain the message\r\n *    {Boolean} dup - whether or not mark a message as duplicate\r\n * @param {Function} [callback] - function(err){}\r\n *    called when publish succeeds or fails\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.publish('topic', 'message');\r\n * @example\r\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\r\n * @example client.publish('topic', 'message', console.log);\r\n */\r\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\r\n  var packet\r\n\r\n  // .publish(topic, payload, cb);\r\n  if (typeof opts === 'function') {\r\n    callback = opts\r\n    opts = null\r\n  }\r\n\r\n  // default opts\r\n  var defaultOpts = {qos: 0, retain: false, dup: false}\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  packet = {\r\n    cmd: 'publish',\r\n    topic: topic,\r\n    payload: message,\r\n    qos: opts.qos,\r\n    retain: opts.retain,\r\n    messageId: this._nextId(),\r\n    dup: opts.dup\r\n  }\r\n\r\n  switch (opts.qos) {\r\n    case 1:\r\n    case 2:\r\n\r\n      // Add to callbacks\r\n      this.outgoing[packet.messageId] = callback || nop\r\n      this._sendPacket(packet)\r\n      break\r\n    default:\r\n      this._sendPacket(packet, callback)\r\n      break\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * subscribe - subscribe to <topic>\r\n *\r\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n * @param {Object} [opts] - optional subscription options, includes:\r\n *    {Number} qos - subscribe qos level\r\n * @param {Function} [callback] - function(err, granted){} where:\r\n *    {Error} err - subscription error (none at the moment!)\r\n *    {Array} granted - array of {topic: 't', qos: 0}\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.subscribe('topic');\r\n * @example client.subscribe('topic', {qos: 1});\r\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\r\n * @example client.subscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.subscribe = function () {\r\n  var packet\r\n  var args = Array.prototype.slice.call(arguments)\r\n  var subs = []\r\n  var obj = args.shift()\r\n  var resubscribe = obj.resubscribe\r\n  var callback = args.pop() || nop\r\n  var opts = args.pop()\r\n  var invalidTopic\r\n  var that = this\r\n\r\n  delete obj.resubscribe\r\n\r\n  if (typeof obj === 'string') {\r\n    obj = [obj]\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    opts = callback\r\n    callback = nop\r\n  }\r\n\r\n  invalidTopic = validations.validateTopics(obj)\r\n  if (invalidTopic !== null) {\r\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\r\n    return this\r\n  }\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  var defaultOpts = { qos: 0 }\r\n  opts = xtend(defaultOpts, opts)\r\n\r\n  if (Array.isArray(obj)) {\r\n    obj.forEach(function (topic) {\r\n      if (that._resubscribeTopics[topic] < opts.qos ||\r\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\r\n          resubscribe) {\r\n        subs.push({\r\n          topic: topic,\r\n          qos: opts.qos\r\n        })\r\n      }\r\n    })\r\n  } else {\r\n    Object\r\n      .keys(obj)\r\n      .forEach(function (k) {\r\n        if (that._resubscribeTopics[k] < obj[k] ||\r\n            !that._resubscribeTopics.hasOwnProperty(k) ||\r\n            resubscribe) {\r\n          subs.push({\r\n            topic: k,\r\n            qos: obj[k]\r\n          })\r\n        }\r\n      })\r\n  }\r\n\r\n  packet = {\r\n    cmd: 'subscribe',\r\n    subscriptions: subs,\r\n    qos: 1,\r\n    retain: false,\r\n    dup: false,\r\n    messageId: this._nextId()\r\n  }\r\n\r\n  if (!subs.length) {\r\n    callback(null, [])\r\n    return\r\n  }\r\n\r\n  // subscriptions to resubscribe to in case of disconnect\r\n  if (this.options.resubscribe) {\r\n    var topics = []\r\n    subs.forEach(function (sub) {\r\n      if (that.options.reconnectPeriod > 0) {\r\n        that._resubscribeTopics[sub.topic] = sub.qos\r\n        topics.push(sub.topic)\r\n      }\r\n    })\r\n    that.messageIdToTopic[packet.messageId] = topics\r\n  }\r\n\r\n  this.outgoing[packet.messageId] = function (err, packet) {\r\n    if (!err) {\r\n      var granted = packet.granted\r\n      for (var i = 0; i < granted.length; i += 1) {\r\n        subs[i].qos = granted[i]\r\n      }\r\n    }\r\n\r\n    callback(err, subs)\r\n  }\r\n\r\n  this._sendPacket(packet)\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * unsubscribe - unsubscribe from topic(s)\r\n *\r\n * @param {String, Array} topic - topics to unsubscribe from\r\n * @param {Function} [callback] - callback fired on unsuback\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n * @example client.unsubscribe('topic');\r\n * @example client.unsubscribe('topic', console.log);\r\n */\r\nMqttClient.prototype.unsubscribe = function (topic, callback) {\r\n  var packet = {\r\n    cmd: 'unsubscribe',\r\n    qos: 1,\r\n    messageId: this._nextId()\r\n  }\r\n  var that = this\r\n\r\n  callback = callback || nop\r\n\r\n  if (this._checkDisconnecting(callback)) {\r\n    return this\r\n  }\r\n\r\n  if (typeof topic === 'string') {\r\n    packet.unsubscriptions = [topic]\r\n  } else if (typeof topic === 'object' && topic.length) {\r\n    packet.unsubscriptions = topic\r\n  }\r\n\r\n  if (this.options.resubscribe) {\r\n    packet.unsubscriptions.forEach(function (topic) {\r\n      delete that._resubscribeTopics[topic]\r\n    })\r\n  }\r\n\r\n  this.outgoing[packet.messageId] = callback\r\n\r\n  this._sendPacket(packet)\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * end - close connection\r\n *\r\n * @returns {MqttClient} this - for chaining\r\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n * @param {Function} cb - called when the client has been closed\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.end = function (force, cb) {\r\n  var that = this\r\n\r\n  if (typeof force === 'function') {\r\n    cb = force\r\n    force = false\r\n  }\r\n\r\n  function closeStores () {\r\n    that.disconnected = true\r\n    that.incomingStore.close(function () {\r\n      that.outgoingStore.close(function () {\r\n        if (cb) {\r\n          cb.apply(null, arguments)\r\n        }\r\n        that.emit('end')\r\n      })\r\n    })\r\n    if (that._deferredReconnect) {\r\n      that._deferredReconnect()\r\n    }\r\n  }\r\n\r\n  function finish () {\r\n    // defer closesStores of an I/O cycle,\r\n    // just to make sure things are\r\n    // ok for websockets\r\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\r\n  }\r\n\r\n  if (this.disconnecting) {\r\n    return this\r\n  }\r\n\r\n  this._clearReconnect()\r\n\r\n  this.disconnecting = true\r\n\r\n  if (!force && Object.keys(this.outgoing).length > 0) {\r\n    // wait 10ms, just to be sure we received all of it\r\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\r\n  } else {\r\n    finish()\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * removeOutgoingMessage - remove a message in outgoing store\r\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n *\r\n * @param {Number} mid - messageId to remove message\r\n * @returns {MqttClient} this - for chaining\r\n * @api public\r\n *\r\n * @example client.removeOutgoingMessage(client.getLastMessageId());\r\n */\r\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\r\n  var cb = this.outgoing[mid]\r\n  delete this.outgoing[mid]\r\n  this.outgoingStore.del({messageId: mid}, function () {\r\n    cb(new Error('Message removed'))\r\n  })\r\n  return this\r\n}\r\n\r\n/**\r\n * reconnect - connect again using the same options as connect()\r\n *\r\n * @param {Object} [opts] - optional reconnect options, includes:\r\n *    {Store} incomingStore - a store for the incoming packets\r\n *    {Store} outgoingStore - a store for the outgoing packets\r\n *    if opts is not given, current stores are used\r\n * @returns {MqttClient} this - for chaining\r\n *\r\n * @api public\r\n */\r\nMqttClient.prototype.reconnect = function (opts) {\r\n  var that = this\r\n  var f = function () {\r\n    if (opts) {\r\n      that.options.incomingStore = opts.incomingStore\r\n      that.options.outgoingStore = opts.outgoingStore\r\n    } else {\r\n      that.options.incomingStore = null\r\n      that.options.outgoingStore = null\r\n    }\r\n    that.incomingStore = that.options.incomingStore || new Store()\r\n    that.outgoingStore = that.options.outgoingStore || new Store()\r\n    that.disconnecting = false\r\n    that.disconnected = false\r\n    that._deferredReconnect = null\r\n    that._reconnect()\r\n  }\r\n\r\n  if (this.disconnecting && !this.disconnected) {\r\n    this._deferredReconnect = f\r\n  } else {\r\n    f()\r\n  }\r\n  return this\r\n}\r\n\r\n/**\r\n * _reconnect - implement reconnection\r\n * @api privateish\r\n */\r\nMqttClient.prototype._reconnect = function () {\r\n  this.emit('reconnect')\r\n  this._setupStream()\r\n}\r\n\r\n/**\r\n * _setupReconnect - setup reconnect timer\r\n */\r\nMqttClient.prototype._setupReconnect = function () {\r\n  var that = this\r\n\r\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\r\n    if (!this.reconnecting) {\r\n      this.emit('offline')\r\n      this.reconnecting = true\r\n    }\r\n    that.reconnectTimer = setInterval(function () {\r\n      that._reconnect()\r\n    }, that.options.reconnectPeriod)\r\n  }\r\n}\r\n\r\n/**\r\n * _clearReconnect - clear the reconnect timer\r\n */\r\nMqttClient.prototype._clearReconnect = function () {\r\n  if (this.reconnectTimer) {\r\n    clearInterval(this.reconnectTimer)\r\n    this.reconnectTimer = null\r\n  }\r\n}\r\n\r\n/**\r\n * _cleanUp - clean up on connection end\r\n * @api private\r\n */\r\nMqttClient.prototype._cleanUp = function (forced, done) {\r\n  if (done) {\r\n    this.stream.on('close', done)\r\n  }\r\n\r\n  if (forced) {\r\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\r\n      flush(this.outgoing)\r\n    }\r\n    this.stream.destroy()\r\n  } else {\r\n    this._sendPacket(\r\n      { cmd: 'disconnect' },\r\n      setImmediate.bind(\r\n        null,\r\n        this.stream.end.bind(this.stream)\r\n      )\r\n    )\r\n  }\r\n\r\n  if (!this.disconnecting) {\r\n    this._clearReconnect()\r\n    this._setupReconnect()\r\n  }\r\n\r\n  if (this.pingTimer !== null) {\r\n    this.pingTimer.clear()\r\n    this.pingTimer = null\r\n  }\r\n\r\n  if (done && !this.connected) {\r\n    this.stream.removeListener('close', done)\r\n    done()\r\n  }\r\n}\r\n\r\n/**\r\n * _sendPacket - send or queue a packet\r\n * @param {String} type - packet type (see `protocol`)\r\n * @param {Object} packet - packet options\r\n * @param {Function} cb - callback when the packet is sent\r\n * @api private\r\n */\r\nMqttClient.prototype._sendPacket = function (packet, cb) {\r\n  if (!this.connected) {\r\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\r\n      this.queue.push({ packet: packet, cb: cb })\r\n    } else if (packet.qos > 0) {\r\n      cb = this.outgoing[packet.messageId]\r\n      this.outgoingStore.put(packet, function (err) {\r\n        if (err) {\r\n          return cb && cb(err)\r\n        }\r\n      })\r\n    } else if (cb) {\r\n      cb(new Error('No connection to broker'))\r\n    }\r\n\r\n    return\r\n  }\r\n\r\n  // When sending a packet, reschedule the ping timer\r\n  this._shiftPingInterval()\r\n\r\n  switch (packet.cmd) {\r\n    case 'publish':\r\n      break\r\n    case 'pubrel':\r\n      storeAndSend(this, packet, cb)\r\n      return\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      return\r\n  }\r\n\r\n  switch (packet.qos) {\r\n    case 2:\r\n    case 1:\r\n      storeAndSend(this, packet, cb)\r\n      break\r\n    /**\r\n     * no need of case here since it will be caught by default\r\n     * and jshint comply that before default it must be a break\r\n     * anyway it will result in -1 evaluation\r\n     */\r\n    case 0:\r\n      /* falls through */\r\n    default:\r\n      sendPacket(this, packet, cb)\r\n      break\r\n  }\r\n}\r\n\r\n/**\r\n * _setupPingTimer - setup the ping timer\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._setupPingTimer = function () {\r\n  var that = this\r\n\r\n  if (!this.pingTimer && this.options.keepalive) {\r\n    this.pingResp = true\r\n    this.pingTimer = reInterval(function () {\r\n      that._checkPing()\r\n    }, this.options.keepalive * 1000)\r\n  }\r\n}\r\n\r\n/**\r\n * _shiftPingInterval - reschedule the ping interval\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._shiftPingInterval = function () {\r\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\r\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\r\n  }\r\n}\r\n/**\r\n * _checkPing - check if a pingresp has come back, and ping the server again\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._checkPing = function () {\r\n  if (this.pingResp) {\r\n    this.pingResp = false\r\n    this._sendPacket({ cmd: 'pingreq' })\r\n  } else {\r\n    // do a forced cleanup since socket will be in bad shape\r\n    this._cleanUp(true)\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePingresp - handle a pingresp\r\n *\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePingresp = function () {\r\n  this.pingResp = true\r\n}\r\n\r\n/**\r\n * _handleConnack\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n\r\nMqttClient.prototype._handleConnack = function (packet) {\r\n  var rc = packet.returnCode\r\n  var errors = [\r\n    '',\r\n    'Unacceptable protocol version',\r\n    'Identifier rejected',\r\n    'Server unavailable',\r\n    'Bad username or password',\r\n    'Not authorized'\r\n  ]\r\n\r\n  clearTimeout(this.connackTimer)\r\n\r\n  if (rc === 0) {\r\n    this.reconnecting = false\r\n    this.emit('connect', packet)\r\n  } else if (rc > 0) {\r\n    var err = new Error('Connection refused: ' + errors[rc])\r\n    err.code = rc\r\n    this.emit('error', err)\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePublish\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n/*\r\nthose late 2 case should be rewrite to comply with coding style:\r\n\r\ncase 1:\r\ncase 0:\r\n  // do not wait sending a puback\r\n  // no callback passed\r\n  if (1 === qos) {\r\n    this._sendPacket({\r\n      cmd: 'puback',\r\n      messageId: mid\r\n    });\r\n  }\r\n  // emit the message event for both qos 1 and 0\r\n  this.emit('message', topic, message, packet);\r\n  this.handleMessage(packet, done);\r\n  break;\r\ndefault:\r\n  // do nothing but every switch mus have a default\r\n  // log or throw an error about unknown qos\r\n  break;\r\n\r\nfor now i just suppressed the warnings\r\n*/\r\nMqttClient.prototype._handlePublish = function (packet, done) {\r\n  done = typeof done !== 'undefined' ? done : nop\r\n  var topic = packet.topic.toString()\r\n  var message = packet.payload\r\n  var qos = packet.qos\r\n  var mid = packet.messageId\r\n  var that = this\r\n\r\n  switch (qos) {\r\n    case 2:\r\n      this.incomingStore.put(packet, function (err) {\r\n        if (err) {\r\n          return done(err)\r\n        }\r\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\r\n      })\r\n      break\r\n    case 1:\r\n      // emit the message event\r\n      this.emit('message', topic, message, packet)\r\n      this.handleMessage(packet, function (err) {\r\n        if (err) {\r\n          return done(err)\r\n        }\r\n        // send 'puback' if the above 'handleMessage' method executed\r\n        // successfully.\r\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\r\n      })\r\n      break\r\n    case 0:\r\n      // emit the message event\r\n      this.emit('message', topic, message, packet)\r\n      this.handleMessage(packet, done)\r\n      break\r\n    default:\r\n      // do nothing\r\n      // log or throw an error about unknown qos\r\n      break\r\n  }\r\n}\r\n\r\n/**\r\n * Handle messages with backpressure support, one at a time.\r\n * Override at will.\r\n *\r\n * @param Packet packet the packet\r\n * @param Function callback call when finished\r\n * @api public\r\n */\r\nMqttClient.prototype.handleMessage = function (packet, callback) {\r\n  callback()\r\n}\r\n\r\n/**\r\n * _handleAck\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\n\r\nMqttClient.prototype._handleAck = function (packet) {\r\n  /* eslint no-fallthrough: \"off\" */\r\n  var mid = packet.messageId\r\n  var type = packet.cmd\r\n  var response = null\r\n  var cb = this.outgoing[mid]\r\n  var that = this\r\n\r\n  if (!cb) {\r\n    // Server sent an ack in error, ignore it.\r\n    return\r\n  }\r\n\r\n  // Process\r\n  switch (type) {\r\n    case 'pubcomp':\r\n      // same thing as puback for QoS 2\r\n    case 'puback':\r\n      // Callback - we're done\r\n      delete this.outgoing[mid]\r\n      this.outgoingStore.del(packet, cb)\r\n      break\r\n    case 'pubrec':\r\n      response = {\r\n        cmd: 'pubrel',\r\n        qos: 2,\r\n        messageId: mid\r\n      }\r\n\r\n      this._sendPacket(response)\r\n      break\r\n    case 'suback':\r\n      delete this.outgoing[mid]\r\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\r\n        // suback with Failure status\r\n        var topics = this.messageIdToTopic[mid]\r\n        if (topics) {\r\n          topics.forEach(function (topic) {\r\n            delete that._resubscribeTopics[topic]\r\n          })\r\n        }\r\n      }\r\n      cb(null, packet)\r\n      break\r\n    case 'unsuback':\r\n      delete this.outgoing[mid]\r\n      cb(null)\r\n      break\r\n    default:\r\n      that.emit('error', new Error('unrecognized packet type'))\r\n  }\r\n\r\n  if (this.disconnecting &&\r\n      Object.keys(this.outgoing).length === 0) {\r\n    this.emit('outgoingEmpty')\r\n  }\r\n}\r\n\r\n/**\r\n * _handlePubrel\r\n *\r\n * @param {Object} packet\r\n * @api private\r\n */\r\nMqttClient.prototype._handlePubrel = function (packet, callback) {\r\n  callback = typeof callback !== 'undefined' ? callback : nop\r\n  var mid = packet.messageId\r\n  var that = this\r\n\r\n  var comp = {cmd: 'pubcomp', messageId: mid}\r\n\r\n  that.incomingStore.get(packet, function (err, pub) {\r\n    if (!err && pub.cmd !== 'pubrel') {\r\n      that.emit('message', pub.topic, pub.payload, pub)\r\n      that.incomingStore.put(packet, function (err) {\r\n        if (err) {\r\n          return callback(err)\r\n        }\r\n        that.handleMessage(pub, function (err) {\r\n          if (err) {\r\n            return callback(err)\r\n          }\r\n          that._sendPacket(comp, callback)\r\n        })\r\n      })\r\n    } else {\r\n      that._sendPacket(comp, callback)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * _nextId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype._nextId = function () {\r\n  // id becomes current state of this.nextId and increments afterwards\r\n  var id = this.nextId++\r\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\r\n  if (this.nextId === 65536) {\r\n    this.nextId = 1\r\n  }\r\n  return id\r\n}\r\n\r\n/**\r\n * getLastMessageId\r\n * @return unsigned int\r\n */\r\nMqttClient.prototype.getLastMessageId = function () {\r\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\r\n}\r\n\r\nmodule.exports = MqttClient\r\n","'use strict'\r\n\r\nvar MqttClient = require('../client')\r\nvar Store = require('../store')\r\nvar url = require('url')\r\nvar xtend = require('xtend')\r\nvar protocols = {}\r\n\r\nif (process.title !== 'browser') {\r\n  protocols.mqtt = require('./tcp')\r\n  protocols.tcp = require('./tcp')\r\n  protocols.ssl = require('./tls')\r\n  protocols.tls = require('./tls')\r\n  protocols.mqtts = require('./tls')\r\n} else {\r\n  protocols.wx = require('./wx')\r\n  protocols.wxs = require('./wx')\r\n}\r\n\r\nprotocols.ws = require('./ws')\r\nprotocols.wss = require('./ws')\r\n\r\n/**\r\n * Parse the auth attribute and merge username and password in the options object.\r\n *\r\n * @param {Object} [opts] option object\r\n */\r\nfunction parseAuthOptions (opts) {\r\n  var matches\r\n  if (opts.auth) {\r\n    matches = opts.auth.match(/^(.+):(.+)$/)\r\n    if (matches) {\r\n      opts.username = matches[1]\r\n      opts.password = matches[2]\r\n    } else {\r\n      opts.username = opts.auth\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * connect - connect to an MQTT broker.\r\n *\r\n * @param {String} [brokerUrl] - url of the broker, optional\r\n * @param {Object} opts - see MqttClient#constructor\r\n */\r\nfunction connect (brokerUrl, opts) {\r\n  if ((typeof brokerUrl === 'object') && !opts) {\r\n    opts = brokerUrl\r\n    brokerUrl = null\r\n  }\r\n\r\n  opts = opts || {}\r\n\r\n  if (brokerUrl) {\r\n    var parsed = url.parse(brokerUrl, true)\r\n    if (parsed.port != null) {\r\n      parsed.port = Number(parsed.port)\r\n    }\r\n\r\n    opts = xtend(parsed, opts)\r\n\r\n    if (opts.protocol === null) {\r\n      throw new Error('Missing protocol')\r\n    }\r\n    opts.protocol = opts.protocol.replace(/:$/, '')\r\n  }\r\n\r\n  // merge in the auth options if supplied\r\n  parseAuthOptions(opts)\r\n\r\n  // support clientId passed in the query string of the url\r\n  if (opts.query && typeof opts.query.clientId === 'string') {\r\n    opts.clientId = opts.query.clientId\r\n  }\r\n\r\n  if (opts.cert && opts.key) {\r\n    if (opts.protocol) {\r\n      if (['mqtts', 'wss', 'wxs'].indexOf(opts.protocol) === -1) {\r\n        switch (opts.protocol) {\r\n          case 'mqtt':\r\n            opts.protocol = 'mqtts'\r\n            break\r\n          case 'ws':\r\n            opts.protocol = 'wss'\r\n            break\r\n          case 'wx':\r\n            opts.protocol = 'wxs'\r\n            break\r\n          default:\r\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!')\r\n        }\r\n      }\r\n    } else {\r\n      // don't know what protocol he want to use, mqtts or wss\r\n      throw new Error('Missing secure protocol key')\r\n    }\r\n  }\r\n\r\n  if (!protocols[opts.protocol]) {\r\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\r\n    opts.protocol = [\r\n      'mqtt',\r\n      'mqtts',\r\n      'ws',\r\n      'wss',\r\n      'wx',\r\n      'wxs'\r\n    ].filter(function (key, index) {\r\n      if (isSecure && index % 2 === 0) {\r\n        // Skip insecure protocols when requesting a secure one.\r\n        return false\r\n      }\r\n      return (typeof protocols[key] === 'function')\r\n    })[0]\r\n  }\r\n\r\n  if (opts.clean === false && !opts.clientId) {\r\n    throw new Error('Missing clientId for unclean clients')\r\n  }\r\n\r\n  if (opts.protocol) {\r\n    opts.defaultProtocol = opts.protocol\r\n  }\r\n\r\n  function wrapper (client) {\r\n    if (opts.servers) {\r\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\r\n        client._reconnectCount = 0\r\n      }\r\n\r\n      opts.host = opts.servers[client._reconnectCount].host\r\n      opts.port = opts.servers[client._reconnectCount].port\r\n      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)\r\n      opts.hostname = opts.host\r\n\r\n      client._reconnectCount++\r\n    }\r\n\r\n    return protocols[opts.protocol](client, opts)\r\n  }\r\n\r\n  return new MqttClient(wrapper, opts)\r\n}\r\n\r\nmodule.exports = connect\r\nmodule.exports.connect = connect\r\nmodule.exports.MqttClient = MqttClient\r\nmodule.exports.Store = Store\r\n","'use strict'\r\nvar net = require('net')\r\n\r\n/*\r\n  variables port and host can be removed since\r\n  you have all required information in opts object\r\n*/\r\nfunction buildBuilder (client, opts) {\r\n  var port, host\r\n  opts.port = opts.port || 1883\r\n  opts.hostname = opts.hostname || opts.host || 'localhost'\r\n\r\n  port = opts.port\r\n  host = opts.hostname\r\n\r\n  return net.createConnection(port, host)\r\n}\r\n\r\nmodule.exports = buildBuilder\r\n","'use strict'\r\nvar tls = require('tls')\r\n\r\nfunction buildBuilder (mqttClient, opts) {\r\n  var connection\r\n  opts.port = opts.port || 8883\r\n  opts.host = opts.hostname || opts.host || 'localhost'\r\n\r\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\r\n\r\n  delete opts.path\r\n\r\n  connection = tls.connect(opts)\r\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\r\n  connection.on('secureConnect', function () {\r\n    if (opts.rejectUnauthorized && !connection.authorized) {\r\n      connection.emit('error', new Error('TLS not authorized'))\r\n    } else {\r\n      connection.removeListener('error', handleTLSerrors)\r\n    }\r\n  })\r\n\r\n  function handleTLSerrors (err) {\r\n    // How can I get verify this error is a tls error?\r\n    if (opts.rejectUnauthorized) {\r\n      mqttClient.emit('error', err)\r\n    }\r\n\r\n    // close this connection to match the behaviour of net\r\n    // otherwise all we get is an error from the connection\r\n    // and close event doesn't fire. This is a work around\r\n    // to enable the reconnect code to work the same as with\r\n    // net.createConnection\r\n    connection.end()\r\n  }\r\n\r\n  connection.on('error', handleTLSerrors)\r\n  return connection\r\n}\r\n\r\nmodule.exports = buildBuilder\r\n","'use strict'\r\n\r\nvar websocket = require('websocket-stream')\r\nvar urlModule = require('url')\r\nvar WSS_OPTIONS = [\r\n  'rejectUnauthorized',\r\n  'ca',\r\n  'cert',\r\n  'key',\r\n  'pfx',\r\n  'passphrase'\r\n]\r\nvar IS_BROWSER = process.title === 'browser'\r\n\r\nfunction buildUrl (opts, client) {\r\n  var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\r\n  if (typeof (opts.transformWsUrl) === 'function') {\r\n    url = opts.transformWsUrl(url, opts, client)\r\n  }\r\n  return url\r\n}\r\n\r\nfunction setDefaultOpts (opts) {\r\n  if (!opts.hostname) {\r\n    opts.hostname = 'localhost'\r\n  }\r\n  if (!opts.port) {\r\n    if (opts.protocol === 'wss') {\r\n      opts.port = 443\r\n    } else {\r\n      opts.port = 80\r\n    }\r\n  }\r\n  if (!opts.path) {\r\n    opts.path = '/'\r\n  }\r\n\r\n  if (!opts.wsOptions) {\r\n    opts.wsOptions = {}\r\n  }\r\n  if (!IS_BROWSER && opts.protocol === 'wss') {\r\n    // Add cert/key/ca etc options\r\n    WSS_OPTIONS.forEach(function (prop) {\r\n      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\r\n        opts.wsOptions[prop] = opts[prop]\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction createWebSocket (client, opts) {\r\n  var websocketSubProtocol =\r\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\r\n      ? 'mqttv3.1'\r\n      : 'mqtt'\r\n\r\n  setDefaultOpts(opts)\r\n  var url = buildUrl(opts, client)\r\n  return websocket(url, [websocketSubProtocol], opts.wsOptions)\r\n}\r\n\r\nfunction buildBuilder (client, opts) {\r\n  return createWebSocket(client, opts)\r\n}\r\n\r\nfunction buildBuilderBrowser (client, opts) {\r\n  if (!opts.hostname) {\r\n    opts.hostname = opts.host\r\n  }\r\n\r\n  if (!opts.hostname) {\r\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\r\n    // can not determine the `hostname` automatically.  If connecting to\r\n    // localhost, please supply the `hostname` as an argument.\r\n    if (typeof (document) === 'undefined') {\r\n      throw new Error('Could not determine host. Specify host manually.')\r\n    }\r\n    var parsed = urlModule.parse(document.URL)\r\n    opts.hostname = parsed.hostname\r\n\r\n    if (!opts.port) {\r\n      opts.port = parsed.port\r\n    }\r\n  }\r\n  return createWebSocket(client, opts)\r\n}\r\n\r\nif (IS_BROWSER) {\r\n  module.exports = buildBuilderBrowser\r\n} else {\r\n  module.exports = buildBuilder\r\n}\r\n","'use strict'\r\n\r\n/* global wx */\r\nvar socketOpen = false\r\nvar socketMsgQueue = []\r\n\r\nfunction sendSocketMessage (msg) {\r\n  if (socketOpen) {\r\n    wx.sendSocketMessage({\r\n      data: msg.buffer || msg\r\n    })\r\n  } else {\r\n    socketMsgQueue.push(msg)\r\n  }\r\n}\r\n\r\nfunction WebSocket (url, protocols) {\r\n  var ws = {\r\n    OPEN: 1,\r\n    CLOSING: 2,\r\n    CLOSED: 3,\r\n    readyState: socketOpen ? 1 : 0,\r\n    send: sendSocketMessage,\r\n    close: wx.closeSocket,\r\n    onopen: null,\r\n    onmessage: null,\r\n    onclose: null,\r\n    onerror: null\r\n  }\r\n\r\n  wx.connectSocket({\r\n    url: url,\r\n    protocols: protocols\r\n  })\r\n  wx.onSocketOpen(function (res) {\r\n    ws.readyState = ws.OPEN\r\n    socketOpen = true\r\n    for (var i = 0; i < socketMsgQueue.length; i++) {\r\n      sendSocketMessage(socketMsgQueue[i])\r\n    }\r\n    socketMsgQueue = []\r\n\r\n    ws.onopen && ws.onopen.apply(ws, arguments)\r\n  })\r\n  wx.onSocketMessage(function (res) {\r\n    ws.onmessage && ws.onmessage.apply(ws, arguments)\r\n  })\r\n  wx.onSocketClose(function () {\r\n    ws.onclose && ws.onclose.apply(ws, arguments)\r\n    ws.readyState = ws.CLOSED\r\n    socketOpen = false\r\n  })\r\n  wx.onSocketError(function () {\r\n    ws.onerror && ws.onerror.apply(ws, arguments)\r\n    ws.readyState = ws.CLOSED\r\n    socketOpen = false\r\n  })\r\n\r\n  return ws\r\n}\r\n\r\nvar websocket = require('websocket-stream')\r\n\r\nfunction buildUrl (opts, client) {\r\n  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'\r\n  var url = protocol + '://' + opts.hostname + opts.path\r\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\r\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\r\n  }\r\n  if (typeof (opts.transformWsUrl) === 'function') {\r\n    url = opts.transformWsUrl(url, opts, client)\r\n  }\r\n  return url\r\n}\r\n\r\nfunction setDefaultOpts (opts) {\r\n  if (!opts.hostname) {\r\n    opts.hostname = 'localhost'\r\n  }\r\n  if (!opts.path) {\r\n    opts.path = '/'\r\n  }\r\n\r\n  if (!opts.wsOptions) {\r\n    opts.wsOptions = {}\r\n  }\r\n}\r\n\r\nfunction createWebSocket (client, opts) {\r\n  var websocketSubProtocol =\r\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\r\n      ? 'mqttv3.1'\r\n      : 'mqtt'\r\n\r\n  setDefaultOpts(opts)\r\n  var url = buildUrl(opts, client)\r\n  return websocket(WebSocket(url, [websocketSubProtocol]))\r\n}\r\n\r\nfunction buildBuilder (client, opts) {\r\n  opts.hostname = opts.hostname || opts.host\r\n\r\n  if (!opts.hostname) {\r\n    throw new Error('Could not determine host. Specify host manually.')\r\n  }\r\n\r\n  return createWebSocket(client, opts)\r\n}\r\n\r\nmodule.exports = buildBuilder\r\n","'use strict'\r\n\r\n/**\r\n * Module dependencies\r\n */\r\nvar xtend = require('xtend')\r\n\r\nvar Readable = require('readable-stream').Readable\r\nvar streamsOpts = { objectMode: true }\r\nvar defaultStoreOptions = {\r\n  clean: true\r\n}\r\n\r\n/**\r\n * es6-map can preserve insertion order even if ES version is older.\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\r\n * It should be noted that a Map which is a map of an object, especially\r\n * a dictionary of dictionaries, will only map to the object's insertion\r\n * order. In ES2015 this is ordered for objects but for older versions of\r\n * ES, this may be random and not ordered.\r\n *\r\n */\r\nvar Map = require('es6-map')\r\n\r\n/**\r\n * In-memory implementation of the message store\r\n * This can actually be saved into files.\r\n *\r\n * @param {Object} [options] - store options\r\n */\r\nfunction Store (options) {\r\n  if (!(this instanceof Store)) {\r\n    return new Store(options)\r\n  }\r\n\r\n  this.options = options || {}\r\n\r\n  // Defaults\r\n  this.options = xtend(defaultStoreOptions, options)\r\n\r\n  this._inflights = new Map()\r\n}\r\n\r\n/**\r\n * Adds a packet to the store, a packet is\r\n * anything that has a messageId property.\r\n *\r\n */\r\nStore.prototype.put = function (packet, cb) {\r\n  this._inflights.set(packet.messageId, packet)\r\n\r\n  if (cb) {\r\n    cb()\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * Creates a stream with all the packets in the store\r\n *\r\n */\r\nStore.prototype.createStream = function () {\r\n  var stream = new Readable(streamsOpts)\r\n  var destroyed = false\r\n  var values = []\r\n  var i = 0\r\n\r\n  this._inflights.forEach(function (value, key) {\r\n    values.push(value)\r\n  })\r\n\r\n  stream._read = function () {\r\n    if (!destroyed && i < values.length) {\r\n      this.push(values[i++])\r\n    } else {\r\n      this.push(null)\r\n    }\r\n  }\r\n\r\n  stream.destroy = function () {\r\n    if (destroyed) {\r\n      return\r\n    }\r\n\r\n    var self = this\r\n\r\n    destroyed = true\r\n\r\n    process.nextTick(function () {\r\n      self.emit('close')\r\n    })\r\n  }\r\n\r\n  return stream\r\n}\r\n\r\n/**\r\n * deletes a packet from the store.\r\n */\r\nStore.prototype.del = function (packet, cb) {\r\n  packet = this._inflights.get(packet.messageId)\r\n  if (packet) {\r\n    this._inflights.delete(packet.messageId)\r\n    cb(null, packet)\r\n  } else if (cb) {\r\n    cb(new Error('missing packet'))\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * get a packet from the store.\r\n */\r\nStore.prototype.get = function (packet, cb) {\r\n  packet = this._inflights.get(packet.messageId)\r\n  if (packet) {\r\n    cb(null, packet)\r\n  } else if (cb) {\r\n    cb(new Error('missing packet'))\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n/**\r\n * Close the store\r\n */\r\nStore.prototype.close = function (cb) {\r\n  if (this.options.clean) {\r\n    this._inflights = null\r\n  }\r\n  if (cb) {\r\n    cb()\r\n  }\r\n}\r\n\r\nmodule.exports = Store\r\n","'use strict'\r\n\r\n/**\r\n * Validate a topic to see if it's valid or not.\r\n * A topic is valid if it follow below rules:\r\n * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\r\n * - Rule #2: Part `#` must be located at the end of the mailbox\r\n *\r\n * @param {String} topic - A topic\r\n * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\r\n */\r\nfunction validateTopic (topic) {\r\n  var parts = topic.split('/')\r\n\r\n  for (var i = 0; i < parts.length; i++) {\r\n    if (parts[i] === '+') {\r\n      continue\r\n    }\r\n\r\n    if (parts[i] === '#') {\r\n      // for Rule #2\r\n      return i === parts.length - 1\r\n    }\r\n\r\n    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Validate an array of topics to see if any of them is valid or not\r\n  * @param {Array} topics - Array of topics\r\n * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\r\n */\r\nfunction validateTopics (topics) {\r\n  if (topics.length === 0) {\r\n    return 'empty_topic_list'\r\n  }\r\n  for (var i = 0; i < topics.length; i++) {\r\n    if (!validateTopic(topics[i])) {\r\n      return topics[i]\r\n    }\r\n  }\r\n  return null\r\n}\r\n\r\nmodule.exports = {\r\n  validateTopics: validateTopics\r\n}\r\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","'use strict'\n\nfunction ReInterval (callback, interval, args) {\n  var self = this;\n\n  this._callback = callback;\n  this._args = args;\n\n  this._interval = setInterval(callback, interval, this._args);\n\n  this.reschedule = function (interval) {\n    // if no interval entered, use the interval passed in on creation\n    if (!interval)\n      interval = self._interval;\n\n    if (self._interval)\n      clearInterval(self._interval);\n    self._interval = setInterval(self._callback, interval, self._args);\n  };\n\n  this.clear = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n      self._interval = undefined;\n    }\n  };\n  \n  this.destroy = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n    }\n    self._callback = undefined;\n    self._interval = undefined;\n    self._args = undefined;\n  };\n}\n\nfunction reInterval () {\n  if (typeof arguments[0] !== 'function')\n    throw new Error('callback needed');\n  if (typeof arguments[1] !== 'number')\n    throw new Error('interval needed');\n\n  var args;\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2];\n    }\n  }\n\n  return new ReInterval(arguments[0], arguments[1], args);\n}\n\nmodule.exports = reInterval;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","module.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. audio\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseAudioType(str, input, output) {\n  str = str.toLowerCase();\n  let result = '';\n\n  if (str.indexOf('input') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('display audio') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('speak') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('laut') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('loud') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('head') >= 0) { result = 'Headset'; }\n  if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('mikr') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('controll') >= 0) { result = 'Controller'; }\n  if (str.indexOf('line o') >= 0) { result = 'Line Out'; }\n  if (str.indexOf('digital o') >= 0) { result = 'Digital Out'; }\n  if (str.indexOf('smart sound technology') >= 0) { result = 'Digital Signal Processor'; }\n  if (str.indexOf('high definition audio') >= 0) { result = 'Sound Driver'; }\n\n  if (!result && output) {\n    result = 'Speaker';\n  } else if (!result && input) {\n    result = 'Microphone';\n  }\n  return result;\n}\n\n\nfunction getLinuxAudioPci() {\n  let cmd = 'lspci -v 2>/dev/null';\n  let result = [];\n  try {\n    const parts = execSync(cmd).toString().split('\\n\\n');\n    parts.forEach(element => {\n      const lines = element.split('\\n');\n      if (lines && lines.length && lines[0].toLowerCase().indexOf('audio') >= 0) {\n        const audio = {};\n        audio.slotId = lines[0].split(' ')[0];\n        audio.driver = util.getValue(lines, 'Kernel driver in use', ':', true) || util.getValue(lines, 'Kernel modules', ':', true);\n        result.push(audio);\n      }\n    });\n    return result;\n  } catch (e) {\n    return result;\n  }\n}\n\nfunction parseLinuxAudioPciMM(lines, audioPCI) {\n  const result = {};\n  const slotId = util.getValue(lines, 'Slot');\n\n  const pciMatch = audioPCI.filter(function (item) { return item.slotId === slotId; });\n\n  result.id = slotId;\n  result.name = util.getValue(lines, 'SDevice');\n  result.manufacturer = util.getValue(lines, 'SVendor');\n  result.revision = util.getValue(lines, 'Rev');\n  result.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : '';\n  result.default = null;\n  result.channel = 'PCIe';\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseDarwinChannel(str) {\n  let result = '';\n\n  if (str.indexOf('builtin') >= 0) { result = 'Built-In'; }\n  if (str.indexOf('extern') >= 0) { result = 'Audio-Jack'; }\n  if (str.indexOf('hdmi') >= 0) { result = 'HDMI'; }\n  if (str.indexOf('displayport') >= 0) { result = 'Display-Port'; }\n  if (str.indexOf('usb') >= 0) { result = 'USB'; }\n  if (str.indexOf('pci') >= 0) { result = 'PCIe'; }\n\n  return result;\n}\n\nfunction parseDarwinAudio(audioObject, id) {\n  const result = {};\n  const channelStr = ((audioObject.coreaudio_device_transport || '') + ' ' + (audioObject._name || '')).toLowerCase();\n\n  result.id = id;\n  result.name = audioObject._name;\n  result.manufacturer = audioObject.coreaudio_device_manufacturer;\n  result.revision = null;\n  result.driver = null;\n  result.default = !!(audioObject.coreaudio_default_audio_input_device || '') || !!(audioObject.coreaudio_default_audio_output_device || '');\n  result.channel = parseDarwinChannel(channelStr);\n  result.type = parseAudioType(result.name, !!(audioObject.coreaudio_device_input || ''), !!(audioObject.coreaudio_device_output || ''));\n  result.in = !!(audioObject.coreaudio_device_input || '');\n  result.out = !!(audioObject.coreaudio_device_output || '');\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseWindowsAudio(lines) {\n  const result = {};\n  const status = util.getValue(lines, 'StatusInfo', ':');\n\n  result.id = util.getValue(lines, 'DeviceID', ':'); // PNPDeviceID??\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.revision = null;\n  result.driver = null;\n  result.default = null;\n  result.channel = null;\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = status;\n\n  return result;\n}\n\nfunction audio(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'lspci -vmm 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // PCI\n          if (!error) {\n            const audioPCI = getLinuxAudioPci();\n            const parts = stdout.toString().split('\\n\\n');\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'class', ':', true).toLowerCase().indexOf('audio') >= 0) {\n                const audio = parseLinuxAudioPciMM(lines, audioPCI);\n                result.push(audio);\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPAudioDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]['_items'] && outObj.SPAudioDataType[0]['_items'].length) {\n                for (let i = 0; i < outObj.SPAudioDataType[0]['_items'].length; i++) {\n                  const audio = parseDarwinAudio(outObj.SPAudioDataType[0]['_items'][i], i);\n                  result.push(audio);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'name', ':')) {\n                result.push(parseWindowsAudio(lines));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.audio = audio;\n","'use strict';\n// @ts-check;\n// ==================================================================================\n// battery.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 6. Battery\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {\n  const result = {};\n  let status = util.getValue(lines, 'BatteryStatus', ':').trim();\n  // 1 = \"Discharging\"\n  // 2 = \"On A/C\"\n  // 3 = \"Fully Charged\"\n  // 4 = \"Low\"\n  // 5 = \"Critical\"\n  // 6 = \"Charging\"\n  // 7 = \"Charging High\"\n  // 8 = \"Charging Low\"\n  // 9 = \"Charging Critical\"\n  // 10 = \"Undefined\"\n  // 11 = \"Partially Charged\"\n  if (status >= 0) {\n    const statusValue = status ? parseInt(status) : 0;\n    result.status = statusValue;\n    result.hasBattery = true;\n    result.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, 'DesignCapacity', ':') || 0);\n    result.designedCapacity = parseInt(util.getValue(lines, 'DesignCapacity', ':') || designedCapacity);\n    result.voltage = parseInt(util.getValue(lines, 'DesignVoltage', ':') || 0) / 1000.0;\n    result.capacityUnit = 'mWh';\n    result.percent = parseInt(util.getValue(lines, 'EstimatedChargeRemaining', ':') || 0);\n    result.currentCapacity = parseInt(result.maxCapacity * result.percent / 100);\n    result.isCharging = (statusValue >= 6 && statusValue <= 9) || statusValue === 11 || ((statusValue !== 3) && (statusValue !== 1) && result.percent < 100);\n    result.acConnected = result.isCharging || statusValue === 2;\n    result.model = util.getValue(lines, 'DeviceID', ':');\n  } else {\n    result.status = -1;\n  }\n\n  return result;\n}\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        hasBattery: false,\n        cycleCount: 0,\n        isCharging: false,\n        designedCapacity: 0,\n        maxCapacity: 0,\n        currentCapacity: 0,\n        voltage: 0,\n        capacityUnit: '',\n        percent: 0,\n        timeRemaining: null,\n        acConnected: true,\n        type: '',\n        model: '',\n        manufacturer: '',\n        serial: ''\n      };\n\n      if (_linux) {\n        let battery_path = '';\n        if (fs.existsSync('/sys/class/power_supply/BAT1/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT1/';\n        } else if (fs.existsSync('/sys/class/power_supply/BAT0/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT0/';\n        }\n\n        let acConnected = false;\n        let acPath = '';\n        if (fs.existsSync('/sys/class/power_supply/AC/online')) {\n          acPath = '/sys/class/power_supply/AC/online';\n        } else if (fs.existsSync('/sys/class/power_supply/AC0/online')) {\n          acPath = '/sys/class/power_supply/AC0/online';\n        }\n\n        if (acPath) {\n          const file = fs.readFileSync(acPath);\n          acConnected = file.toString().trim() === '1';\n        }\n\n        if (battery_path) {\n          fs.readFile(battery_path + 'uevent', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n\n              result.isCharging = (util.getValue(lines, 'POWER_SUPPLY_STATUS', '=').toLowerCase() === 'charging');\n              result.acConnected = acConnected || result.isCharging;\n              result.voltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_NOW', '='), 10) / 1000000.0;\n              result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n              result.cycleCount = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CYCLE_COUNT', '='), 10);\n              result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL', '=', true, true), 10) / 1000.0 * (result.voltage || 1));\n              const desingedMinVoltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_MIN_DESIGN', '='), 10) / 1000000.0;\n              result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL_DESIGN', '=', true, true), 10) / 1000.0 * (desingedMinVoltage || result.voltage || 1));\n              result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_NOW', '='), 10) / 1000.0 * (result.voltage || 1));\n              if (!result.maxCapacity) {\n                result.maxCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL', '=', true, true), 10) / 1000.0;\n                result.designedCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL_DESIGN', '=', true, true), 10) / 1000.0 | result.maxCapacity;\n                result.currentCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10) / 1000.0;\n              }\n              const percent = util.getValue(lines, 'POWER_SUPPLY_CAPACITY', '=');\n              const energy = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10);\n              const power = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_POWER_NOW', '='), 10);\n              const current = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CURRENT_NOW', '='), 10);\n\n              result.percent = parseInt('0' + percent, 10);\n              if (result.maxCapacity && result.currentCapacity) {\n                result.hasBattery = true;\n                if (!percent) {\n                  result.percent = 100.0 * result.currentCapacity / result.maxCapacity;\n                }\n              }\n              if (result.isCharging) {\n                result.hasBattery = true;\n              }\n              if (energy && power) {\n                result.timeRemaining = Math.floor(energy / power * 60);\n              } else if (current && result.currentCapacity) {\n                result.timeRemaining = Math.floor(result.currentCapacity / current * 60);\n              }\n              result.type = util.getValue(lines, 'POWER_SUPPLY_TECHNOLOGY', '=');\n              result.model = util.getValue(lines, 'POWER_SUPPLY_MODEL_NAME', '=');\n              result.manufacturer = util.getValue(lines, 'POWER_SUPPLY_MANUFACTURER', '=');\n              result.serial = util.getValue(lines, 'POWER_SUPPLY_SERIAL_NUMBER', '=');\n              if (callback) { callback(result); }\n              resolve(result);\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i hw.acpi.battery hw.acpi.acline', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const batteries = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.units'), 10);\n          const percent = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.life'), 10);\n          result.hasBattery = (batteries > 0);\n          result.cycleCount = null;\n          result.isCharging = util.getValue(lines, 'hw.acpi.acline') !== '1';\n          result.acConnected = result.isCharging;\n          result.maxCapacity = null;\n          result.currentCapacity = null;\n          result.capacityUnit = 'unknown';\n          result.percent = batteries ? percent : null;\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('ioreg -n AppleSmartBattery -r | egrep \"CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage\"; pmset -g batt | grep %', function (error, stdout) {\n          if (stdout) {\n            let lines = stdout.toString().replace(/ +/g, '').replace(/\"+/g, '').replace(/-/g, '').split('\\n');\n            result.cycleCount = parseInt('0' + util.getValue(lines, 'cyclecount', '='), 10);\n            result.voltage = parseInt('0' + util.getValue(lines, 'voltage', '='), 10) / 1000.0;\n            result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n            result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawmaxcapacity', '='), 10) * (result.voltage || 1));\n            result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawcurrentcapacity', '='), 10) * (result.voltage || 1));\n            result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'DesignCapacity', '='), 10) * (result.voltage || 1));\n            result.manufacturer = 'Apple';\n            result.serial = util.getValue(lines, 'BatterySerialNumber', '=');\n            let percent = null;\n            const line = util.getValue(lines, 'internal', 'Battery');\n            let parts = line.split(';');\n            if (parts && parts[0]) {\n              let parts2 = parts[0].split('\\t');\n              if (parts2 && parts2[1]) {\n                percent = parseFloat(parts2[1].trim().replace(/%/g, ''));\n              }\n            }\n            if (parts && parts[1]) {\n              result.isCharging = (parts[1].trim() === 'charging');\n              result.acConnected = (parts[1].trim() !== 'discharging');\n            } else {\n              result.isCharging = util.getValue(lines, 'ischarging', '=').toLowerCase() === 'yes';\n              result.acConnected = result.isCharging;\n            }\n            if (result.maxCapacity && result.currentCapacity) {\n              result.hasBattery = true;\n              result.type = 'Li-ion';\n              result.percent = percent !== null ? percent : Math.round(100.0 * result.currentCapacity / result.maxCapacity);\n              if (!result.isCharging) {\n                result.timeRemaining = parseInt('0' + util.getValue(lines, 'TimeRemaining', '='), 10);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            if (data) {\n              let parts = data.results[0].split(/\\n\\s*\\n/);\n              let batteries = [];\n              const hasValue = value => /\\S/.test(value);\n              for (let i = 0; i < parts.length; i++) {\n                if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {\n                  batteries.push([]);\n                }\n                if (hasValue(parts[i])) {\n                  batteries[batteries.length - 1].push(parts[i]);\n                }\n              }\n              let designCapacities = data.results[1].split('\\r\\n').filter(e => e);\n              let fullChargeCapacities = data.results[2].split('\\r\\n').filter(e => e);\n              if (batteries.length) {\n                let first = false;\n                let additionalBatteries = [];\n                for (let i = 0; i < batteries.length; i++) {\n                  let lines = batteries[i][0].split('\\r\\n');\n                  const designedCapacity = designCapacities && designCapacities.length >= (i + 1) && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;\n                  const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= (i + 1) && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;\n                  const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);\n                  if (!first && parsed.status > 0 && parsed.status !== 10) {\n                    result.hasBattery = parsed.hasBattery;\n                    result.maxCapacity = parsed.maxCapacity;\n                    result.designedCapacity = parsed.designedCapacity;\n                    result.voltage = parsed.voltage;\n                    result.capacityUnit = parsed.capacityUnit;\n                    result.percent = parsed.percent;\n                    result.currentCapacity = parsed.currentCapacity;\n                    result.isCharging = parsed.isCharging;\n                    result.acConnected = parsed.acConnected;\n                    result.model = parsed.model;\n                    first = true;\n                  } else if (parsed.status !== -1) {\n                    additionalBatteries.push(\n                      {\n                        hasBattery: parsed.hasBattery,\n                        maxCapacity: parsed.maxCapacity,\n                        designedCapacity: parsed.designedCapacity,\n                        voltage: parsed.voltage,\n                        capacityUnit: parsed.capacityUnit,\n                        percent: parsed.percent,\n                        currentCapacity: parsed.currentCapacity,\n                        isCharging: parsed.isCharging,\n                        timeRemaining: null,\n                        acConnected: parsed.acConnected,\n                        model: parsed.model,\n                        type: '',\n                        manufacturer: '',\n                        serial: ''\n                      }\n                    );\n                  }\n                }\n                if (!first && additionalBatteries.length) {\n                  result = additionalBatteries[0];\n                  additionalBatteries.shift();\n                }\n                if (additionalBatteries.length) {\n                  result.additionalBatteries = additionalBatteries;\n                }\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n};\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 17. bluetooth\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst path = require('path');\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseBluetoothType(str) {\n  let result = '';\n\n  if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  if (str.indexOf('speaker') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('headset') >= 0) { result = 'Headset'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Computer'; }\n  if (str.indexOf('imac') >= 0) { result = 'Computer'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Tablet'; }\n  if (str.indexOf('watch') >= 0) { result = 'Watch'; }\n  if (str.indexOf('headphone') >= 0) { result = 'Headset'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseBluetoothManufacturer(str) {\n  let result = str.split(' ')[0];\n  str = str.toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Apple'; }\n  if (str.indexOf('imac') >= 0) { result = 'Apple'; }\n  if (str.indexOf('iphone') >= 0) { result = 'Apple'; }\n  if (str.indexOf('magic mouse') >= 0) { result = 'Apple'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Apple'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', '=');\n  result.manufacturer = null;\n  result.macDevice = macAddr1;\n  result.macHost = macAddr2;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = false;\n\n  return result;\n}\n\nfunction parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {\n  const result = {};\n  const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || '') + (bluetoothObject.device_name || '')).toLowerCase();\n\n  result.device = bluetoothObject.device_services || '';\n  result.name = bluetoothObject.device_name || '';\n  result.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothManufacturer(bluetoothObject.device_name || '') || '';\n  result.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || '').toLowerCase().replace(/-/g, ':');\n  result.macHost = macAddr2;\n  result.batteryPercent = bluetoothObject.device_batteryPercent || null;\n  result.type = parseBluetoothType(typeStr);\n  result.connected = bluetoothObject.device_isconnected === 'attrib_Yes' || false;\n\n  return result;\n}\n\nfunction parseWindowsBluetooth(lines) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.macDevice = null;\n  result.macHost = null;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = null;\n\n  return result;\n}\n\nfunction bluetoothDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        // get files in /var/lib/bluetooth/ recursive\n        const btFiles = util.getFilesInPath('/var/lib/bluetooth/');\n        btFiles.forEach((element) => {\n          const filename = path.basename(element);\n          const pathParts = element.split('/');\n          const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;\n          const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;\n          if (filename === 'info') {\n            const infoFile = fs.readFileSync(element, { encoding: 'utf8' }).split('\\n');\n            result.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));\n          }\n        });\n        // determine \"connected\" with hcitool con\n        try {\n          const hdicon = execSync('hcitool con').toString().toLowerCase();\n          for (let i = 0; i < result.length; i++) {\n            if (result[i].macDevice && result[i].macDevice.length > 10 && hdicon.indexOf(result[i].macDevice.toLowerCase()) >= 0) {\n              result[i].connected = true;\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPBluetoothDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_title'] && outObj.SPBluetoothDataType[0]['device_title'].length) {\n                // missing: host BT Adapter macAddr ()\n                let macAddr2 = null;\n                if (outObj.SPBluetoothDataType[0]['local_device_title'] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {\n                  macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ':');\n                }\n                outObj.SPBluetoothDataType[0]['device_title'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_connected'] && outObj.SPBluetoothDataType[0]['device_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_Yes';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_not_connected'] && outObj.SPBluetoothDataType[0]['device_not_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_not_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_No';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach((part) => {\n              if (util.getValue(part.split('\\n'), 'PNPClass', ':') === 'Bluetooth') {\n                result.push(parseWindowsBluetooth(part.split('\\n')));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _netbsd || _openbsd || _sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.bluetoothDevices = bluetoothDevices;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// cpu.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 4. CPU\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _cpu_speed = 0;\nlet _current_cpu = {\n  user: 0,\n  nice: 0,\n  system: 0,\n  idle: 0,\n  irq: 0,\n  load: 0,\n  tick: 0,\n  ms: 0,\n  currentLoad: 0,\n  currentLoadUser: 0,\n  currentLoadSystem: 0,\n  currentLoadNice: 0,\n  currentLoadIdle: 0,\n  currentLoadIrq: 0,\n  rawCurrentLoad: 0,\n  rawCurrentLoadUser: 0,\n  rawCurrentLoadSystem: 0,\n  rawCurrentLoadNice: 0,\n  rawCurrentLoadIdle: 0,\n  rawCurrentLoadIrq: 0\n};\nlet _cpus = [];\nlet _corecount = 0;\n\nconst AMDBaseFrequencies = {\n  '8346': '1.8',\n  '8347': '1.9',\n  '8350': '2.0',\n  '8354': '2.2',\n  '8356|SE': '2.4',\n  '8356': '2.3',\n  '8360': '2.5',\n  '2372': '2.1',\n  '2373': '2.1',\n  '2374': '2.2',\n  '2376': '2.3',\n  '2377': '2.3',\n  '2378': '2.4',\n  '2379': '2.4',\n  '2380': '2.5',\n  '2381': '2.5',\n  '2382': '2.6',\n  '2384': '2.7',\n  '2386': '2.8',\n  '2387': '2.8',\n  '2389': '2.9',\n  '2393': '3.1',\n  '8374': '2.2',\n  '8376': '2.3',\n  '8378': '2.4',\n  '8379': '2.4',\n  '8380': '2.5',\n  '8381': '2.5',\n  '8382': '2.6',\n  '8384': '2.7',\n  '8386': '2.8',\n  '8387': '2.8',\n  '8389': '2.9',\n  '8393': '3.1',\n  '2419EE': '1.8',\n  '2423HE': '2.0',\n  '2425HE': '2.1',\n  '2427': '2.2',\n  '2431': '2.4',\n  '2435': '2.6',\n  '2439SE': '2.8',\n  '8425HE': '2.1',\n  '8431': '2.4',\n  '8435': '2.6',\n  '8439SE': '2.8',\n  '4122': '2.2',\n  '4130': '2.6',\n  '4162EE': '1.7',\n  '4164EE': '1.8',\n  '4170HE': '2.1',\n  '4174HE': '2.3',\n  '4176HE': '2.4',\n  '4180': '2.6',\n  '4184': '2.8',\n  '6124HE': '1.8',\n  '6128HE': '2.0',\n  '6132HE': '2.2',\n  '6128': '2.0',\n  '6134': '2.3',\n  '6136': '2.4',\n  '6140': '2.6',\n  '6164HE': '1.7',\n  '6166HE': '1.8',\n  '6168': '1.9',\n  '6172': '2.1',\n  '6174': '2.2',\n  '6176': '2.3',\n  '6176SE': '2.3',\n  '6180SE': '2.5',\n  '3250': '2.5',\n  '3260': '2.7',\n  '3280': '2.4',\n  '4226': '2.7',\n  '4228': '2.8',\n  '4230': '2.9',\n  '4234': '3.1',\n  '4238': '3.3',\n  '4240': '3.4',\n  '4256': '1.6',\n  '4274': '2.5',\n  '4276': '2.6',\n  '4280': '2.8',\n  '4284': '3.0',\n  '6204': '3.3',\n  '6212': '2.6',\n  '6220': '3.0',\n  '6234': '2.4',\n  '6238': '2.6',\n  '6262HE': '1.6',\n  '6272': '2.1',\n  '6274': '2.2',\n  '6276': '2.3',\n  '6278': '2.4',\n  '6282SE': '2.6',\n  '6284SE': '2.7',\n  '6308': '3.5',\n  '6320': '2.8',\n  '6328': '3.2',\n  '6338P': '2.3',\n  '6344': '2.6',\n  '6348': '2.8',\n  '6366': '1.8',\n  '6370P': '2.0',\n  '6376': '2.3',\n  '6378': '2.4',\n  '6380': '2.5',\n  '6386': '2.8',\n  'FX|4100': '3.6',\n  'FX|4120': '3.9',\n  'FX|4130': '3.8',\n  'FX|4150': '3.8',\n  'FX|4170': '4.2',\n  'FX|6100': '3.3',\n  'FX|6120': '3.6',\n  'FX|6130': '3.6',\n  'FX|6200': '3.8',\n  'FX|8100': '2.8',\n  'FX|8120': '3.1',\n  'FX|8140': '3.2',\n  'FX|8150': '3.6',\n  'FX|8170': '3.9',\n  'FX|4300': '3.8',\n  'FX|4320': '4.0',\n  'FX|4350': '4.2',\n  'FX|6300': '3.5',\n  'FX|6350': '3.9',\n  'FX|8300': '3.3',\n  'FX|8310': '3.4',\n  'FX|8320': '3.5',\n  'FX|8350': '4.0',\n  'FX|8370': '4.0',\n  'FX|9370': '4.4',\n  'FX|9590': '4.7',\n  'FX|8320E': '3.2',\n  'FX|8370E': '3.3',\n\n  // ZEN Desktop CPUs\n  '1200': '3.1',\n  'Pro 1200': '3.1',\n  '1300X': '3.5',\n  'Pro 1300': '3.5',\n  '1400': '3.2',\n  '1500X': '3.5',\n  'Pro 1500': '3.5',\n  '1600': '3.2',\n  '1600X': '3.6',\n  'Pro 1600': '3.2',\n  '1700': '3.0',\n  'Pro 1700': '3.0',\n  '1700X': '3.4',\n  'Pro 1700X': '3.4',\n  '1800X': '3.6',\n  '1900X': '3.8',\n  '1920': '3.2',\n  '1920X': '3.5',\n  '1950X': '3.4',\n\n  // ZEN Desktop APUs\n  '200GE': '3.2',\n  'Pro 200GE': '3.2',\n  '220GE': '3.4',\n  '240GE': '3.5',\n  '3000G': '3.5',\n  '300GE': '3.4',\n  '3050GE': '3.4',\n  '2200G': '3.5',\n  'Pro 2200G': '3.5',\n  '2200GE': '3.2',\n  'Pro 2200GE': '3.2',\n  '2400G': '3.6',\n  'Pro 2400G': '3.6',\n  '2400GE': '3.2',\n  'Pro 2400GE': '3.2',\n\n  // ZEN Mobile APUs\n  'Pro 200U': '2.3',\n  '300U': '2.4',\n  '2200U': '2.5',\n  '3200U': '2.6',\n  '2300U': '2.0',\n  'Pro 2300U': '2.0',\n  '2500U': '2.0',\n  'Pro 2500U': '2.2',\n  '2600H': '3.2',\n  '2700U': '2.0',\n  'Pro 2700U': '2.2',\n  '2800H': '3.3',\n\n  // ZEN Server Processors\n  '7351': '2.4',\n  '7351P': '2.4',\n  '7401': '2.0',\n  '7401P': '2.0',\n  '7551P': '2.0',\n  '7551': '2.0',\n  '7251': '2.1',\n  '7261': '2.5',\n  '7281': '2.1',\n  '7301': '2.2',\n  '7371': '3.1',\n  '7451': '2.3',\n  '7501': '2.0',\n  '7571': '2.2',\n  '7601': '2.2',\n\n  // ZEN Embedded Processors\n  'V1500B': '2.2',\n  'V1780B': '3.35',\n  'V1202B': '2.3',\n  'V1404I': '2.0',\n  'V1605B': '2.0',\n  'V1756B': '3.25',\n  'V1807B': '3.35',\n\n  '3101': '2.1',\n  '3151': '2.7',\n  '3201': '1.5',\n  '3251': '2.5',\n  '3255': '2.5',\n  '3301': '2.0',\n  '3351': '1.9',\n  '3401': '1.85',\n  '3451': '2.15',\n\n  // ZEN+ Desktop\n  '1200|AF': '3.1',\n  '2300X': '3.5',\n  '2500X': '3.6',\n  '2600': '3.4',\n  '2600E': '3.1',\n  '1600|AF': '3.2',\n  '2600X': '3.6',\n  '2700': '3.2',\n  '2700E': '2.8',\n  'Pro 2700': '3.2',\n  '2700X': '3.7',\n  'Pro 2700X': '3.6',\n  '2920X': '3.5',\n  '2950X': '3.5',\n  '2970WX': '3.0',\n  '2990WX': '3.0',\n\n  // ZEN+ Desktop APU\n  'Pro 300GE': '3.4',\n  'Pro 3125GE': '3.4',\n  '3150G': '3.5',\n  'Pro 3150G': '3.5',\n  '3150GE': '3.3',\n  'Pro 3150GE': '3.3',\n  '3200G': '3.6',\n  'Pro 3200G': '3.6',\n  '3200GE': '3.3',\n  'Pro 3200GE': '3.3',\n  '3350G': '3.6',\n  'Pro 3350G': '3.6',\n  '3350GE': '3.3',\n  'Pro 3350GE': '3.3',\n  '3400G': '3.7',\n  'Pro 3400G': '3.7',\n  '3400GE': '3.3',\n  'Pro 3400GE': '3.3',\n\n  // ZEN+ Mobile\n  '3300U': '2.1',\n  'PRO 3300U': '2.1',\n  '3450U': '2.1',\n  '3500U': '2.1',\n  'PRO 3500U': '2.1',\n  '3500C': '2.1',\n  '3550H': '2.1',\n  '3580U': '2.1',\n  '3700U': '2.3',\n  'PRO 3700U': '2.3',\n  '3700C': '2.3',\n  '3750H': '2.3',\n  '3780U': '2.3',\n\n  // ZEN2 Desktop CPUS\n  '3100': '3.6',\n  '3300X': '3.8',\n  '3500': '3.6',\n  '3500X': '3.6',\n  '3600': '3.6',\n  'Pro 3600': '3.6',\n  '3600X': '3.8',\n  '3600XT': '3.8',\n  'Pro 3700': '3.6',\n  '3700X': '3.6',\n  '3800X': '3.9',\n  '3800XT': '3.9',\n  '3900': '3.1',\n  'Pro 3900': '3.1',\n  '3900X': '3.8',\n  '3900XT': '3.8',\n  '3950X': '3.5',\n  '3960X': '3.8',\n  '3970X': '3.7',\n  '3990X': '2.9',\n  '3945WX': '4.0',\n  '3955WX': '3.9',\n  '3975WX': '3.5',\n  '3995WX': '2.7',\n\n  // ZEN2 Desktop APUs\n  '4300GE': '3.5',\n  'Pro 4300GE': '3.5',\n  '4300G': '3.8',\n  'Pro 4300G': '3.8',\n  '4600GE': '3.3',\n  'Pro 4650GE': '3.3',\n  '4600G': '3.7',\n  'Pro 4650G': '3.7',\n  '4700GE': '3.1',\n  'Pro 4750GE': '3.1',\n  '4700G': '3.6',\n  'Pro 4750G': '3.6',\n  '4300U': '2.7',\n  '4450U': '2.5',\n  'Pro 4450U': '2.5',\n  '4500U': '2.3',\n  '4600U': '2.1',\n  'PRO 4650U': '2.1',\n  '4680U': '2.1',\n  '4600HS': '3.0',\n  '4600H': '3.0',\n  '4700U': '2.0',\n  'PRO 4750U': '1.7',\n  '4800U': '1.8',\n  '4800HS': '2.9',\n  '4800H': '2.9',\n  '4900HS': '3.0',\n  '4900H': '3.3',\n  '5300U': '2.6',\n  '5500U': '2.1',\n  '5700U': '1.8',\n\n  // ZEN2 - EPYC\n  '7232P': '3.1',\n  '7302P': '3.0',\n  '7402P': '2.8',\n  '7502P': '2.5',\n  '7702P': '2.0',\n  '7252': '3.1',\n  '7262': '3.2',\n  '7272': '2.9',\n  '7282': '2.8',\n  '7302': '3.0',\n  '7352': '2.3',\n  '7402': '2.8',\n  '7452': '2.35',\n  '7502': '2.5',\n  '7532': '2.4',\n  '7542': '2.9',\n  '7552': '2.2',\n  '7642': '2.3',\n  '7662': '2.0',\n  '7702': '2.0',\n  '7742': '2.25',\n  '7H12': '2.6',\n  '7F32': '3.7',\n  '7F52': '3.5',\n  '7F72': '3.2',\n\n  // Epyc (Milan)\n\n  '7763': '2.45',\n  '7713': '2.0',\n  '7713P': '2.0',\n  '7663': '2.0',\n  '7643': '2.3',\n  '75F3': '2.95',\n  '7543': '2.8',\n  '7543P': '2.8',\n  '7513': '2.6',\n  '7453': '2.75',\n  '74F3': '3.2',\n  '7443': '2.85',\n  '7443P': '2.85',\n  '7413': '2.65',\n  '73F3': '3.5',\n  '7343': '3.2',\n  '7313': '3.0',\n  '7313P': '3.0',\n  '72F3': '3.7',\n\n  // ZEN3\n  '5600X': '3.7',\n  '5800X': '3.8',\n  '5900X': '3.7',\n  '5950X': '3.4'\n};\n\n\nconst socketTypes = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Daughter Board',\n  4: 'ZIF Socket',\n  5: 'Replacement/Piggy Back',\n  6: 'None',\n  7: 'LIF Socket',\n  8: 'Slot 1',\n  9: 'Slot 2',\n  10: '370 Pin Socket',\n  11: 'Slot A',\n  12: 'Slot M',\n  13: '423',\n  14: 'A (Socket 462)',\n  15: '478',\n  16: '754',\n  17: '940',\n  18: '939',\n  19: 'mPGA604',\n  20: 'LGA771',\n  21: 'LGA775',\n  22: 'S1',\n  23: 'AM2',\n  24: 'F (1207)',\n  25: 'LGA1366',\n  26: 'G34',\n  27: 'AM3',\n  28: 'C32',\n  29: 'LGA1156',\n  30: 'LGA1567',\n  31: 'PGA988A',\n  32: 'BGA1288',\n  33: 'rPGA988B',\n  34: 'BGA1023',\n  35: 'BGA1224',\n  36: 'LGA1155',\n  37: 'LGA1356',\n  38: 'LGA2011',\n  39: 'FS1',\n  40: 'FS2',\n  41: 'FM1',\n  42: 'FM2',\n  43: 'LGA2011-3',\n  44: 'LGA1356-3',\n  45: 'LGA1150',\n  46: 'BGA1168',\n  47: 'BGA1234',\n  48: 'BGA1364',\n  49: 'AM4',\n  50: 'LGA1151',\n  51: 'BGA1356',\n  52: 'BGA1440',\n  53: 'BGA1515',\n  54: 'LGA3647-1',\n  55: 'SP3',\n  56: 'SP3r2',\n  57: 'LGA2066',\n  58: 'BGA1392',\n  59: 'BGA1510',\n  60: 'BGA1528',\n  61: 'LGA4189',\n  62: 'LGA1200',\n  63: 'LGA4677',\n};\n\nconst socketTypesByName = {\n  'LGA1150': 'i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430',\n  'LGA1151': 'i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400',\n  '1155': 'G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290'\n};\n\nfunction getSocketTypesByName(str) {\n  let result = '';\n  for (const key in socketTypesByName) {\n    const names = socketTypesByName[key].split(' ');\n    names.forEach(element => {\n      if (str.indexOf(element) >= 0) {\n        result = key;\n      }\n    });\n  }\n  return result;\n}\n\nfunction cpuManufacturer(str) {\n  let result = str;\n  str = str.toLowerCase();\n\n  if (str.indexOf('intel') >= 0) { result = 'Intel'; }\n  if (str.indexOf('amd') >= 0) { result = 'AMD'; }\n  if (str.indexOf('qemu') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('hygon') >= 0) { result = 'Hygon'; }\n  if (str.indexOf('centaur') >= 0) { result = 'WinChip/Via'; }\n  if (str.indexOf('vmware') >= 0) { result = 'VMware'; }\n  if (str.indexOf('Xen') >= 0) { result = 'Xen Hypervisor'; }\n  if (str.indexOf('tcg') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n\n  return result;\n}\n\nfunction cpuBrandManufacturer(res) {\n  res.brand = res.brand.replace(/\\(R\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(TM\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(C\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/CPU+/g, '').replace(/\\s+/g, ' ').trim();\n  res.manufacturer = cpuManufacturer(res.brand);\n\n  let parts = res.brand.split(' ');\n  parts.shift();\n  res.brand = parts.join(' ');\n  return res;\n}\n\nfunction getAMDSpeed(brand) {\n  let result = '0';\n  for (let key in AMDBaseFrequencies) {\n    if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {\n      let parts = key.split('|');\n      let found = 0;\n      parts.forEach(item => {\n        if (brand.indexOf(item) > -1) {\n          found++;\n        }\n      });\n      if (found === parts.length) {\n        result = AMDBaseFrequencies[key];\n      }\n    }\n  }\n  return parseFloat(result);\n}\n\n// --------------------------\n// CPU - brand, speed\n\nfunction getCpu() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const UNKNOWN = 'unknown';\n      let result = {\n        manufacturer: UNKNOWN,\n        brand: UNKNOWN,\n        vendor: '',\n        family: '',\n        model: '',\n        stepping: '',\n        revision: '',\n        voltage: '',\n        speed: 0,\n        speedMin: 0,\n        speedMax: 0,\n        governor: '',\n        cores: util.cores(),\n        physicalCores: util.cores(),\n        performanceCores: util.cores(),\n        efficiencyCores: 0,\n        processors: 1,\n        socket: '',\n        flags: '',\n        virtualization: false,\n        cache: {}\n      };\n      cpuFlags().then(flags => {\n        result.flags = flags;\n        result.virtualization = flags.indexOf('vmx') > -1 || flags.indexOf('svm') > -1;\n        if (_darwin) {\n          exec('sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily', function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            const modelline = util.getValue(lines, 'machdep.cpu.brand_string');\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            const speed = modellineParts[1] ? modellineParts[1].trim() : '0';\n            result.speed = parseFloat(speed.replace(/GHz+/g, ''));\n            let tbFrequency = util.getValue(lines, 'hw.tbfrequency') / 1000000000.0;\n            tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;\n            result.speed = result.speed === 0 ? tbFrequency : result.speed;\n\n            _cpu_speed = result.speed;\n            result = cpuBrandManufacturer(result);\n            result.speedMin = util.getValue(lines, 'hw.cpufrequency_min') ? (util.getValue(lines, 'hw.cpufrequency_min') / 1000000000.0) : result.speed;\n            result.speedMax = util.getValue(lines, 'hw.cpufrequency_max') ? (util.getValue(lines, 'hw.cpufrequency_max') / 1000000000.0) : result.speed;\n            result.vendor = util.getValue(lines, 'machdep.cpu.vendor') || 'Apple';\n            result.family = util.getValue(lines, 'machdep.cpu.family') || util.getValue(lines, 'hw.cpufamily');\n            result.model = util.getValue(lines, 'machdep.cpu.model');\n            result.stepping = util.getValue(lines, 'machdep.cpu.stepping') || util.getValue(lines, 'hw.cpusubfamily');\n            result.virtualization = true;\n            const countProcessors = util.getValue(lines, 'hw.packages');\n            const countCores = util.getValue(lines, 'hw.physicalcpu_max');\n            const countThreads = util.getValue(lines, 'hw.ncpu');\n            if (os.arch() === 'arm64') {\n              const clusters = execSync('ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type').toString().split('\\n');\n              const efficiencyCores = clusters.filter(line => line.indexOf('\"E\"') >= 0).length;\n              const performanceCores = clusters.filter(line => line.indexOf('\"P\"') >= 0).length;\n              result.socket = 'SOC';\n              result.efficiencyCores = efficiencyCores;\n              result.performanceCores = performanceCores;\n            }\n            if (countProcessors) {\n              result.processors = parseInt(countProcessors) || 1;\n            }\n            if (countCores && countThreads) {\n              result.cores = parseInt(countThreads) || util.cores();\n              result.physicalCores = parseInt(countCores) || util.cores();\n            }\n            cpuCache().then((res) => {\n              result.cache = res;\n              resolve(result);\n            });\n          });\n        }\n        if (_linux) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; lscpu; echo -n \"Governor: \"; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n            }\n            modelline = util.getValue(lines, 'model name') || modelline;\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            result.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = Math.round(parseFloat(util.getValue(lines, 'cpu min mhz').replace(/,/g, '.')) / 10.0) / 100;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'cpu max mhz').replace(/,/g, '.')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'vendor id'));\n\n            result.family = util.getValue(lines, 'cpu family');\n            result.model = util.getValue(lines, 'model:');\n            result.stepping = util.getValue(lines, 'stepping');\n            result.revision = util.getValue(lines, 'cpu revision');\n            result.cache.l1d = util.getValue(lines, 'l1d cache');\n            if (result.cache.l1d) { result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1d.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l1i = util.getValue(lines, 'l1i cache');\n            if (result.cache.l1i) { result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1i.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l2 = util.getValue(lines, 'l2 cache');\n            if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l2.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l3 = util.getValue(lines, 'l3 cache');\n            if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l3.indexOf('K') !== -1 ? 1024 : 1)); }\n\n            const threadsPerCore = util.getValue(lines, 'thread(s) per core') || '1';\n            const processors = util.getValue(lines, 'socket(s)') || '1';\n            let threadsPerCoreInt = parseInt(threadsPerCore, 10); // threads per code (normally only for performance cores)\n            let processorsInt = parseInt(processors, 10) || 1;  // number of sockets /  processor units in machine (normally 1)\n            const coresPerSocket = parseInt(util.getValue(lines, 'core(s) per socket'), 10); // number of cores (e.g. 16 on i12900)\n            result.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result.cores / threadsPerCoreInt;\n            result.performanceCores = threadsPerCoreInt > 1 ? result.cores - result.physicalCores : result.cores;\n            result.efficiencyCores = threadsPerCoreInt > 1 ? result.cores - (threadsPerCoreInt * result.performanceCores) : 0;\n            result.processors = processorsInt;\n            result.governor = util.getValue(lines, 'governor') || '';\n\n            // Test Raspberry\n            if (result.vendor === 'ARM') {\n              const linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n              const rPIRevision = util.decodePiCpuinfo(linesRpi);\n              if (rPIRevision.model.toLowerCase().indexOf('raspberry') >= 0) {\n                result.family = result.manufacturer;\n                result.manufacturer = rPIRevision.manufacturer;\n                result.brand = rPIRevision.processor;\n                result.revision = rPIRevision.revisionCode;\n                result.socket = 'SOC';\n              }\n            }\n\n            // socket type\n            let lines2 = [];\n            exec('export LC_ALL=C; dmidecode t 4 2>/dev/null | grep \"Upgrade: Socket\"; unset LC_ALL', function (error2, stdout2) {\n              lines2 = stdout2.toString().split('\\n');\n              if (lines2 && lines2.length) {\n                result.socket = util.getValue(lines2, 'Upgrade').replace('Socket', '').trim() || result.socket;\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL', function (error, stdout) {\n            let cache = [];\n            if (!error) {\n              const data = stdout.toString().split('# dmidecode');\n              const processor = data.length > 1 ? data[1] : '';\n              cache = data.length > 2 ? data[2].split('Cache Information') : [];\n\n              lines = processor.split('\\n');\n            }\n            result.brand = modelline.split('@')[0].trim();\n            result.speed = modelline.split('@')[1] ? parseFloat(modelline.split('@')[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = result.speed;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'max speed').replace(/Mhz/g, '')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'manufacturer'));\n            let sig = util.getValue(lines, 'signature');\n            sig = sig.split(',');\n            for (let i = 0; i < sig.length; i++) {\n              sig[i] = sig[i].trim();\n            }\n            result.family = util.getValue(sig, 'Family', ' ', true);\n            result.model = util.getValue(sig, 'Model', ' ', true);\n            result.stepping = util.getValue(sig, 'Stepping', ' ', true);\n            result.revision = '';\n            const voltage = parseFloat(util.getValue(lines, 'voltage'));\n            result.voltage = isNaN(voltage) ? '' : voltage.toFixed(2);\n            for (let i = 0; i < cache.length; i++) {\n              lines = cache[i].split('\\n');\n              let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n              cacheType = cacheType.length ? cacheType[0] : '';\n              const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n              let size = parseInt(sizeParts[0], 10);\n              const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n              size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n              if (cacheType) {\n                if (cacheType === 'l1') {\n                  result.cache[cacheType + 'd'] = size / 2;\n                  result.cache[cacheType + 'i'] = size / 2;\n                } else {\n                  result.cache[cacheType] = size;\n                }\n              }\n            }\n            // socket type\n            result.socket = util.getValue(lines, 'Upgrade').replace('Socket', '').trim();\n            // # threads / # cores\n            const threadCount = util.getValue(lines, 'thread count').trim();\n            const coreCount = util.getValue(lines, 'core count').trim();\n            if (coreCount && threadCount) {\n              result.cores = parseInt(threadCount, 10);\n              result.physicalCores = parseInt(coreCount, 10);\n            }\n            resolve(result);\n          });\n        }\n        if (_sunos) {\n          resolve(result);\n        }\n        if (_windows) {\n          try {\n            const workload = [];\n            workload.push(util.powerShell('Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl'));\n            workload.push(util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl'));\n            workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n\n            Promise.all(\n              workload\n            ).then((data) => {\n              let lines = data[0].split('\\r\\n');\n              let name = util.getValue(lines, 'name', ':') || '';\n              if (name.indexOf('@') >= 0) {\n                result.brand = name.split('@')[0].trim();\n                result.speed = name.split('@')[1] ? parseFloat(name.split('@')[1].trim()) : 0;\n                _cpu_speed = result.speed;\n              } else {\n                result.brand = name.trim();\n                result.speed = 0;\n              }\n              result = cpuBrandManufacturer(result);\n              result.revision = util.getValue(lines, 'revision', ':');\n              result.cache.l1d = 0;\n              result.cache.l1i = 0;\n              result.cache.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.cache.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2, 10) * 1024; }\n              if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3, 10) * 1024; }\n              result.vendor = util.getValue(lines, 'manufacturer', ':');\n              result.speedMax = Math.round(parseFloat(util.getValue(lines, 'maxclockspeed', ':').replace(/,/g, '.')) / 10.0) / 100;\n              if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n                result.speed = getAMDSpeed(result.brand);\n              }\n              if (result.speed === 0) {\n                result.speed = result.speedMax;\n              }\n              result.speedMin = result.speed;\n\n              let description = util.getValue(lines, 'description', ':').split(' ');\n              for (let i = 0; i < description.length; i++) {\n                if (description[i].toLowerCase().startsWith('family') && (i + 1) < description.length && description[i + 1]) {\n                  result.family = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('model') && (i + 1) < description.length && description[i + 1]) {\n                  result.model = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('stepping') && (i + 1) < description.length && description[i + 1]) {\n                  result.stepping = description[i + 1];\n                }\n              }\n              // socket type\n              const socketId = util.getValue(lines, 'UpgradeMethod', ':');\n              if (socketTypes[socketId]) {\n                result.socket = socketTypes[socketId];\n              }\n              const socketByName = getSocketTypesByName(name);\n              if (socketByName) {\n                result.socket = socketByName;\n              }\n              // # threads / # cores\n              const countProcessors = util.countLines(lines, 'Caption');\n              const countThreads = util.getValue(lines, 'NumberOfLogicalProcessors', ':');\n              const countCores = util.getValue(lines, 'NumberOfCores', ':');\n              if (countProcessors) {\n                result.processors = parseInt(countProcessors) || 1;\n              }\n              if (countCores && countThreads) {\n                result.cores = parseInt(countThreads) || util.cores();\n                result.physicalCores = parseInt(countCores) || util.cores();\n              }\n              if (countProcessors > 1) {\n                result.cores = result.cores * countProcessors;\n                result.physicalCores = result.physicalCores * countProcessors;\n              }\n              const parts = data[1].split(/\\n\\s*\\n/);\n              parts.forEach(function (part) {\n                lines = part.split('\\r\\n');\n                const cacheType = util.getValue(lines, 'CacheType');\n                const level = util.getValue(lines, 'Level');\n                const installedSize = util.getValue(lines, 'InstalledSize');\n                // L1 Instructions\n                if (level === '3' && cacheType === '3') {\n                  result.cache.l1i = parseInt(installedSize, 10);\n                }\n                // L1 Data\n                if (level === '3' && cacheType === '4') {\n                  result.cache.l1d = parseInt(installedSize, 10);\n                }\n                // L1 all\n                if (level === '3' && cacheType === '5' && !result.cache.l1i && !result.cache.l1d) {\n                  result.cache.l1i = parseInt(installedSize, 10) / 2;\n                  result.cache.l1d = parseInt(installedSize, 10) / 2;\n                }\n              });\n              const hyperv = data[2] ? data[2].toString().toLowerCase() : '';\n              result.virtualization = hyperv.indexOf('true') !== -1;\n\n              resolve(result);\n            });\n          } catch (e) {\n            resolve(result);\n          }\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// CPU - Processor Data\n\nfunction cpu(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getCpu().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.cpu = cpu;\n\n// --------------------------\n// CPU - current speed - in GHz\n\nfunction getCpuCurrentSpeedSync() {\n\n  let cpus = os.cpus();\n  let minFreq = 999999999;\n  let maxFreq = 0;\n  let avgFreq = 0;\n  let cores = [];\n\n  if (cpus && cpus.length) {\n    for (let i in cpus) {\n      if ({}.hasOwnProperty.call(cpus, i)) {\n        let freq = cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1000 : cpus[i].speed / 10;\n        avgFreq = avgFreq + freq;\n        if (freq > maxFreq) { maxFreq = freq; }\n        if (freq < minFreq) { minFreq = freq; }\n        cores.push(parseFloat(freq.toFixed(2)));\n      }\n    }\n    avgFreq = avgFreq / cpus.length;\n    return {\n      min: parseFloat(minFreq.toFixed(2)),\n      max: parseFloat(maxFreq.toFixed(2)),\n      avg: parseFloat((avgFreq).toFixed(2)),\n      cores: cores\n    };\n  } else {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0,\n      cores: cores\n    };\n  }\n}\n\nfunction cpuCurrentSpeed(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getCpuCurrentSpeedSync();\n      if (result.avg === 0 && _cpu_speed !== 0) {\n        const currCpuSpeed = parseFloat(_cpu_speed);\n        result = {\n          min: currCpuSpeed,\n          max: currCpuSpeed,\n          avg: currCpuSpeed,\n          cores: []\n        };\n      }\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.cpuCurrentSpeed = cpuCurrentSpeed;\n\n// --------------------------\n// CPU - temperature\n// if sensors are installed\n\nfunction cpuTemperature(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        main: null,\n        cores: [],\n        max: null,\n        socket: [],\n        chipset: null\n      };\n      if (_linux) {\n        // CPU Chipset, Socket\n        try {\n          const cmd = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo \"-----\"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';\n          const parts = execSync(cmd).toString().split('-----\\n');\n          if (parts.length === 2) {\n            const lines = parts[0].split('\\n');\n            const lines2 = parts[1].split('\\n');\n            for (let i = 0; i < lines.length; i++) {\n              const line = lines[i].trim();\n              if (line.startsWith('acpi') && lines2[i]) {\n                result.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);\n              }\n              if (line.startsWith('pch') && lines2[i]) {\n                result.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;\n              }\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in \"$mon\"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat \"$label\")___$(cat \"$value\"); fi; done; done;';\n        try {\n          exec(cmd, function (error, stdout) {\n            stdout = stdout.toString();\n            const tdiePos = stdout.toLowerCase().indexOf('tdie');\n            if (tdiePos !== -1) {\n              stdout = stdout.substring(tdiePos);\n            }\n            let lines = stdout.split('\\n');\n            lines.forEach(line => {\n              const parts = line.split('___');\n              const label = parts[0];\n              const value = parts.length > 1 && parts[1] ? parts[1] : '0';\n              if (value && (label === undefined || (label && label.toLowerCase().startsWith('core')))) {\n                result.cores.push(Math.round(parseInt(value, 10) / 100) / 10);\n              } else if (value && label && result.main === null && (label.toLowerCase().indexOf('package') >= 0 || label.toLowerCase().indexOf('physical') >= 0)) {\n                result.main = Math.round(parseInt(value, 10) / 100) / 10;\n              }\n            });\n\n            if (result.cores.length > 0) {\n              if (result.main === null) {\n                result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n              }\n              let maxtmp = Math.max.apply(Math, result.cores);\n              result.max = (maxtmp > result.main) ? maxtmp : result.main;\n            }\n            if (result.main !== null) {\n              if (result.max === null) {\n                result.max = result.main;\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n              return;\n            }\n            exec('sensors', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                let tdieTemp = null;\n                let newSectionStarts = true;\n                let section = '';\n                lines.forEach(function (line) {\n                  // determine section\n                  if (line.trim() === '') {\n                    newSectionStarts = true;\n                  } else if (newSectionStarts) {\n                    if (line.trim().toLowerCase().startsWith('acpi')) { section = 'acpi'; }\n                    if (line.trim().toLowerCase().startsWith('pch')) { section = 'pch'; }\n                    if (line.trim().toLowerCase().startsWith('core')) { section = 'core'; }\n                    newSectionStarts = false;\n                  }\n                  let regex = /[+-]([^]*)/g;\n                  let temps = line.match(regex);\n                  let firstPart = line.split(':')[0].toUpperCase();\n                  if (section === 'acpi') {\n                    // socket temp\n                    if (firstPart.indexOf('TEMP') !== -1) {\n                      result.socket.push(parseFloat(temps));\n                    }\n                  } else if (section === 'pch') {\n                    // chipset temp\n                    if (firstPart.indexOf('TEMP') !== -1 && !result.chipset) {\n                      result.chipset = parseFloat(temps);\n                    }\n                  }\n                  // cpu temp\n                  if (firstPart.indexOf('PHYSICAL') !== -1 || firstPart.indexOf('PACKAGE') !== -1) {\n                    result.main = parseFloat(temps);\n                  }\n                  if (firstPart.indexOf('CORE ') !== -1) {\n                    result.cores.push(parseFloat(temps));\n                  }\n                  if (firstPart.indexOf('TDIE') !== -1 && tdieTemp === null) {\n                    tdieTemp = parseFloat(temps);\n                  }\n                });\n                if (result.cores.length > 0) {\n                  result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n                  let maxtmp = Math.max.apply(Math, result.cores);\n                  result.max = (maxtmp > result.main) ? maxtmp : result.main;\n                } else {\n                  if (result.main === null && tdieTemp !== null) {\n                    result.main = tdieTemp;\n                    result.max = tdieTemp;\n                  }\n                }\n                if (result.main !== null || result.max !== null) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                  return;\n                }\n              }\n              fs.stat('/sys/class/thermal/thermal_zone0/temp', function (err) {\n                if (err === null) {\n                  fs.readFile('/sys/class/thermal/thermal_zone0/temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0) {\n                        result.main = parseFloat(lines[0]) / 1000.0;\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  exec('/opt/vc/bin/vcgencmd measure_temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0 && lines[0].indexOf('=')) {\n                        result.main = parseFloat(lines[0].split('=')[1]);\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              });\n            });\n          });\n        } catch (er) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl dev.cpu | grep temp', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            let sum = 0;\n            lines.forEach(function (line) {\n              const parts = line.split(':');\n              if (parts.length > 1) {\n                const temp = parseFloat(parts[1].replace(',', '.'));\n                if (temp > result.max) { result.max = temp; }\n                sum = sum + temp;\n                result.cores.push(temp);\n              }\n            });\n            if (result.cores.length) {\n              result.main = Math.round(sum / result.cores.length * 100) / 100;\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        /*\n        let osxTemp = null;\n        try {\n          //osxTemp = require('osx-temperature-sensor');\n        } catch (er) {\n          osxTemp = null;\n        }\n        if (osxTemp) {\n          //result = osxTemp.cpuTemperature();\n          // round to 2 digits\n          if (result.main) {\n            result.main = Math.round(result.main * 100) / 100;\n          }\n          if (result.max) {\n            result.max = Math.round(result.max * 100) / 100;\n          }\n          if (result.cores && result.cores.length) {\n            for (let i = 0; i < result.cores.length; i++) {\n              result.cores[i] = Math.round(result.cores[i] * 100) / 100;\n            }\n          }\n        }\n\n        if (callback) { callback(result); }\n        resolve(result);\n        */\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace \"root/wmi\" | Select CurrentTemperature').then((stdout, error) => {\n            if (!error) {\n              let sum = 0;\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                let value = (parseInt(line, 10) - 2732) / 10;\n                if (!isNaN(value)) {\n                  sum = sum + value;\n                  if (value > result.max) { result.max = value; }\n                  result.cores.push(value);\n                }\n              });\n              if (result.cores.length) {\n                result.main = sum / result.cores.length;\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuTemperature = cpuTemperature;\n\n// --------------------------\n// CPU Flags\n\nfunction cpuFlags(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_windows) {\n        try {\n          exec('reg query \"HKEY_LOCAL_MACHINE\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\" /v FeatureSet', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let flag_hex = stdout.split('0x').pop().trim();\n              let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);\n              let flag_bin = '0'.repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;\n              // empty flags are the reserved fields in the CPUID feature bit list\n              // as found on wikipedia:\n              // https://en.wikipedia.org/wiki/CPUID\n              let all_flags = [\n                'fpu', 'vme', 'de', 'pse', 'tsc', 'msr', 'pae', 'mce', 'cx8', 'apic',\n                '', 'sep', 'mtrr', 'pge', 'mca', 'cmov', 'pat', 'pse-36', 'psn', 'clfsh',\n                '', 'ds', 'acpi', 'mmx', 'fxsr', 'sse', 'sse2', 'ss', 'htt', 'tm', 'ia64', 'pbe'\n              ];\n              for (let f = 0; f < all_flags.length; f++) {\n                if (flag_bin[f] === '1' && all_flags[f] !== '') {\n                  result += ' ' + all_flags[f];\n                }\n              }\n              result = result.trim().toLowerCase();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        try {\n\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                if (line.split(':')[0].toUpperCase().indexOf('FLAGS') !== -1) {\n                  result = line.split(':')[1].trim().toLowerCase();\n                }\n              });\n            }\n            if (!result) {\n              fs.readFile('/proc/cpuinfo', function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  result = util.getValue(lines, 'features', ':', true).toLowerCase();\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let flags = [];\n          if (!error) {\n            let parts = stdout.toString().split('\\tFlags:');\n            const lines = parts.length > 1 ? parts[1].split('\\tVersion:')[0].split('\\n') : [];\n            lines.forEach(function (line) {\n              let flag = (line.indexOf('(') ? line.split('(')[0].toLowerCase() : '').trim().replace(/\\t/g, '');\n              if (flag) {\n                flags.push(flag);\n              }\n            });\n          }\n          result = flags.join(' ').trim().toLowerCase();\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl machdep.cpu.features', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0 && lines[0].indexOf('machdep.cpu.features:') !== -1) {\n              result = lines[0].split(':')[1].trim().toLowerCase();\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.cpuFlags = cpuFlags;\n\n// --------------------------\n// CPU Cache\n\nfunction cpuCache(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        l1d: null,\n        l1i: null,\n        l2: null,\n        l3: null,\n      };\n      if (_linux) {\n        try {\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                let parts = line.split(':');\n                if (parts[0].toUpperCase().indexOf('L1D CACHE') !== -1) {\n                  result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L1I CACHE') !== -1) {\n                  result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L2 CACHE') !== -1) {\n                  result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L3 CACHE') !== -1) {\n                  result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let cache = [];\n          if (!error) {\n            const data = stdout.toString();\n            cache = data.split('Cache Information');\n            cache.shift();\n          }\n          for (let i = 0; i < cache.length; i++) {\n            const lines = cache[i].split('\\n');\n            let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n            cacheType = cacheType.length ? cacheType[0] : '';\n            const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n            let size = parseInt(sizeParts[0], 10);\n            const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n            size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n            if (cacheType) {\n              if (cacheType === 'l1') {\n                result.cache[cacheType + 'd'] = size / 2;\n                result.cache[cacheType + 'i'] = size / 2;\n              } else {\n                result.cache[cacheType] = size;\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let parts = line.split(':');\n              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.l1d = 0;\n              result.l1i = 0;\n              result.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.l2) { result.l2 = parseInt(result.l2, 10) * 1024; }\n              if (result.l3) { result.l3 = parseInt(result.l3, 10) * 1024; }\n            }\n            util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl').then((stdout, error) => {\n              if (!error) {\n                const parts = stdout.split(/\\n\\s*\\n/);\n                parts.forEach(function (part) {\n                  const lines = part.split('\\r\\n');\n                  const cacheType = util.getValue(lines, 'CacheType');\n                  const level = util.getValue(lines, 'Level');\n                  const installedSize = util.getValue(lines, 'InstalledSize');\n                  // L1 Instructions\n                  if (level === '3' && cacheType === '3') {\n                    result.l1i = parseInt(installedSize, 10);\n                  }\n                  // L1 Data\n                  if (level === '3' && cacheType === '4') {\n                    result.l1d = parseInt(installedSize, 10);\n                  }\n                  // L1 all\n                  if (level === '3' && cacheType === '5' && !result.l1i && !result.l1d) {\n                    result.l1i = parseInt(installedSize, 10) / 2;\n                    result.l1d = parseInt(installedSize, 10) / 2;\n                  }\n                });\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuCache = cpuCache;\n\n// --------------------------\n// CPU - current load - in %\n\nfunction getLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let loads = os.loadavg().map(function (x) { return x / util.cores(); });\n      let avgLoad = parseFloat((Math.max.apply(Math, loads)).toFixed(2));\n      let result = {};\n\n      let now = Date.now() - _current_cpu.ms;\n      if (now >= 200) {\n        _current_cpu.ms = Date.now();\n        const cpus = os.cpus();\n        let totalUser = 0;\n        let totalSystem = 0;\n        let totalNice = 0;\n        let totalIrq = 0;\n        let totalIdle = 0;\n        let cores = [];\n        _corecount = (cpus && cpus.length) ? cpus.length : 0;\n\n        for (let i = 0; i < _corecount; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIdle += cpu.idle;\n          totalIrq += cpu.irq;\n          let tmpTick = (_cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0);\n          let tmpLoad = (_cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0);\n          let tmpUser = (_cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0);\n          let tmpSystem = (_cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0);\n          let tmpNice = (_cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0);\n          let tmpIdle = (_cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0);\n          let tmpIrq = (_cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0);\n          _cpus[i] = cpu;\n          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;\n          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;\n          _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;\n          _cpus[i].load = (_cpus[i].totalLoad - tmpLoad);\n          _cpus[i].loadUser = (_cpus[i].user - tmpUser);\n          _cpus[i].loadSystem = (_cpus[i].sys - tmpSystem);\n          _cpus[i].loadNice = (_cpus[i].nice - tmpNice);\n          _cpus[i].loadIdle = (_cpus[i].idle - tmpIdle);\n          _cpus[i].loadIrq = (_cpus[i].irq - tmpIrq);\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;\n        let totalLoad = totalUser + totalSystem + totalNice + totalIrq;\n        let currentTick = totalTick - _current_cpu.tick;\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,\n          currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,\n          currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,\n          currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,\n          currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,\n          currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,\n          rawCurrentLoad: (totalLoad - _current_cpu.load),\n          rawCurrentLoadUser: (totalUser - _current_cpu.user),\n          rawCurrentLoadSystem: (totalSystem - _current_cpu.system),\n          rawCurrentLoadNice: (totalNice - _current_cpu.nice),\n          rawCurrentLoadIdle: (totalIdle - _current_cpu.idle),\n          rawCurrentLoadIrq: (totalIrq - _current_cpu.irq),\n          cpus: cores\n        };\n        _current_cpu = {\n          user: totalUser,\n          nice: totalNice,\n          system: totalSystem,\n          idle: totalIdle,\n          irq: totalIrq,\n          tick: totalTick,\n          load: totalLoad,\n          ms: _current_cpu.ms,\n          currentLoad: result.currentLoad,\n          currentLoadUser: result.currentLoadUser,\n          currentLoadSystem: result.currentLoadSystem,\n          currentLoadNice: result.currentLoadNice,\n          currentLoadIdle: result.currentLoadIdle,\n          currentLoadIrq: result.currentLoadIrq,\n          rawCurrentLoad: result.rawCurrentLoad,\n          rawCurrentLoadUser: result.rawCurrentLoadUser,\n          rawCurrentLoadSystem: result.rawCurrentLoadSystem,\n          rawCurrentLoadNice: result.rawCurrentLoadNice,\n          rawCurrentLoadIdle: result.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: result.rawCurrentLoadIrq,\n        };\n      } else {\n        let cores = [];\n        for (let i = 0; i < _corecount; i++) {\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: _current_cpu.currentLoad,\n          currentLoadUser: _current_cpu.currentLoadUser,\n          currentLoadSystem: _current_cpu.currentLoadSystem,\n          currentLoadNice: _current_cpu.currentLoadNice,\n          currentLoadIdle: _current_cpu.currentLoadIdle,\n          currentLoadIrq: _current_cpu.currentLoadIrq,\n          rawCurrentLoad: _current_cpu.rawCurrentLoad,\n          rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,\n          rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,\n          rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,\n          rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,\n          cpus: cores\n        };\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction currentLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.currentLoad = currentLoad;\n\n// --------------------------\n// PS - full load\n// since bootup\n\nfunction getFullLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const cpus = os.cpus();\n      let totalUser = 0;\n      let totalSystem = 0;\n      let totalNice = 0;\n      let totalIrq = 0;\n      let totalIdle = 0;\n\n      let result = 0;\n\n      if (cpus && cpus.length) {\n        for (let i = 0, len = cpus.length; i < len; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIrq += cpu.irq;\n          totalIdle += cpu.idle;\n        }\n        let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;\n        result = (totalTicks - totalIdle) / totalTicks * 100.0;\n\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction fullLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getFullLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.fullLoad = fullLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// docker.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. Docker\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst DockerSocket = require('./dockerSocket');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\n\nlet _docker_container_stats = {};\nlet _docker_socket;\nlet _docker_last_read = 0;\n\n\n// --------------------------\n// get containers (parameter all: get also inactive/exited containers)\n\nfunction dockerInfo(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const result = {};\n\n      _docker_socket.getInfo((data) => {\n        result.id = data.ID;\n        result.containers = data.Containers;\n        result.containersRunning = data.ContainersRunning;\n        result.containersPaused = data.ContainersPaused;\n        result.containersStopped = data.ContainersStopped;\n        result.images = data.Images;\n        result.driver = data.Driver;\n        result.memoryLimit = data.MemoryLimit;\n        result.swapLimit = data.SwapLimit;\n        result.kernelMemory = data.KernelMemory;\n        result.cpuCfsPeriod = data.CpuCfsPeriod;\n        result.cpuCfsQuota = data.CpuCfsQuota;\n        result.cpuShares = data.CPUShares;\n        result.cpuSet = data.CPUSet;\n        result.ipv4Forwarding = data.IPv4Forwarding;\n        result.bridgeNfIptables = data.BridgeNfIptables;\n        result.bridgeNfIp6tables = data.BridgeNfIp6tables;\n        result.debug = data.Debug;\n        result.nfd = data.NFd;\n        result.oomKillDisable = data.OomKillDisable;\n        result.ngoroutines = data.NGoroutines;\n        result.systemTime = data.SystemTime;\n        result.loggingDriver = data.LoggingDriver;\n        result.cgroupDriver = data.CgroupDriver;\n        result.nEventsListener = data.NEventsListener;\n        result.kernelVersion = data.KernelVersion;\n        result.operatingSystem = data.OperatingSystem;\n        result.osType = data.OSType;\n        result.architecture = data.Architecture;\n        result.ncpu = data.NCPU;\n        result.memTotal = data.MemTotal;\n        result.dockerRootDir = data.DockerRootDir;\n        result.httpProxy = data.HttpProxy;\n        result.httpsProxy = data.HttpsProxy;\n        result.noProxy = data.NoProxy;\n        result.name = data.Name;\n        result.labels = data.Labels;\n        result.experimentalBuild = data.ExperimentalBuild;\n        result.serverVersion = data.ServerVersion;\n        result.clusterStore = data.ClusterStore;\n        result.clusterAdvertise = data.ClusterAdvertise;\n        result.defaultRuntime = data.DefaultRuntime;\n        result.liveRestoreEnabled = data.LiveRestoreEnabled;\n        result.isolation = data.Isolation;\n        result.initBinary = data.InitBinary;\n        result.productLicense = data.ProductLicense;\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.dockerInfo = dockerInfo;\n\nfunction dockerImages(all, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listImages(all, data => {\n        let dockerImages = {};\n        try {\n          dockerImages = data;\n          if (dockerImages && Object.prototype.toString.call(dockerImages) === '[object Array]' && dockerImages.length > 0) {\n\n            dockerImages.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerImagesInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerImagesInspect(imageID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      imageID = imageID || '';\n      if (typeof imageID !== 'string') {\n        return resolve();\n      }\n      const imageIDSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(imageID, true)).trim();\n      if (imageIDSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.inspectImage(imageIDSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              container: data.Container,\n              comment: data.Comment,\n              os: data.Os,\n              architecture: data.Architecture,\n              parent: data.Parent,\n              dockerVersion: data.DockerVersion,\n              size: data.Size,\n              sharedSize: payload.SharedSize,\n              virtualSize: data.VirtualSize,\n              author: data.Author,\n              created: data.Created ? Math.round(new Date(data.Created).getTime() / 1000) : 0,\n              containerConfig: data.ContainerConfig ? data.ContainerConfig : {},\n              graphDriver: data.GraphDriver ? data.GraphDriver : {},\n              repoDigests: data.RepoDigests ? data.RepoDigests : {},\n              repoTags: data.RepoTags ? data.RepoTags : {},\n              config: data.Config ? data.Config : {},\n              rootFS: data.RootFS ? data.RootFS : {},\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerImages = dockerImages;\n\nfunction dockerContainers(all, callback) {\n\n  function inContainers(containers, id) {\n    let filtered = containers.filter(obj => {\n      /**\n       * @namespace\n       * @property {string}  Id\n       */\n      return (obj.Id && (obj.Id === id));\n    });\n    return (filtered.length > 0);\n  }\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listContainers(all, data => {\n        let docker_containers = {};\n        try {\n          docker_containers = data;\n          if (docker_containers && Object.prototype.toString.call(docker_containers) === '[object Array]' && docker_containers.length > 0) {\n            // GC in _docker_container_stats\n            for (let key in _docker_container_stats) {\n              if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n                if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n              }\n            }\n\n            docker_containers.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerContainerInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          // GC in _docker_container_stats\n          for (let key in _docker_container_stats) {\n            if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n              if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerContainerInspect(containerID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve();\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerIdSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              name: payload.Name,\n              image: payload.Image,\n              imageID: payload.ImageID,\n              command: payload.Command,\n              created: payload.Created,\n              started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1000) : 0,\n              finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? Math.round(new Date(data.State.FinishedAt).getTime() / 1000) : 0,\n              createdAt: data.Created ? data.Created : '',\n              startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : '',\n              finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? data.State.FinishedAt : '',\n              state: payload.State,\n              restartCount: data.RestartCount || 0,\n              platform: data.Platform || '',\n              driver: data.Driver || '',\n              ports: payload.Ports,\n              mounts: payload.Mounts,\n              // hostconfig: payload.HostConfig,\n              // network: payload.NetworkSettings\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerContainers = dockerContainers;\n\n// --------------------------\n// helper functions for calculation of docker stats\n\nfunction docker_calcCPUPercent(cpu_stats, precpu_stats) {\n  /**\n   * @namespace\n   * @property {object}  cpu_usage\n   * @property {number}  cpu_usage.total_usage\n   * @property {number}  system_cpu_usage\n   * @property {object}  cpu_usage\n   * @property {Array}  cpu_usage.percpu_usage\n   */\n\n  if (!_windows) {\n    let cpuPercent = 0.0;\n    // calculate the change for the cpu usage of the container in between readings\n    let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n    // calculate the change for the entire system between readings\n    let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;\n\n    if (systemDelta > 0.0 && cpuDelta > 0.0) {\n      // calculate the change for the cpu usage of the container in between readings\n      if (precpu_stats.online_cpus) {\n        cpuPercent = (cpuDelta / systemDelta) * precpu_stats.online_cpus * 100.0;\n      }\n      else {\n        cpuPercent = (cpuDelta / systemDelta) * cpu_stats.cpu_usage.percpu_usage.length * 100.0;\n      }\n    }\n\n    return cpuPercent;\n  } else {\n    let nanoSecNow = util.nanoSeconds();\n    let cpuPercent = 0.0;\n    if (_docker_last_read > 0) {\n      let possIntervals = (nanoSecNow - _docker_last_read); //  / 100 * os.cpus().length;\n      let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n      if (possIntervals > 0) {\n        cpuPercent = 100.0 * intervalsUsed / possIntervals;\n      }\n    }\n    _docker_last_read = nanoSecNow;\n    return cpuPercent;\n  }\n}\n\nfunction docker_calcNetworkIO(networks) {\n  let rx;\n  let wx;\n  for (let key in networks) {\n    // skip loop if the property is from prototype\n    if (!{}.hasOwnProperty.call(networks, key)) { continue; }\n\n    /**\n     * @namespace\n     * @property {number}  rx_bytes\n     * @property {number}  tx_bytes\n     */\n    let obj = networks[key];\n    rx = +obj.rx_bytes;\n    wx = +obj.tx_bytes;\n  }\n  return {\n    rx,\n    wx\n  };\n}\n\nfunction docker_calcBlockIO(blkio_stats) {\n  let result = {\n    r: 0,\n    w: 0\n  };\n\n  /**\n   * @namespace\n   * @property {Array}  io_service_bytes_recursive\n   */\n  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === '[object Array]' && blkio_stats.io_service_bytes_recursive.length > 0) {\n    blkio_stats.io_service_bytes_recursive.forEach(function (element) {\n      /**\n       * @namespace\n       * @property {string}  op\n       * @property {number}  value\n       */\n\n      if (element.op && element.op.toLowerCase() === 'read' && element.value) {\n        result.r += element.value;\n      }\n      if (element.op && element.op.toLowerCase() === 'write' && element.value) {\n        result.w += element.value;\n      }\n    });\n  }\n  return result;\n}\n\nfunction dockerContainerStats(containerIDs, callback) {\n\n  let containerArray = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(containerIDs) && !callback) {\n        callback = containerIDs;\n        containerArray = ['*'];\n      } else {\n        containerIDs = containerIDs || '*';\n        if (typeof containerIDs !== 'string') {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        let containerIDsSanitized = '';\n        containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;\n        containerIDsSanitized.__proto__.replace = util.stringReplace;\n        containerIDsSanitized.__proto__.trim = util.stringTrim;\n\n        containerIDsSanitized = containerIDs;\n        containerIDsSanitized = containerIDsSanitized.trim();\n        if (containerIDsSanitized !== '*') {\n          containerIDsSanitized = '';\n          const s = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerIDs, true)).trim();\n          for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n            if (s[i] !== undefined) {\n              s[i].__proto__.toLowerCase = util.stringToLower;\n              const sl = s[i].toLowerCase();\n              if (sl && sl[0] && !sl[1]) {\n                containerIDsSanitized = containerIDsSanitized + sl[0];\n              }\n            }\n          }\n        }\n\n        containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, '|');\n        containerArray = containerIDsSanitized.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (containerArray.length && containerArray[0].trim() === '*') {\n        containerArray = [];\n        dockerContainers().then(allContainers => {\n          for (let container of allContainers) {\n            containerArray.push(container.id);\n          }\n          if (containerArray.length) {\n            dockerContainerStats(containerArray.join(',')).then(result => {\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      } else {\n        for (let containerID of containerArray) {\n          workload.push(dockerContainerStatsSingle(containerID.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\n// --------------------------\n// container stats (for one container)\n\nfunction dockerContainerStatsSingle(containerID) {\n  containerID = containerID || '';\n  let result = {\n    id: containerID,\n    memUsage: 0,\n    memLimit: 0,\n    memPercent: 0,\n    cpuPercent: 0,\n    pids: 0,\n    netIO: {\n      rx: 0,\n      wx: 0\n    },\n    blockIO: {\n      r: 0,\n      w: 0\n    },\n    restartCount: 0,\n    cpuStats: {},\n    precpuStats: {},\n    memoryStats: {},\n    networks: {},\n  };\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (containerID) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerID, dataInspect => {\n          try {\n            _docker_socket.getStats(containerID, data => {\n              try {\n                let stats = data;\n\n                if (!stats.message) {\n                  result.memUsage = (stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0);\n                  result.memLimit = (stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0);\n                  result.memPercent = (stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100.0 : 0);\n                  result.cpuPercent = (stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0);\n                  result.pids = (stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0);\n                  result.restartCount = (dataInspect.RestartCount ? dataInspect.RestartCount : 0);\n                  if (stats.networks) { result.netIO = docker_calcNetworkIO(stats.networks); }\n                  if (stats.blkio_stats) { result.blockIO = docker_calcBlockIO(stats.blkio_stats); }\n                  result.cpuStats = (stats.cpu_stats ? stats.cpu_stats : {});\n                  result.precpuStats = (stats.precpu_stats ? stats.precpu_stats : {});\n                  result.memoryStats = (stats.memory_stats ? stats.memory_stats : {});\n                  result.networks = (stats.networks ? stats.networks : {});\n                }\n              } catch (err) {\n                util.noop();\n              }\n              // }\n              resolve(result);\n            });\n          } catch (err) {\n            util.noop();\n          }\n        });\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerStats = dockerContainerStats;\n\n// --------------------------\n// container processes (for one container)\n\nfunction dockerContainerProcesses(containerID, callback) {\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve(result);\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getProcesses(containerIdSanitized, data => {\n          /**\n           * @namespace\n           * @property {Array}  Titles\n           * @property {Array}  Processes\n           **/\n          try {\n            if (data && data.Titles && data.Processes) {\n              let titles = data.Titles.map(function (value) {\n                return value.toUpperCase();\n              });\n              let pos_pid = titles.indexOf('PID');\n              let pos_ppid = titles.indexOf('PPID');\n              let pos_pgid = titles.indexOf('PGID');\n              let pos_vsz = titles.indexOf('VSZ');\n              let pos_time = titles.indexOf('TIME');\n              let pos_elapsed = titles.indexOf('ELAPSED');\n              let pos_ni = titles.indexOf('NI');\n              let pos_ruser = titles.indexOf('RUSER');\n              let pos_user = titles.indexOf('USER');\n              let pos_rgroup = titles.indexOf('RGROUP');\n              let pos_group = titles.indexOf('GROUP');\n              let pos_stat = titles.indexOf('STAT');\n              let pos_rss = titles.indexOf('RSS');\n              let pos_command = titles.indexOf('COMMAND');\n\n              data.Processes.forEach(process => {\n                result.push({\n                  pidHost: (pos_pid >= 0 ? process[pos_pid] : ''),\n                  ppid: (pos_ppid >= 0 ? process[pos_ppid] : ''),\n                  pgid: (pos_pgid >= 0 ? process[pos_pgid] : ''),\n                  user: (pos_user >= 0 ? process[pos_user] : ''),\n                  ruser: (pos_ruser >= 0 ? process[pos_ruser] : ''),\n                  group: (pos_group >= 0 ? process[pos_group] : ''),\n                  rgroup: (pos_rgroup >= 0 ? process[pos_rgroup] : ''),\n                  stat: (pos_stat >= 0 ? process[pos_stat] : ''),\n                  time: (pos_time >= 0 ? process[pos_time] : ''),\n                  elapsed: (pos_elapsed >= 0 ? process[pos_elapsed] : ''),\n                  nice: (pos_ni >= 0 ? process[pos_ni] : ''),\n                  rss: (pos_rss >= 0 ? process[pos_rss] : ''),\n                  vsz: (pos_vsz >= 0 ? process[pos_vsz] : ''),\n                  command: (pos_command >= 0 ? process[pos_command] : '')\n                });\n              });\n            }\n          } catch (err) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerProcesses = dockerContainerProcesses;\n\nfunction dockerVolumes(callback) {\n\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      _docker_socket.listVolumes((data) => {\n        let dockerVolumes = {};\n        try {\n          dockerVolumes = data;\n          if (dockerVolumes && dockerVolumes.Volumes && Object.prototype.toString.call(dockerVolumes.Volumes) === '[object Array]' && dockerVolumes.Volumes.length > 0) {\n\n            dockerVolumes.Volumes.forEach(function (element) {\n\n              result.push({\n                name: element.Name,\n                driver: element.Driver,\n                labels: element.Labels,\n                mountpoint: element.Mountpoint,\n                options: element.Options,\n                scope: element.Scope,\n                created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1000) : 0,\n              });\n            });\n            if (callback) { callback(result); }\n            resolve(result);\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerVolumes = dockerVolumes;\n\nfunction dockerAll(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      dockerContainers(true).then(result => {\n        if (result && Object.prototype.toString.call(result) === '[object Array]' && result.length > 0) {\n          let l = result.length;\n          result.forEach(function (element) {\n            dockerContainerStats(element.id).then((res) => {\n              // include stats in array\n              element.memUsage = res[0].memUsage;\n              element.memLimit = res[0].memLimit;\n              element.memPercent = res[0].memPercent;\n              element.cpuPercent = res[0].cpuPercent;\n              element.pids = res[0].pids;\n              element.netIO = res[0].netIO;\n              element.blockIO = res[0].blockIO;\n              element.cpuStats = res[0].cpuStats;\n              element.precpuStats = res[0].precpuStats;\n              element.memoryStats = res[0].memoryStats;\n              element.networks = res[0].networks;\n\n              dockerContainerProcesses(element.id).then(processes => {\n                element.processes = processes;\n\n                l -= 1;\n                if (l === 0) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n              // all done??\n            });\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerAll = dockerAll;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// dockerSockets.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. DockerSockets\n// ----------------------------------------------------------------------------------\n\nconst net = require('net');\nconst isWin = require('os').type() === 'Windows_NT';\nconst socketPath = isWin ? '//./pipe/docker_engine' : '/var/run/docker.sock';\n\nclass DockerSocket {\n\n  getInfo(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/info HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  listImages(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/images/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  inspectImage(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/images/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listContainers(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/containers/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  getStats(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getInspect(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getProcesses(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listVolumes(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/volumes HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n}\n\nmodule.exports = DockerSocket;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst fs = require('fs');\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromiseSave = util.promisifySave(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _fs_speed = {};\nlet _disk_io = {};\n\n// --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n\n  let macOsDisks = [];\n  let osMounts = [];\n\n  function getmacOsFsType(fs) {\n    if (!fs.startsWith('/')) { return 'NFS'; }\n    const parts = fs.split('/');\n    const fsShort = parts[parts.length - 1];\n    const macOsDisksSingle = macOsDisks.filter(item => item.indexOf(fsShort) >= 0);\n    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf('APFS') >= 0) { return 'APFS'; }\n    return 'HFS';\n  }\n\n  function isLinuxTmpFs(fs) {\n    const linuxTmpFileSystems = ['rootfs', 'unionfs', 'squashfs', 'cramfs', 'initrd', 'initramfs', 'devtmpfs', 'tmpfs', 'udev', 'devfs', 'specfs', 'type', 'appimaged'];\n    let result = false;\n    linuxTmpFileSystems.forEach(linuxFs => {\n      if (fs.toLowerCase().indexOf(linuxFs) >= 0) { result = true; }\n    });\n    return result;\n  }\n\n  function filterLines(stdout) {\n    let lines = stdout.toString().split('\\n');\n    if (stdout.toString().toLowerCase().indexOf('filesystem')) {\n      let removeLines = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i].toLowerCase().startsWith('filesystem')) {\n          removeLines = i;\n        }\n      }\n      for (let i = 0; i < removeLines; i++) {\n        lines.shift();\n      }\n    }\n    return lines;\n  }\n\n  function parseDf(lines) {\n    let data = [];\n    lines.forEach(function (line) {\n      if (line !== '') {\n        line = line.replace(/ +/g, ' ').split(' ');\n        if (line && ((line[0].startsWith('/')) || (line[6] && line[6] === '/') || (line[0].indexOf('/') > 0) || (line[0].indexOf(':') === 1) || !_darwin && !isLinuxTmpFs(line[1]))) {\n          const fs = line[0];\n          const fsType = ((_linux || _freebsd || _openbsd || _netbsd) ? line[1] : getmacOsFsType(line[0]));\n          const size = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[2] : line[1])) * 1024;\n          const used = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[3] : line[2])) * 1024;\n          const available = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[4] : line[3])) * 1024;\n          const use = parseFloat((100.0 * (used / (used + available))).toFixed(2));\n          let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs] || false : null;\n          line.splice(0, (_linux || _freebsd || _openbsd || _netbsd) ? 6 : 5);\n          const mount = line.join(' ');\n          if (!data.find(el => (el.fs === fs && el.type === fsType))) {\n            data.push({\n              fs,\n              type: fsType,\n              size,\n              used,\n              available,\n              use,\n              mount,\n              rw\n            });\n          }\n        }\n      }\n    });\n    return data;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = '';\n        macOsDisks = [];\n        osMounts = {};\n        if (_darwin) {\n          cmd = 'df -kP';\n          try {\n            macOsDisks = execSync('diskutil list').toString().split('\\n').filter(line => {\n              return !line.startsWith('/') && line.indexOf(':') > 0;\n            });\n            execSync('mount').toString().split('\\n').filter(line => {\n              return line.startsWith('/');\n            }).forEach((line) => {\n              osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n            });\n          } catch (e) {\n            util.noop();\n          }\n        }\n        if (_linux) {\n          cmd = 'df -lkPTx squashfs';\n          execSync('cat /proc/mounts 2>/dev/null').toString().split('\\n').filter(line => {\n            return line.startsWith('/');\n          }).forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('rw') >= 0;\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'df -lkPT';\n          execSync('mount').toString().split('\\n').forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n          });\n        }\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          let lines = filterLines(stdout);\n          data = parseDf(lines);\n          if (!error || data.length) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('df -kPT', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = filterLines(stdout);\n                data = parseDf(lines);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        try {\n          // util.wmic('logicaldisk get Caption,FileSystem,FreeSpace,Size').then((stdout) => {\n          util.powerShell('Get-CimInstance Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const size = util.toInt(util.getValue(lines, 'size', ':'));\n                const free = util.toInt(util.getValue(lines, 'freespace', ':'));\n                const caption = util.getValue(lines, 'caption', ':');\n                const rwValue = util.getValue(lines, 'access', ':');\n                const rw = rwValue ? (util.toInt(rwValue) !== 1) : null;\n                if (size) {\n                  data.push({\n                    fs: caption,\n                    type: util.getValue(lines, 'filesystem', ':'),\n                    size,\n                    used: size - free,\n                    available: free,\n                    use: parseFloat(((100.0 * (size - free)) / size).toFixed(2)),\n                    mount: caption,\n                    rw\n                  });\n                }\n              });\n            }\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize;\n\n// --------------------------\n// FS - open files count\n\nfunction fsOpenFiles(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = {\n        max: null,\n        allocated: null,\n        available: null\n      };\n      if (_freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = 'sysctl -i kern.maxfiles kern.num_files kern.open_files';\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.max = parseInt(util.getValue(lines, 'kern.maxfiles', ':'), 10);\n            result.allocated = parseInt(util.getValue(lines, 'kern.num_files', ':'), 10) || parseInt(util.getValue(lines, 'kern.open_files', ':'), 10);\n            result.available = result.max - result.allocated;\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        fs.readFile('/proc/sys/fs/file-nr', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines[0]) {\n              const parts = lines[0].replace(/\\s+/g, ' ').split(' ');\n              if (parts.length === 3) {\n                result.allocated = parseInt(parts[0], 10);\n                result.available = parseInt(parts[1], 10);\n                result.max = parseInt(parts[2], 10);\n                if (!result.available) { result.available = result.max - result.allocated; }\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            fs.readFile('/proc/sys/fs/file-max', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                if (lines[0]) {\n                  result.max = parseInt(lines[0], 10);\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.fsOpenFiles = fsOpenFiles;\n\n// --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n        if (parts.length > 1) {\n          if (!devices[i]) {\n            devices[i] = {\n              name: '',\n              identifier: '',\n              type: 'disk',\n              fsType: '',\n              mount: '',\n              size: 0,\n              physical: 'HDD',\n              uuid: '',\n              label: '',\n              model: '',\n              serial: '',\n              removable: false,\n              protocol: '',\n              group: '',\n              device: ''\n            };\n          }\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) { devices[i].identifier = parts[1]; }\n          if ('DEVICENODE' === parts[0]) { devices[i].name = parts[1]; }\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) { devices[i].label = parts[1]; }\n          }\n          if ('PROTOCOL' === parts[0]) { devices[i].protocol = parts[1]; }\n          if ('DISKSIZE' === parts[0]) { devices[i].size = parseBytes(parts[1]); }\n          if ('FILESYSTEMPERSONALITY' === parts[0]) { devices[i].fsType = parts[1]; }\n          if ('MOUNTPOINT' === parts[0]) { devices[i].mount = parts[1]; }\n          if ('VOLUMEUUID' === parts[0]) { devices[i].uuid = parts[1]; }\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'CD/DVD'; }\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'SSD'; }\n          if ('VIRTUAL' === parts[0]) { devices[i].type = 'virtual'; }\n          if ('REMOVABLEMEDIA' === parts[0]) { devices[i].removable = (parts[1] === 'Removable'); }\n          if ('PARTITIONTYPE' === parts[0]) { devices[i].type = 'part'; }\n          if ('DEVICE/MEDIANAME' === parts[0]) { devices[i].model = parts[1]; }\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n\n  lines.filter(line => line !== '').forEach((line) => {\n    try {\n      line = decodeURIComponent(line.replace(/\\\\x/g, '%'));\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n      let disk = JSON.parse(line);\n      data.push({\n        'name': disk.name,\n        'type': disk.type,\n        'fsType': disk.fsType,\n        'mount': disk.mountpoint,\n        'size': parseInt(disk.size),\n        'physical': (disk.type === 'disk' ? (disk.rota === '0' ? 'SSD' : 'HDD') : (disk.type === 'rom' ? 'CD/DVD' : '')),\n        'uuid': disk.uuid,\n        'label': disk.label,\n        'model': (disk.model || '').trim(),\n        'serial': disk.serial,\n        'removable': disk.rm === '1',\n        'protocol': disk.tran,\n        'group': disk.group || '',\n      });\n    } catch (e) {\n      util.noop();\n    }\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction decodeMdabmData(lines) {\n  const raid = util.getValue(lines, 'md_level', '=');\n  const label = util.getValue(lines, 'md_name', '='); // <- get label info\n  const uuid = util.getValue(lines, 'md_uuid', '='); // <- get uuid info\n  const members = [];\n  lines.forEach(line => {\n    if (line.toLowerCase().startsWith('md_device_dev') && line.toLowerCase().indexOf('/dev/') > 0) {\n      members.push(line.split('/dev/')[1]);\n    }\n  });\n  return {\n    raid,\n    label,\n    uuid,\n    members\n  };\n}\n\nfunction raidMatchLinux(data) {\n  // for all block devices of type \"raid%\"\n  let result = data;\n  try {\n    data.forEach(element => {\n      if (element.type.startsWith('raid')) {\n        const lines = execSync(`mdadm --export --detail /dev/${element.name}`).toString().split('\\n');\n        const mdData = decodeMdabmData(lines);\n\n        element.label = mdData.label; // <- assign label info\n        element.uuid = mdData.uuid; // <- assign uuid info\n\n        if (mdData.members && mdData.members.length && mdData.raid === element.type) {\n          result = result.map(blockdevice => {\n            if (blockdevice.fsType === 'linux_raid_member' && mdData.members.indexOf(blockdevice.name) >= 0) {\n              blockdevice.group = element.name;\n            }\n            return blockdevice;\n          });\n        }\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesLinux(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push(element.name);\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesLinux(data) {\n  let result = data;\n  try {\n    const devices = getDevicesLinux(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element)) {\n            blockdevice.device = '/dev/' + element;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesMac(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push({ name: element.name, model: element.model, device: element.name });\n    }\n    if (element.type.startsWith('virtual')) {\n      let device = '';\n      result.forEach(e => {\n        if (e.model === element.model) {\n          device = e.device;\n        }\n      });\n      if (device) {\n        result.push({ name: element.name, model: element.model, device });\n      }\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesMac(data) {\n  let result = data;\n  try {\n    const devices = getDevicesMac(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk') || blockdevice.type.startsWith('virtual')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element.name)) {\n            blockdevice.device = element.device;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesWin(diskDrives) {\n  const result = [];\n  diskDrives.forEach(element => {\n    const lines = element.split('\\r\\n');\n    const device = util.getValue(lines, 'DeviceID', ':');\n    let partitions = element.split('@{DeviceID=');\n    if (partitions.length > 1) {\n      partitions = partitions.slice(1);\n      partitions.forEach(partition => {\n        result.push({ name: partition.split(';')[0].toUpperCase(), device });\n      });\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesWin(data, diskDrives) {\n  const devices = getDevicesWin(diskDrives);\n  data.map(element => {\n    const filteresDevices = devices.filter((e) => { return e.name === element.name.toUpperCase(); });\n    if (filteresDevices.length > 0) {\n      element.device = filteresDevices[0].device;\n    }\n    return element;\n  });\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString()\n    .replace(/NAME=/g, '{\"name\":')\n    .replace(/FSTYPE=/g, ',\"fsType\":')\n    .replace(/TYPE=/g, ',\"type\":')\n    .replace(/SIZE=/g, ',\"size\":')\n    .replace(/MOUNTPOINT=/g, ',\"mountpoint\":')\n    .replace(/UUID=/g, ',\"uuid\":')\n    .replace(/ROTA=/g, ',\"rota\":')\n    .replace(/RO=/g, ',\"ro\":')\n    .replace(/RM=/g, ',\"rm\":')\n    .replace(/TRAN=/g, ',\"tran\":')\n    .replace(/SERIAL=/g, ',\"serial\":')\n    .replace(/LABEL=/g, ',\"label\":')\n    .replace(/MODEL=/g, ',\"model\":')\n    .replace(/OWNER=/g, ',\"owner\":')\n    .replace(/GROUP=/g, ',\"group\":')\n    .replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n            data = raidMatchLinux(data);\n            data = matchDevicesLinux(data);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n                data = raidMatchLinux(data);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        exec('diskutil info -all', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            // parse lines into temp array of devices\n            data = parseDevices(lines);\n            data = matchDevicesMac(data);\n          }\n          if (callback) {\n            callback(data);\n          }\n          resolve(data);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        let drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n        try {\n          // util.wmic('logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value').then((stdout, error) => {\n          // util.powerShell('Get-CimInstance Win32_logicaldisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl').then((stdout, error) => {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl'));\n          workload.push(util.powerShell('Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L=\\'Partitions\\'; E={$_.GetRelated(\\'Win32_DiskPartition\\').GetRelated(\\'Win32_LogicalDisk\\') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl'));\n          util.promiseAll(\n            workload\n          ).then((res) => {\n            let logicalDisks = res.results[0].toString().split(/\\n\\s*\\n/);\n            let diskDrives = res.results[1].toString().split(/\\n\\s*\\n/);\n            logicalDisks.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              let drivetype = util.getValue(lines, 'drivetype', ':');\n              if (drivetype) {\n                data.push({\n                  name: util.getValue(lines, 'name', ':'),\n                  identifier: util.getValue(lines, 'caption', ':'),\n                  type: 'disk',\n                  fsType: util.getValue(lines, 'filesystem', ':').toLowerCase(),\n                  mount: util.getValue(lines, 'caption', ':'),\n                  size: util.getValue(lines, 'size', ':'),\n                  physical: (drivetype >= 0 && drivetype <= 6) ? drivetypes[drivetype] : drivetypes[0],\n                  uuid: util.getValue(lines, 'volumeserialnumber', ':'),\n                  label: util.getValue(lines, 'volumename', ':'),\n                  model: '',\n                  serial: util.getValue(lines, 'volumeserialnumber', ':'),\n                  removable: drivetype === '2',\n                  protocol: '',\n                  group: '',\n                  device: ''\n                });\n              }\n            });\n            // match devices\n            data = matchDevicesWin(data, diskDrives);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        // will follow\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n\n    });\n  });\n}\n\nexports.blockDevices = blockDevices;\n\n// --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: null,\n    wx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = null;\n    _fs_speed.wx_sec = null;\n    _fs_speed.tx_sec = null;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n  return result;\n}\n\nfunction fsStats(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: null,\n        wx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let rx = 0;\n      let wx = 0;\n      if ((_fs_speed && !_fs_speed.ms) || (_fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500)) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk -r 2>/dev/null | grep /', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) { fs_filter.push(line[0]); }\n                }\n              });\n\n              let output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: null,\n    wIO_sec: null,\n    tIO_sec: null,\n    rWaitTime: 0,\n    wWaitTime: 0,\n    tWaitTime: 0,\n    rWaitPercent: null,\n    wWaitPercent: null,\n    tWaitPercent: null,\n    ms: 0\n  };\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    result.rWaitPercent = (result.rWaitTime - _disk_io.rWaitTime) * 100 / (result.ms);\n    result.wWaitPercent = (result.wWaitTime - _disk_io.wWaitTime) * 100 / (result.ms);\n    result.tWaitPercent = (result.tWaitTime - _disk_io.tWaitTime) * 100 / (result.ms);\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = result.rWaitPercent;\n    _disk_io.wWaitPercent = result.wWaitPercent;\n    _disk_io.tWaitPercent = result.tWaitPercent;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = null;\n    _disk_io.wIO_sec = null;\n    _disk_io.tIO_sec = null;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = null;\n    _disk_io.wWaitPercent = null;\n    _disk_io.tWaitPercent = null;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n  return result;\n}\n\nfunction disksIO(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        return resolve(null);\n      }\n      if (_sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: null,\n        wIO_sec: null,\n        tIO_sec: null,\n        rWaitTime: 0,\n        wWaitTime: 0,\n        tWaitTime: 0,\n        rWaitPercent: null,\n        wWaitPercent: null,\n        tWaitPercent: null,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n      let rWaitTime = 0;\n      let wWaitTime = 0;\n      let tWaitTime = 0;\n\n      if ((_disk_io && !_disk_io.ms) || (_disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500)) {\n        if (_linux || _freebsd || _openbsd || _netbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/ //' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = 'for mount in `lsblk 2>/dev/null | grep \" disk \" | sed \"s/[]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n\n          exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) { return; }\n\n                // sum r/wIO of all disks to compute all disks IO\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n                rWaitTime += parseInt(stats[3]);\n                wWaitTime += parseInt(stats[7]);\n                tWaitTime += parseInt(stats[10]);\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n        result.rWaitTime = _disk_io.rWaitTime;\n        result.wWaitTime = _disk_io.wWaitTime;\n        result.tWaitTime = _disk_io.tWaitTime;\n        result.rWaitPercent = _disk_io.rWaitPercent;\n        result.wWaitPercent = _disk_io.wWaitPercent;\n        result.tWaitPercent = _disk_io.tWaitPercent;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n\n  function getVendorFromModel(model) {\n    const diskManufacturers = [\n      { pattern: 'WESTERN.*', manufacturer: 'Western Digital' },\n      { pattern: '^WDC.*', manufacturer: 'Western Digital' },\n      { pattern: 'WD.*', manufacturer: 'Western Digital' },\n      { pattern: 'TOSHIBA.*', manufacturer: 'Toshiba' },\n      { pattern: 'HITACHI.*', manufacturer: 'Hitachi' },\n      { pattern: '^IC.*', manufacturer: 'Hitachi' },\n      { pattern: '^HTS.*', manufacturer: 'Hitachi' },\n      { pattern: 'SANDISK.*', manufacturer: 'SanDisk' },\n      { pattern: 'KINGSTON.*', manufacturer: 'Kingston Technology' },\n      { pattern: '^SONY.*', manufacturer: 'Sony' },\n      { pattern: 'TRANSCEND.*', manufacturer: 'Transcend' },\n      { pattern: 'SAMSUNG.*', manufacturer: 'Samsung' },\n      { pattern: '^ST(?!I\\\\ ).*', manufacturer: 'Seagate' },\n      { pattern: '^STI\\\\ .*', manufacturer: 'SimpleTech' },\n      { pattern: '^D...-.*', manufacturer: 'IBM' },\n      { pattern: '^IBM.*', manufacturer: 'IBM' },\n      { pattern: '^FUJITSU.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MP.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MK.*', manufacturer: 'Toshiba' },\n      { pattern: 'MAXTO.*', manufacturer: 'Maxtor' },\n      { pattern: 'PIONEER.*', manufacturer: 'Pioneer' },\n      { pattern: 'PHILIPS.*', manufacturer: 'Philips' },\n      { pattern: 'QUANTUM.*', manufacturer: 'Quantum Technology' },\n      { pattern: 'FIREBALL.*', manufacturer: 'Quantum Technology' },\n      { pattern: '^VBOX.*', manufacturer: 'VirtualBox' },\n      { pattern: 'CORSAIR.*', manufacturer: 'Corsair Components' },\n      { pattern: 'CRUCIAL.*', manufacturer: 'Crucial' },\n      { pattern: 'ECM.*', manufacturer: 'ECM' },\n      { pattern: 'INTEL.*', manufacturer: 'INTEL' },\n      { pattern: 'EVO.*', manufacturer: 'Samsung' },\n      { pattern: 'APPLE.*', manufacturer: 'Apple' },\n    ];\n\n    let result = '';\n    if (model) {\n      model = model.toUpperCase();\n      diskManufacturers.forEach((manufacturer) => {\n        const re = RegExp(manufacturer.pattern);\n        if (re.test(model)) { result = manufacturer.manufacturer; }\n      });\n    }\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const commitResult = res => {\n        for (let i = 0; i < res.length; i++) {\n          delete res[i].BSDName;\n        }\n        if (callback) {\n          callback(res);\n        }\n        resolve(res);\n      };\n\n      let result = [];\n      let cmd = '';\n\n      if (_linux) {\n        let cmdFullSmart = '';\n\n        exec('export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            try {\n              const out = stdout.toString().trim();\n              let devices = [];\n              try {\n                const outJSON = JSON.parse(out);\n                if (outJSON && {}.hasOwnProperty.call(outJSON, 'blockdevices')) {\n                  devices = outJSON.blockdevices.filter(item => { return (item.type === 'disk') && item.size > 0 && (item.model !== null || (item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf('/ram') !== 0 && item.path.indexOf('/loop') !== 0 && item['disc-max'] && item['disc-max'] !== 0)); });\n                }\n              } catch (e) {\n                // fallback to older version of lsblk\n                const out2 = execSync('export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL').toString();\n                let lines = blkStdoutToObject(out2).split('\\n');\n                const data = parseBlk(lines);\n                devices = data.filter(item => { return (item.type === 'disk') && item.size > 0 && ((item.model !== null && item.model !== '') || (item.mount === '' && item.label === '' && item.fsType === '')); });\n              }\n              devices.forEach((device) => {\n                let mediumType = '';\n                const BSDName = '/dev/' + device.name;\n                const logical = device.name;\n                try {\n                  mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational 2>/dev/null').toString().split('\\n')[0];\n                } catch (e) {\n                  util.noop();\n                }\n                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : '';\n                if (interfaceType === 'NVME') {\n                  mediumType = '2';\n                  interfaceType = 'PCIe';\n                }\n                result.push({\n                  device: BSDName,\n                  type: (mediumType === '0' ? 'SSD' : (mediumType === '1' ? 'HD' : (mediumType === '2' ? 'NVMe' : (device.model && device.model.indexOf('SSD') > -1 ? 'SSD' : (device.model && device.model.indexOf('NVM') > -1 ? 'NVMe' : 'HD'))))),\n                  name: device.model || '',\n                  vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ''),\n                  size: device.size || 0,\n                  bytesPerSector: null,\n                  totalCylinders: null,\n                  totalHeads: null,\n                  totalSectors: null,\n                  totalTracks: null,\n                  tracksPerCylinder: null,\n                  sectorsPerTrack: null,\n                  firmwareRevision: device.rev ? device.rev.trim() : '',\n                  serialNum: device.serial ? device.serial.trim() : '',\n                  interfaceType: interfaceType,\n                  smartStatus: 'unknown',\n                  temperature: null,\n                  BSDName: BSDName\n                });\n                cmd += `printf \"\\n${BSDName}|\"; smartctl -H ${BSDName} | grep overall;`;\n                cmdFullSmart += `${cmdFullSmart ? 'printf \",\";' : ''}smartctl -a -j ${BSDName};`;\n              });\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // check S.M.A.R.T. status\n          if (cmdFullSmart) {\n            exec(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              try {\n                const data = JSON.parse(`[${stdout}]`);\n                data.forEach(disk => {\n                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];\n\n                  for (let i = 0; i < result.length; i++) {\n                    if (result[i].BSDName === diskBSDName) {\n                      result[i].smartStatus = (disk.smart_status.passed ? 'Ok' : (disk.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (disk.temperature && disk.temperature.current) {\n                        result[i].temperature = disk.temperature.current;\n                      }\n                      result[i].smartData = disk;\n                    }\n                  }\n                });\n                commitResult(result);\n              } catch (e) {\n                if (cmd) {\n                  cmd = cmd + 'printf \"\\n\"';\n                  exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                    let lines = stdout.toString().split('\\n');\n                    lines.forEach(line => {\n                      if (line) {\n                        let parts = line.split('|');\n                        if (parts.length === 2) {\n                          let BSDName = parts[0];\n                          parts[1] = parts[1].trim();\n                          let parts2 = parts[1].split(':');\n                          if (parts2.length === 2) {\n                            parts2[1] = parts2[1].trim();\n                            let status = parts2[1].toLowerCase();\n                            for (let i = 0; i < result.length; i++) {\n                              if (result[i].BSDName === BSDName) {\n                                result[i].smartStatus = (status === 'passed' ? 'Ok' : (status === 'failed!' ? 'Predicted Failure' : 'unknown'));\n                              }\n                            }\n                          }\n                        }\n                      }\n                    });\n                    commitResult(result);\n                  });\n                } else {\n                  commitResult(result);\n                }\n              }\n            });\n          } else {\n            commitResult(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            // split by type:\n            let lines = stdout.toString().split('\\n');\n            let linesSATA = [];\n            let linesNVMe = [];\n            let linesUSB = [];\n            let dataType = 'SATA';\n            lines.forEach(line => {\n              if (line === 'NVMExpress:') { dataType = 'NVMe'; }\n              else if (line === 'USB:') { dataType = 'USB'; }\n              else if (line === 'SATA/SATA Express:') { dataType = 'SATA'; }\n              else if (dataType === 'SATA') { linesSATA.push(line); }\n              else if (dataType === 'NVMe') { linesNVMe.push(line); }\n              else if (dataType === 'USB') { linesUSB.push(line); }\n            });\n            try {\n              // Serial ATA Drives\n              let devices = linesSATA.join('\\n').split(' Physical Interconnect: ');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = 'InterfaceType: ' + device;\n                let lines = device.split('\\n');\n                const mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n                const sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()) || util.getValue(lines, 'Manufacturer', ':', true),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n\n            // NVME Drives\n            try {\n              let devices = linesNVMe.join('\\n').split('\\n\\n          Capacity:');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                let lines = device.split('\\n');\n                const linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                const sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            // USB Drives\n            try {\n              let devices = linesUSB.join('\\n').replaceAll('Media:\\n ', 'Model:').split('\\n\\n          Product ID:');\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\n');\n                const sizeStr = util.getValue(lines, 'Capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'USB',\n                      name: util.getValue(lines, 'Model', ':', true).trim().replaceAll(':', ''),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: 'USB',\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            if (cmd) {\n              cmd = cmd + 'printf \"\\n\"';\n              exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(line => {\n                  if (line) {\n                    let parts = line.split('|');\n                    if (parts.length === 2) {\n                      let BSDName = parts[0];\n                      parts[1] = parts[1].trim();\n                      let parts2 = parts[1].split(':');\n                      if (parts2.length === 2) {\n                        parts2[1] = parts2[1].trim();\n                        let status = parts2[1].toLowerCase();\n                        for (let i = 0; i < result.length; i++) {\n                          if (result[i].BSDName === BSDName) {\n                            result[i].smartStatus = (status === 'not supported' ? 'not supported' : (status === 'verified' ? 'Ok' : (status === 'failing' ? 'Predicted Failure' : 'unknown')));\n                          }\n                        }\n                      }\n                    }\n                  }\n                });\n                for (let i = 0; i < result.length; i++) {\n                  delete result[i].BSDName;\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              for (let i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          }\n        });\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl'));\n          workload.push(util.powerShell('Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl'));\n          if (util.smartMonToolsInstalled()) {\n            try {\n              const smartDev = JSON.parse(execSync('smartctl --scan -j'));\n              if (smartDev && smartDev.devices && smartDev.devices.length > 0) {\n                smartDev.devices.forEach((dev) => {\n                  workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let devices = data.results[0].toString().split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const status = util.getValue(lines, 'Status', ':').trim().toLowerCase();\n              if (size) {\n                result.push({\n                  device: util.getValue(lines, 'DeviceId', ':'),  // changed from PNPDeviceId to DeviceID (be be able to match devices)\n                  type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                  name: util.getValue(lines, 'Caption', ':'),\n                  vendor: getVendorFromModel(util.getValue(lines, 'Caption', ':', true).trim()),\n                  size: parseInt(size),\n                  bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', ':')),\n                  totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', ':')),\n                  totalHeads: parseInt(util.getValue(lines, 'TotalHeads', ':')),\n                  totalSectors: parseInt(util.getValue(lines, 'TotalSectors', ':')),\n                  totalTracks: parseInt(util.getValue(lines, 'TotalTracks', ':')),\n                  tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', ':')),\n                  sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', ':')),\n                  firmwareRevision: util.getValue(lines, 'FirmwareRevision', ':').trim(),\n                  serialNum: util.getValue(lines, 'SerialNumber', ':').trim(),\n                  interfaceType: util.getValue(lines, 'InterfaceType', ':').trim(),\n                  smartStatus: (status === 'ok' ? 'Ok' : (status === 'degraded' ? 'Degraded' : (status === 'pred fail' ? 'Predicted Failure' : 'Unknown'))),\n                  temperature: null,\n                });\n              }\n            });\n            devices = data.results[1].split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n              const name = util.getValue(lines, 'FriendlyName', ':').trim().replace('Msft ', 'Microsoft');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const model = util.getValue(lines, 'Model', ':').trim();\n              const interfaceType = util.getValue(lines, 'BusType', ':').trim();\n              let mediaType = util.getValue(lines, 'MediaType', ':').trim();\n              if (mediaType === '3' || mediaType === 'HDD') { mediaType = 'HD'; }\n              if (mediaType === '4') { mediaType = 'SSD'; }\n              if (mediaType === '5') { mediaType = 'SCM'; }\n              if (mediaType === 'Unspecified' && (model.toLowerCase().indexOf('virtual') > -1 || model.toLowerCase().indexOf('vbox') > -1)) { mediaType = 'Virtual'; }\n              if (size) {\n                let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                if (i === -1 || serialNum === '') {\n                  i = util.findObjectByKey(result, 'name', name);\n                }\n                if (i != -1) {\n                  result[i].type = mediaType;\n                  result[i].interfaceType = interfaceType;\n                }\n              }\n            });\n            // S.M.A.R.T\n            data.results.shift();\n            data.results.shift();\n            if (data.results.length) {\n              data.results.forEach((smartStr) => {\n                try {\n                  const smartData = JSON.parse(smartStr);\n                  if (smartData.serial_number) {\n                    const serialNum = smartData.serial_number;\n                    let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                    if (i != -1) {\n                      result[i].smartStatus = (smartData.smart_status && smartData.smart_status.passed ? 'Ok' : (smartData.smart_status && smartData.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (smartData.temperature && smartData.temperature.current) {\n                        result[i].temperature = smartData.temperature.current;\n                      }\n                      result[i].smartData = smartData;\n                    }\n                  }\n                } catch (e) {\n                  util.noop();\n                }\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// graphics.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 7. Graphics (controller, display)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\nlet _nvidiaSmiPath = '';\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _resolutionX = 0;\nlet _resolutionY = 0;\nlet _pixelDepth = 0;\nlet _refreshRate = 0;\n\nconst videoTypes = {\n  '-2': 'UNINITIALIZED',\n  '-1': 'OTHER',\n  '0': 'HD15',\n  '1': 'SVIDEO',\n  '2': 'Composite video',\n  '3': 'Component video',\n  '4': 'DVI',\n  '5': 'HDMI',\n  '6': 'LVDS',\n  '8': 'D_JPN',\n  '9': 'SDI',\n  '10': 'DP',\n  '11': 'DP embedded',\n  '12': 'UDI',\n  '13': 'UDI embedded',\n  '14': 'SDTVDONGLE',\n  '15': 'MIRACAST',\n  '2147483648': 'INTERNAL'\n};\n\nfunction getVendorFromModel(model) {\n  const manufacturers = [\n    { pattern: '^LG.+', manufacturer: 'LG' },\n    { pattern: '^BENQ.+', manufacturer: 'BenQ' },\n    { pattern: '^ASUS.+', manufacturer: 'Asus' },\n    { pattern: '^DELL.+', manufacturer: 'Dell' },\n    { pattern: '^SAMSUNG.+', manufacturer: 'Samsung' },\n    { pattern: '^VIEWSON.+', manufacturer: 'ViewSonic' },\n    { pattern: '^SONY.+', manufacturer: 'Sony' },\n    { pattern: '^ACER.+', manufacturer: 'Acer' },\n    { pattern: '^AOC.+', manufacturer: 'AOC Monitors' },\n    { pattern: '^HP.+', manufacturer: 'HP' },\n    { pattern: '^EIZO.?', manufacturer: 'Eizo' },\n    { pattern: '^PHILIPS.?', manufacturer: 'Philips' },\n    { pattern: '^IIYAMA.?', manufacturer: 'Iiyama' },\n    { pattern: '^SHARP.?', manufacturer: 'Sharp' },\n    { pattern: '^NEC.?', manufacturer: 'NEC' },\n    { pattern: '^LENOVO.?', manufacturer: 'Lenovo' },\n    { pattern: 'COMPAQ.?', manufacturer: 'Compaq' },\n    { pattern: 'APPLE.?', manufacturer: 'Apple' },\n    { pattern: 'INTEL.?', manufacturer: 'Intel' },\n    { pattern: 'AMD.?', manufacturer: 'AMD' },\n    { pattern: 'NVIDIA.?', manufacturer: 'NVDIA' },\n  ];\n\n  let result = '';\n  if (model) {\n    model = model.toUpperCase();\n    manufacturers.forEach((manufacturer) => {\n      const re = RegExp(manufacturer.pattern);\n      if (re.test(model)) { result = manufacturer.manufacturer; }\n    });\n  }\n  return result;\n}\n\nfunction getVendorFromId(id) {\n  const vendors = {\n    '610': 'Apple',\n    '1e6d': 'LG',\n    '10ac': 'DELL',\n    '4dd9': 'Sony',\n    '38a3': 'NEC',\n  };\n  return vendors[id] || '';\n}\n\nfunction vendorToId(str) {\n  let result = '';\n  str = (str || '').toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = '0x05ac'; }\n  else if (str.indexOf('nvidia') >= 0) { result = '0x10de'; }\n  else if (str.indexOf('intel') >= 0) { result = '0x8086'; }\n  else if (str.indexOf('ati') >= 0 || str.indexOf('amd') >= 0) { result = '0x1002'; }\n\n  return result;\n}\n\nfunction getMetalVersion(id) {\n  const families = {\n    'spdisplays_mtlgpufamilymac1': 'mac1',\n    'spdisplays_mtlgpufamilymac2': 'mac2',\n    'spdisplays_mtlgpufamilyapple1': 'apple1',\n    'spdisplays_mtlgpufamilyapple2': 'apple2',\n    'spdisplays_mtlgpufamilyapple3': 'apple3',\n    'spdisplays_mtlgpufamilyapple4': 'apple4',\n    'spdisplays_mtlgpufamilyapple5': 'apple5',\n    'spdisplays_mtlgpufamilyapple6': 'apple6',\n    'spdisplays_mtlgpufamilyapple7': 'apple7',\n    'spdisplays_metalfeaturesetfamily11': 'family1_v1',\n    'spdisplays_metalfeaturesetfamily12': 'family1_v2',\n    'spdisplays_metalfeaturesetfamily13': 'family1_v3',\n    'spdisplays_metalfeaturesetfamily14': 'family1_v4',\n    'spdisplays_metalfeaturesetfamily21': 'family2_v1'\n  };\n  return families[id] || '';\n}\n\nfunction graphics(callback) {\n\n  function parseLinesDarwin(graphicsArr) {\n    const res = {\n      controllers: [],\n      displays: []\n    };\n    try {\n      graphicsArr.forEach(function (item) {\n        // controllers\n        const bus = ((item.sppci_bus || '').indexOf('builtin') > -1 ? 'Built-In' : ((item.sppci_bus || '').indexOf('pcie') > -1 ? 'PCIe' : ''));\n        const vram = (parseInt((item.spdisplays_vram || ''), 10) || 0) * (((item.spdisplays_vram || '').indexOf('GB') > -1) ? 1024 : 1);\n        const vramDyn = (parseInt((item.spdisplays_vram_shared || ''), 10) || 0) * (((item.spdisplays_vram_shared || '').indexOf('GB') > -1) ? 1024 : 1);\n        let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || '');\n        res.controllers.push({\n          vendor: getVendorFromModel(item.spdisplays_vendor || '') || item.spdisplays_vendor || '',\n          model: item.sppci_model || '',\n          bus,\n          vramDynamic: bus === 'Built-In',\n          vram: vram || vramDyn || null,\n          deviceId: item['spdisplays_device-id'] || '',\n          vendorId: item['spdisplays_vendor-id'] || vendorToId((item['spdisplays_vendor'] || '') + (item.sppci_model || '')),\n          external: (item.sppci_device_type === 'spdisplays_egpu'),\n          cores: item['sppci_cores'] || null,\n          metalVersion\n        });\n\n        // displays\n        if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {\n          item.spdisplays_ndrvs.forEach(function (displayItem) {\n            const connectionType = displayItem['spdisplays_connection_type'] || '';\n            const currentResolutionParts = (displayItem['_spdisplays_resolution'] || '').split('@');\n            const currentResolution = currentResolutionParts[0].split('x');\n            const pixelParts = (displayItem['_spdisplays_pixels'] || '').split('x');\n            const pixelDepthString = displayItem['spdisplays_depth'] || '';\n            const serial = displayItem['_spdisplays_display-serial-number'] || displayItem['_spdisplays_display-serial-number2'] || null;\n            res.displays.push({\n              vendor: getVendorFromId(displayItem['_spdisplays_display-vendor-id'] || '') || getVendorFromModel(displayItem['_name'] || ''),\n              vendorId: displayItem['_spdisplays_display-vendor-id'] || '',\n              model: displayItem['_name'] || '',\n              productionYear: displayItem['_spdisplays_display-year'] || null,\n              serial: serial !== '0' ? serial : null,\n              displayId: displayItem['_spdisplays_displayID'] || null,\n              main: displayItem['spdisplays_main'] ? displayItem['spdisplays_main'] === 'spdisplays_yes' : false,\n              builtin: (displayItem['spdisplays_display_type'] || '').indexOf('built-in') > -1,\n              connection: ((connectionType.indexOf('_internal') > -1) ? 'Internal' : ((connectionType.indexOf('_displayport') > -1) ? 'Display Port' : ((connectionType.indexOf('_hdmi') > -1) ? 'HDMI' : null))),\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: (pixelDepthString === 'CGSThirtyBitColor' ? 30 : (pixelDepthString === 'CGSThirtytwoBitColor' ? 32 : (pixelDepthString === 'CGSTwentyfourBitColor' ? 24 : null))),\n              resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,\n              resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,\n              currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,\n              currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null,\n\n            });\n          });\n        }\n      });\n      return res;\n    } catch (e) {\n      return res;\n    }\n  }\n\n  function parseLinesLinuxControllers(lines) {\n    let controllers = [];\n    let currentController = {\n      vendor: '',\n      model: '',\n      bus: '',\n      busAddress: '',\n      vram: null,\n      vramDynamic: false,\n      pciID: ''\n    };\n    let isGraphicsController = false;\n    // PCI bus IDs\n    let pciIDs = [];\n    try {\n      pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep \"Bus Address: \"').toString().split('\\n');\n      for (let i = 0; i < pciIDs.length; i++) {\n        pciIDs[i] = pciIDs[i].replace('Bus Address:', '').replace('0000:', '').trim();\n      }\n      pciIDs = pciIDs.filter(function (el) {\n        return el != null && el;\n      });\n    } catch (e) {\n      util.noop();\n    }\n    lines.forEach((line) => {\n      if ('' !== line.trim()) {\n        if (' ' !== line[0] && '\\t' !== line[0]) {        // first line of new entry\n          let isExternal = (pciIDs.indexOf(line.split(' ')[0]) >= 0);\n          let vgapos = line.toLowerCase().indexOf(' vga ');\n          let _3dcontrollerpos = line.toLowerCase().indexOf('3d controller');\n          if (vgapos !== -1 || _3dcontrollerpos !== -1) {         // VGA\n            if (_3dcontrollerpos !== -1 && vgapos === -1) {\n              vgapos = _3dcontrollerpos;\n            }\n            if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n              controllers.push(currentController);\n              currentController = {\n                vendor: '',\n                model: '',\n                bus: '',\n                busAddress: '',\n                vram: null,\n                vramDynamic: false,\n              };\n            }\n\n            const pciIDCandidate = line.split(' ')[0];\n            if (/[\\da-fA-F]{2}:[\\da-fA-F]{2}\\.[\\da-fA-F]/.test(pciIDCandidate)) {\n              currentController.busAddress = pciIDCandidate;\n            }\n            isGraphicsController = true;\n            let endpos = line.search(/\\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);\n            let parts = line.substr(vgapos, endpos - vgapos).split(':');\n            currentController.busAddress = line.substr(0, vgapos).trim();\n            if (parts.length > 1) {\n              parts[1] = parts[1].trim();\n              if (parts[1].toLowerCase().indexOf('corporation') >= 0) {\n                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf('corporation') + 11).trim();\n                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf('corporation') + 11, 200).trim().split('(')[0];\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' inc.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' inc.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' inc.') + 5, 200).trim().split('(')[0].trim();\n                }\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' ltd.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' ltd.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' ltd.') + 5, 200).trim().split('(')[0].trim();\n                }\n              }\n            }\n\n          } else {\n            isGraphicsController = false;\n          }\n        }\n        if (isGraphicsController) { // within VGA details\n          let parts = line.split(':');\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('devicename') !== -1 && parts[1].toLowerCase().indexOf('onboard') !== -1) { currentController.bus = 'Onboard'; }\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('region') !== -1 && parts[1].toLowerCase().indexOf('memory') !== -1) {\n            let memparts = parts[1].split('=');\n            if (memparts.length > 1) {\n              currentController.vram = parseInt(memparts[1]);\n            }\n          }\n        }\n      }\n    });\n\n    if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n      controllers.push(currentController);\n    }\n    return (controllers);\n  }\n\n  function parseLinesLinuxClinfo(controllers, lines) {\n    const fieldPattern = /\\[([^\\]]+)\\]\\s+(\\w+)\\s+(.*)/;\n    const devices = lines.reduce((devices, line) => {\n      const field = fieldPattern.exec(line.trim());\n      if (field) {\n        if (!devices[field[1]]) {\n          devices[field[1]] = {};\n        }\n        devices[field[1]][field[2]] = field[3];\n      }\n      return devices;\n    }, {});\n    for (let deviceId in devices) {\n      const device = devices[deviceId];\n      if (device['CL_DEVICE_TYPE'] === 'CL_DEVICE_TYPE_GPU') {\n        let busAddress;\n        if (device['CL_DEVICE_TOPOLOGY_AMD']) {\n          const bdf = device['CL_DEVICE_TOPOLOGY_AMD'].match(/[a-zA-Z0-9]+:\\d+\\.\\d+/);\n          if (bdf) {\n            busAddress = bdf[0];\n          }\n        } else if (device['CL_DEVICE_PCI_BUS_ID_NV'] && device['CL_DEVICE_PCI_SLOT_ID_NV']) {\n          const bus = parseInt(device['CL_DEVICE_PCI_BUS_ID_NV']);\n          const slot = parseInt(device['CL_DEVICE_PCI_SLOT_ID_NV']);\n          if (!isNaN(bus) && !isNaN(slot)) {\n            const b = bus & 0xff;\n            const d = (slot >> 3) & 0xff;\n            const f = slot & 0x07;\n            busAddress = `${b.toString().padStart(2, '0')}:${d.toString().padStart(2, '0')}.${f}`;\n          }\n        }\n        if (busAddress) {\n          let controller = controllers.find(controller => controller.busAddress === busAddress);\n          if (!controller) {\n            controller = {\n              vendor: '',\n              model: '',\n              bus: '',\n              busAddress,\n              vram: null,\n              vramDynamic: false\n            };\n            controllers.push(controller);\n          }\n          controller.vendor = device['CL_DEVICE_VENDOR'];\n          if (device['CL_DEVICE_BOARD_NAME_AMD']) {\n            controller.model = device['CL_DEVICE_BOARD_NAME_AMD'];\n          } else {\n            controller.model = device['CL_DEVICE_NAME'];\n          }\n          const memory = parseInt(device['CL_DEVICE_GLOBAL_MEM_SIZE']);\n          if (!isNaN(memory)) {\n            controller.vram = Math.round(memory / 1024 / 1024);\n          }\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function getNvidiaSmi() {\n    if (_nvidiaSmiPath) {\n      return _nvidiaSmiPath;\n    }\n\n    if (_windows) {\n      try {\n        const basePath = util.WINDIR + '\\\\System32\\\\DriverStore\\\\FileRepository';\n        // find all directories that have an nvidia-smi.exe file\n        const candidateDirs = fs.readdirSync(basePath).filter(dir => {\n          return fs.readdirSync([basePath, dir].join('/')).includes('nvidia-smi.exe');\n        });\n        // use the directory with the most recently created nvidia-smi.exe file\n        const targetDir = candidateDirs.reduce((prevDir, currentDir) => {\n          const previousNvidiaSmi = fs.statSync([basePath, prevDir, 'nvidia-smi.exe'].join('/'));\n          const currentNvidiaSmi = fs.statSync([basePath, currentDir, 'nvidia-smi.exe'].join('/'));\n          return (previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs) ? prevDir : currentDir;\n        });\n\n        if (targetDir) {\n          _nvidiaSmiPath = [basePath, targetDir, 'nvidia-smi.exe'].join('/');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else if (_linux) {\n      _nvidiaSmiPath = 'nvidia-smi';\n    }\n    return _nvidiaSmiPath;\n  }\n\n  function nvidiaSmi(options) {\n    const nvidiaSmiExe = getNvidiaSmi();\n    options = options || util.execOptsWin;\n    if (nvidiaSmiExe) {\n      const nvidiaSmiOpts = '--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits';\n      const cmd = nvidiaSmiExe + ' ' + nvidiaSmiOpts + (_linux ? '  2>/dev/null' : '');\n      try {\n        const res = execSync(cmd, options).toString();\n        return res;\n      } catch (e) {\n        util.noop();\n      }\n    }\n    return '';\n  }\n\n  function nvidiaDevices() {\n\n    function safeParseNumber(value) {\n      if ([null, undefined].includes(value)) {\n        return value;\n      }\n      return parseFloat(value);\n    }\n\n    const stdout = nvidiaSmi();\n    if (!stdout) {\n      return [];\n    }\n\n    const gpus = stdout.split('\\n').filter(Boolean);\n    let results = gpus.map(gpu => {\n      const splittedData = gpu.split(', ').map(value => value.includes('N/A') ? undefined : value);\n      if (splittedData.length === 16) {\n        return {\n          driverVersion: splittedData[0],\n          subDeviceId: splittedData[1],\n          name: splittedData[2],\n          pciBus: splittedData[3],\n          fanSpeed: safeParseNumber(splittedData[4]),\n          memoryTotal: safeParseNumber(splittedData[5]),\n          memoryUsed: safeParseNumber(splittedData[6]),\n          memoryFree: safeParseNumber(splittedData[7]),\n          utilizationGpu: safeParseNumber(splittedData[8]),\n          utilizationMemory: safeParseNumber(splittedData[9]),\n          temperatureGpu: safeParseNumber(splittedData[10]),\n          temperatureMemory: safeParseNumber(splittedData[11]),\n          powerDraw: safeParseNumber(splittedData[12]),\n          powerLimit: safeParseNumber(splittedData[13]),\n          clockCore: safeParseNumber(splittedData[14]),\n          clockMemory: safeParseNumber(splittedData[15]),\n        };\n      } else {\n        return {};\n      }\n    });\n    results = results.filter((item) => {\n      return ('pciBus' in item);\n    });\n    return results;\n  }\n\n  function mergeControllerNvidia(controller, nvidia) {\n    if (nvidia.driverVersion) { controller.driverVersion = nvidia.driverVersion; }\n    if (nvidia.subDeviceId) { controller.subDeviceId = nvidia.subDeviceId; }\n    if (nvidia.name) { controller.name = nvidia.name; }\n    if (nvidia.pciBus) { controller.pciBus = nvidia.pciBus; }\n    if (nvidia.fanSpeed) { controller.fanSpeed = nvidia.fanSpeed; }\n    if (nvidia.memoryTotal) {\n      controller.memoryTotal = nvidia.memoryTotal;\n      controller.vram = nvidia.memoryTotal;\n      controller.vramDynamic = false;\n    }\n    if (nvidia.memoryUsed) { controller.memoryUsed = nvidia.memoryUsed; }\n    if (nvidia.memoryFree) { controller.memoryFree = nvidia.memoryFree; }\n    if (nvidia.utilizationGpu) { controller.utilizationGpu = nvidia.utilizationGpu; }\n    if (nvidia.utilizationMemory) { controller.utilizationMemory = nvidia.utilizationMemory; }\n    if (nvidia.temperatureGpu) { controller.temperatureGpu = nvidia.temperatureGpu; }\n    if (nvidia.temperatureMemory) { controller.temperatureMemory = nvidia.temperatureMemory; }\n    if (nvidia.powerDraw) { controller.powerDraw = nvidia.powerDraw; }\n    if (nvidia.powerLimit) { controller.powerLimit = nvidia.powerLimit; }\n    if (nvidia.clockCore) { controller.clockCore = nvidia.clockCore; }\n    if (nvidia.clockMemory) { controller.clockMemory = nvidia.clockMemory; }\n    return controller;\n  }\n\n  function parseLinesLinuxEdid(edid) {\n    // parsen EDID\n    // --> model\n    // --> resolutionx\n    // --> resolutiony\n    // --> builtin = false\n    // --> pixeldepth (?)\n    // --> sizex\n    // --> sizey\n    let result = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    // find first \"Detailed Timing Description\"\n    let start = 108;\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    result.resolutionX = parseInt('0x0' + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));\n    result.resolutionY = parseInt('0x0' + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));\n    result.sizeX = parseInt('0x0' + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));\n    result.sizeY = parseInt('0x0' + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));\n    // monitor name\n    start = edid.indexOf('000000fc00'); // find first \"Monitor Description Data\"\n    if (start >= 0) {\n      let model_raw = edid.substr(start + 10, 26);\n      if (model_raw.indexOf('0a') !== -1) {\n        model_raw = model_raw.substr(0, model_raw.indexOf('0a'));\n      }\n      try {\n        if (model_raw.length > 2) {\n          result.model = model_raw.match(/.{1,2}/g).map(function (v) {\n            return String.fromCharCode(parseInt(v, 16));\n          }).join('');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else {\n      result.model = '';\n    }\n    return result;\n  }\n\n  function parseLinesLinuxDisplays(lines, depth) {\n    let displays = [];\n    let currentDisplay = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    let is_edid = false;\n    let is_current = false;\n    let edid_raw = '';\n    let start = 0;\n    for (let i = 1; i < lines.length; i++) {        // start with second line\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0] && lines[i].toLowerCase().indexOf(' connected ') !== -1) {        // first line of new entry\n          if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {         // push last display to array\n            displays.push(currentDisplay);\n            currentDisplay = {\n              vendor: '',\n              model: '',\n              main: false,\n              builtin: false,\n              connection: '',\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: null,\n              resolutionX: null,\n              resolutionY: null,\n              currentResX: null,\n              currentResY: null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: null\n            };\n          }\n          let parts = lines[i].split(' ');\n          currentDisplay.connection = parts[0];\n          currentDisplay.main = lines[i].toLowerCase().indexOf(' primary ') >= 0;\n          currentDisplay.builtin = (parts[0].toLowerCase().indexOf('edp') >= 0);\n        }\n\n        // try to read EDID information\n        if (is_edid) {\n          if (lines[i].search(/\\S|$/) > start) {\n            edid_raw += lines[i].toLowerCase().trim();\n          } else {\n            // parsen EDID\n            let edid_decoded = parseLinesLinuxEdid(edid_raw);\n            currentDisplay.vendor = edid_decoded.vendor;\n            currentDisplay.model = edid_decoded.model;\n            currentDisplay.resolutionX = edid_decoded.resolutionX;\n            currentDisplay.resolutionY = edid_decoded.resolutionY;\n            currentDisplay.sizeX = edid_decoded.sizeX;\n            currentDisplay.sizeY = edid_decoded.sizeY;\n            currentDisplay.pixelDepth = depth;\n            is_edid = false;\n          }\n        }\n        if (lines[i].toLowerCase().indexOf('edid:') >= 0) {\n          is_edid = true;\n          start = lines[i].search(/\\S|$/);\n        }\n        if (lines[i].toLowerCase().indexOf('*current') >= 0) {\n          const parts1 = lines[i].split('(');\n          if (parts1 && parts1.length > 1 && parts1[0].indexOf('x') >= 0) {\n            const resParts = parts1[0].trim().split('x');\n            currentDisplay.currentResX = util.toInt(resParts[0]);\n            currentDisplay.currentResY = util.toInt(resParts[1]);\n          }\n          is_current = true;\n        }\n        if (is_current && lines[i].toLowerCase().indexOf('clock') >= 0 && lines[i].toLowerCase().indexOf('hz') >= 0 && lines[i].toLowerCase().indexOf('v: height') >= 0) {\n          const parts1 = lines[i].split('clock');\n          if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf('hz') >= 0) {\n            currentDisplay.currentRefreshRate = util.toInt(parts1[1]);\n          }\n          is_current = false;\n        }\n      }\n    }\n\n    // pushen displays\n    if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {  // still information there\n      displays.push(currentDisplay);\n    }\n    return displays;\n  }\n\n  // function starts here\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        controllers: [],\n        displays: []\n      };\n      if (_darwin) {\n        let cmd = 'system_profiler -xml -detailLevel full SPDisplaysDataType';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const output = stdout.toString();\n              result = parseLinesDarwin(util.plistParser(output)[0]._items);\n            } catch (e) {\n              util.noop();\n            }\n            stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo \"\"');\n            const output = (stdout || '').toString();\n            const obj = util.plistReader(output);\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets']['Configs'] && obj['DisplayAnyUserSets']['Configs'][0] && obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig']) {\n              const current = obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig'];\n              let i = 0;\n              current.forEach((o) => {\n                if (o['CurrentInfo'] && 'OriginX' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['CurrentInfo']['OriginX'];\n                }\n                if (o['CurrentInfo'] && 'OriginY' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['CurrentInfo']['OriginY'];\n                }\n                i++;\n              });\n            }\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets'].length > 0 && obj['DisplayAnyUserSets'][0].length > 0 && obj['DisplayAnyUserSets'][0][0]['DisplayID']) {\n              const current = obj['DisplayAnyUserSets'][0];\n              let i = 0;\n              current.forEach((o) => {\n                if ('OriginX' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['OriginX'];\n                }\n                if ('OriginY' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['OriginY'];\n                }\n                if (o['Mode'] && 'BitsPerPixel' in o['Mode'] && result.displays && result.displays[i]) {\n                  result.displays[i].pixelDepth = o['Mode']['BitsPerPixel'];\n                }\n                i++;\n              });\n            }\n\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        // Raspberry: https://elinux.org/RPI_vcgencmd_usage\n        if (util.isRaspberry() && util.isRaspbian()) {\n          let cmd = 'fbset -s | grep \\'mode \"\\'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;';\n          exec(cmd, function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 3 && lines[0].indexOf('mode \"') >= -1 && lines[2].indexOf('0x12000a') > -1) {\n              const parts = lines[0].replace('mode', '').replace(/\"/g, '').trim().split('x');\n              if (parts.length === 2) {\n                result.displays.push({\n                  vendor: '',\n                  model: util.getValue(lines, 'device_name', '='),\n                  main: true,\n                  builtin: false,\n                  connection: 'HDMI',\n                  sizeX: null,\n                  sizeY: null,\n                  pixelDepth: null,\n                  resolutionX: parseInt(parts[0], 10),\n                  resolutionY: parseInt(parts[1], 10),\n                  currentResX: null,\n                  currentResY: null,\n                  positionX: 0,\n                  positionY: 0,\n                  currentRefreshRate: null\n                });\n              }\n            }\n            if (lines.length > 1 && stdout.toString().indexOf('gpu=') >= -1) {\n              result.controllers.push({\n                vendor: 'Broadcom',\n                model: 'VideoCore IV',\n                bus: '',\n                vram: util.getValue(lines, 'gpu', '=').replace('M', ''),\n                vramDynamic: true\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } else {\n          let cmd = 'lspci -vvv  2>/dev/null';\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              result.controllers = parseLinesLinuxControllers(lines);\n              const nvidiaData = nvidiaDevices();\n              // needs to be rewritten ... using no spread operators\n              result.controllers = result.controllers.map((controller) => { // match by busAddress\n                return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});\n              });\n            }\n            let cmd = 'clinfo --raw';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.controllers = parseLinesLinuxClinfo(result.controllers, lines);\n              }\n              let cmd = 'xdpyinfo 2>/dev/null | grep \\'depth of root window\\' | awk \\'{ print $5 }\\'';\n              exec(cmd, function (error, stdout) {\n                let depth = 0;\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  depth = parseInt(lines[0]) || 0;\n                }\n                let cmd = 'xrandr --verbose 2>/dev/null';\n                exec(cmd, function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    result.displays = parseLinesLinuxDisplays(lines, depth);\n                  }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                });\n              });\n            });\n          });\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n\n        // https://blogs.technet.microsoft.com/heyscriptingguy/2013/10/03/use-powershell-to-discover-multi-monitor-information/\n        // https://devblogs.microsoft.com/scripting/use-powershell-to-discover-multi-monitor-information/\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance win32_VideoController | fl *'));\n          workload.push(util.powerShell('gp \"HKLM:\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\*\" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));\n          workload.push(util.powerShell('Get-CimInstance win32_desktopmonitor | fl *'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorBasicDisplayParams | fl'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorConnectionParams | fl'));\n          workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + $_.InstanceName}'));\n\n          const nvidiaData = nvidiaDevices();\n\n          Promise.all(\n            workload\n          ).then((data) => {\n            // controller + vram\n            let csections = data[0].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            let vsections = data[1].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            result.controllers = parseLinesWindowsControllers(csections, vsections);\n            result.controllers = result.controllers.map((controller) => { // match by subDeviceId\n              if (controller.vendor.toLowerCase() === 'nvidia') {\n                return mergeControllerNvidia(controller, nvidiaData.find(device => {\n                  let windowsSubDeviceId = (controller.subDeviceId || '').toLowerCase();\n                  const nvidiaSubDeviceIdParts = device.subDeviceId.split('x');\n                  let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();\n                  const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);\n                  if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      nvidiaSubDeviceId = '0' + nvidiaSubDeviceId;\n                    }\n                  } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      windowsSubDeviceId = '0' + windowsSubDeviceId;\n                    }\n                  }\n                  return windowsSubDeviceId === nvidiaSubDeviceId;\n                }) || {});\n              } else {\n                return controller;\n              }\n            });\n\n            // displays\n            let dsections = data[2].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            // result.displays = parseLinesWindowsDisplays(dsections);\n            if (dsections[0].trim() === '') { dsections.shift(); }\n            if (dsections.length && dsections[dsections.length - 1].trim() === '') { dsections.pop(); }\n\n            // monitor (powershell)\n            let msections = data[3].replace(/\\r/g, '').split('Active ');\n            msections.shift();\n\n            // forms.screens (powershell)\n            let ssections = data[4].replace(/\\r/g, '').split('BitsPerPixel ');\n            ssections.shift();\n\n            // connection params (powershell) - video type\n            let tsections = data[5].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            tsections.shift();\n\n            // monitor ID (powershell) - model / vendor\n            const res = data[6].replace(/\\r/g, '').split(/\\n/);\n            let isections = [];\n            res.forEach(element => {\n              const parts = element.split('|');\n              if (parts.length === 5) {\n                isections.push({\n                  vendor: parts[0],\n                  code: parts[1],\n                  model: parts[2],\n                  serial: parts[3],\n                  instanceId: parts[4]\n                });\n              }\n            });\n\n            result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);\n\n            if (result.displays.length === 1) {\n              if (_resolutionX) {\n                result.displays[0].resolutionX = _resolutionX;\n                if (!result.displays[0].currentResX) {\n                  result.displays[0].currentResX = _resolutionX;\n                }\n              }\n              if (_resolutionY) {\n                result.displays[0].resolutionY = _resolutionY;\n                if (result.displays[0].currentResY === 0) {\n                  result.displays[0].currentResY = _resolutionY;\n                }\n              }\n              if (_pixelDepth) {\n                result.displays[0].pixelDepth = _pixelDepth;\n              }\n            }\n            result.displays = result.displays.map(element => {\n              if (_refreshRate && !element.currentRefreshRate) {\n                element.currentRefreshRate = _refreshRate;\n              }\n              return element;\n            });\n\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          })\n            .catch(() => {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n\n  function parseLinesWindowsControllers(sections, vections) {\n    const memorySizes = {};\n    for (const i in vections) {\n      if ({}.hasOwnProperty.call(vections, i)) {\n        if (vections[i].trim() !== '') {\n          const lines = vections[i].trim().split('\\n');\n          const matchingDeviceId = util.getValue(lines, 'MatchingDeviceId').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          if (matchingDeviceId) {\n            const quadWordmemorySize = parseInt(util.getValue(lines, 'HardwareInformation.qwMemorySize'));\n            if (!isNaN(quadWordmemorySize)) {\n              let deviceId = matchingDeviceId[1].toUpperCase() + '&' + matchingDeviceId[2].toUpperCase();\n              if (matchingDeviceId[3]) {\n                deviceId += '&' + matchingDeviceId[3].toUpperCase();\n              }\n              if (matchingDeviceId[4]) {\n                deviceId += '&' + matchingDeviceId[4].toUpperCase();\n              }\n              memorySizes[deviceId] = quadWordmemorySize;\n            }\n          }\n        }\n      }\n    }\n\n    let controllers = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\n');\n          let pnpDeviceId = util.getValue(lines, 'PNPDeviceID', ':').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          let subDeviceId = null;\n          let memorySize = null;\n          if (pnpDeviceId) {\n            subDeviceId = pnpDeviceId[3] || '';\n            if (subDeviceId) {\n              subDeviceId = subDeviceId.split('_')[1];\n            }\n\n            // Match PCI device identifier (there's an order of increasing generality):\n            // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/identifiers-for-pci-devices\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)\n            if (memorySize == null && pnpDeviceId[3]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)\n            if (memorySize == null) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n          }\n\n          controllers.push({\n            vendor: util.getValue(lines, 'AdapterCompatibility', ':'),\n            model: util.getValue(lines, 'name', ':'),\n            bus: util.getValue(lines, 'PNPDeviceID', ':').startsWith('PCI') ? 'PCI' : '',\n            vram: (memorySize == null ? util.toInt(util.getValue(lines, 'AdapterRAM', ':')) : memorySize) / 1024 / 1024,\n            vramDynamic: (util.getValue(lines, 'VideoMemoryType', ':') === '2'),\n            subDeviceId\n          });\n          _resolutionX = util.toInt(util.getValue(lines, 'CurrentHorizontalResolution', ':')) || _resolutionX;\n          _resolutionY = util.toInt(util.getValue(lines, 'CurrentVerticalResolution', ':')) || _resolutionY;\n          _refreshRate = util.toInt(util.getValue(lines, 'CurrentRefreshRate', ':')) || _refreshRate;\n          _pixelDepth = util.toInt(util.getValue(lines, 'CurrentBitsPerPixel', ':')) || _pixelDepth;\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {\n    let displays = [];\n    let vendor = '';\n    let model = '';\n    let deviceID = '';\n    let resolutionX = 0;\n    let resolutionY = 0;\n    if (dsections && dsections.length) {\n      let linesDisplay = dsections[0].split('\\n');\n      vendor = util.getValue(linesDisplay, 'MonitorManufacturer', ':');\n      model = util.getValue(linesDisplay, 'Name', ':');\n      deviceID = util.getValue(linesDisplay, 'PNPDeviceID', ':').replace(/&amp;/g, '&').toLowerCase();\n      resolutionX = util.toInt(util.getValue(linesDisplay, 'ScreenWidth', ':'));\n      resolutionY = util.toInt(util.getValue(linesDisplay, 'ScreenHeight', ':'));\n    }\n    for (let i = 0; i < ssections.length; i++) {\n      if (ssections[i].trim() !== '') {\n        ssections[i] = 'BitsPerPixel ' + ssections[i];\n        msections[i] = 'Active ' + msections[i];\n        // tsections can be empty OR undefined on earlier versions of powershell (<=2.0)\n        // Tag connection type as UNKNOWN by default if this information is missing\n        if (tsections.length === 0 || tsections[i] === undefined) {\n          tsections[i] = 'Unknown';\n        }\n        let linesScreen = ssections[i].split('\\n');\n        let linesMonitor = msections[i].split('\\n');\n\n        let linesConnection = tsections[i].split('\\n');\n        const bitsPerPixel = util.getValue(linesScreen, 'BitsPerPixel');\n        const bounds = util.getValue(linesScreen, 'Bounds').replace('{', '').replace('}', '').replace(/=/g, ':').split(',');\n        const primary = util.getValue(linesScreen, 'Primary');\n        const sizeX = util.getValue(linesMonitor, 'MaxHorizontalImageSize');\n        const sizeY = util.getValue(linesMonitor, 'MaxVerticalImageSize');\n        const instanceName = util.getValue(linesMonitor, 'InstanceName').toLowerCase();\n        const videoOutputTechnology = util.getValue(linesConnection, 'VideoOutputTechnology');\n        const deviceName = util.getValue(linesScreen, 'DeviceName');\n        let displayVendor = '';\n        let displayModel = '';\n        isections.forEach(element => {\n          if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith('(') && model.startsWith('PnP')) {\n            displayVendor = element.vendor;\n            displayModel = element.model;\n          }\n        });\n        displays.push({\n          vendor: instanceName.startsWith(deviceID) && displayVendor === '' ? vendor : displayVendor,\n          model: instanceName.startsWith(deviceID) && displayModel === '' ? model : displayModel,\n          deviceName,\n          main: primary.toLowerCase() === 'true',\n          builtin: videoOutputTechnology === '2147483648',\n          connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : '',\n          resolutionX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          resolutionY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          sizeX: sizeX ? parseInt(sizeX, 10) : null,\n          sizeY: sizeY ? parseInt(sizeY, 10) : null,\n          pixelDepth: bitsPerPixel,\n          currentResX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          currentResY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          positionX: util.toInt(util.getValue(bounds, 'X', ':')),\n          positionY: util.toInt(util.getValue(bounds, 'Y', ':')),\n        });\n      }\n    }\n    if (ssections.length === 0) {\n      displays.push({\n        vendor,\n        model,\n        main: true,\n        sizeX: null,\n        sizeY: null,\n        resolutionX,\n        resolutionY,\n        pixelDepth: null,\n        currentResX: resolutionX,\n        currentResY: resolutionY,\n        positionX: 0,\n        positionY: 0\n      });\n    }\n    return displays;\n  }\n}\n\nexports.graphics = graphics;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// index.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// Contributors:  Guillaume Legrain (https://github.com/glegrain)\n//                Riccardo Novaglia (https://github.com/richy24)\n//                Quentin Busuttil (https://github.com/Buzut)\n//                Lapsio (https://github.com/lapsio)\n//                csy (https://github.com/csy1983)\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n\n// ----------------------------------------------------------------------------------\n// Dependencies\n// ----------------------------------------------------------------------------------\n\nconst lib_version = require('../package.json').version;\nconst util = require('./util');\nconst system = require('./system');\nconst osInfo = require('./osinfo');\nconst cpu = require('./cpu');\nconst memory = require('./memory');\nconst battery = require('./battery');\nconst graphics = require('./graphics');\nconst filesystem = require('./filesystem');\nconst network = require('./network');\nconst wifi = require('./wifi');\nconst processes = require('./processes');\nconst users = require('./users');\nconst internet = require('./internet');\nconst docker = require('./docker');\nconst vbox = require('./virtualbox');\nconst printer = require('./printer');\nconst usb = require('./usb');\nconst audio = require('./audio');\nconst bluetooth = require('./bluetooth');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// ----------------------------------------------------------------------------------\n// init\n// ----------------------------------------------------------------------------------\n\nif (_windows) {\n  util.getCodepage();\n}\n\n// ----------------------------------------------------------------------------------\n// General\n// ----------------------------------------------------------------------------------\n\nfunction version() {\n  return lib_version;\n}\n\n// ----------------------------------------------------------------------------------\n// Get static and dynamic data (all)\n// ----------------------------------------------------------------------------------\n\n// --------------------------\n// get static data - they should not change until restarted\n\nfunction getStaticData(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let data = {};\n\n      data.version = version();\n\n      Promise.all([\n        system.system(),\n        system.bios(),\n        system.baseboard(),\n        system.chassis(),\n        osInfo.osInfo(),\n        osInfo.uuid(),\n        osInfo.versions(),\n        cpu.cpu(),\n        cpu.cpuFlags(),\n        graphics.graphics(),\n        network.networkInterfaces(),\n        memory.memLayout(),\n        filesystem.diskLayout()\n      ]).then((res) => {\n        data.system = res[0];\n        data.bios = res[1];\n        data.baseboard = res[2];\n        data.chassis = res[3];\n        data.os = res[4];\n        data.uuid = res[5];\n        data.versions = res[6];\n        data.cpu = res[7];\n        data.cpu.flags = res[8];\n        data.graphics = res[9];\n        data.net = res[10];\n        data.memLayout = res[11];\n        data.diskLayout = res[12];\n        if (callback) { callback(data); }\n        resolve(data);\n      });\n    });\n  });\n}\n\n\n// --------------------------\n// get all dynamic data - e.g. for monitoring agents\n// may take some seconds to get all data\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getDynamicData(srv, iface, callback) {\n\n  if (util.isFunction(iface)) {\n    callback = iface;\n    iface = '';\n  }\n  if (util.isFunction(srv)) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      iface = iface || network.getDefaultNetworkInterface();\n      srv = srv || '';\n\n      // use closure to track  completion\n      let functionProcessed = (function () {\n        let totalFunctions = 15;\n        if (_windows) { totalFunctions = 13; }\n        if (_freebsd || _openbsd || _netbsd) { totalFunctions = 11; }\n        if (_sunos) { totalFunctions = 6; }\n\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          }\n        };\n      })();\n\n      let data = {};\n\n      // get time\n      data.time = osInfo.time();\n\n      /**\n       * @namespace\n       * @property {Object}  versions\n       * @property {string}  versions.node\n       * @property {string}  versions.v8\n       */\n      data.node = process.versions.node;\n      data.v8 = process.versions.v8;\n\n      cpu.cpuCurrentSpeed().then((res) => {\n        data.cpuCurrentSpeed = res;\n        functionProcessed();\n      });\n\n      users.users().then((res) => {\n        data.users = res;\n        functionProcessed();\n      });\n\n      processes.processes().then((res) => {\n        data.processes = res;\n        functionProcessed();\n      });\n\n      cpu.currentLoad().then((res) => {\n        data.currentLoad = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        cpu.cpuTemperature().then((res) => {\n          data.temp = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        network.networkStats(iface).then((res) => {\n          data.networkStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        network.networkConnections().then((res) => {\n          data.networkConnections = res;\n          functionProcessed();\n        });\n      }\n\n      memory.mem().then((res) => {\n        data.mem = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        battery().then((res) => {\n          data.battery = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        processes.services(srv).then((res) => {\n          data.services = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        filesystem.fsSize().then((res) => {\n          data.fsSize = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.fsStats().then((res) => {\n          data.fsStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.disksIO().then((res) => {\n          data.disksIO = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        wifi.wifiNetworks().then((res) => {\n          data.wifiNetworks = res;\n          functionProcessed();\n        });\n      }\n\n      internet.inetLatency().then((res) => {\n        data.inetLatency = res;\n        functionProcessed();\n      });\n    });\n  });\n}\n\n// --------------------------\n// get all data at once\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getAllData(srv, iface, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = {};\n\n      if (iface && util.isFunction(iface) && !callback) {\n        callback = iface;\n        iface = '';\n      }\n\n      if (srv && util.isFunction(srv) && !iface && !callback) {\n        callback = srv;\n        srv = '';\n        iface = '';\n      }\n\n      getStaticData().then((res) => {\n        data = res;\n        getDynamicData(srv, iface).then((res) => {\n          for (let key in res) {\n            if ({}.hasOwnProperty.call(res, key)) {\n              data[key] = res[key];\n            }\n          }\n          if (callback) { callback(data); }\n          resolve(data);\n        });\n      });\n    });\n  });\n}\n\nfunction get(valueObject, callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const allPromises = Object.keys(valueObject)\n        .filter(func => ({}.hasOwnProperty.call(exports, func)))\n        .map(func => {\n          const params = valueObject[func].substring(valueObject[func].lastIndexOf('(') + 1, valueObject[func].lastIndexOf(')'));\n          let funcWithoutParams = func.indexOf(')') >= 0 ? func.split(')')[1].trim() : func;\n          funcWithoutParams = func.indexOf('|') >= 0 ? func.split('|')[0].trim() : funcWithoutParams;\n          if (params) {\n            return exports[funcWithoutParams](params);\n          } else {\n            return exports[funcWithoutParams]('');\n          }\n        });\n\n      Promise.all(allPromises).then((data) => {\n        const result = {};\n        let i = 0;\n        for (let key in valueObject) {\n          if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {\n            if (valueObject[key] === '*' || valueObject[key] === 'all') {\n              result[key] = data[i];\n            } else {\n              let keys = valueObject[key];\n              let filter = '';\n              let filterParts = [];\n              // remove params\n              if (keys.indexOf(')') >= 0) {\n                keys = keys.split(')')[1].trim();\n              }\n              // extract filter and remove it from keys\n              if (keys.indexOf('|') >= 0) {\n                filter = keys.split('|')[1].trim();\n                filterParts = filter.split(':');\n\n                keys = keys.split('|')[0].trim();\n              }\n              keys = keys.replace(/,/g, ' ').replace(/ +/g, ' ').split(' ');\n              if (data[i]) {\n                if (Array.isArray(data[i])) {\n                  // result is in an array, go through all elements of array and pick only the right ones\n                  const partialArray = [];\n                  data[i].forEach(element => {\n                    let partialRes = {};\n                    if (keys.length === 1 && (keys[0] === '*' || keys[0] === 'all')) {\n                      partialRes = element;\n                    } else {\n                      keys.forEach(k => {\n                        if ({}.hasOwnProperty.call(element, k)) {\n                          partialRes[k] = element[k];\n                        }\n                      });\n                    }\n                    // if there is a filter, then just take those elements\n                    if (filter && filterParts.length === 2) {\n                      if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {\n                        const val = partialRes[filterParts[0].trim()];\n                        if (typeof val == 'number') {\n                          if (val === parseFloat(filterParts[1].trim())) {\n                            partialArray.push(partialRes);\n                          }\n                        } else if (typeof val == 'string') {\n                          if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {\n                            partialArray.push(partialRes);\n                          }\n                        }\n                      }\n                    } else {\n                      partialArray.push(partialRes);\n                    }\n\n                  });\n                  result[key] = partialArray;\n                } else {\n                  const partialRes = {};\n                  keys.forEach(k => {\n                    if ({}.hasOwnProperty.call(data[i], k)) {\n                      partialRes[k] = data[i][k];\n                    }\n                  });\n                  result[key] = partialRes;\n                }\n              } else {\n                result[key] = {};\n              }\n            }\n            i++;\n          }\n        }\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nfunction observe(valueObject, interval, callback) {\n  let _data = null;\n\n  const result = setInterval(() => {\n    get(valueObject).then((data) => {\n      if (JSON.stringify(_data) !== JSON.stringify(data)) {\n        _data = Object.assign({}, data);\n        callback(data);\n      }\n    });\n  }, interval);\n  return result;\n}\n\n// ----------------------------------------------------------------------------------\n// export all libs\n// ----------------------------------------------------------------------------------\n\nexports.version = version;\nexports.system = system.system;\nexports.bios = system.bios;\nexports.baseboard = system.baseboard;\nexports.chassis = system.chassis;\n\nexports.time = osInfo.time;\nexports.osInfo = osInfo.osInfo;\nexports.versions = osInfo.versions;\nexports.shell = osInfo.shell;\nexports.uuid = osInfo.uuid;\n\nexports.cpu = cpu.cpu;\nexports.cpuFlags = cpu.cpuFlags;\nexports.cpuCache = cpu.cpuCache;\nexports.cpuCurrentSpeed = cpu.cpuCurrentSpeed;\nexports.cpuTemperature = cpu.cpuTemperature;\nexports.currentLoad = cpu.currentLoad;\nexports.fullLoad = cpu.fullLoad;\n\nexports.mem = memory.mem;\nexports.memLayout = memory.memLayout;\n\nexports.battery = battery;\n\nexports.graphics = graphics.graphics;\n\nexports.fsSize = filesystem.fsSize;\nexports.fsOpenFiles = filesystem.fsOpenFiles;\nexports.blockDevices = filesystem.blockDevices;\nexports.fsStats = filesystem.fsStats;\nexports.disksIO = filesystem.disksIO;\nexports.diskLayout = filesystem.diskLayout;\n\nexports.networkInterfaceDefault = network.networkInterfaceDefault;\nexports.networkGatewayDefault = network.networkGatewayDefault;\nexports.networkInterfaces = network.networkInterfaces;\nexports.networkStats = network.networkStats;\nexports.networkConnections = network.networkConnections;\n\nexports.wifiNetworks = wifi.wifiNetworks;\nexports.wifiInterfaces = wifi.wifiInterfaces;\nexports.wifiConnections = wifi.wifiConnections;\n\nexports.services = processes.services;\nexports.processes = processes.processes;\nexports.processLoad = processes.processLoad;\n\nexports.users = users.users;\n\nexports.inetChecksite = internet.inetChecksite;\nexports.inetLatency = internet.inetLatency;\n\nexports.dockerInfo = docker.dockerInfo;\nexports.dockerImages = docker.dockerImages;\nexports.dockerContainers = docker.dockerContainers;\nexports.dockerContainerStats = docker.dockerContainerStats;\nexports.dockerContainerProcesses = docker.dockerContainerProcesses;\nexports.dockerVolumes = docker.dockerVolumes;\nexports.dockerAll = docker.dockerAll;\n\nexports.vboxInfo = vbox.vboxInfo;\n\nexports.printer = printer.printer;\n\nexports.usb = usb.usb;\n\nexports.audio = audio.audio;\nexports.bluetoothDevices = bluetooth.bluetoothDevices;\n\nexports.getStaticData = getStaticData;\nexports.getDynamicData = getDynamicData;\nexports.getAllData = getAllData;\nexports.get = get;\nexports.observe = observe;\n\nexports.powerShellStart = util.powerShellStart;\nexports.powerShellRelease = util.powerShellRelease;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\n// const exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: null\n      };\n      if (typeof url !== 'string') {\n        if (callback) { callback(result); }\n        return resolve(result);\n      }\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url, true);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      result.url = urlSanitized;\n      try {\n        if (urlSanitized && !util.isPrototypePolluted()) {\n          urlSanitized.__proto__.startsWith = util.stringStartWith;\n          if (urlSanitized.startsWith('file:') || urlSanitized.startsWith('gopher:') || urlSanitized.startsWith('telnet:') || urlSanitized.startsWith('mailto:') || urlSanitized.startsWith('news:') || urlSanitized.startsWith('nntp:')) {\n            if (callback) { callback(result); }\n            return resolve(result);\n          }\n          let t = Date.now();\n          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n            let args = ['-I', '--connect-timeout', '5', '-m', '5'];\n            args.push(urlSanitized);\n            let cmd = 'curl';\n            util.execSafe(cmd, args).then((stdout) => {\n              const lines = stdout.split('\\n');\n              let statusCode = lines[0] && lines[0].indexOf(' ') >= 0 ? parseInt(lines[0].split(' ')[1], 10) : 404;\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n              result.ms = (result.ok ? Date.now() - t : null);\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          }\n          if (_windows) {   // if this is stable, this can be used for all OS types\n            const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n            try {\n              http.get(urlSanitized, (res) => {\n                const statusCode = res.statusCode;\n\n                result.status = statusCode || 404;\n                result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n                if (statusCode !== 200) {\n                  res.resume();\n                  result.ms = (result.ok ? Date.now() - t : null);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  res.on('data', () => { });\n                  res.on('end', () => {\n                    result.ms = (result.ok ? Date.now() - t : null);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              }).on('error', () => {\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } catch (err) {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } catch (err) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof host !== 'string') {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let hostSanitized = '';\n      const s = (util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host, true)).trim();\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1]) {\n            hostSanitized = hostSanitized + sl[0];\n          }\n        }\n      }\n      hostSanitized.__proto__.startsWith = util.stringStartWith;\n      if (hostSanitized.startsWith('file:') || hostSanitized.startsWith('gopher:') || hostSanitized.startsWith('telnet:') || hostSanitized.startsWith('mailto:') || hostSanitized.startsWith('news:') || hostSanitized.startsWith('nntp:')) {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let params;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          params = ['-c', '2', '-w', '3', hostSanitized];\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          params = ['-c', '2', '-t', '3', hostSanitized];\n        }\n        if (_darwin) {\n          params = ['-c2', '-t3', hostSanitized];\n        }\n        util.execSafe('ping', params).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter((line) => (line.indexOf('rtt') >= 0 || line.indexOf('round-trip') >= 0 || line.indexOf('avg') >= 0)).join('\\n');\n\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        const params = ['-s', '-a', hostSanitized, '56', '2'];\n        const filt = 'avg';\n        util.execSafe('ping', params, { timeout: 3000 }).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = null;\n        try {\n          const params = [hostSanitized, '-n', '1'];\n          util.execSafe('ping', params, util.execOptsWin).then((stdout) => {\n            if (stdout) {\n              let lines = stdout.split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// memory.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 5. Memory\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst OSX_RAM_manufacturers = {\n  '0x014F': 'Transcend Information',\n  '0x2C00': 'Micron Technology Inc.',\n  '0x802C': 'Micron Technology Inc.',\n  '0x80AD': 'Hynix Semiconductor Inc.',\n  '0x80CE': 'Samsung Electronics Inc.',\n  '0xAD00': 'Hynix Semiconductor Inc.',\n  '0xCE00': 'Samsung Electronics Inc.',\n  '0x02FE': 'Elpida',\n  '0x5105': 'Qimonda AG i. In.',\n  '0x8551': 'Qimonda AG i. In.',\n  '0x859B': 'Crucial',\n  '0x04CD': 'G-Skill'\n};\n\nconst LINUX_RAM_manufacturers = {\n  '017A': 'Apacer',\n  '0198': 'HyperX',\n  '029E': 'Corsair',\n  '04CB': 'A-DATA',\n  '04CD': 'G-Skill',\n  '059B': 'Crucial',\n  '00CE': 'Samsung',\n  '1315': 'Crutial',\n  '014F': 'Transcend Information',\n  '2C00': 'Micron Technology Inc.',\n  '802C': 'Micron Technology Inc.',\n  '80AD': 'Hynix Semiconductor Inc.',\n  '80CE': 'Samsung Electronics Inc.',\n  'AD00': 'Hynix Semiconductor Inc.',\n  'CE00': 'Samsung Electronics Inc.',\n  '02FE': 'Elpida',\n  '5105': 'Qimonda AG i. In.',\n  '8551': 'Qimonda AG i. In.',\n  '859B': 'Crucial'\n};\n\n// _______________________________________________________________________________________\n// |                         R A M                              |          H D           |\n// |______________________|_________________________|           |                        |\n// |        active             buffers/cache        |           |                        |\n// |________________________________________________|___________|_________|______________|\n// |                     used                            free   |   used       free      |\n// |____________________________________________________________|________________________|\n// |                        total                               |          swap          |\n// |____________________________________________________________|________________________|\n\n// free (older versions)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers     cached\n// Mem:         16038 (1)   15653 (2)   384 (3)  0 (4)     236 (5)     14788 (6)\n// -/+ buffers/cache:       628 (7)     15409 (8)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// | active (2-(5+6) = 7) |  available (3+5+6 = 8)              |\n// |______________________|_________________________|___________|\n// |        active        |  buffers/cache (5+6)    |           |\n// |________________________________________________|___________|\n// |                   used (2)                     | free (3)  |\n// |____________________________________________________________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n\n//\n// free (since free von procps-ng 3.3.10)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers/cache   available\n// Mem:         16038 (1)   628 (2)     386 (3)  0 (4)     15024 (5)     14788 (6)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// |                      |      available (6) estimated        |\n// |______________________|_________________________|___________|\n// |     active (2)       |   buffers/cache (5)     | free (3)  |\n// |________________________________________________|___________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n//\n// Reference: http://www.software-architect.net/blog/article/date/2015/06/12/-826c6e5052.html\n\n// /procs/meminfo - sample (all in kB)\n//\n// MemTotal: 32806380 kB\n// MemFree: 17977744 kB\n// MemAvailable: 19768972 kB\n// Buffers: 517028 kB\n// Cached: 2161876 kB\n// SwapCached: 456 kB\n// Active: 12081176 kB\n// Inactive: 2164616 kB\n// Active(anon): 10832884 kB\n// Inactive(anon): 1477272 kB\n// Active(file): 1248292 kB\n// Inactive(file): 687344 kB\n// Unevictable: 0 kB\n// Mlocked: 0 kB\n// SwapTotal: 16768892 kB\n// SwapFree: 16768304 kB\n// Dirty: 268 kB\n// Writeback: 0 kB\n// AnonPages: 11568832 kB\n// Mapped: 719992 kB\n// Shmem: 743272 kB\n// Slab: 335716 kB\n// SReclaimable: 256364 kB\n// SUnreclaim: 79352 kB\n\nfunction mem(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        total: os.totalmem(),\n        free: os.freemem(),\n        used: os.totalmem() - os.freemem(),\n\n        active: os.totalmem() - os.freemem(),     // temporarily (fallback)\n        available: os.freemem(),                  // temporarily (fallback)\n        buffers: 0,\n        cached: 0,\n        slab: 0,\n        buffcache: 0,\n\n        swaptotal: 0,\n        swapused: 0,\n        swapfree: 0\n      };\n\n      if (_linux) {\n        fs.readFile('/proc/meminfo', function (error, stdout) {\n          if (!error) {\n            const lines = stdout.toString().split('\\n');\n            result.total = parseInt(util.getValue(lines, 'memtotal'), 10);\n            result.total = result.total ? result.total * 1024 : os.totalmem();\n            result.free = parseInt(util.getValue(lines, 'memfree'), 10);\n            result.free = result.free ? result.free * 1024 : os.freemem();\n            result.used = result.total - result.free;\n\n            result.buffers = parseInt(util.getValue(lines, 'buffers'), 10);\n            result.buffers = result.buffers ? result.buffers * 1024 : 0;\n            result.cached = parseInt(util.getValue(lines, 'cached'), 10);\n            result.cached = result.cached ? result.cached * 1024 : 0;\n            result.slab = parseInt(util.getValue(lines, 'slab'), 10);\n            result.slab = result.slab ? result.slab * 1024 : 0;\n            result.buffcache = result.buffers + result.cached + result.slab;\n\n            let available = parseInt(util.getValue(lines, 'memavailable'), 10);\n            result.available = available ? available * 1024 : result.free + result.buffcache;\n            result.active = result.total - result.available;\n\n            result.swaptotal = parseInt(util.getValue(lines, 'swaptotal'), 10);\n            result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;\n            result.swapfree = parseInt(util.getValue(lines, 'swapfree'), 10);\n            result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;\n            result.swapused = result.swaptotal - result.swapfree;\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            const pagesize = parseInt(util.getValue(lines, 'vm.stats.vm.v_page_size'), 10);\n            const inactive = parseInt(util.getValue(lines, 'vm.stats.vm.v_inactive_count'), 10) * pagesize;\n            const cache = parseInt(util.getValue(lines, 'vm.stats.vm.v_cache_count'), 10) * pagesize;\n\n            result.total = parseInt(util.getValue(lines, 'hw.realmem'), 10);\n            if (isNaN(result.total)) { result.total = parseInt(util.getValue(lines, 'hw.physmem'), 10); }\n            result.free = parseInt(util.getValue(lines, 'vm.stats.vm.v_free_count'), 10) * pagesize;\n            result.buffcache = inactive + cache;\n            result.available = result.buffcache + result.free;\n            result.active = result.total - result.free - result.buffcache;\n\n            result.swaptotal = 0;\n            result.swapfree = 0;\n            result.swapused = 0;\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        let pageSize = 4096;\n        try {\n          let sysPpageSize = util.toInt(execSync('sysctl -n vm.pagesize').toString());\n          pageSize = sysPpageSize || pageSize;\n        } catch (e) {\n          util.noop();\n        }\n        exec('vm_stat 2>/dev/null | grep \"Pages active\"', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            result.active = parseInt(lines[0].split(':')[1], 10) * pageSize;\n            result.buffcache = result.used - result.active;\n            result.available = result.free + result.buffcache;\n          }\n          exec('sysctl -n vm.swapusage 2>/dev/null', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              if (lines.length > 0) {\n                let firstline = lines[0].replace(/,/g, '.').replace(/M/g, '');\n                let lineArray = firstline.trim().split('  ');\n                lineArray.forEach(line => {\n                  if (line.toLowerCase().indexOf('total') !== -1) { result.swaptotal = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('used') !== -1) { result.swapused = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('free') !== -1) { result.swapfree = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                });\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      }\n      if (_windows) {\n        let swaptotal = 0;\n        let swapused = 0;\n        try {\n          util.powerShell('Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(/\\s\\s+/);\n                  swaptotal = swaptotal + (parseInt(line[0], 10) || 0);\n                  swapused = swapused + (parseInt(line[1], 10) || 0);\n                }\n              });\n            }\n            result.swaptotal = swaptotal * 1024 * 1024;\n            result.swapused = swapused * 1024 * 1024;\n            result.swapfree = result.swaptotal - result.swapused;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.mem = mem;\n\nfunction memLayout(callback) {\n\n  function getManufacturerDarwin(manId) {\n    if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {\n      return (OSX_RAM_manufacturers[manId]);\n    }\n    return manId;\n  }\n\n  function getManufacturerLinux(manId) {\n    const manIdSearch = manId.replace('0x', '').toUpperCase();\n    if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {\n      return (LINUX_RAM_manufacturers[manIdSearch]);\n    }\n    return manId;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = [];\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE \"Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number\"; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            let devices = stdout.toString().split('Memory Device');\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const sizeString = util.getValue(lines, 'Size');\n              const size = sizeString.indexOf('GB') >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;\n              let bank = util.getValue(lines, 'Bank Locator');\n              if (bank.toLowerCase().indexOf('bad') >= 0) {\n                bank = '';\n              }\n              if (parseInt(util.getValue(lines, 'Size'), 10) > 0) {\n                const totalWidth = util.toInt(util.getValue(lines, 'Total Width'));\n                const dataWidth = util.toInt(util.getValue(lines, 'Data Width'));\n                result.push({\n                  size,\n                  bank,\n                  type: util.getValue(lines, 'Type:'),\n                  ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                  clockSpeed: (util.getValue(lines, 'Configured Clock Speed:') ? parseInt(util.getValue(lines, 'Configured Clock Speed:'), 10) : (util.getValue(lines, 'Speed:') ? parseInt(util.getValue(lines, 'Speed:'), 10) : null)),\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  manufacturer: getManufacturerLinux(util.getValue(lines, 'Manufacturer:')),\n                  partNum: util.getValue(lines, 'Part Number:'),\n                  serialNum: util.getValue(lines, 'Serial Number:'),\n                  voltageConfigured: parseFloat(util.getValue(lines, 'Configured Voltage:')) || null,\n                  voltageMin: parseFloat(util.getValue(lines, 'Minimum Voltage:')) || null,\n                  voltageMax: parseFloat(util.getValue(lines, 'Maximum Voltage:')) || null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            result.push({\n              size: os.totalmem(),\n              bank: '',\n              type: '',\n              ecc: null,\n              clockSpeed: 0,\n              formFactor: '',\n              partNum: '',\n              serialNum: '',\n              voltageConfigured: null,\n              voltageMin: null,\n              voltageMax: null,\n            });\n\n            // Try Raspberry PI\n            try {\n              let stdout = execSync('cat /proc/cpuinfo 2>/dev/null');\n              let lines = stdout.toString().split('\\n');\n              let model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n              let version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n\n              if (model === 'BCM2835' || model === 'BCM2708' || model === 'BCM2709' || model === 'BCM2835' || model === 'BCM2837') {\n\n                const clockSpeed = {\n                  '0': 400,\n                  '1': 450,\n                  '2': 450,\n                  '3': 3200\n                };\n                result[0].type = 'LPDDR2';\n                result[0].type = version && version[2] && version[2] === '3' ? 'LPDDR4' : result[0].type;\n                result[0].ecc = false;\n                result[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;\n                result[0].clockSpeed = version && version[4] && version[4] === 'd' ? 500 : result[0].clockSpeed;\n                result[0].formFactor = 'SoC';\n\n                stdout = execSync('vcgencmd get_config sdram_freq 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let freq = parseInt(util.getValue(lines, 'sdram_freq', '=', true), 10) || 0;\n                if (freq) {\n                  result[0].clockSpeed = freq;\n                }\n\n                stdout = execSync('vcgencmd measure_volts sdram_p 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let voltage = parseFloat(util.getValue(lines, 'volt', '=', true)) || 0;\n                if (voltage) {\n                  result[0].voltageConfigured = voltage;\n                  result[0].voltageMin = voltage;\n                  result[0].voltageMax = voltage;\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('system_profiler SPMemoryDataType', function (error, stdout) {\n          if (!error) {\n            const allLines = stdout.toString().split('\\n');\n            const eccStatus = util.getValue(allLines, 'ecc', ':', true).toLowerCase();\n            let devices = stdout.toString().split('        BANK ');\n            let hasBank = true;\n            if (devices.length === 1) {\n              devices = stdout.toString().split('        DIMM');\n              hasBank = false;\n            }\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const bank = (hasBank ? 'BANK ' : 'DIMM') + lines[0].trim().split('/')[0];\n              const size = parseInt(util.getValue(lines, '          Size'));\n              if (size) {\n                result.push({\n                  size: size * 1024 * 1024 * 1024,\n                  bank: bank,\n                  type: util.getValue(lines, '          Type:'),\n                  ecc: eccStatus ? eccStatus === 'enabled' : null,\n                  clockSpeed: parseInt(util.getValue(lines, '          Speed:'), 10),\n                  formFactor: '',\n                  manufacturer: getManufacturerDarwin(util.getValue(lines, '          Manufacturer:')),\n                  partNum: util.getValue(lines, '          Part Number:'),\n                  serialNum: util.getValue(lines, '          Serial Number:'),\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank: bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: '',\n                  manufacturer: '',\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            const lines = stdout.toString().split('\\n');\n            const size = parseInt(util.getValue(lines, '      Memory:'));\n            const type = util.getValue(lines, '      Type:');\n            if (size && type) {\n              result.push({\n                size: size * 1024 * 1024 * 1024,\n                bank: '0',\n                type,\n                ecc: false,\n                clockSpeed: 0,\n                formFactor: '',\n                manufacturer: 'Apple',\n                partNum: '',\n                serialNum: '',\n                voltageConfigured: null,\n                voltageMin: null,\n                voltageMax: null,\n              });\n\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        const memoryTypes = 'Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4'.split('|');\n        const FormFactors = 'Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA'.split('|');\n\n        try {\n          util.powerShell('Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const dataWidth = util.toInt(util.getValue(lines, 'DataWidth', ':'));\n                const totalWidth = util.toInt(util.getValue(lines, 'TotalWidth', ':'));\n                const size = parseInt(util.getValue(lines, 'Capacity', ':'), 10) || 0;\n                if (size) {\n                  result.push({\n                    size,\n                    bank: util.getValue(lines, 'BankLabel', ':'), // BankLabel\n                    type: memoryTypes[parseInt(util.getValue(lines, 'MemoryType', ':'), 10) || parseInt(util.getValue(lines, 'SMBIOSMemoryType', ':'), 10)],\n                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                    clockSpeed: parseInt(util.getValue(lines, 'ConfiguredClockSpeed', ':'), 10) || parseInt(util.getValue(lines, 'Speed', ':'), 10) || 0,\n                    formFactor: FormFactors[parseInt(util.getValue(lines, 'FormFactor', ':'), 10) || 0],\n                    manufacturer: util.getValue(lines, 'Manufacturer', ':'),\n                    partNum: util.getValue(lines, 'PartNumber', ':'),\n                    serialNum: util.getValue(lines, 'SerialNumber', ':'),\n                    voltageConfigured: (parseInt(util.getValue(lines, 'ConfiguredVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMin: (parseInt(util.getValue(lines, 'MinVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMax: (parseInt(util.getValue(lines, 'MaxVoltage', ':'), 10) || 0) / 1000.0,\n                  });\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.memLayout = memLayout;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _network = {};\nlet _default_iface = '';\nlet _ifaces = {};\nlet _dhcpNics = [];\nlet _networkInterfaces = [];\nlet _mac = {};\nlet pathToIp;\n\nfunction getDefaultNetworkInterface() {\n\n  let ifacename = '';\n  let ifacenameFirst = '';\n  try {\n    let ifaces = os.networkInterfaces();\n\n    let scopeid = 9999;\n\n    // fallback - \"first\" external interface (sorted by scopeid)\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.internal === false) {\n            ifacenameFirst = ifacenameFirst || dev; // fallback if no scopeid\n            if (details.scopeid && details.scopeid < scopeid) {\n              ifacename = dev;\n              scopeid = details.scopeid;\n            }\n          }\n        });\n      }\n    }\n    ifacename = ifacename || ifacenameFirst || '';\n\n    if (_windows) {\n      // https://www.inetdaemon.com/tutorials/internet/ip/routing/default_route.shtml\n      let defaultIp = '';\n      const cmd = 'netstat -r';\n      const result = execSync(cmd, util.execOptsWin);\n      const lines = result.toString().split(os.EOL);\n      lines.forEach(line => {\n        line = line.replace(/\\s+/g, ' ').trim();\n        if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n          const parts = line.split(' ');\n          if (parts.length >= 5) {\n            defaultIp = parts[parts.length - 2];\n          }\n        }\n      });\n      if (defaultIp) {\n        for (let dev in ifaces) {\n          if ({}.hasOwnProperty.call(ifaces, dev)) {\n            ifaces[dev].forEach(function (details) {\n              if (details && details.address && details.address === defaultIp) {\n                ifacename = dev;\n              }\n            });\n          }\n        }\n      }\n    }\n    if (_linux) {\n      let cmd = 'ip route 2> /dev/null | grep default';\n      let result = execSync(cmd);\n      let parts = result.toString().split('\\n')[0].split(/\\s+/);\n      if (parts[0] === 'none' && parts[5]) {\n        ifacename = parts[5];\n      } else if (parts[4]) {\n        ifacename = parts[4];\n      }\n\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n    if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {\n      let cmd = '';\n      if (_linux) { cmd = 'ip route 2> /dev/null | grep default | awk \\'{print $5}\\''; }\n      if (_darwin) { cmd = 'route -n get default 2>/dev/null | grep interface: | awk \\'{print $2}\\''; }\n      if (_freebsd || _openbsd || _netbsd || _sunos) { cmd = 'route get 0.0.0.0 | grep interface:'; }\n      let result = execSync(cmd);\n      ifacename = result.toString().split('\\n')[0];\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n  } catch (e) {\n    util.noop();\n  }\n  if (ifacename) { _default_iface = ifacename; }\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  let iface = '';\n  let mac = '';\n  let result = {};\n  if (_linux || _freebsd || _openbsd || _netbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        const lines = execSync('which ip').toString().split('\\n');\n        if (lines.length && lines[0].indexOf(':') === -1 && lines[0].indexOf('/') === 0) {\n          pathToIp = lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n    try {\n      const cmd = 'export LC_ALL=C; ' + ((pathToIp) ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== ' ') {\n          if (pathToIp) {\n            let nextline = lines[i + 1].trim().split(' ');\n            if (nextline[0] === 'link/ether') {\n              iface = lines[i].split(' ')[1];\n              iface = iface.slice(0, iface.length - 1);\n              mac = nextline[1];\n            }\n          } else {\n            iface = lines[i].split(' ')[0];\n            mac = lines[i].split('HWaddr ')[1];\n          }\n\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_darwin) {\n    try {\n      const cmd = '/sbin/ifconfig';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== '\\t' && lines[i].indexOf(':') > 0) {\n          iface = lines[i].split(':')[0];\n        } else if (lines[i].indexOf('\\tether ') === 0) {\n          mac = lines[i].split('\\tether ')[1];\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction parseLinesWindowsNics(sections, nconfigsections) {\n  let nics = [];\n  for (let i in sections) {\n    if ({}.hasOwnProperty.call(sections, i)) {\n\n      if (sections[i].trim() !== '') {\n\n        let lines = sections[i].trim().split('\\r\\n');\n        let linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split('\\r\\n') : [];\n        let netEnabled = util.getValue(lines, 'NetEnabled', ':');\n        let adapterType = util.getValue(lines, 'AdapterTypeID', ':') === '9' ? 'wireless' : 'wired';\n        let ifacename = util.getValue(lines, 'Name', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        let iface = util.getValue(lines, 'NetConnectionID', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        if (ifacename.toLowerCase().indexOf('wi-fi') >= 0 || ifacename.toLowerCase().indexOf('wireless') >= 0) {\n          adapterType = 'wireless';\n        }\n        if (netEnabled !== '') {\n          const speed = parseInt(util.getValue(lines, 'speed', ':').trim(), 10) / 1000000;\n          nics.push({\n            mac: util.getValue(lines, 'MACAddress', ':').toLowerCase(),\n            dhcp: util.getValue(linesNicConfig, 'dhcpEnabled', ':').toLowerCase() === 'true',\n            name: ifacename,\n            iface,\n            netEnabled: netEnabled === 'TRUE',\n            speed: isNaN(speed) ? null : speed,\n            operstate: util.getValue(lines, 'NetConnectionStatus', ':') === '2' ? 'up' : 'down',\n            type: adapterType\n          });\n        }\n      }\n    }\n  }\n  return nics;\n}\n\nfunction getWindowsNics() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let cmd = 'Get-CimInstance Win32_NetworkAdapter | fl *' + '; echo \\'#-#-#-#\\';';\n      cmd += 'Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled' + '';\n      try {\n        util.powerShell(cmd).then((data) => {\n          data = data.split('#-#-#-#');\n          const nsections = (data[0] || '').split(/\\n\\s*\\n/);\n          const nconfigsections = (data[1] || '').split(/\\n\\s*\\n/);\n          resolve(parseLinesWindowsNics(nsections, nconfigsections));\n        });\n      } catch (e) {\n        resolve([]);\n      }\n    });\n  });\n}\n\nfunction getWindowsDNSsuffixes() {\n\n  let iface = {};\n\n  let dnsSuffixes = {\n    primaryDNS: '',\n    exitCode: 0,\n    ifaces: [],\n  };\n\n  try {\n    const ipconfig = execSync('ipconfig /all', util.execOptsWin);\n    const ipconfigArray = ipconfig.split('\\r\\n\\r\\n');\n\n    ipconfigArray.forEach((element, index) => {\n\n      if (index == 1) {\n        const longPrimaryDNS = element.split('\\r\\n').filter((element) => {\n          return element.toUpperCase().includes('DNS');\n        });\n        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(':') + 1);\n        dnsSuffixes.primaryDNS = primaryDNS.trim();\n        if (!dnsSuffixes.primaryDNS) { dnsSuffixes.primaryDNS = 'Not defined'; }\n      }\n      if (index > 1) {\n        if (index % 2 == 0) {\n          const name = element.substring(element.lastIndexOf(' ') + 1).replace(':', '');\n          iface.name = name;\n        } else {\n          const connectionSpecificDNS = element.split('\\r\\n').filter((element) => {\n            return element.toUpperCase().includes('DNS');\n          });\n          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(':') + 1);\n          iface.dnsSuffix = dnsSuffix.trim();\n          dnsSuffixes.ifaces.push(iface);\n          iface = {};\n        }\n      }\n    });\n\n    return dnsSuffixes;\n  } catch (error) {\n    return {\n      primaryDNS: '',\n      exitCode: 0,\n      ifaces: [],\n    };\n  }\n}\n\nfunction getWindowsIfaceDNSsuffix(ifaces, ifacename) {\n  let dnsSuffix = '';\n  // Adding (.) to ensure ifacename compatibility when duplicated iface-names\n  const interfaceName = ifacename + '.';\n  try {\n    const connectionDnsSuffix = ifaces.filter((iface) => {\n      return interfaceName.includes(iface.name + '.');\n    }).map((iface) => iface.dnsSuffix);\n    if (connectionDnsSuffix[0]) {\n      dnsSuffix = connectionDnsSuffix[0];\n    }\n    if (!dnsSuffix) { dnsSuffix = ''; }\n    return dnsSuffix;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\n\nfunction getWindowsWiredProfilesInformation() {\n  try {\n    const result = execSync('netsh lan show profiles', util.execOptsWin);\n    const profileList = result.split('\\r\\nProfile on interface');\n    return profileList;\n  } catch (error) {\n    if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n      return 'Disabled';\n    }\n    return [];\n  }\n}\n\nfunction getWindowsWirelessIfaceSSID(interfaceName) {\n  try {\n    const result = execSync(`netsh wlan show  interface name=\"${interfaceName}\" | findstr \"SSID\"`, util.execOptsWin);\n    const SSID = result.split('\\r\\n').shift();\n    const parseSSID = SSID.split(':').pop();\n    return parseSSID;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\nfunction getWindowsIEEE8021x(connectionType, iface, ifaces) {\n  let i8021x = {\n    state: 'Unknown',\n    protocol: 'Unknown',\n  };\n\n  if (ifaces === 'Disabled') {\n    i8021x.state = 'Disabled';\n    i8021x.protocol = 'Not defined';\n    return i8021x;\n  }\n\n  if (connectionType == 'wired' && ifaces.length > 0) {\n    try {\n      // Get 802.1x information by interface name\n      const iface8021xInfo = ifaces.find((element) => {\n        return element.includes(iface + '\\r\\n');\n      });\n      const arrayIface8021xInfo = iface8021xInfo.split('\\r\\n');\n      const state8021x = arrayIface8021xInfo.find((element) => {\n        return element.includes('802.1x');\n      });\n\n      if (state8021x.includes('Disabled')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      } else if (state8021x.includes('Enabled')) {\n        const protocol8021x = arrayIface8021xInfo.find((element) => {\n          return element.includes('EAP');\n        });\n        i8021x.protocol = protocol8021x.split(':').pop();\n        i8021x.state = 'Enabled';\n      }\n    } catch (error) {\n      return i8021x;\n    }\n  } else if (connectionType == 'wireless') {\n\n    let i8021xState = '';\n    let i8021xProtocol = '';\n\n\n\n    try {\n      const SSID = getWindowsWirelessIfaceSSID(iface);\n      if (SSID !== 'Unknown') {\n        i8021xState = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"802.1X\"`, util.execOptsWin);\n        i8021xProtocol = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"EAP\"`, util.execOptsWin);\n      }\n\n      if (i8021xState.includes(':') && i8021xProtocol.includes(':')) {\n        i8021x.state = i8021xState.split(':').pop();\n        i8021x.protocol = i8021xProtocol.split(':').pop();\n      }\n    } catch (error) {\n      if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      }\n      return i8021x;\n    }\n  }\n\n  return i8021x;\n}\n\nfunction splitSectionsNics(lines) {\n  const result = [];\n  let section = [];\n  lines.forEach(function (line) {\n    if (!line.startsWith('\\t') && !line.startsWith(' ')) {\n      if (section.length) {\n        result.push(section);\n        section = [];\n      }\n    }\n    section.push(line);\n  });\n  if (section.length) {\n    result.push(section);\n  }\n  return result;\n}\n\nfunction parseLinesDarwinNics(sections) {\n  let nics = [];\n  sections.forEach(section => {\n    let nic = {\n      iface: '',\n      mtu: null,\n      mac: '',\n      ip6: '',\n      ip4: '',\n      speed: null,\n      type: '',\n      operstate: '',\n      duplex: '',\n      internal: false\n    };\n    const first = section[0];\n    nic.iface = first.split(':')[0].trim();\n    let parts = first.split('> mtu');\n    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;\n    if (isNaN(nic.mtu)) {\n      nic.mtu = null;\n    }\n    nic.internal = parts[0].toLowerCase().indexOf('loopback') > -1;\n    section.forEach(line => {\n      if (line.trim().startsWith('ether ')) {\n        nic.mac = line.split('ether ')[1].toLowerCase().trim();\n      }\n      if (line.trim().startsWith('inet6 ') && !nic.ip6) {\n        nic.ip6 = line.split('inet6 ')[1].toLowerCase().split('%')[0].split(' ')[0];\n      }\n      if (line.trim().startsWith('inet ') && !nic.ip4) {\n        nic.ip4 = line.split('inet ')[1].toLowerCase().split(' ')[0];\n      }\n    });\n    let speed = util.getValue(section, 'link rate');\n    nic.speed = speed ? parseFloat(speed) : null;\n    if (nic.speed === null) {\n      speed = util.getValue(section, 'uplink rate');\n      nic.speed = speed ? parseFloat(speed) : null;\n      if (nic.speed !== null && speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    } else {\n      if (speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    }\n    nic.type = util.getValue(section, 'type').toLowerCase().indexOf('wi-fi') > -1 ? 'wireless' : 'wired';\n    const operstate = util.getValue(section, 'status').toLowerCase();\n    nic.operstate = (operstate === 'active' ? 'up' : (operstate === 'inactive' ? 'down' : 'unknown'));\n    nic.duplex = util.getValue(section, 'media').toLowerCase().indexOf('half-duplex') > -1 ? 'half' : 'full';\n    if (nic.ip6 || nic.ip4 || nic.mac) {\n      nics.push(nic);\n    }\n  });\n  return nics;\n}\n\nfunction getDarwinNics() {\n  const cmd = '/sbin/ifconfig -v';\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    return (parseLinesDarwinNics(nsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getLinuxIfaceConnectionName(interfaceName) {\n  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;\n\n  try {\n    const result = execSync(cmd).toString();\n    const resultFormat = result.replace(/\\s+/g, ' ').trim();\n    const connectionNameLines = resultFormat.split(' ').slice(3);\n    const connectionName = connectionNameLines.join(' ');\n    return connectionName != '--' ? connectionName : '';\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction checkLinuxDCHPInterfaces(file) {\n  let result = [];\n  try {\n    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\\\|source'`;\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n\n    lines.forEach(line => {\n      const parts = line.replace(/\\s+/g, ' ').trim().split(' ');\n      if (parts.length >= 4) {\n        if (line.toLowerCase().indexOf(' inet ') >= 0 && line.toLowerCase().indexOf('dhcp') >= 0) {\n          result.push(parts[1]);\n        }\n      }\n      if (line.toLowerCase().includes('source')) {\n        let file = line.split(' ')[1];\n        result = result.concat(checkLinuxDCHPInterfaces(file));\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxDHCPNics() {\n  // alternate methods getting interfaces using DHCP\n  let cmd = 'ip a 2> /dev/null';\n  let result = [];\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    result = (parseLinuxDHCPNics(nsections));\n  } catch (e) {\n    util.noop();\n  }\n  try {\n    result = checkLinuxDCHPInterfaces('/etc/network/interfaces');\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction parseLinuxDHCPNics(sections) {\n  const result = [];\n  if (sections && sections.length) {\n    sections.forEach(lines => {\n      if (lines && lines.length) {\n        const parts = lines[0].split(':');\n        if (parts.length > 2) {\n          for (let line of lines) {\n            if (line.indexOf(' inet ') >= 0 && line.indexOf(' dynamic ') >= 0) {\n              const parts2 = line.split(' ');\n              const nic = parts2[parts2.length - 1].trim();\n              result.push(nic);\n              break;\n            }\n          }\n        }\n      }\n    });\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {\n  let result = false;\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.method;`;\n    try {\n      const lines = execSync(cmd).toString();\n      const resultFormat = lines.replace(/\\s+/g, ' ').trim();\n\n      let dhcStatus = resultFormat.split(' ').slice(1).toString();\n      switch (dhcStatus) {\n        case 'auto':\n          result = true;\n          break;\n\n        default:\n          result = false;\n          break;\n      }\n      return result;\n    } catch (e) {\n      return (DHCPNics.indexOf(iface) >= 0);\n    }\n  } else {\n    return (DHCPNics.indexOf(iface) >= 0);\n  }\n}\n\nfunction getDarwinIfaceDHCPstatus(iface) {\n  let result = false;\n  const cmd = `ipconfig getpacket \"${iface}\" 2>/dev/null | grep lease_time;`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    if (lines.length && lines[0].startsWith('lease_time')) {\n      result = true;\n    }\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDNSsuffix(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.dns-search;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const dnsSuffix = resultFormat.split(' ').slice(1).toString();\n      return dnsSuffix == '--' ? 'Not defined' : dnsSuffix;\n    } catch (e) {\n      return 'Unknown';\n    }\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xAuth(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep 802-1x.eap;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const authenticationProtocol = resultFormat.split(' ').slice(1).toString();\n\n\n      return authenticationProtocol == '--' ? '' : authenticationProtocol;\n    } catch (e) {\n      return 'Not defined';\n    }\n  } else {\n    return 'Not defined';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xState(authenticationProtocol) {\n  if (authenticationProtocol) {\n    if (authenticationProtocol == 'Not defined') {\n      return 'Disabled';\n    }\n    return 'Enabled';\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction testVirtualNic(iface, ifaceName, mac) {\n  const virtualMacs = ['00:00:00:00:00:00', '00:03:FF', '00:05:69', '00:0C:29', '00:0F:4B', '00:0F:4B', '00:13:07', '00:13:BE', '00:15:5d', '00:16:3E', '00:1C:42', '00:21:F6', '00:21:F6', '00:24:0B', '00:24:0B', '00:50:56', '00:A0:B1', '00:E0:C8', '08:00:27', '0A:00:27', '18:92:2C', '16:DF:49', '3C:F3:92', '54:52:00', 'FC:15:97'];\n  if (mac) {\n    return virtualMacs.filter(item => { return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length)); }).length > 0 ||\n      iface.toLowerCase().indexOf(' virtual ') > -1 ||\n      ifaceName.toLowerCase().indexOf(' virtual ') > -1 ||\n      iface.toLowerCase().indexOf('vethernet ') > -1 ||\n      ifaceName.toLowerCase().indexOf('vethernet ') > -1 ||\n      iface.toLowerCase().startsWith('veth') ||\n      ifaceName.toLowerCase().startsWith('veth') ||\n      iface.toLowerCase().startsWith('vboxnet') ||\n      ifaceName.toLowerCase().startsWith('vboxnet');\n  } else { return false; }\n}\n\nfunction networkInterfaces(callback, rescan, defaultString) {\n\n  if (typeof callback === 'string') {\n    defaultString = callback;\n    rescan = true;\n    callback = null;\n  }\n\n  if (typeof callback === 'boolean') {\n    rescan = callback;\n    callback = null;\n    defaultString = '';\n  }\n  if (typeof rescan === 'undefined') {\n    rescan = true;\n  }\n  defaultString = defaultString || '';\n  defaultString = '' + defaultString;\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let ifaces = os.networkInterfaces();\n\n      let result = [];\n      let nics = [];\n      let dnsSuffixes = [];\n      let nics8021xInfo = [];\n      // seperate handling in OSX\n      if (_darwin || _freebsd || _openbsd || _netbsd) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          const defaultInterface = getDefaultNetworkInterface();\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n\n          nics = getDarwinNics();\n\n\n          nics.forEach(nic => {\n\n            if ({}.hasOwnProperty.call(ifaces, nic.iface)) {\n              ifaces[nic.iface].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  nic.ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  nic.ip6subnet = details.netmask;\n                }\n              });\n            }\n\n            let ifaceSanitized = '';\n            const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(nic.iface);\n            for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n              if (s[i] !== undefined) {\n                ifaceSanitized = ifaceSanitized + s[i];\n              }\n            }\n\n            result.push({\n              iface: nic.iface,\n              ifaceName: nic.iface,\n              default: nic.iface === defaultInterface,\n              ip4: nic.ip4,\n              ip4subnet: nic.ip4subnet || '',\n              ip6: nic.ip6,\n              ip6subnet: nic.ip6subnet || '',\n              mac: nic.mac,\n              internal: nic.internal,\n              virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),\n              operstate: nic.operstate,\n              type: nic.type,\n              duplex: nic.duplex,\n              mtu: nic.mtu,\n              speed: nic.speed,\n              dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),\n              dnsSuffix: '',\n              ieee8021xAuth: '',\n              ieee8021xState: '',\n              carrierChanges: 0\n            });\n          });\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          _dhcpNics = getLinuxDHCPNics();\n          const defaultInterface = getDefaultNetworkInterface();\n          for (let dev in ifaces) {\n            let ip4 = '';\n            let ip4subnet = '';\n            let ip6 = '';\n            let ip6subnet = '';\n            let mac = '';\n            let duplex = '';\n            let mtu = '';\n            let speed = null;\n            let carrierChanges = 0;\n            let dhcp = false;\n            let dnsSuffix = '';\n            let ieee8021xAuth = '';\n            let ieee8021xState = '';\n            let type = '';\n\n            if ({}.hasOwnProperty.call(ifaces, dev)) {\n              let ifaceName = dev;\n              ifaces[dev].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  ip4 = details.address;\n                  ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  if (!ip6 || ip6.match(/^fe80::/i)) {\n                    ip6 = details.address;\n                    ip6subnet = details.netmask;\n                  }\n                }\n                mac = details.mac;\n                // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                  if (Object.keys(_mac).length === 0) {\n                    _mac = getMacAddresses();\n                  }\n                  mac = _mac[dev] || '';\n                }\n              });\n              let iface = dev.split(':')[0].trim().toLowerCase();\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n              const cmd = `echo -n \"addr_assign_type: \"; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;\n            echo -n \"address: \"; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;\n            echo -n \"addr_len: \"; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;\n            echo -n \"broadcast: \"; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;\n            echo -n \"carrier: \"; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;\n            echo -n \"carrier_changes: \"; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;\n            echo -n \"dev_id: \"; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;\n            echo -n \"dev_port: \"; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;\n            echo -n \"dormant: \"; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;\n            echo -n \"duplex: \"; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;\n            echo -n \"flags: \"; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;\n            echo -n \"gro_flush_timeout: \"; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;\n            echo -n \"ifalias: \"; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;\n            echo -n \"ifindex: \"; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;\n            echo -n \"iflink: \"; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;\n            echo -n \"link_mode: \"; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;\n            echo -n \"mtu: \"; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;\n            echo -n \"netdev_group: \"; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;\n            echo -n \"operstate: \"; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;\n            echo -n \"proto_down: \"; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;\n            echo -n \"speed: \"; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;\n            echo -n \"tx_queue_len: \"; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;\n            echo -n \"type: \"; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;\n            echo -n \"wireless: \"; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;\n            echo -n \"wirelessspeed: \"; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;\n\n              let lines = [];\n              try {\n                lines = execSync(cmd).toString().split('\\n');\n                const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);\n                dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);\n                dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);\n                ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);\n                ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);\n              } catch (e) {\n                util.noop();\n              }\n              duplex = util.getValue(lines, 'duplex');\n              duplex = duplex.startsWith('cat') ? '' : duplex;\n              mtu = parseInt(util.getValue(lines, 'mtu'), 10);\n              let myspeed = parseInt(util.getValue(lines, 'speed'), 10);\n              speed = isNaN(myspeed) ? null : myspeed;\n              let wirelessspeed = util.getValue(lines, 'wirelessspeed').split('tx bitrate: ');\n              if (speed === null && wirelessspeed.length === 2) {\n                myspeed = parseFloat(wirelessspeed[1]);\n                speed = isNaN(myspeed) ? null : myspeed;\n              }\n              carrierChanges = parseInt(util.getValue(lines, 'carrier_changes'), 10);\n              const operstate = util.getValue(lines, 'operstate');\n              type = operstate === 'up' ? (util.getValue(lines, 'wireless').trim() ? 'wireless' : 'wired') : 'unknown';\n              if (ifaceSanitized === 'lo' || ifaceSanitized.startsWith('bond')) { type = 'virtual'; }\n\n              let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n              if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                internal = true;\n              }\n              const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n              result.push({\n                iface: ifaceSanitized,\n                ifaceName,\n                default: iface === defaultInterface,\n                ip4,\n                ip4subnet,\n                ip6,\n                ip6subnet,\n                mac,\n                internal,\n                virtual,\n                operstate,\n                type,\n                duplex,\n                mtu,\n                speed,\n                dhcp,\n                dnsSuffix,\n                ieee8021xAuth,\n                ieee8021xState,\n                carrierChanges,\n              });\n            }\n          }\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          const defaultInterface = getDefaultNetworkInterface();\n\n          getWindowsNics().then(function (nics) {\n            nics.forEach(nic => {\n              let found = false;\n              Object.keys(ifaces).forEach(key => {\n                if (!found) {\n                  ifaces[key].forEach(value => {\n                    if (Object.keys(value).indexOf('mac') >= 0) {\n                      found = value['mac'] === nic.mac;\n                    }\n                  });\n                }\n              });\n\n              if (!found) {\n                ifaces[nic.name] = [{ mac: nic.mac }];\n              }\n            });\n            nics8021xInfo = getWindowsWiredProfilesInformation();\n            dnsSuffixes = getWindowsDNSsuffixes();\n            for (let dev in ifaces) {\n\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(dev);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n\n              let iface = dev;\n              let ip4 = '';\n              let ip4subnet = '';\n              let ip6 = '';\n              let ip6subnet = '';\n              let mac = '';\n              let duplex = '';\n              let mtu = '';\n              let speed = null;\n              let carrierChanges = 0;\n              let operstate = 'down';\n              let dhcp = false;\n              let dnsSuffix = '';\n              let ieee8021xAuth = '';\n              let ieee8021xState = '';\n              let type = '';\n\n              if ({}.hasOwnProperty.call(ifaces, dev)) {\n                let ifaceName = dev;\n                ifaces[dev].forEach(function (details) {\n                  if (details.family === 'IPv4' || details.family === 4) {\n                    ip4 = details.address;\n                    ip4subnet = details.netmask;\n                  }\n                  if (details.family === 'IPv6' || details.family === 6) {\n                    if (!ip6 || ip6.match(/^fe80::/i)) {\n                      ip6 = details.address;\n                      ip6subnet = details.netmask;\n                    }\n                  }\n                  mac = details.mac;\n                  // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                  const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                  if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                    if (Object.keys(_mac).length === 0) {\n                      _mac = getMacAddresses();\n                    }\n                    mac = _mac[dev] || '';\n                  }\n                });\n\n\n\n                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);\n                let foundFirst = false;\n                nics.forEach(detail => {\n                  if (detail.mac === mac && !foundFirst) {\n                    iface = detail.iface || iface;\n                    ifaceName = detail.name;\n                    dhcp = detail.dhcp;\n                    operstate = detail.operstate;\n                    speed = detail.speed;\n                    type = detail.type;\n                    foundFirst = true;\n                  }\n                });\n\n                if (dev.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('802.11n') >= 0 || ifaceName.toLowerCase().indexOf('wireless') >= 0 || ifaceName.toLowerCase().indexOf('wi-fi') >= 0 || ifaceName.toLowerCase().indexOf('wifi') >= 0) {\n                  type = 'wireless';\n                }\n\n                const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);\n                ieee8021xAuth = IEEE8021x.protocol;\n                ieee8021xState = IEEE8021x.state;\n                let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n                if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                  internal = true;\n                }\n                const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n                result.push({\n                  iface,\n                  ifaceName,\n                  default: iface === defaultInterface,\n                  ip4,\n                  ip4subnet,\n                  ip6,\n                  ip6subnet,\n                  mac,\n                  internal,\n                  virtual,\n                  operstate,\n                  type,\n                  duplex,\n                  mtu,\n                  speed,\n                  dhcp,\n                  dnsSuffix,\n                  ieee8021xAuth,\n                  ieee8021xState,\n                  carrierChanges,\n                });\n              }\n            }\n            _networkInterfaces = result;\n            if (defaultString.toLowerCase().indexOf('default') >= 0) {\n              result = result.filter(item => item.default);\n              if (result.length > 0) {\n                result = result[0];\n              } else {\n                result = [];\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {\n  let result = {\n    iface,\n    operstate,\n    rx_bytes,\n    rx_dropped,\n    rx_errors,\n    tx_bytes,\n    tx_dropped,\n    tx_errors,\n    rx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx_bytes - _network[iface].rx_bytes) >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;\n    result.tx_sec = (tx_bytes - _network[iface].tx_bytes) >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) { _network[iface] = {}; }\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = null;\n    _network[iface].tx_sec = null;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n  return result;\n}\n\nfunction networkStats(ifaces, callback) {\n\n  let ifacesArray = [];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(ifaces) && !callback) {\n        callback = ifaces;\n        ifacesArray = [getDefaultNetworkInterface()];\n      } else {\n        if (typeof ifaces !== 'string' && ifaces !== undefined) {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        ifaces = ifaces || getDefaultNetworkInterface();\n\n        ifaces.__proto__.toLowerCase = util.stringToLower;\n        ifaces.__proto__.replace = util.stringReplace;\n        ifaces.__proto__.trim = util.stringTrim;\n\n        ifaces = ifaces.trim().toLowerCase().replace(/,+/g, '|');\n        ifacesArray = ifaces.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (ifacesArray.length && ifacesArray[0].trim() === '*') {\n        ifacesArray = [];\n        networkInterfaces(false).then(allIFaces => {\n          for (let iface of allIFaces) {\n            ifacesArray.push(iface.iface);\n          }\n          networkStats(ifacesArray.join(',')).then(result => {\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      } else {\n        for (let iface of ifacesArray) {\n          workload.push(networkStatsSingle(iface.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction networkStatsSingle(iface) {\n\n  function parseLinesWindowsPerfData(sections) {\n    let perfData = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', ':').replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase(),\n            rx_bytes: parseInt(util.getValue(lines, 'BytesReceivedPersec', ':'), 10),\n            rx_errors: parseInt(util.getValue(lines, 'PacketsReceivedErrors', ':'), 10),\n            rx_dropped: parseInt(util.getValue(lines, 'PacketsReceivedDiscarded', ':'), 10),\n            tx_bytes: parseInt(util.getValue(lines, 'BytesSentPersec', ':'), 10),\n            tx_errors: parseInt(util.getValue(lines, 'PacketsOutboundErrors', ':'), 10),\n            tx_dropped: parseInt(util.getValue(lines, 'PacketsOutboundDiscarded', ':'), 10)\n          });\n        }\n      }\n    }\n    return perfData;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaceSanitized = '';\n      const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          ifaceSanitized = ifaceSanitized + s[i];\n        }\n      }\n\n      let result = {\n        iface: ifaceSanitized,\n        operstate: 'unknown',\n        rx_bytes: 0,\n        rx_dropped: 0,\n        rx_errors: 0,\n        tx_bytes: 0,\n        tx_dropped: 0,\n        tx_errors: 0,\n        rx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx_bytes = 0;\n      let tx_bytes = 0;\n      let rx_dropped = 0;\n      let rx_errors = 0;\n      let tx_dropped = 0;\n      let tx_errors = 0;\n\n      let cmd, lines, stats;\n      if (!_network[ifaceSanitized] || (_network[ifaceSanitized] && !_network[ifaceSanitized].ms) || (_network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + ifaceSanitized)) {\n            cmd =\n              'cat /sys/class/net/' + ifaceSanitized + '/operstate; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_errors; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_errors; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx_bytes = parseInt(lines[1], 10);\n                tx_bytes = parseInt(lines[2], 10);\n                rx_dropped = parseInt(lines[3], 10);\n                rx_errors = parseInt(lines[4], 10);\n                tx_dropped = parseInt(lines[5], 10);\n                tx_errors = parseInt(lines[6], 10);\n\n                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n\n              }\n              resolve(result);\n            });\n          } else {\n            resolve(result);\n          }\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'netstat -ibndI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n              for (let i = 1; i < lines.length; i++) {\n                const line = lines[i].replace(/ +/g, ' ').split(' ');\n                if (line && line[0] && line[7] && line[10]) {\n                  rx_bytes = rx_bytes + parseInt(line[7]);\n                  if (line[6].trim() !== '-') { rx_dropped = rx_dropped + parseInt(line[6]); }\n                  if (line[5].trim() !== '-') { rx_errors = rx_errors + parseInt(line[5]); }\n                  tx_bytes = tx_bytes + parseInt(line[10]);\n                  if (line[12].trim() !== '-') { tx_dropped = tx_dropped + parseInt(line[12]); }\n                  if (line[9].trim() !== '-') { tx_errors = tx_errors + parseInt(line[9]); }\n                  operstate = 'up';\n                }\n              }\n              result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n            }\n            resolve(result);\n          });\n        }\n        if (_darwin) {\n          cmd = 'ifconfig ' + ifaceSanitized + ' | grep \"status\"';    // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = 'netstat -bdI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  const offset = stats.length > 11 ? 1 : 0;\n                  rx_bytes = parseInt(stats[offset + 5]);\n                  rx_dropped = parseInt(stats[offset + 10]);\n                  rx_errors = parseInt(stats[offset + 4]);\n                  tx_bytes = parseInt(stats[offset + 8]);\n                  tx_dropped = parseInt(stats[offset + 10]);\n                  tx_errors = parseInt(stats[offset + 7]);\n                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n                }\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_windows) {\n          let perfData = [];\n          let ifaceName = ifaceSanitized;\n\n          // Performance Data\n          util.powerShell('Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl').then((stdout, error) => {\n            if (!error) {\n              const psections = stdout.toString().split(/\\n\\s*\\n/);\n              perfData = parseLinesWindowsPerfData(psections);\n            }\n\n            // Network Interfaces\n            networkInterfaces(false).then(interfaces => {\n              // get bytes sent, received from perfData by name\n              rx_bytes = 0;\n              tx_bytes = 0;\n              perfData.forEach(detail => {\n                interfaces.forEach(det => {\n                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.mac.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === ifaceSanitized.replace(/[()[\\] ]+/g, '').replace('#', '_').toLowerCase()) &&\n                    (det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === detail.name)) {\n                    ifaceName = det.iface;\n                    rx_bytes = detail.rx_bytes;\n                    rx_dropped = detail.rx_dropped;\n                    rx_errors = detail.rx_errors;\n                    tx_bytes = detail.tx_bytes;\n                    tx_dropped = detail.tx_dropped;\n                    tx_errors = detail.tx_errors;\n                    operstate = det.operstate;\n                  }\n                });\n              });\n              if (rx_bytes && tx_bytes) {\n                result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n              }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx_bytes = _network[ifaceSanitized].rx_bytes;\n        result.tx_bytes = _network[ifaceSanitized].tx_bytes;\n        result.rx_sec = _network[ifaceSanitized].rx_sec;\n        result.tx_sec = _network[ifaceSanitized].tx_sec;\n        result.ms = _network[ifaceSanitized].last_ms;\n        result.operstate = _network[ifaceSanitized].operstate;\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction getProcessName(processes, pid) {\n  let cmd = '';\n  processes.forEach(line => {\n    const parts = line.split(' ');\n    const id = parseInt(parts[0], 10) || -1;\n    if (id === pid) {\n      parts.shift();\n      cmd = parts.join(' ').split(':')[0];\n    }\n  });\n  cmd = cmd.split(' -')[0];\n  // return cmd;\n  const cmdParts = cmd.split('/');\n  return cmdParts[cmdParts.length - 1];\n}\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'export LC_ALL=C; netstat -tunap | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL'; }\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          if (!error && (lines.length > 1 || lines[0] != '')) {\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 7) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                let proc = line[6].split('/');\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localAddress: localip,\n                    localPort: localport,\n                    peerAddress: peerip,\n                    peerPort: peerport,\n                    state: connstate,\n                    pid: proc[0] && proc[0] !== '-' ? parseInt(proc[0], 10) : null,\n                    process: proc[1] ? proc[1].split(' ')[0].split(':')[0] : ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            cmd = 'ss -tunap | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') { connstate = 'ESTABLISHED'; }\n                    if (connstate === 'TIME-WAIT') { connstate = 'TIME_WAIT'; }\n                    let pid = null;\n                    let process = '';\n                    if (line.length >= 7 && line[6].indexOf('users:') > -1) {\n                      let proc = line[6].replace('users:((\"', '').replace(/\"/g, '').split(',');\n                      if (proc.length > 2) {\n                        process = proc[0].split(' ')[0].split(':')[0];\n                        pid = parseInt(proc[1], 10);\n                      }\n                    }\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localAddress: localip,\n                        localPort: localport,\n                        peerAddress: peerip,\n                        peerPort: peerport,\n                        state: connstate,\n                        pid,\n                        process\n                      });\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        // let cmd = 'netstat -natv | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        let cmd = 'netstat -natv | grep \"tcp4\\\\|tcp6\\\\|udp4\\\\|udp6\"';\n        const states = 'ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          if (!error) {\n            exec('ps -axo pid,command', { maxBuffer: 1024 * 20000 }, function (err2, stdout2) {\n              let processes = stdout2.toString().split('\\n');\n              processes = processes.map((line => { return line.trim().replace(/ +/g, ' '); }));\n              let lines = stdout.toString().split('\\n');\n\n              lines.forEach(function (line) {\n                line = line.replace(/ +/g, ' ').split(' ');\n                if (line.length >= 8) {\n                  let localip = line[3];\n                  let localport = '';\n                  let localaddress = line[3].split('.');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join('.');\n                  }\n                  let peerip = line[4];\n                  let peerport = '';\n                  let peeraddress = line[4].split('.');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join('.');\n                  }\n                  const hasState = states.indexOf(line[5]) >= 0;\n                  let connstate = hasState ? line[5] : 'UNKNOWN';\n                  let pid = parseInt(line[8 + (hasState ? 0 : -1)], 10);\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0],\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid: pid,\n                      process: getProcessName(processes, pid)\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n\n          }\n        });\n      }\n      if (_windows) {\n        let cmd = 'netstat -nao';\n        try {\n          exec(cmd, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n\n              let lines = stdout.toString().split('\\r\\n');\n\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n                if (line.length >= 4) {\n                  let localip = line[1];\n                  let localport = '';\n                  let localaddress = line[1].split(':');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n                  localip = localip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let peerip = line[2];\n                  let peerport = '';\n                  let peeraddress = line[2].split(':');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n                  peerip = peerip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let pid = util.toInt(line[4]);\n                  let connstate = line[3];\n                  if (connstate === 'HERGESTELLT') { connstate = 'ESTABLISHED'; }\n                  if (connstate.startsWith('ABH')) { connstate = 'LISTEN'; }\n                  if (connstate === 'SCHLIESSEN_WARTEN') { connstate = 'CLOSE_WAIT'; }\n                  if (connstate === 'WARTEND') { connstate = 'TIME_WAIT'; }\n                  if (connstate === 'SYN_GESENDET') { connstate = 'SYN_SENT'; }\n\n                  if (connstate === 'LISTENING') { connstate = 'LISTEN'; }\n                  if (connstate === 'SYN_RECEIVED') { connstate = 'SYN_RECV'; }\n                  if (connstate === 'FIN_WAIT_1') { connstate = 'FIN_WAIT1'; }\n                  if (connstate === 'FIN_WAIT_2') { connstate = 'FIN_WAIT2'; }\n                  if (line[0].toLowerCase() !== 'udp' && connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid,\n                      process: ''\n                    });\n                  } else if (line[0].toLowerCase() === 'udp') {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: '',\n                      pid: parseInt(line[3], 10),\n                      process: ''\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n\nfunction networkGatewayDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'ip route get 1';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              const line = lines && lines[0] ? lines[0] : '';\n              let parts = line.split(' via ');\n              if (parts && parts[1]) {\n                parts = parts[1].split(' ');\n                result = parts[0];\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        let cmd = 'route -n get default';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n').map(line => line.trim());\n              result = util.getValue(lines, 'gateway');\n            }\n            if (!result) {\n              cmd = 'netstat -rn | awk \\'/default/ {print $2}\\'';\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                const lines = stdout.toString().split('\\n').map(line => line.trim());\n                result = lines.find(line => (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line)));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        try {\n          exec('netstat -r', util.execOptsWin, function (error, stdout) {\n            const lines = stdout.toString().split(os.EOL);\n            lines.forEach(line => {\n              line = line.replace(/\\s+/g, ' ').trim();\n              if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n                const parts = line.split(' ');\n                if (parts.length >= 5 && (parts[parts.length - 3]).indexOf('.') > -1) {\n                  result = parts[parts.length - 3];\n                }\n              }\n            });\n            if (!result) {\n              util.powerShell('Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \\'0.0.0.0\\' -and $_.Mask -eq \\'0.0.0.0\\' }')\n                .then((data) => {\n                  let lines = data.toString().split('\\r\\n');\n                  if (lines.length > 1 && !result) {\n                    result = util.getValue(lines, 'NextHop');\n                    if (callback) {\n                      callback(result);\n                    }\n                    resolve(result);\n                    // } else {\n                    //   exec('ipconfig', util.execOptsWin, function (error, stdout) {\n                    //     let lines = stdout.toString().split('\\r\\n');\n                    //     lines.forEach(function (line) {\n                    //       line = line.trim().replace(/\\. /g, '');\n                    //       line = line.trim().replace(/ +/g, '');\n                    //       const parts = line.split(':');\n                    //       if ((parts[0].toLowerCase().startsWith('standardgate') || parts[0].toLowerCase().indexOf('gateway') > -1 || parts[0].toLowerCase().indexOf('enlace') > -1) && parts[1]) {\n                    //         result = parts[1];\n                    //       }\n                    //     });\n                    //     if (callback) { callback(result); }\n                    //     resolve(result);\n                    //   });\n                  }\n                });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkGatewayDefault = networkGatewayDefault;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// osinfo.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 3. Operating System\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// Get current time and OS uptime\n\nfunction time() {\n  let t = new Date().toString().split(' ');\n  return {\n    current: Date.now(),\n    uptime: os.uptime(),\n    timezone: (t.length >= 7) ? t[5] : '',\n    timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : (t.length >= 7) ? t.slice(6).join(' ').replace(/\\(/g, '').replace(/\\)/g, '') : ''\n  };\n}\n\nexports.time = time;\n\n// --------------------------\n// Get logo filename of OS distribution\n\nfunction getLogoFile(distro) {\n  distro = distro || '';\n  distro = distro.toLowerCase();\n  let result = _platform;\n  if (_windows) {\n    result = 'windows';\n  }\n  else if (distro.indexOf('mac os') !== -1) {\n    result = 'apple';\n  }\n  else if (distro.indexOf('arch') !== -1) {\n    result = 'arch';\n  }\n  else if (distro.indexOf('centos') !== -1) {\n    result = 'centos';\n  }\n  else if (distro.indexOf('coreos') !== -1) {\n    result = 'coreos';\n  }\n  else if (distro.indexOf('debian') !== -1) {\n    result = 'debian';\n  }\n  else if (distro.indexOf('deepin') !== -1) {\n    result = 'deepin';\n  }\n  else if (distro.indexOf('elementary') !== -1) {\n    result = 'elementary';\n  }\n  else if (distro.indexOf('fedora') !== -1) {\n    result = 'fedora';\n  }\n  else if (distro.indexOf('gentoo') !== -1) {\n    result = 'gentoo';\n  }\n  else if (distro.indexOf('mageia') !== -1) {\n    result = 'mageia';\n  }\n  else if (distro.indexOf('mandriva') !== -1) {\n    result = 'mandriva';\n  }\n  else if (distro.indexOf('manjaro') !== -1) {\n    result = 'manjaro';\n  }\n  else if (distro.indexOf('mint') !== -1) {\n    result = 'mint';\n  }\n  else if (distro.indexOf('mx') !== -1) {\n    result = 'mx';\n  }\n  else if (distro.indexOf('openbsd') !== -1) {\n    result = 'openbsd';\n  }\n  else if (distro.indexOf('freebsd') !== -1) {\n    result = 'freebsd';\n  }\n  else if (distro.indexOf('opensuse') !== -1) {\n    result = 'opensuse';\n  }\n  else if (distro.indexOf('pclinuxos') !== -1) {\n    result = 'pclinuxos';\n  }\n  else if (distro.indexOf('puppy') !== -1) {\n    result = 'puppy';\n  }\n  else if (distro.indexOf('raspbian') !== -1) {\n    result = 'raspbian';\n  }\n  else if (distro.indexOf('reactos') !== -1) {\n    result = 'reactos';\n  }\n  else if (distro.indexOf('redhat') !== -1) {\n    result = 'redhat';\n  }\n  else if (distro.indexOf('slackware') !== -1) {\n    result = 'slackware';\n  }\n  else if (distro.indexOf('sugar') !== -1) {\n    result = 'sugar';\n  }\n  else if (distro.indexOf('steam') !== -1) {\n    result = 'steam';\n  }\n  else if (distro.indexOf('suse') !== -1) {\n    result = 'suse';\n  }\n  else if (distro.indexOf('mate') !== -1) {\n    result = 'ubuntu-mate';\n  }\n  else if (distro.indexOf('lubuntu') !== -1) {\n    result = 'lubuntu';\n  }\n  else if (distro.indexOf('xubuntu') !== -1) {\n    result = 'xubuntu';\n  }\n  else if (distro.indexOf('ubuntu') !== -1) {\n    result = 'ubuntu';\n  }\n  else if (distro.indexOf('solaris') !== -1) {\n    result = 'solaris';\n  }\n  else if (distro.indexOf('tails') !== -1) {\n    result = 'tails';\n  }\n  else if (distro.indexOf('feren') !== -1) {\n    result = 'ferenos';\n  }\n  else if (distro.indexOf('robolinux') !== -1) {\n    result = 'robolinux';\n  } else if (_linux && distro) {\n    result = distro.toLowerCase().trim().replace(/\\s+/g, '-');\n  }\n  return result;\n}\n\n// --------------------------\n// FQDN\n\nfunction getFQDN() {\n  let fqdn = os.hostname;\n  if (_linux || _darwin) {\n    try {\n      const stdout = execSync('hostname -f');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_freebsd || _openbsd || _netbsd) {\n    try {\n      const stdout = execSync('hostname');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_windows) {\n    try {\n      const stdout = execSync('echo %COMPUTERNAME%.%USERDNSDOMAIN%', util.execOptsWin);\n      fqdn = stdout.toString().replace('.%USERDNSDOMAIN%', '').split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return fqdn;\n}\n\n// --------------------------\n// OS Information\n\nfunction osInfo(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n\n        platform: (_platform === 'win32' ? 'Windows' : _platform),\n        distro: 'unknown',\n        release: 'unknown',\n        codename: '',\n        kernel: os.release(),\n        arch: os.arch(),\n        hostname: os.hostname(),\n        fqdn: getFQDN(),\n        codepage: '',\n        logofile: '',\n        serial: '',\n        build: '',\n        servicepack: '',\n        uefi: false\n      };\n\n      if (_linux) {\n\n        exec('cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release', function (error, stdout) {\n          /**\n           * @namespace\n           * @property {string}  DISTRIB_ID\n           * @property {string}  NAME\n           * @property {string}  DISTRIB_RELEASE\n           * @property {string}  VERSION_ID\n           * @property {string}  DISTRIB_CODENAME\n           */\n          let release = {};\n          let lines = stdout.toString().split('\\n');\n          lines.forEach(function (line) {\n            if (line.indexOf('=') !== -1) {\n              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();\n            }\n          });\n          let releaseVersion = (release.VERSION || '').replace(/\"/g, '');\n          let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || '').replace(/\"/g, '');\n          if (releaseVersion.indexOf('(') >= 0) {\n            codename = releaseVersion.split('(')[1].replace(/[()]/g, '').trim();\n            releaseVersion = releaseVersion.split('(')[0].trim();\n          }\n          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/\"/g, '');\n          result.logofile = getLogoFile(result.distro);\n          result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/\"/g, '');\n          result.codename = codename;\n          result.codepage = util.getCodepage();\n          result.build = (release.BUILD_ID || '').replace(/\"/g, '').trim();\n          isUefiLinux().then(uefi => {\n            result.uefi = uefi;\n            uuid().then((data) => {\n              result.serial = data.os;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n\n        exec('sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const distro = util.getValue(lines, 'kern.ostype');\n          const logofile = util.getValue(lines, 'kern.ostype');\n          const release = util.getValue(lines, 'kern.osrelease').split('-')[0];\n          const serial = util.getValue(lines, 'kern.uuid');\n          const bootmethod = util.getValue(lines, 'machdep.bootmethod');\n          const uefiConf = stdout.toString().indexOf('<type>efi</type>') >= 0;\n          const uefi = bootmethod ? bootmethod.toLowerCase().indexOf('uefi') >= 0 : (uefiConf ? uefiConf : null);\n          result.distro = distro || result.distro;\n          result.logofile = logofile || result.logofile;\n          result.release = release || result.release;\n          result.serial = serial || result.serial;\n          result.codename = '';\n          result.codepage = util.getCodepage();\n          result.uefi = uefi || null;\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.serial = util.getValue(lines, 'kern.uuid');\n          result.distro = util.getValue(lines, 'ProductName');\n          result.release = util.getValue(lines, 'ProductVersion');\n          result.build = util.getValue(lines, 'BuildVersion');\n          result.logofile = getLogoFile(result.distro);\n          result.codename = 'macOS';\n          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);\n          result.codename = (result.release.indexOf('10.5') > -1 ? 'Mac OS X Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.6') > -1 ? 'Mac OS X Snow Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.7') > -1 ? 'Mac OS X Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.8') > -1 ? 'OS X Mountain Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.9') > -1 ? 'OS X Mavericks' : result.codename);\n          result.codename = (result.release.indexOf('10.10') > -1 ? 'OS X Yosemite' : result.codename);\n          result.codename = (result.release.indexOf('10.11') > -1 ? 'OS X El Capitan' : result.codename);\n          result.codename = (result.release.indexOf('10.12') > -1 ? 'macOS Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.13') > -1 ? 'macOS High Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.14') > -1 ? 'macOS Mojave' : result.codename);\n          result.codename = (result.release.indexOf('10.15') > -1 ? 'macOS Catalina' : result.codename);\n          result.codename = (result.release.startsWith('11.') ? 'macOS Big Sur' : result.codename);\n          result.codename = (result.release.startsWith('12.') ? 'macOS Monterey' : result.codename);\n          result.codename = (result.release.startsWith('13.') ? 'macOS Ventura' : result.codename);\n          result.uefi = true;\n          result.codepage = util.getCodepage();\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        result.release = result.kernel;\n        exec('uname -o', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.distro = lines[0];\n          result.logofile = getLogoFile(result.distro);\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        result.logofile = getLogoFile();\n        result.release = result.kernel;\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl'));\n          workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n            result.distro = util.getValue(lines, 'Caption', ':').trim();\n            result.serial = util.getValue(lines, 'SerialNumber', ':').trim();\n            result.build = util.getValue(lines, 'BuildNumber', ':').trim();\n            result.servicepack = util.getValue(lines, 'ServicePackMajorVersion', ':').trim() + '.' + util.getValue(lines, 'ServicePackMinorVersion', ':').trim();\n            result.codepage = util.getCodepage();\n            const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : '';\n            result.hypervisor = hyperv.indexOf('true') !== -1;\n            const term = data.results[2] ? data.results[2].toString() : '';\n            result.remoteSession = (term.toString().toLowerCase().indexOf('true') >= 0);\n            isUefiWindows().then(uefi => {\n              result.uefi = uefi;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.osInfo = osInfo;\n\nfunction isUefiLinux() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      fs.stat('/sys/firmware/efi', function (err) {\n        if (!err) {\n          return resolve(true);\n        } else {\n          exec('dmesg | grep -E \"EFI v\"', function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n');\n              return resolve(lines.length > 0);\n            }\n            return resolve(false);\n          });\n        }\n      });\n    });\n  });\n}\n\nfunction isUefiWindows() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec('findstr /C:\"Detected boot environment\" \"%windir%\\\\Panther\\\\setupact.log\"', util.execOptsWin, function (error, stdout) {\n          if (!error) {\n            const line = stdout.toString().split('\\n\\r')[0];\n            return resolve(line.toLowerCase().indexOf('efi') >= 0);\n          } else {\n            exec('echo %firmware_type%', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                const line = stdout.toString() || '';\n                return resolve(line.toLowerCase().indexOf('efi') >= 0);\n              } else {\n                return resolve(false);\n              }\n            });\n          }\n        });\n      } catch (e) {\n        return resolve(false);\n      }\n    });\n  });\n}\n\nfunction versions(apps, callback) {\n  let versionObject = {\n    kernel: os.release(),\n    openssl: '',\n    systemOpenssl: '',\n    systemOpensslLib: '',\n    node: process.versions.node,\n    v8: process.versions.v8,\n    npm: '',\n    yarn: '',\n    pm2: '',\n    gulp: '',\n    grunt: '',\n    git: '',\n    tsc: '',\n    mysql: '',\n    redis: '',\n    mongodb: '',\n    apache: '',\n    nginx: '',\n    php: '',\n    docker: '',\n    postfix: '',\n    postgresql: '',\n    perl: '',\n    python: '',\n    python3: '',\n    pip: '',\n    pip3: '',\n    java: '',\n    gcc: '',\n    virtualbox: '',\n    bash: '',\n    zsh: '',\n    fish: '',\n    powershell: '',\n    dotnet: ''\n  };\n\n  function checkVersionParam(apps) {\n    if (apps === '*') {\n      return {\n        versions: versionObject,\n        counter: 30\n      };\n    }\n    if (!Array.isArray(apps)) {\n      apps = apps.trim().toLowerCase().replace(/,+/g, '|').replace(/ /g, '|');\n      apps = apps.split('|');\n      const result = {\n        versions: {},\n        counter: 0\n      };\n      apps.forEach(el => {\n        if (el) {\n          for (let key in versionObject) {\n            if ({}.hasOwnProperty.call(versionObject, key)) {\n              if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {\n                result.versions[key] = versionObject[key];\n                if (key === 'openssl') {\n                  result.versions.systemOpenssl = '';\n                  result.versions.systemOpensslLib = '';\n                }\n\n                if (!result.versions[key]) { result.counter++; }\n              }\n            }\n          }\n        }\n      });\n      return result;\n    }\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (util.isFunction(apps) && !callback) {\n        callback = apps;\n        apps = '*';\n      } else {\n        apps = apps || '*';\n        if (typeof apps !== 'string') {\n          if (callback) { callback({}); }\n          return resolve({});\n        }\n      }\n      const appsObj = checkVersionParam(apps);\n      let totalFunctions = appsObj.counter;\n\n      let functionProcessed = (function () {\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(appsObj.versions);\n            }\n            resolve(appsObj.versions);\n          }\n        };\n      })();\n\n      let cmd = '';\n      try {\n        if ({}.hasOwnProperty.call(appsObj.versions, 'openssl')) {\n          appsObj.versions.openssl = process.versions.openssl;\n          exec('openssl version', function (error, stdout) {\n            if (!error) {\n              let openssl_string = stdout.toString().split('\\n')[0].trim();\n              let openssl = openssl_string.split(' ');\n              appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];\n              appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : 'openssl';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'npm')) {\n          exec('npm -v', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.npm = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pm2')) {\n          cmd = 'pm2';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} -v`, function (error, stdout) {\n            if (!error) {\n              let pm2 = stdout.toString().split('\\n')[0].trim();\n              if (!pm2.startsWith('[PM2]')) {\n                appsObj.versions.pm2 = pm2;\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'yarn')) {\n          exec('yarn --version', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.yarn = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gulp')) {\n          cmd = 'gulp';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const gulp = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.gulp = (gulp.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'tsc')) {\n          cmd = 'tsc';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const tsc = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.tsc = (tsc.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'grunt')) {\n          cmd = 'grunt';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const grunt = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.grunt = (grunt.toLowerCase().split('cli v')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'git')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/git') || fs.existsSync('/opt/homebrew/bin/git');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('git --version', function (error, stdout) {\n                if (!error) {\n                  let git = stdout.toString().split('\\n')[0] || '';\n                  git = (git.toLowerCase().split('version')[1] || '').trim();\n                  appsObj.versions.git = (git.split(' ')[0] || '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('git --version', function (error, stdout) {\n              if (!error) {\n                let git = stdout.toString().split('\\n')[0] || '';\n                git = (git.toLowerCase().split('version')[1] || '').trim();\n                appsObj.versions.git = (git.split(' ')[0] || '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'apache')) {\n          exec('apachectl -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const apache = (stdout.toString().split('\\n')[0] || '').split(':');\n              appsObj.versions.apache = (apache.length > 1 ? apache[1].replace('Apache', '').replace('/', '').split('(')[0].trim() : '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'nginx')) {\n          exec('nginx -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const nginx = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.nginx = (nginx.toLowerCase().split('/')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mysql')) {\n          exec('mysql -V', function (error, stdout) {\n            if (!error) {\n              let mysql = stdout.toString().split('\\n')[0] || '';\n              mysql = mysql.toLowerCase();\n              if (mysql.indexOf(',') > -1) {\n                mysql = (mysql.split(',')[0] || '').trim();\n                const parts = mysql.split(' ');\n                appsObj.versions.mysql = (parts[parts.length - 1] || '').trim();\n              } else {\n                if (mysql.indexOf(' ver ') > -1) {\n                  mysql = mysql.split(' ver ')[1];\n                  appsObj.versions.mysql = mysql.split(' ')[0];\n                }\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'php')) {\n          exec('php -v', function (error, stdout) {\n            if (!error) {\n              const php = stdout.toString().split('\\n')[0] || '';\n              let parts = php.split('(');\n              if (parts[0].indexOf('-')) {\n                parts = parts[0].split('-');\n              }\n              appsObj.versions.php = parts[0].replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'redis')) {\n          exec('redis-server --version', function (error, stdout) {\n            if (!error) {\n              const redis = stdout.toString().split('\\n')[0] || '';\n              const parts = redis.split(' ');\n              appsObj.versions.redis = util.getValue(parts, 'v', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'docker')) {\n          exec('docker --version', function (error, stdout) {\n            if (!error) {\n              const docker = stdout.toString().split('\\n')[0] || '';\n              const parts = docker.split(' ');\n              appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(',') ? parts[2].slice(0, -1) : '';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postfix')) {\n          exec('postconf -d | grep mail_version', function (error, stdout) {\n            if (!error) {\n              const postfix = stdout.toString().split('\\n') || [];\n              appsObj.versions.postfix = util.getValue(postfix, 'mail_version', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mongodb')) {\n          exec('mongod --version', function (error, stdout) {\n            if (!error) {\n              const mongodb = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.mongodb = (mongodb.toLowerCase().split(',')[0] || '').replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postgresql')) {\n          if (_linux) {\n            exec('locate bin/postgres', function (error, stdout) {\n              if (!error) {\n                const postgresqlBin = stdout.toString().split('\\n').sort();\n                if (postgresqlBin.length) {\n                  exec(postgresqlBin[postgresqlBin.length - 1] + ' -V', function (error, stdout) {\n                    if (!error) {\n                      const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    }\n                    functionProcessed();\n                  });\n                } else {\n                  functionProcessed();\n                }\n              } else {\n                exec('psql -V', function (error, stdout) {\n                  if (!error) {\n                    const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    appsObj.versions.postgresql = appsObj.versions.postgresql.split('-')[0];\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            if (_windows) {\n              util.powerShell('Get-CimInstance Win32_Service | select caption | fl').then((stdout) => {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((item) => {\n                  if (item.trim() !== '') {\n                    let lines = item.trim().split('\\r\\n');\n                    let srvCaption = util.getValue(lines, 'caption', ':', true).toLowerCase();\n                    if (srvCaption.indexOf('postgresql') > -1) {\n                      const parts = srvCaption.split(' server ');\n                      if (parts.length > 1) {\n                        appsObj.versions.postgresql = parts[1];\n                      }\n                    }\n                  }\n                });\n                functionProcessed();\n              });\n            } else {\n              exec('postgres -V', function (error, stdout) {\n                if (!error) {\n                  const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                  appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                }\n                functionProcessed();\n              });\n            }\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'perl')) {\n          exec('perl -v', function (error, stdout) {\n            if (!error) {\n              const perl = stdout.toString().split('\\n') || '';\n              while (perl.length > 0 && perl[0].trim() === '') {\n                perl.shift();\n              }\n              if (perl.length > 0) {\n                appsObj.versions.perl = perl[0].split('(').pop().split(')')[0].replace('v', '');\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python')) {\n          if (_darwin) {\n            const stdout = execSync('sw_vers');\n            const lines = stdout.toString().split('\\n');\n            const osVersion = util.getValue(lines, 'ProductVersion', ':');\n            const gitHomebrewExists1 = fs.existsSync('/usr/local/Cellar/python');\n            const gitHomebrewExists2 = fs.existsSync('/opt/homebrew/bin/python');\n            if ((util.darwinXcodeExists() && util.semverCompare('12.0.1', osVersion) < 0) || gitHomebrewExists1 || gitHomebrewExists2) {\n              const cmd = gitHomebrewExists1 ? '/usr/local/Cellar/python -V 2>&1' : (gitHomebrewExists2 ? '/opt/homebrew/bin/python -V 2>&1' : 'python -V 2>&1');\n              exec(cmd, function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/python3') || fs.existsSync('/opt/homebrew/bin/python3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('python3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip') || fs.existsSync('/opt/homebrew/bin/pip');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip3') || fs.existsSync('/opt/homebrew/bin/pip3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'java')) {\n          if (_darwin) {\n            // check if any JVM is installed but avoid dialog box that Java needs to be installed\n            exec('/usr/libexec/java_home -V 2>&1', function (error, stdout) {\n              if (!error && stdout.toString().toLowerCase().indexOf('no java runtime') === -1) {\n                // now this can be done savely\n                exec('java -version 2>&1', function (error, stdout) {\n                  if (!error) {\n                    const java = stdout.toString().split('\\n')[0] || '';\n                    const parts = java.split('\"');\n                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n                  }\n                  functionProcessed();\n                });\n              } else {\n                functionProcessed();\n              }\n            });\n          } else {\n            exec('java -version 2>&1', function (error, stdout) {\n              if (!error) {\n                const java = stdout.toString().split('\\n')[0] || '';\n                const parts = java.split('\"');\n                appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gcc')) {\n          if ((_darwin && util.darwinXcodeExists()) || !_darwin) {\n            exec('gcc -dumpversion', function (error, stdout) {\n              if (!error) {\n                appsObj.versions.gcc = stdout.toString().split('\\n')[0].trim() || '';\n              }\n              if (appsObj.versions.gcc.indexOf('.') > -1) {\n                functionProcessed();\n              } else {\n                exec('gcc --version', function (error, stdout) {\n                  if (!error) {\n                    const gcc = stdout.toString().split('\\n')[0].trim();\n                    if (gcc.indexOf('gcc') > -1 && gcc.indexOf(')') > -1) {\n                      const parts = gcc.split(')');\n                      appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;\n                    }\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'virtualbox')) {\n          exec(util.getVboxmanage() + ' -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const vbox = stdout.toString().split('\\n')[0] || '';\n              const parts = vbox.split('r');\n              appsObj.versions.virtualbox = parts[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'bash')) {\n          exec('bash --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.bash = parts[1].split(' ')[0].split('(')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'zsh')) {\n          exec('zsh --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split('zsh ');\n              if (parts.length > 1) {\n                appsObj.versions.zsh = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'fish')) {\n          exec('fish --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.fish = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'powershell')) {\n          if (_windows) {\n            util.powerShell('$PSVersionTable').then(stdout => {\n              const lines = stdout.toString().split('\\n').map(line => line.replace(/ +/g, ' ').replace(/ +/g, ':'));\n              appsObj.versions.powershell = util.getValue(lines, 'psversion');\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'dotnet')) {\n          if (_windows) {\n            util.powerShell('gci \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\NET Framework Setup\\\\NDP\" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match \"^(?!S)\\\\p{L}\"} | select PSChildName, Version, Release').then(stdout => {\n              const lines = stdout.toString().split('\\r\\n');\n              let dotnet = '';\n              lines.forEach(line => {\n                line = line.replace(/ +/g, ' ');\n                const parts = line.split(' ');\n                dotnet = dotnet || (parts[0].toLowerCase().startsWith('client') && parts.length > 2 ? parts[1].trim() : (parts[0].toLowerCase().startsWith('full') && parts.length > 2 ? parts[1].trim() : ''));\n              });\n              appsObj.versions.dotnet = dotnet.trim();\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n      } catch (e) {\n        if (callback) { callback(appsObj.versions); }\n        resolve(appsObj.versions);\n      }\n    });\n  });\n}\n\nexports.versions = versions;\n\nfunction shell(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        resolve('cmd');\n      } else {\n        let result = '';\n        exec('echo $SHELL', function (error, stdout) {\n          if (!error) {\n            result = stdout.toString().split('\\n')[0];\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.shell = shell;\n\nfunction getUniqueMacAdresses() {\n  let macs = [];\n  try {\n    const ifaces = os.networkInterfaces();\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.mac && details.mac !== '00:00:00:00:00:00') {\n            const mac = details.mac.toLowerCase();\n            if (macs.indexOf(mac) === -1) {\n              macs.push(mac);\n            }\n          }\n        });\n      }\n    }\n    macs = macs.sort(function (a, b) {\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      return 0;\n    });\n  } catch (e) {\n    macs.push('00:00:00:00:00:00');\n  }\n  return macs;\n}\n\nfunction uuid(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        os: '',\n        hardware: '',\n        macs: getUniqueMacAdresses()\n      };\n      let parts;\n\n      if (_darwin) {\n        exec('system_profiler SPHardwareDataType -json', function (error, stdout) {\n          if (!error) {\n            try {\n              const jsonObj = JSON.parse(stdout.toString());\n              if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {\n                const spHardware = jsonObj.SPHardwareDataType[0];\n                result.os = spHardware.platform_UUID.toLowerCase();\n                result.hardware = spHardware.serial_number;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        const cmd = `echo -n \"os: \"; cat /var/lib/dbus/machine-id 2> /dev/null; echo;\necho -n \"os: \"; cat /etc/machine-id 2> /dev/null; echo;\necho -n \"hardware: \"; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'os').toLowerCase();\n          result.hardware = util.getValue(lines, 'hardware').toLowerCase();\n          if (!result.hardware) {\n            const lines = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n            const serial = util.getValue(lines, 'serial');\n            result.hardware = serial || '';\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i kern.hostid kern.hostuuid', function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'kern.hostid', ':').toLowerCase();\n          result.hardware = util.getValue(lines, 'kern.hostuuid', ':').toLowerCase();\n          if (result.os.indexOf('unknown') >= 0) { result.os = ''; }\n          if (result.hardware.indexOf('unknown') >= 0) { result.hardware = ''; }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let sysdir = '%windir%\\\\System32';\n        if (process.arch === 'ia32' && Object.prototype.hasOwnProperty.call(process.env, 'PROCESSOR_ARCHITEW6432')) {\n          sysdir = '%windir%\\\\sysnative\\\\cmd.exe /c %windir%\\\\System32';\n        }\n        util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl').then((stdout) => {\n          let lines = stdout.split('\\r\\n');\n          result.hardware = util.getValue(lines, 'uuid', ':').toLowerCase();\n          exec(`${sysdir}\\\\reg query \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\" /v MachineGuid`, util.execOptsWin, function (error, stdout) {\n            parts = stdout.toString().split('\\n\\r')[0].split('REG_SZ');\n            result.os = parts.length > 1 ? parts[1].replace(/\\r+|\\n+|\\s+/ig, '').toLowerCase() : '';\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        });\n      }\n    });\n  });\n}\n\nexports.uuid = uuid;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// printers.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 15. printers\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst winPrinterStatus = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Idle',\n  4: 'Printing',\n  5: 'Warmup',\n  6: 'Stopped Printing',\n  7: 'Offline',\n};\n\nfunction parseLinuxCupsHeader(lines) {\n  const result = {};\n  if (lines && lines.length) {\n    if (lines[0].indexOf(' CUPS v') > 0) {\n      const parts = lines[0].split(' CUPS v');\n      result.cupsVersion = parts[1];\n    }\n  }\n  return result;\n}\n\nfunction parseLinuxCupsPrinter(lines) {\n  const result = {};\n  const printerId = util.getValue(lines, 'PrinterId', ' ');\n  result.id = printerId ? parseInt(printerId, 10) : null;\n  result.name = util.getValue(lines, 'Info', ' ');\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = util.getValue(lines, 'DeviceURI', ' ');\n  result.uuid = util.getValue(lines, 'UUID', ' ');\n  result.status = util.getValue(lines, 'State', ' ');\n  result.local = util.getValue(lines, 'Location', ' ').toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseLinuxLpstatPrinter(lines, id) {\n  const result = {};\n  result.id = id;\n  result.name = util.getValue(lines, 'Description', ':', true);\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = null;\n  result.uuid = null;\n  result.status = lines.length > 0 && lines[0] ? (lines[0].indexOf(' idle') > 0 ? 'idle' : (lines[0].indexOf(' printing') > 0 ? 'printing' : 'unknown')) : null;\n  result.local = util.getValue(lines, 'Location', ':', true).toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseDarwinPrinters(printerObject, id) {\n  const result = {};\n  const uriParts = printerObject.uri.split('/');\n  result.id = id;\n  result.name = printerObject._name;\n  result.model = uriParts.length ? uriParts[uriParts.length - 1] : '';\n  result.uri = printerObject.uri;\n  result.uuid = null;\n  result.status = printerObject.status;\n  result.local = printerObject.printserver === 'local';\n  result.default = printerObject.default === 'yes';\n  result.shared = printerObject.shared === 'yes';\n\n  return result;\n}\n\nfunction parseWindowsPrinters(lines, id) {\n  const result = {};\n  const status = parseInt(util.getValue(lines, 'PrinterStatus', ':'), 10);\n\n  result.id = id;\n  result.name = util.getValue(lines, 'name', ':');\n  result.model = util.getValue(lines, 'DriverName', ':');\n  result.uri = null;\n  result.uuid = null;\n  result.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;\n  result.local = util.getValue(lines, 'Local', ':').toUpperCase() === 'TRUE';\n  result.default = util.getValue(lines, 'Default', ':').toUpperCase() === 'TRUE';\n  result.shared = util.getValue(lines, 'Shared', ':').toUpperCase() === 'TRUE';\n\n  return result;\n}\n\nfunction printer(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'cat /etc/cups/printers.conf 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // printers.conf\n          if (!error) {\n            const parts = stdout.toString().split('<Printer ');\n            const printerHeader = parseLinuxCupsHeader(parts[0]);\n            for (let i = 1; i < parts.length; i++) {\n              const printers = parseLinuxCupsPrinter(parts[i].split('\\n'));\n              if (printers.name) {\n                printers.engine = 'CUPS';\n                printers.engineVersion = printerHeader.cupsVersion;\n                result.push(printers);\n              }\n            }\n          }\n          if (result.length === 0) {\n            if (_linux) {\n              cmd = 'export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL';\n              // lpstat\n              exec(cmd, function (error, stdout) {\n                const parts = ('\\n' + stdout.toString()).split('\\nprinter ');\n                for (let i = 1; i < parts.length; i++) {\n                  const printers = parseLinuxLpstatPrinter(parts[i].split('\\n'), i);\n                  result.push(printers);\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } else {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPPrintersDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {\n                for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {\n                  const printer = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);\n                  result.push(printer);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const printer = parseWindowsPrinters(parts[i].split('\\n'), i);\n              if (printer.name || printer.model) {\n                result.push(printer);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.printer = printer;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// processes.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 10. Processes\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst _processes_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _services_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _process_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\n\nconst _winStatusValues = {\n  '0': 'unknown',\n  '1': 'other',\n  '2': 'ready',\n  '3': 'running',\n  '4': 'blocked',\n  '5': 'suspended blocked',\n  '6': 'suspended ready',\n  '7': 'terminated',\n  '8': 'stopped',\n  '9': 'growing',\n};\n\nfunction parseTimeUnix(time) {\n  let result = time;\n  let parts = time.replace(/ +/g, ' ').split(' ');\n  if (parts.length === 5) {\n    result = parts[4] + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + parts[2]).slice(-2) + ' ' + parts[3];\n  }\n  return result;\n}\n\nfunction parseElapsedTime(etime) {\n  let current = new Date();\n  current = new Date(current.getTime() - current.getTimezoneOffset() * 60000);\n\n  const elapsed = etime.split('-');\n\n  const timeIndex = elapsed.length - 1;\n  const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;\n\n  const timeStr = elapsed[timeIndex].split(':');\n  const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;\n  const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);\n  const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);\n  const ms = (((((days * 24 + hours) * 60) + mins) * 60 + secs) * 1000);\n\n  let res = new Date(current.getTime());\n  let result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  try {\n    res = new Date(current.getTime() - ms);\n    result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\n// --------------------------\n// PS - services\n// pass a comma separated string with services to check (mysql, apache, postgresql, ...)\n// this function gives an array back, if the services are running.\n\nfunction services(srv, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(srv) && !callback) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof srv !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      if (srv) {\n        let srvString = '';\n        srvString.__proto__.toLowerCase = util.stringToLower;\n        srvString.__proto__.replace = util.stringReplace;\n        srvString.__proto__.trim = util.stringTrim;\n\n        const s = util.sanitizeShellString(srv);\n        for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n          if (s[i] !== undefined) {\n            srvString = srvString + s[i];\n          }\n        }\n\n        srvString = srvString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n        if (srvString === '') {\n          srvString = '*';\n        }\n        if (util.isPrototypePolluted() && srvString !== '*') {\n          srvString = '------';\n        }\n        let srvs = srvString.split('|');\n        let result = [];\n        let dataSrv = [];\n\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n          if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === '*') {\n            try {\n              const tmpsrv = execSync('systemctl --all --type=service --no-legend 2> /dev/null').toString().split('\\n');\n              srvs = [];\n              for (const s of tmpsrv) {\n                const name = s.split('.service')[0];\n                if (name && s.indexOf(' not-found ') === -1) {\n                  srvs.push(name.trim());\n                }\n              }\n              srvString = srvs.join('|');\n            } catch (d) {\n              try {\n                srvString = '';\n                const tmpsrv = execSync('service --status-all 2> /dev/null').toString().split('\\n');\n                for (const s of tmpsrv) {\n                  const parts = s.split(']');\n                  if (parts.length === 2) {\n                    srvString += (srvString !== '' ? '|' : '') + parts[1].trim();\n                  }\n                }\n                srvs = srvString.split('|');\n              } catch (e) {\n                try {\n                  const srvStr = execSync('ls /etc/init.d/ -m 2> /dev/null').toString().split('\\n').join('');\n                  srvString = '';\n                  if (srvStr) {\n                    const tmpsrv = srvStr.split(',');\n                    for (const s of tmpsrv) {\n                      const name = s.trim();\n                      if (name) {\n                        srvString += (srvString !== '' ? '|' : '') + name;\n                      }\n                    }\n                    srvs = srvString.split('|');\n                  }\n                } catch (f) {\n                  srvString = '';\n                  srvs = [];\n                }\n              }\n            }\n          }\n          if ((_darwin) && srvString === '*') { // service enumeration not yet suported on mac OS\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n          let args = (_darwin) ? ['-caxo', 'pcpu,pmem,pid,command'] : ['-axo', 'pcpu,pmem,pid,command'];\n          if (srvString !== '' && srvs.length > 0) {\n            util.execSafe('ps', args).then((stdout) => {\n              if (stdout) {\n                let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                srvs.forEach(function (srv) {\n                  let ps;\n                  if (_darwin) {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(srv) !== -1);\n                    });\n\n                  } else {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(' ' + srv + ':') !== -1) || (e.toLowerCase().indexOf('/' + srv) !== -1);\n                    });\n                  }\n                  const pids = [];\n                  for (const p of ps) {\n                    const pid = p.trim().split(' ')[2];\n                    if (pid) {\n                      pids.push(parseInt(pid, 10));\n                    }\n                  }\n                  result.push({\n                    name: srv,\n                    running: ps.length > 0,\n                    startmode: '',\n                    pids: pids,\n                    cpu: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[0]);\n                    }, 0)).toFixed(2)),\n                    mem: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[1]);\n                    }, 0)).toFixed(2))\n                  });\n                });\n                if (_linux) {\n                  // calc process_cpu - ps is not accurate in linux!\n                  let cmd = 'cat /proc/stat | grep \"cpu \"';\n                  for (let i in result) {\n                    for (let j in result[i].pids) {\n                      cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                    }\n                  }\n                  exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                    let curr_processes = stdout.toString().split('\\n');\n\n                    // first line (all - /proc/stat)\n                    let all = parseProcStat(curr_processes.shift());\n\n                    // process\n                    let list_new = {};\n                    let resultProcess = {};\n                    curr_processes.forEach((element) => {\n                      resultProcess = calcProcStatLinux(element, all, _services_cpu);\n\n                      if (resultProcess.pid) {\n                        let listPos = -1;\n                        for (let i in result) {\n                          for (let j in result[i].pids) {\n                            if (parseInt(result[i].pids[j]) === parseInt(resultProcess.pid)) {\n                              listPos = i;\n                            }\n                          }\n                        }\n                        if (listPos >= 0) {\n                          result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                        }\n\n                        // save new values\n                        list_new[resultProcess.pid] = {\n                          cpuu: resultProcess.cpuu,\n                          cpus: resultProcess.cpus,\n                          utime: resultProcess.utime,\n                          stime: resultProcess.stime,\n                          cutime: resultProcess.cutime,\n                          cstime: resultProcess.cstime\n                        };\n                      }\n                    });\n\n                    // store old values\n                    _services_cpu.all = all;\n                    _services_cpu.list = Object.assign({}, list_new);\n                    _services_cpu.ms = Date.now() - _services_cpu.ms;\n                    _services_cpu.result = Object.assign({}, result);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              } else {\n                args = ['-o', 'comm'];\n                util.execSafe('ps', args).then((stdout) => {\n                  if (stdout) {\n                    let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                    srvs.forEach(function (srv) {\n                      let ps = lines.filter(function (e) {\n                        return e.indexOf(srv) !== -1;\n                      });\n                      result.push({\n                        name: srv,\n                        running: ps.length > 0,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  } else {\n                    srvs.forEach(function (srv) {\n                      result.push({\n                        name: srv,\n                        running: false,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  }\n                });\n              }\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n        if (_windows) {\n          try {\n            let wincommand = 'Get-CimInstance Win32_Service';\n            if (srvs[0] !== '*') {\n              wincommand += ' -Filter \"';\n              srvs.forEach((srv) => {\n                wincommand += `Name='${srv}' or `;\n              });\n              wincommand = `${wincommand.slice(0, -4)}\"`;\n            }\n            wincommand += ' | select Name,Caption,Started,StartMode,ProcessId | fl';\n            util.powerShell(wincommand).then((stdout, error) => {\n              if (!error) {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let srvName = util.getValue(lines, 'Name', ':', true).toLowerCase();\n                    let srvCaption = util.getValue(lines, 'Caption', ':', true).toLowerCase();\n                    let started = util.getValue(lines, 'Started', ':', true);\n                    let startMode = util.getValue(lines, 'StartMode', ':', true);\n                    let pid = util.getValue(lines, 'ProcessId', ':', true);\n                    if (srvString === '*' || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {\n                      result.push({\n                        name: srvName,\n                        running: (started.toLowerCase() === 'true'),\n                        startmode: startMode,\n                        pids: [pid],\n                        cpu: 0,\n                        mem: 0\n                      });\n                      dataSrv.push(srvName);\n                      dataSrv.push(srvCaption);\n                    }\n                  }\n\n                });\n\n                if (srvString !== '*') {\n                  let srvsMissing = srvs.filter(function (e) {\n                    return dataSrv.indexOf(e) === -1;\n                  });\n                  srvsMissing.forEach(function (srvName) {\n                    result.push({\n                      name: srvName,\n                      running: false,\n                      startmode: '',\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              } else {\n                srvs.forEach(function (srvName) {\n                  result.push({\n                    name: srvName,\n                    running: false,\n                    startmode: '',\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) { callback([]); }\n        resolve([]);\n      }\n    });\n  });\n}\n\nexports.services = services;\n\nfunction parseProcStat(line) {\n  let parts = line.replace(/ +/g, ' ').split(' ');\n  let user = (parts.length >= 2 ? parseInt(parts[1]) : 0);\n  let nice = (parts.length >= 3 ? parseInt(parts[2]) : 0);\n  let system = (parts.length >= 4 ? parseInt(parts[3]) : 0);\n  let idle = (parts.length >= 5 ? parseInt(parts[4]) : 0);\n  let iowait = (parts.length >= 6 ? parseInt(parts[5]) : 0);\n  let irq = (parts.length >= 7 ? parseInt(parts[6]) : 0);\n  let softirq = (parts.length >= 8 ? parseInt(parts[7]) : 0);\n  let steal = (parts.length >= 9 ? parseInt(parts[8]) : 0);\n  let guest = (parts.length >= 10 ? parseInt(parts[9]) : 0);\n  let guest_nice = (parts.length >= 11 ? parseInt(parts[10]) : 0);\n  return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;\n}\n\nfunction calcProcStatLinux(line, all, _cpu_old) {\n  let statparts = line.replace(/ +/g, ' ').split(')');\n  if (statparts.length >= 2) {\n    let parts = statparts[1].split(' ');\n    if (parts.length >= 16) {\n      let pid = parseInt(statparts[0].split(' ')[0]);\n      let utime = parseInt(parts[12]);\n      let stime = parseInt(parts[13]);\n      let cutime = parseInt(parts[14]);\n      let cstime = parseInt(parts[15]);\n\n      // calc\n      let cpuu = 0;\n      let cpus = 0;\n      if (_cpu_old.all > 0 && _cpu_old.list[pid]) {\n        cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100; // user\n        cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100; // system\n      } else {\n        cpuu = (utime + cutime) / (all) * 100; // user\n        cpus = (stime + cstime) / (all) * 100; // system\n      }\n      return {\n        pid: pid,\n        utime: utime,\n        stime: stime,\n        cutime: cutime,\n        cstime: cstime,\n        cpuu: cpuu,\n        cpus: cpus\n      };\n    } else {\n      return {\n        pid: 0,\n        utime: 0,\n        stime: 0,\n        cutime: 0,\n        cstime: 0,\n        cpuu: 0,\n        cpus: 0\n      };\n    }\n  } else {\n    return {\n      pid: 0,\n      utime: 0,\n      stime: 0,\n      cutime: 0,\n      cstime: 0,\n      cpuu: 0,\n      cpus: 0\n    };\n  }\n}\n\nfunction calcProcStatWin(procStat, all, _cpu_old) {\n  // calc\n  let cpuu = 0;\n  let cpus = 0;\n  if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {\n    cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100; // user\n    cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100; // system\n  } else {\n    cpuu = (procStat.utime) / (all) * 100; // user\n    cpus = (procStat.stime) / (all) * 100; // system\n  }\n  return {\n    pid: procStat.pid,\n    utime: procStat.utime,\n    stime: procStat.stime,\n    cpuu: cpuu > 0 ? cpuu : 0,\n    cpus: cpus > 0 ? cpus : 0\n  };\n}\n\n\n\n// --------------------------\n// running processes\n\nfunction processes(callback) {\n\n  let parsedhead = [];\n\n  function getName(command) {\n    command = command || '';\n    let result = command.split(' ')[0];\n    if (result.substr(-1) === ':') {\n      result = result.substr(0, result.length - 1);\n    }\n    if (result.substr(0, 1) !== '[') {\n      let parts = result.split('/');\n      if (isNaN(parseInt(parts[parts.length - 1]))) {\n        result = parts[parts.length - 1];\n      } else {\n        result = parts[0];\n      }\n    }\n    return result;\n  }\n\n  function parseLine(line) {\n\n    let offset = 0;\n    let offset2 = 0;\n\n    function checkColumn(i) {\n      offset = offset2;\n      if (parsedhead[i]) {\n        offset2 = line.substring(parsedhead[i].to + offset, 10000).indexOf(' ');\n      } else {\n        offset2 = 10000;\n      }\n    }\n\n    checkColumn(0);\n    const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));\n    checkColumn(1);\n    const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));\n    checkColumn(2);\n    const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, '.'));\n    checkColumn(3);\n    const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, '.'));\n    checkColumn(4);\n    const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));\n    checkColumn(5);\n    const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));\n    checkColumn(6);\n    const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));\n    checkColumn(7);\n    const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;\n    checkColumn(8);\n    const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());\n    checkColumn(9);\n    let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();\n    state = (state[0] === 'R' ? 'running' : (state[0] === 'S' ? 'sleeping' : (state[0] === 'T' ? 'stopped' : (state[0] === 'W' ? 'paging' : (state[0] === 'X' ? 'dead' : (state[0] === 'Z' ? 'zombie' : ((state[0] === 'D' || state[0] === 'U') ? 'blocked' : 'unknown')))))));\n    checkColumn(10);\n    let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();\n    if (tty === '?' || tty === '??') { tty = ''; }\n    checkColumn(11);\n    const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();\n    checkColumn(12);\n    let cmdPath = '';\n    let command = '';\n    let params = '';\n    let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();\n    if (fullcommand.substr(fullcommand.length - 1) === ']') { fullcommand = fullcommand.slice(0, -1); }\n    if (fullcommand.substr(0, 1) === '[') { command = fullcommand.substring(1); }\n    else {\n      const p1 = fullcommand.indexOf('(');\n      const p2 = fullcommand.indexOf(')');\n      const p3 = fullcommand.indexOf('/');\n      const p4 = fullcommand.indexOf(':');\n      if (p1 < p2 && p1 < p3 && p3 < p2) {\n        command = fullcommand.split(' ')[0];\n        command = command.replace(/:/g, '');\n      } else {\n        if (p4 > 0 && (p3 === -1 || p3 > 3)) {\n          command = fullcommand.split(' ')[0];\n          command = command.replace(/:/g, '');\n        } else {\n          // try to figure out where parameter starts\n          let firstParamPos = fullcommand.indexOf(' -');\n          let firstParamPathPos = fullcommand.indexOf(' /');\n          firstParamPos = (firstParamPos >= 0 ? firstParamPos : 10000);\n          firstParamPathPos = (firstParamPathPos >= 0 ? firstParamPathPos : 10000);\n          const firstPos = Math.min(firstParamPos, firstParamPathPos);\n          let tmpCommand = fullcommand.substr(0, firstPos);\n          const tmpParams = fullcommand.substr(firstPos);\n          const lastSlashPos = tmpCommand.lastIndexOf('/');\n          if (lastSlashPos >= 0) {\n            cmdPath = tmpCommand.substr(0, lastSlashPos);\n            tmpCommand = tmpCommand.substr(lastSlashPos + 1);\n          }\n\n          if (firstPos === 10000 && tmpCommand.indexOf(' ') > -1) {\n            const parts = tmpCommand.split(' ');\n            if (fs.existsSync(path.join(cmdPath, parts[0]))) {\n              command = parts.shift();\n              params = (parts.join(' ') + ' ' + tmpParams).trim();\n            } else {\n              command = tmpCommand.trim();\n              params = tmpParams.trim();\n            }\n          } else {\n            command = tmpCommand.trim();\n            params = tmpParams.trim();\n          }\n        }\n      }\n\n    }\n\n    return ({\n      pid: pid,\n      parentPid: ppid,\n      name: _linux ? getName(command) : command,\n      cpu: cpu,\n      cpuu: 0,\n      cpus: 0,\n      mem: mem,\n      priority: priority,\n      memVsz: vsz,\n      memRss: rss,\n      nice: nice,\n      started: started,\n      state: state,\n      tty: tty,\n      user: user,\n      command: command,\n      params: params,\n      path: cmdPath\n    });\n  }\n\n  function parseProcesses(lines) {\n    let result = [];\n    if (lines.length > 1) {\n      let head = lines[0];\n      parsedhead = util.parseHead(head, 8);\n      lines.shift();\n      lines.forEach(function (line) {\n        if (line.trim() !== '') {\n          result.push(parseLine(line));\n        }\n      });\n    }\n    return result;\n  }\n  function parseProcesses2(lines) {\n\n    function formatDateTime(time) {\n      const month = ('0' + (time.getMonth() + 1).toString()).slice(-2);\n      const year = time.getFullYear().toString();\n      const day = ('0' + time.getDate().toString()).slice(-2);\n      const hours = ('0' + time.getHours().toString()).slice(-2);\n      const mins = ('0' + time.getMinutes().toString()).slice(-2);\n      const secs = ('0' + time.getSeconds().toString()).slice(-2);\n\n      return (year + '-' + month + '-' + day + ' ' + hours + ':' + mins + ':' + secs);\n    }\n\n    function parseElapsed(etime) {\n      let started = '';\n      if (etime.indexOf('d') >= 0) {\n        const elapsed_parts = etime.split('d');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1000));\n      } else if (etime.indexOf('h') >= 0) {\n        const elapsed_parts = etime.split('h');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1000));\n      } else if (etime.indexOf(':') >= 0) {\n        const elapsed_parts = etime.split(':');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));\n      }\n      return started;\n    }\n\n    let result = [];\n    lines.forEach(function (line) {\n      if (line.trim() !== '') {\n        line = line.trim().replace(/ +/g, ' ').replace(/,+/g, '.');\n        const parts = line.split(' ');\n        const command = parts.slice(9).join(' ');\n        const pmem = parseFloat((1.0 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));\n        const started = parseElapsed(parts[5]);\n\n        result.push({\n          pid: parseInt(parts[0]),\n          parentPid: parseInt(parts[1]),\n          name: getName(command),\n          cpu: 0,\n          cpuu: 0,\n          cpus: 0,\n          mem: pmem,\n          priority: 0,\n          memVsz: parseInt(parts[2]),\n          memRss: parseInt(parts[3]),\n          nice: parseInt(parts[4]),\n          started: started,\n          state: (parts[6] === 'R' ? 'running' : (parts[6] === 'S' ? 'sleeping' : (parts[6] === 'T' ? 'stopped' : (parts[6] === 'W' ? 'paging' : (parts[6] === 'X' ? 'dead' : (parts[6] === 'Z' ? 'zombie' : ((parts[6] === 'D' || parts[6] === 'U') ? 'blocked' : 'unknown'))))))),\n          tty: parts[7],\n          user: parts[8],\n          command: command\n        });\n      }\n    });\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        all: 0,\n        running: 0,\n        blocked: 0,\n        sleeping: 0,\n        unknown: 0,\n        list: []\n      };\n\n      let cmd = '';\n\n      if ((_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500) || _processes_cpu.ms === 0) {\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n          if (_linux) { cmd = 'export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL'; }\n          if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL'; }\n          if (_darwin) { cmd = 'ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r'; }\n          if (_sunos) { cmd = 'ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm'; }\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error && stdout.toString().trim()) {\n              result.list = (parseProcesses(stdout.toString().split('\\n'))).slice();\n              result.all = result.list.length;\n              result.running = result.list.filter(function (e) {\n                return e.state === 'running';\n              }).length;\n              result.blocked = result.list.filter(function (e) {\n                return e.state === 'blocked';\n              }).length;\n              result.sleeping = result.list.filter(function (e) {\n                return e.state === 'sleeping';\n              }).length;\n\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                cmd = 'cat /proc/stat | grep \"cpu \"';\n                result.list.forEach((element) => {\n                  cmd += (';cat /proc/' + element.pid + '/stat');\n                });\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _processes_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // store pcpu in outer array\n                      let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                      if (listPos >= 0) {\n                        result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                        result.list[listPos].cpuu = resultProcess.cpuu;\n                        result.list[listPos].cpus = resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  // store old values\n                  _processes_cpu.all = all;\n                  _processes_cpu.list = Object.assign({}, list_new);\n                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                  _processes_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm';\n              if (_sunos) {\n                cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm';\n              }\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.shift();\n\n                  result.list = parseProcesses2(lines).slice();\n                  result.all = result.list.length;\n                  result.running = result.list.filter(function (e) {\n                    return e.state === 'running';\n                  }).length;\n                  result.blocked = result.list.filter(function (e) {\n                    return e.state === 'blocked';\n                  }).length;\n                  result.sleeping = result.list.filter(function (e) {\n                    return e.state === 'sleeping';\n                  }).length;\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            }\n          });\n        } else if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n=\"CreationDate\";e={$_.CreationDate.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procs = [];\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let parentPid = parseInt(util.getValue(lines, 'ParentProcessId', ':', true), 10);\n                    let statusValue = util.getValue(lines, 'ExecutionState', ':');\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let commandLine = util.getValue(lines, 'CommandLine', ':', true);\n                    // get additional command line data\n                    let additionalCommand = false;\n                    lines.forEach((line) => {\n                      if (additionalCommand && line.toLowerCase().startsWith(' ')) {\n                        commandLine += ' ' + line.trim();\n                      } else {\n                        additionalCommand = false;\n                      }\n                      if (line.toLowerCase().startsWith('commandline')) {\n                        additionalCommand = true;\n                      }\n                    });\n                    let commandPath = util.getValue(lines, 'ExecutablePath', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let memw = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n                    result.all++;\n                    if (!statusValue) { result.unknown++; }\n                    if (statusValue === '3') { result.running++; }\n                    if (statusValue === '4' || statusValue === '5') { result.blocked++; }\n\n                    procStats.push({\n                      pid: pid,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                    });\n                    procs.push({\n                      pid: pid,\n                      parentPid: parentPid,\n                      name: name,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem: memw / os.totalmem() * 100,\n                      priority: parseInt(util.getValue(lines, 'Priority', ':', true), 10),\n                      memVsz: parseInt(util.getValue(lines, 'PageFileUsage', ':', true), 10),\n                      memRss: Math.floor(parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10) / 1024),\n                      nice: 0,\n                      started: util.getValue(lines, 'CreationDate', ':', true),\n                      state: (!statusValue ? _winStatusValues[0] : _winStatusValues[statusValue]),\n                      tty: '',\n                      user: '',\n                      command: commandLine || name,\n                      path: commandPath,\n                      params: ''\n                    });\n                  }\n                });\n\n                result.sleeping = result.all - result.running - result.blocked - result.unknown;\n                result.list = procs;\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);\n\n                  // store pcpu in outer array\n                  let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                  if (listPos >= 0) {\n                    result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                    result.list[listPos].cpuu = resultProcess.cpuu;\n                    result.list[listPos].cpus = resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _processes_cpu.all = allcpuu + allcpus;\n                _processes_cpu.all_utime = allcpuu;\n                _processes_cpu.all_stime = allcpus;\n                _processes_cpu.list = Object.assign({}, list_new);\n                _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                _processes_cpu.result = Object.assign({}, result);\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } else {\n        if (callback) { callback(_processes_cpu.result); }\n        resolve(_processes_cpu.result);\n      }\n    });\n  });\n}\n\nexports.processes = processes;\n\n// --------------------------\n// PS - process load\n// get detailed information about a certain process\n// (PID, CPU-Usage %, Mem-Usage %)\n\nfunction processLoad(proc, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(proc) && !callback) {\n    callback = proc;\n    proc = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      proc = proc || '';\n\n      if (typeof proc !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      let processesString = '';\n      processesString.__proto__.toLowerCase = util.stringToLower;\n      processesString.__proto__.replace = util.stringReplace;\n      processesString.__proto__.trim = util.stringTrim;\n\n      const s = util.sanitizeShellString(proc);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          processesString = processesString + s[i];\n        }\n      }\n\n      processesString = processesString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n      if (processesString === '') {\n        processesString = '*';\n      }\n      if (util.isPrototypePolluted() && processesString !== '*') {\n        processesString = '------';\n      }\n      let processes = processesString.split('|');\n      let result = [];\n\n      const procSanitized = util.isPrototypePolluted() ? '' : util.sanitizeShellString(proc);\n\n      // from here new\n      // let result = {\n      //   'proc': procSanitized,\n      //   'pid': null,\n      //   'cpu': 0,\n      //   'mem': 0\n      // };\n      if (procSanitized && processes.length && processes[0] !== '------') {\n        if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n\n                // go through all processes\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let mem = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n\n                    procStats.push({\n                      pid: pid,\n                      name,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem\n                    });\n                    let pname = '';\n                    let inList = false;\n                    processes.forEach(function (proc) {\n                      if (name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                        inList = true;\n                        pname = proc;\n                      }\n                    });\n\n                    if (processesString === '*' || inList) {\n                      let processFound = false;\n                      result.forEach(function (item) {\n                        if (item.proc.toLowerCase() === pname.toLowerCase()) {\n                          item.pids.push(pid);\n                          item.mem += mem / os.totalmem() * 100;\n                          processFound = true;\n                        }\n                      });\n                      if (!processFound) {\n                        result.push({\n                          proc: pname,\n                          pid: pid,\n                          pids: [pid],\n                          cpu: 0,\n                          mem: mem / os.totalmem() * 100\n                        });\n                      }\n                    }\n                  }\n                });\n\n                // add missing processes\n                if (processesString !== '*') {\n                  let processesMissing = processes.filter(function (name) {\n                    return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n\n                  });\n                  processesMissing.forEach(function (procName) {\n                    result.push({\n                      proc: procName,\n                      pid: null,\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n\n                // calculate proc stats for each proc\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);\n\n                  let listPos = -1;\n                  for (let j = 0; j < result.length; j++) {\n                    if (result[j].pid === resultProcess.pid || result[j].pids.indexOf(resultProcess.pid) >= 0) { listPos = j; }\n                  }\n                  if (listPos >= 0) {\n                    result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _process_cpu.all = allcpuu + allcpus;\n                _process_cpu.all_utime = allcpuu;\n                _process_cpu.all_stime = allcpus;\n                _process_cpu.list = Object.assign({}, list_new);\n                _process_cpu.ms = Date.now() - _process_cpu.ms;\n                _process_cpu.result = JSON.parse(JSON.stringify(result));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n\n        if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {\n          const params = ['-axo', 'pid,ppid,pcpu,pmem,comm'];\n          util.execSafe('ps', params).then((stdout) => {\n            if (stdout) {\n              let procStats = [];\n              let lines = stdout.toString().split('\\n').filter(function (line) {\n                if (processesString === '*') { return true; }\n                if (line.toLowerCase().indexOf('grep') !== -1) { return false; } // remove this??\n                let found = false;\n                processes.forEach(function (item) {\n                  found = found || (line.toLowerCase().indexOf(item.toLowerCase()) >= 0);\n                });\n                return found;\n              });\n\n              lines.forEach(function (line) {\n                let data = line.trim().replace(/ +/g, ' ').split(' ');\n                if (data.length > 4) {\n                  procStats.push({\n                    name: data[4].substring(data[4].lastIndexOf('/') + 1),\n                    pid: parseInt(data[0]) || 0,\n                    ppid: parseInt(data[1]) || 0,\n                    cpu: parseFloat(data[2].replace(',', '.')),\n                    mem: parseFloat(data[3].replace(',', '.'))\n                  });\n                }\n              });\n\n              procStats.forEach(function (item) {\n                let listPos = -1;\n                let inList = false;\n                let name = '';\n                for (let j = 0; j < result.length; j++) {\n                  if (item.name.toLowerCase().indexOf(result[j].proc.toLowerCase()) >= 0) {\n                    listPos = j;\n                  }\n                }\n                processes.forEach(function (proc) {\n\n                  if (item.name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                    inList = true;\n                    name = proc;\n                  }\n                });\n                if ((processesString === '*') || inList) {\n                  if (listPos < 0) {\n                    result.push({\n                      proc: name,\n                      pid: item.pid,\n                      pids: [item.pid],\n                      cpu: item.cpu,\n                      mem: item.mem\n                    });\n                  } else {\n                    if (item.ppid < 10) {\n                      result[listPos].pid = item.pid;\n                    }\n                    result[listPos].pids.push(item.pid);\n                    result[listPos].cpu += item.cpu;\n                    result[listPos].mem += item.mem;\n                  }\n                }\n              });\n\n              if (processesString !== '*') {\n                // add missing processes\n                let processesMissing = processes.filter(function (name) {\n                  return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n                });\n                processesMissing.forEach(function (procName) {\n                  result.push({\n                    proc: procName,\n                    pid: null,\n                    pids: [],\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n              }\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                result.forEach(function (item) {\n                  item.cpu = 0;\n                });\n                let cmd = 'cat /proc/stat | grep \"cpu \"';\n                for (let i in result) {\n                  for (let j in result[i].pids) {\n                    cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                  }\n                }\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _process_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // find result item\n                      let resultItemId = -1;\n                      for (let i in result) {\n                        if (result[i].pids.indexOf(resultProcess.pid) >= 0) {\n                          resultItemId = i;\n                        }\n                      }\n                      // store pcpu in outer result\n                      if (resultItemId >= 0) {\n                        result[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  result.forEach(function (item) {\n                    item.cpu = Math.round(item.cpu * 100) / 100;\n                  });\n\n                  _process_cpu.all = all;\n                  _process_cpu.list = Object.assign({}, list_new);\n                  _process_cpu.ms = Date.now() - _process_cpu.ms;\n                  _process_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.processLoad = processLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// system.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 2. System (Hardware, BIOS, Base Board)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst os = require('os');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromise = util.promisify(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction system(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: 'Computer',\n        version: '',\n        serial: '-',\n        uuid: '-',\n        sku: '-',\n        virtual: false\n      };\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'manufacturer');\n          result.model = util.getValue(lines, 'product name');\n          result.version = util.getValue(lines, 'version');\n          result.serial = util.getValue(lines, 'serial number');\n          result.uuid = util.getValue(lines, 'uuid').toLowerCase();\n          result.sku = util.getValue(lines, 'sku number');\n          // Non-Root values\n          const cmd = `echo -n \"product_name: \"; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;\n            echo -n \"product_serial: \"; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;\n            echo -n \"product_uuid: \"; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;\n            echo -n \"product_version: \"; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;\n            echo -n \"sys_vendor: \"; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = result.manufacturer === '' ? util.getValue(lines, 'sys_vendor') : result.manufacturer;\n            result.model = result.model === '' ? util.getValue(lines, 'product_name') : result.model;\n            result.version = result.version === '' ? util.getValue(lines, 'product_version') : result.version;\n            result.serial = result.serial === '' ? util.getValue(lines, 'product_serial') : result.serial;\n            result.uuid = result.uuid === '' ? util.getValue(lines, 'product_uuid').toLowerCase() : result.uuid;\n          } catch (e) {\n            util.noop();\n          }\n          if (!result.serial || result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = ''; }\n          if (!result.model || result.model.toLowerCase().indexOf('o.e.m.') !== -1) { result.model = 'Computer'; }\n          if (!result.version || result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = ''; }\n          if (!result.sku || result.sku.toLowerCase().indexOf('o.e.m.') !== -1) { result.sku = '-'; }\n\n          // detect virtual (1)\n          if (result.model.toLowerCase() === 'virtualbox' || result.model.toLowerCase() === 'kvm' || result.model.toLowerCase() === 'virtual machine' || result.model.toLowerCase() === 'bochs' || result.model.toLowerCase().startsWith('vmware') || result.model.toLowerCase().startsWith('droplet')) {\n            result.virtual = true;\n            switch (result.model.toLowerCase()) {\n              case 'virtualbox':\n                result.virtualHost = 'VirtualBox';\n                break;\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'kvm':\n                result.virtualHost = 'KVM';\n                break;\n              case 'bochs':\n                result.virtualHost = 'bochs';\n                break;\n            }\n          }\n          if (result.manufacturer.toLowerCase().startsWith('vmware') || result.manufacturer.toLowerCase() === 'xen') {\n            result.virtual = true;\n            switch (result.manufacturer.toLowerCase()) {\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'xen':\n                result.virtualHost = 'Xen';\n                break;\n            }\n          }\n          if (!result.virtual) {\n            try {\n              const disksById = execSync('ls -1 /dev/disk/by-id/ 2>/dev/null').toString();\n              if (disksById.indexOf('_QEMU_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'QEMU';\n              }\n              if (disksById.indexOf('_VBOX_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'VirtualBox';\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (!result.virtual && (os.release().toLowerCase().indexOf('microsoft') >= 0 || os.release().toLowerCase().endsWith('wsl2'))) {\n            const kernelVersion = parseFloat(os.release().toLowerCase());\n            result.virtual = true;\n            result.manufacturer = 'Microsoft';\n            result.model = 'WSL';\n            result.version = kernelVersion < 4.19 ? '1' : '2';\n          }\n          if ((_freebsd || _openbsd || _netbsd) && !result.virtualHost) {\n            try {\n              const procInfo = execSync('dmidecode -t 4');\n              const procLines = procInfo.toString().split('\\n');\n              const procManufacturer = util.getValue(procLines, 'manufacturer', ':', true);\n              switch (procManufacturer.toLowerCase()) {\n                case 'virtualbox':\n                  result.virtualHost = 'VirtualBox';\n                  break;\n                case 'vmware':\n                  result.virtualHost = 'VMware';\n                  break;\n                case 'kvm':\n                  result.virtualHost = 'KVM';\n                  break;\n                case 'bochs':\n                  result.virtualHost = 'bochs';\n                  break;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // detect docker\n          if (fs.existsSync('/.dockerenv') || fs.existsSync('/.dockerinit')) {\n            result.model = 'Docker Container';\n          }\n          try {\n            const stdout = execSync('dmesg 2>/dev/null | grep -iE \"virtual|hypervisor\" | grep -iE \"vmware|qemu|kvm|xen\" | grep -viE \"Nested Virtualization|/virtual/\"');\n            // detect virtual machines\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0) {\n              if (result.model === 'Computer') { result.model = 'Virtual machine'; }\n              result.virtual = true;\n              if (stdout.toString().toLowerCase().indexOf('vmware') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'VMware';\n              }\n              if (stdout.toString().toLowerCase().indexOf('qemu') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'QEMU';\n              }\n              if (stdout.toString().toLowerCase().indexOf('xen') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'Xen';\n              }\n              if (stdout.toString().toLowerCase().indexOf('kvm') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'KVM';\n              }\n            }\n          } catch (e) {\n            util.noop();\n          }\n\n          if (result.manufacturer === '' && result.model === 'Computer' && result.version === '') {\n            // Check Raspberry Pi\n            fs.readFile('/proc/cpuinfo', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n                result.version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n                result.serial = util.getValue(lines, 'serial', ':', true);\n                const model = util.getValue(lines, 'model:', ':', true);\n                // reference values: https://elinux.org/RPi_HardwareHistory\n                // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n                if ((result.model === 'BCM2835' || result.model === 'BCM2708' || result.model === 'BCM2709' || result.model === 'BCM2710' || result.model === 'BCM2711' || result.model === 'BCM2836' || result.model === 'BCM2837') && model.toLowerCase().indexOf('raspberry') >= 0) {\n                  const rPIRevision = util.decodePiCpuinfo(lines);\n                  result.model = rPIRevision.model;\n                  result.version = rPIRevision.revisionCode;\n                  result.manufacturer = 'Raspberry Pi Foundation';\n                  result.raspberry = {\n                    manufacturer: rPIRevision.manufacturer,\n                    processor: rPIRevision.processor,\n                    type: rPIRevision.type,\n                    revision: rPIRevision.revision\n                  };\n                }\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true, true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.uuid = util.getValue(lines, 'ioplatformuuid', '=', true).toLowerCase();\n            result.sku = util.getValue(lines, 'board-id', '=', true);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.manufacturer = util.getValue(lines, 'vendor', ':');\n              result.model = util.getValue(lines, 'name', ':');\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'identifyingnumber', ':');\n              result.uuid = util.getValue(lines, 'uuid', ':').toLowerCase();\n              // detect virtual (1)\n              const model = result.model.toLowerCase();\n              if (model === 'virtualbox' || model === 'kvm' || model === 'virtual machine' || model === 'bochs' || model.startsWith('vmware') || model.startsWith('qemu') || model.startsWith('parallels')) {\n                result.virtual = true;\n                if (model.startsWith('virtualbox')) { result.virtualHost = 'VirtualBox'; }\n                if (model.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (model.startsWith('kvm')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('bochs')) { result.virtualHost = 'bochs'; }\n                if (model.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              const manufacturer = result.manufacturer.toLowerCase();\n              if (manufacturer.startsWith('vmware') || manufacturer.startsWith('qemu') || manufacturer === 'xen' || manufacturer.startsWith('parallels')) {\n                result.virtual = true;\n                if (manufacturer.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (manufacturer.startsWith('xen')) { result.virtualHost = 'Xen'; }\n                if (manufacturer.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (manufacturer.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              util.powerShell('Get-CimInstance MS_Systeminformation -Namespace \"root/wmi\" | select systemsku | fl ').then((stdout, error) => {\n                if (!error) {\n                  let lines = stdout.split('\\r\\n');\n                  result.sku = util.getValue(lines, 'systemsku', ':');\n                }\n                if (!result.virtual) {\n                  util.powerShell('Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion').then((stdout, error) => {\n                    if (!error) {\n                      let lines = stdout.toString();\n                      if (lines.indexOf('VRTUAL') >= 0 || lines.indexOf('A M I ') >= 0 || lines.indexOf('VirtualBox') >= 0 || lines.indexOf('VMWare') >= 0 || lines.indexOf('Xen') >= 0 || lines.indexOf('Parallels') >= 0) {\n                        result.virtual = true;\n                        if (lines.indexOf('VirtualBox') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VirtualBox';\n                        }\n                        if (lines.indexOf('VMware') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VMware';\n                        }\n                        if (lines.indexOf('Xen') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Xen';\n                        }\n                        if (lines.indexOf('VRTUAL') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Hyper-V';\n                        }\n                        if (lines.indexOf('A M I') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Virtual PC';\n                        }\n                        if (lines.indexOf('Parallels') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Parallels';\n                        }\n                      }\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    } else {\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    }\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.system = system;\n\nfunction bios(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        vendor: '',\n        version: '',\n        releaseDate: '',\n        revision: '',\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL';\n        }\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.vendor = util.getValue(lines, 'Vendor');\n          result.version = util.getValue(lines, 'Version');\n          let datetime = util.getValue(lines, 'Release Date');\n          result.releaseDate = util.parseDateTime(datetime).date;\n          result.revision = util.getValue(lines, 'BIOS Revision');\n          result.serial = util.getValue(lines, 'SerialNumber');\n          let language = util.getValue(lines, 'Currently Installed Language').split('|')[0];\n          if (language) {\n            result.language = language;\n          }\n          if (lines.length && stdout.toString().indexOf('Characteristics:') >= 0) {\n            const features = [];\n            lines.forEach(line => {\n              if (line.indexOf(' is supported') >= 0) {\n                const feature = line.split(' is supported')[0].trim();\n                features.push(feature);\n              }\n            });\n            result.features = features;\n          }\n          // Non-Root values\n          const cmd = `echo -n \"bios_date: \"; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;\n            echo -n \"bios_vendor: \"; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;\n            echo -n \"bios_version: \"; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.vendor = !result.vendor ? util.getValue(lines, 'bios_vendor') : result.vendor;\n            result.version = !result.version ? util.getValue(lines, 'bios_version') : result.version;\n            datetime = util.getValue(lines, 'bios_date');\n            result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;\n          } catch (e) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        result.vendor = 'Apple Inc.';\n        exec(\n          'system_profiler SPHardwareDataType -json', function (error, stdout) {\n            try {\n              const hardwareData = JSON.parse(stdout.toString());\n              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {\n                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;\n                bootRomVersion = bootRomVersion ? bootRomVersion.split('(')[0].trim() : null;\n                result.version = bootRomVersion;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n      }\n      if (_sunos) {\n        result.vendor = 'Sun Microsystems';\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n=\"ReleaseDate\";e={$_.ReleaseDate.ToString(\"yyyy-MM-dd\")}},BuildNumber,SerialNumber | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              const description = util.getValue(lines, 'description', ':');\n              if (description.indexOf(' Version ') !== -1) {\n                // ... Phoenix ROM BIOS PLUS Version 1.10 A04\n                result.vendor = description.split(' Version ')[0].trim();\n                result.version = description.split(' Version ')[1].trim();\n              } else if (description.indexOf(' Ver: ') !== -1) {\n                // ... BIOS Date: 06/27/16 17:50:16 Ver: 1.4.5\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = description.split(' Ver: ')[1].trim();\n              } else {\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = util.getValue(lines, 'version', ':');\n              }\n              result.releaseDate = util.getValue(lines, 'releasedate', ':');\n              result.revision = util.getValue(lines, 'buildnumber', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.bios = bios;\n\nfunction baseboard(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        memMax: null,\n        memSlots: null\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n          // 'BCM2709', 'BCM2835', 'BCM2708' -->\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL';\n        }\n        const workload = [];\n        workload.push(execPromise(cmd));\n        workload.push(execPromise('export LC_ALL=C; dmidecode -t memory 2>/dev/null'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'Manufacturer');\n          result.model = util.getValue(lines, 'Product Name');\n          result.version = util.getValue(lines, 'Version');\n          result.serial = util.getValue(lines, 'Serial Number');\n          result.assetTag = util.getValue(lines, 'Asset Tag');\n          // Non-Root values\n          const cmd = `echo -n \"board_asset_tag: \"; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;\n            echo -n \"board_name: \"; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;\n            echo -n \"board_serial: \"; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;\n            echo -n \"board_vendor: \"; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;\n            echo -n \"board_version: \"; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = !result.manufacturer ? util.getValue(lines, 'board_vendor') : result.manufacturer;\n            result.model = !result.model ? util.getValue(lines, 'board_name') : result.model;\n            result.version = !result.version ? util.getValue(lines, 'board_version') : result.version;\n            result.serial = !result.serial ? util.getValue(lines, 'board_serial') : result.serial;\n            result.assetTag = !result.assetTag ? util.getValue(lines, 'board_asset_tag') : result.assetTag;\n          } catch (e) {\n            util.noop();\n          }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          // mem\n          lines = data.results[1] ? data.results[1].toString().split('\\n') : [''];\n          result.memMax = util.toInt(util.getValue(lines, 'Maximum Capacity')) * 1024 * 1024 * 1024 || null;\n          result.memSlots = util.toInt(util.getValue(lines, 'Number Of Devices')) || null;\n\n          // raspberry\n          let linesRpi = '';\n          try {\n            linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n          } catch (e) {\n            util.noop();\n          }\n          const hardware = util.getValue(linesRpi, 'hardware');\n          if (hardware.startsWith('BCM')) {\n            const rpi = util.decodePiCpuinfo(linesRpi);\n            result.manufacturer = rpi.manufacturer;\n            result.model = 'Raspberry Pi';\n            result.serial = rpi.serial;\n            result.version = rpi.type + ' - ' + rpi.revision;\n            result.memMax = os.totalmem();\n            result.memSlots = 0;\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        const workload = [];\n        workload.push(execPromise('ioreg -c IOPlatformExpertDevice -d 2'));\n        workload.push(execPromise('system_profiler SPMemoryDataType'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().replace(/[<>\"]/g, '').split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n          result.model = util.getValue(lines, 'model', '=', true);\n          result.version = util.getValue(lines, 'version', '=', true);\n          result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n          result.assetTag = util.getValue(lines, 'board-id', '=', true);\n\n          // mem\n          let devices = data.results[1] ? data.results[1].toString().split('        BANK ') : [''];\n          if (devices.length === 1) {\n            devices = data.results[1] ? data.results[1].toString().split('        DIMM') : [''];\n          }\n          devices.shift();\n          result.memSlots = devices.length;\n\n          if (os.arch() === 'arm64') {\n            result.memSlots = 0;\n            result.memMax = os.totalmem();\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          const win10plus = parseInt(os.release()) >= 10;\n          const maxCapacityAttribute = win10plus ? 'MaxCapacityEx' : 'MaxCapacity';\n          workload.push(util.powerShell('Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl'));\n          workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n\n            result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n            result.model = util.getValue(lines, 'model', ':');\n            if (!result.model) {\n              result.model = util.getValue(lines, 'product', ':');\n            }\n            result.version = util.getValue(lines, 'version', ':');\n            result.serial = util.getValue(lines, 'serialnumber', ':');\n            result.assetTag = util.getValue(lines, 'partnumber', ':');\n            if (!result.assetTag) {\n              result.assetTag = util.getValue(lines, 'sku', ':');\n            }\n\n            // memphysical\n            lines = data.results[1] ? data.results[1].toString().split('\\r\\n') : [''];\n            result.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ':')) * (win10plus ? 1024 : 1) || null;\n            result.memSlots = util.toInt(util.getValue(lines, 'MemoryDevices', ':')) || null;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.baseboard = baseboard;\n\nfunction chassis(callback) {\n  const chassisTypes = ['Other',\n    'Unknown',\n    'Desktop',\n    'Low Profile Desktop',\n    'Pizza Box',\n    'Mini Tower',\n    'Tower',\n    'Portable',\n    'Laptop',\n    'Notebook',\n    'Hand Held',\n    'Docking Station',\n    'All in One',\n    'Sub Notebook',\n    'Space-Saving',\n    'Lunch Box',\n    'Main System Chassis',\n    'Expansion Chassis',\n    'SubChassis',\n    'Bus Expansion Chassis',\n    'Peripheral Chassis',\n    'Storage Chassis',\n    'Rack Mount Chassis',\n    'Sealed-Case PC',\n    'Multi-System Chassis',\n    'Compact PCI',\n    'Advanced TCA',\n    'Blade',\n    'Blade Enclosure',\n    'Tablet',\n    'Convertible',\n    'Detachable',\n    'IoT Gateway ',\n    'Embedded PC',\n    'Mini PC',\n    'Stick PC',\n  ];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        type: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        sku: '',\n      };\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        const cmd = `echo -n \"chassis_asset_tag: \"; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;\n            echo -n \"chassis_serial: \"; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;\n            echo -n \"chassis_type: \"; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;\n            echo -n \"chassis_vendor: \"; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;\n            echo -n \"chassis_version: \"; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'chassis_vendor');\n          const ctype = parseInt(util.getValue(lines, 'chassis_type').replace(/\\D/g, ''));\n          result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n          result.version = util.getValue(lines, 'chassis_version');\n          result.serial = util.getValue(lines, 'chassis_serial');\n          result.assetTag = util.getValue(lines, 'chassis_asset_tag');\n          if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n          if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.assetTag = util.getValue(lines, 'board-id', '=', true);\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n\n              result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n              result.model = util.getValue(lines, 'model', ':');\n              const ctype = parseInt(util.getValue(lines, 'ChassisTypes', ':').replace(/\\D/g, ''));\n              result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n              result.assetTag = util.getValue(lines, 'partnumber', ':');\n              result.sku = util.getValue(lines, 'sku', ':');\n              if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n              if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n              if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n              if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.chassis = chassis;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// usb.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. usb\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction getLinuxUsbType(type, name) {\n  let result = type;\n  const str = (name + ' ' + type).toLowerCase();\n  if (str.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (str.indexOf('hub') >= 0) { result = 'Hub'; }\n  else if (str.indexOf('keybrd') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (str.indexOf('stora') >= 0) { result = 'Storage'; }\n  else if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (str.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (str.indexOf('audio') >= 0) { result = 'Audio'; }\n\n  return result;\n}\n\nfunction parseLinuxUsb(usb) {\n  const result = {};\n  const lines = usb.split('\\n');\n  if (lines && lines.length && lines[0].indexOf('Device') >= 0) {\n    const parts = lines[0].split(' ');\n    result.bus = parseInt(parts[0], 10);\n    if (parts[2]) {\n      result.deviceId = parseInt(parts[2], 10);\n    } else {\n      result.deviceId = null;\n    }\n  } else {\n    result.bus = null;\n    result.deviceId = null;\n  }\n  const idVendor = util.getValue(lines, 'idVendor', ' ', true).trim();\n  let vendorParts = idVendor.split(' ');\n  vendorParts.shift();\n  const vendor = vendorParts.join(' ');\n\n  const idProduct = util.getValue(lines, 'idProduct', ' ', true).trim();\n  let productParts = idProduct.split(' ');\n  productParts.shift();\n  const product = productParts.join(' ');\n\n  const interfaceClass = util.getValue(lines, 'bInterfaceClass', ' ', true).trim();\n  let interfaceClassParts = interfaceClass.split(' ');\n  interfaceClassParts.shift();\n  const usbType = interfaceClassParts.join(' ');\n\n  const iManufacturer = util.getValue(lines, 'iManufacturer', ' ', true).trim();\n  let iManufacturerParts = iManufacturer.split(' ');\n  iManufacturerParts.shift();\n  const manufacturer = iManufacturerParts.join(' ');\n\n  result.id = (idVendor.startsWith('0x') ? idVendor.split(' ')[0].substr(2, 10) : '') + ':' + (idProduct.startsWith('0x') ? idProduct.split(' ')[0].substr(2, 10) : '');\n  result.name = product;\n  result.type = getLinuxUsbType(usbType, product);\n  result.removable = null;\n  result.vendor = vendor;\n  result.manufacturer = manufacturer;\n  result.maxPower = util.getValue(lines, 'MaxPower', ' ', true);\n  result.serialNumber = null;\n\n  return result;\n}\n\nfunction getDarwinUsbType(name) {\n  let result = '';\n  if (name.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (name.indexOf('touch bar') >= 0) { result = 'Touch Bar'; }\n  else if (name.indexOf('controller') >= 0) { result = 'Controller'; }\n  else if (name.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (name.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (name.indexOf('trackpad') >= 0) { result = 'Trackpad'; }\n  else if (name.indexOf('sensor') >= 0) { result = 'Sensor'; }\n  else if (name.indexOf('bthusb') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('bth') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('rfcomm') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf(' hub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (name.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (name.indexOf('removable') >= 0) { result = 'Storage'; }\n  return result;\n}\n\n\nfunction parseDarwinUsb(usb, id) {\n  const result = {};\n  result.id = id;\n\n  usb = usb.replace(/ \\|/g, '');\n  usb = usb.trim();\n  let lines = usb.split('\\n');\n  lines.shift();\n  try {\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = lines[i].trim();\n      lines[i] = lines[i].replace(/=/g, ':');\n      if (lines[i] !== '{' && lines[i] !== '}' && lines[i + 1] && lines[i + 1].trim() !== '}') {\n        lines[i] = lines[i] + ',';\n      }\n      lines[i] = lines[i].replace(': Yes,', ': \"Yes\",');\n      lines[i] = lines[i].replace(': No,', ': \"No\",');\n    }\n    const usbObj = JSON.parse(lines.join('\\n'));\n    const removableDrive = usbObj['Built-In'].toLowerCase() !== 'yes' && usbObj['non-removable'].toLowerCase() === 'no';\n\n    result.bus = null;\n    result.deviceId = null;\n    result.id = usbObj['USB Address'] || null;\n    result.name = usbObj['kUSBProductString'] || usbObj['USB Product Name'] || null;\n    result.type = getDarwinUsbType((usbObj['kUSBProductString'] || usbObj['USB Product Name'] || '').toLowerCase() + (removableDrive ? ' removable' : ''));\n    result.removable = usbObj['non-removable'].toLowerCase() === 'no';\n    result.vendor = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.manufacturer = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.maxPower = null;\n    result.serialNumber = usbObj['kUSBSerialNumberString'] || null;\n\n    if (result.name) {\n      return result;\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getWindowsUsbTypeCreation(creationclass, name) {\n  let result = '';\n  if (name.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (name.indexOf('speicher') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (creationclass.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbcontroller') >= 0) { result = 'Controller'; }\n  else if (creationclass.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (creationclass.indexOf('pointing') >= 0) { result = 'Mouse'; }\n  else if (creationclass.indexOf('disk') >= 0) { result = 'Storage'; }\n  return result;\n}\n\nfunction parseWindowsUsb(lines, id) {\n  const usbType = getWindowsUsbTypeCreation(util.getValue(lines, 'CreationClassName', ':').toLowerCase(), util.getValue(lines, 'name', ':').toLowerCase());\n\n  if (usbType) {\n    const result = {};\n    result.bus = null;\n    result.deviceId = util.getValue(lines, 'deviceid', ':');\n    result.id = id;\n    result.name = util.getValue(lines, 'name', ':');\n    result.type = usbType;\n    result.removable = null;\n    result.vendor = null;\n    result.manufacturer = util.getValue(lines, 'Manufacturer', ':');\n    result.maxPower = null;\n    result.serialNumber = null;\n\n    return result;\n  } else {\n    return null;\n  }\n}\n\nfunction usb(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        const cmd = 'export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = ('\\n\\n' + stdout.toString()).split('\\n\\nBus ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseLinuxUsb(parts[i]);\n              result.push(usb);\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = (stdout.toString()).split(' +-o ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseDarwinUsb(parts[i]);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match \"USB\"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const usb = parseWindowsUsb(parts[i].split('\\n'), i);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos || _freebsd || _openbsd || _netbsd) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.usb = usb;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// users.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 11. Users/Sessions\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseUsersLinux(lines, phase) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let w_first = true;\n  let w_header = [];\n  let w_pos = [];\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: l[2],\n          time: l[3],\n          ip: (l && l.length > 4) ? l[4].replace(/\\(/g, '').replace(/\\)/g, '') : ''\n        });\n      } else {\n        // w part\n        if (w_first) {    // header\n          w_header = l;\n          w_header.forEach(function (item) {\n            w_pos.push(line.indexOf(item));\n          });\n          w_first = false;\n        } else {\n          // split by w_pos\n          result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();\n          result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();\n          result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\\(/g, '').replace(/\\)/g, '').trim();\n          result_w.command = line.substring(w_pos[7], 1000).trim();\n          // find corresponding 'who' line\n          who_line = result_who.filter(function (obj) {\n            return (obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty);\n          });\n          if (who_line.length === 1) {\n            result.push({\n              user: who_line[0].user,\n              tty: who_line[0].tty,\n              date: who_line[0].date,\n              time: who_line[0].time,\n              ip: who_line[0].ip,\n              command: result_w.command\n            });\n          }\n        }\n      }\n    }\n  });\n  if (result.length === 0 && phase === 2) {\n    return result_who;\n  } else {\n    return result;\n  }\n}\n\nfunction parseUsersDarwin(lines) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: ('' + new Date().getFullYear()) + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + l[3]).slice(-2),\n          time: l[4],\n        });\n      } else {\n        // w part\n        // split by w_pos\n        result_w.user = l[0];\n        result_w.tty = l[1];\n        result_w.ip = (l[2] !== '-') ? l[2] : '';\n        result_w.command = l.slice(5, 1000).join(' ');\n        // find corresponding 'who' line\n        who_line = result_who.filter(function (obj) {\n          return (obj.user === result_w.user && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty));\n        });\n        if (who_line.length === 1) {\n          result.push({\n            user: who_line[0].user,\n            tty: who_line[0].tty,\n            date: who_line[0].date,\n            time: who_line[0].time,\n            ip: result_w.ip,\n            command: result_w.command\n          });\n        }\n      }\n    }\n  });\n  return result;\n}\n\nfunction users(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n\n      // linux\n      if (_linux) {\n        exec('who --ips; echo \"---\"; w | tail -n +2', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersLinux(lines, 1);\n            if (result.length === 0) {\n              exec('who; echo \"---\"; w | tail -n +2', function (error, stdout) {\n                if (!error) {\n                  // lines / split\n                  lines = stdout.toString().split('\\n');\n                  result = parseUsersLinux(lines, 2);\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        exec('who; echo \"---\"; w -h', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        try {\n          let cmd = 'Get-CimInstance Win32_LogonSession | select LogonId,@{n=\"StartTime\";e={$_.StartTime.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl' + '; echo \\'#-#-#-#\\';';\n          cmd += 'Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ' + '; echo \\'#-#-#-#\\';';\n          cmd += '$process = (Get-CimInstance Win32_Process -Filter \"name = \\'explorer.exe\\'\"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo \\'#-#-#-#\\';';\n          cmd += 'query user';\n          util.powerShell(cmd).then((data) => {\n            if (data) {\n              data = data.split('#-#-#-#');\n              let sessions = parseWinSessions((data[0] || '').split(/\\n\\s*\\n/));\n              let loggedons = parseWinLoggedOn((data[1] || '').split(/\\n\\s*\\n/));\n              let queryUser = parseWinUsersQuery((data[3] || '').split('\\r\\n'));\n              let users = parseWinUsers((data[2] || '').split(/\\n\\s*\\n/), queryUser);\n              for (let id in loggedons) {\n                if ({}.hasOwnProperty.call(loggedons, id)) {\n                  loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : '';\n                }\n              }\n              users.forEach(user => {\n                let dateTime = '';\n                for (let id in loggedons) {\n                  if ({}.hasOwnProperty.call(loggedons, id)) {\n                    if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {\n                      dateTime = loggedons[id].dateTime;\n                    }\n                  }\n                }\n\n                result.push({\n                  user: user.user,\n                  tty: user.tty,\n                  date: `${dateTime.substring(0, 10)}`,\n                  time: `${dateTime.substring(11, 19)}`,\n                  ip: '',\n                  command: ''\n                });\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction parseWinSessions(sessionParts) {\n  const sessions = {};\n  sessionParts.forEach(session => {\n    const lines = session.split('\\r\\n');\n    const id = util.getValue(lines, 'LogonId');\n    const starttime = util.getValue(lines, 'starttime');\n    if (id) {\n      sessions[id] = starttime;\n    }\n  });\n  return sessions;\n}\n\nfunction fuzzyMatch(name1, name2) {\n  name1 = name1.toLowerCase();\n  name2 = name2.toLowerCase();\n  let eq = 0;\n  let len = name1.length;\n  if (name2.length > len) { len = name2.length; }\n\n  for (let i = 0; i < len; i++) {\n    const c1 = name1[i] || '';\n    const c2 = name2[i] || '';\n    if (c1 === c2) { eq++; }\n  }\n  return (len > 10 ? eq / len > 0.9 : (len > 0 ? eq / len > 0.8 : false));\n}\n\nfunction parseWinUsers(userParts, userQuery) {\n  const users = [];\n  userParts.forEach(user => {\n    const lines = user.split('\\r\\n');\n\n    const domain = util.getValue(lines, 'domain', ':', true);\n    const username = util.getValue(lines, 'user', ':', true);\n    const sessionid = util.getValue(lines, 'sessionid', ':', true);\n\n    if (username) {\n      const quser = userQuery.filter(item => fuzzyMatch(item.user, username));\n      users.push({\n        domain,\n        user: username,\n        tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid\n      });\n    }\n  });\n  return users;\n}\n\nfunction parseWinLoggedOn(loggedonParts) {\n  const loggedons = {};\n  loggedonParts.forEach(loggedon => {\n    const lines = loggedon.split('\\r\\n');\n\n    const antecendent = util.getValue(lines, 'antecedent', ':', true);\n    let parts = antecendent.split('=');\n    const name = parts.length > 2 ? parts[1].split(',')[0].replace(/\"/g, '').trim() : '';\n    const domain = parts.length > 2 ? parts[2].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    const dependent = util.getValue(lines, 'dependent', ':', true);\n    parts = dependent.split('=');\n    const id = parts.length > 1 ? parts[1].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    if (id) {\n      loggedons[id] = {\n        domain,\n        user: name\n      };\n    }\n  });\n  return loggedons;\n}\n\nfunction parseWinUsersQuery(lines) {\n  lines = lines.filter(item => item);\n  let result = [];\n  const header = lines[0];\n  const headerDelimiter = [];\n  if (header) {\n    const start = (header[0] === ' ') ? 1 : 0;\n    headerDelimiter.push(start - 1);\n    let nextSpace = 0;\n    for (let i = start + 1; i < header.length; i++) {\n      if (header[i] === ' ' && ((header[i - 1] === ' ') || (header[i - 1] === '.'))) {\n        nextSpace = i;\n      } else {\n        if (nextSpace) {\n          headerDelimiter.push(nextSpace);\n          nextSpace = 0;\n        }\n      }\n    }\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim()) {\n        const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || '';\n        const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || '';\n        result.push({\n          user: user,\n          tty: tty,\n        });\n      }\n    }\n  }\n  return result;\n}\n\nexports.users = users;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\nlet _smartMonToolsInstalled = null;\n\nconst WINDIR = process.env.WINDIR || 'C:\\\\Windows';\n\n// powerShell\nlet _psChild;\nlet _psResult = '';\nlet _psCmds = [];\nlet _psPersistent = false;\nconst _psToUTF8 = '$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ';\nconst _psCmdStart = '--###START###--';\nconst _psError = '--ERROR--';\nconst _psCmdSeperator = '--###ENDCMD###--';\nconst _psIdSeperator = '--##ID##--';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\n\nconst stringReplace = new String().replace;\nconst stringToLower = new String().toLowerCase;\nconst stringToString = new String().toString;\nconst stringSubstr = new String().substr;\nconst stringTrim = new String().trim;\nconst stringStartWith = new String().startsWith;\nconst mathMin = Math.min;\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed, lineMatch) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  lineMatch = lineMatch || false;\n  let result = '';\n  lines.forEach((line) => {\n    let lineLower = line.toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      lineLower = lineLower.trim();\n    }\n    if (lineLower.startsWith(property) && (lineMatch ? (lineLower.match(property + separator)) || (lineLower.match(property + ' ' + separator)) : true)) {\n      const parts = trimmed ? line.trim().split(separator) : line.split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        result = parts.join(separator).trim();\n      }\n    }\n  });\n  return result;\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 5000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (let i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC', execOptsWin).toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        powerShell(getWmic() + ' ' + command).then(stdout => {\n          resolve(stdout, '');\n        });\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? `\"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\\\VBoxManage.exe\"` : 'vboxmanage';\n}\n\nfunction powerShellProceedResults(data) {\n  let id = '';\n  let parts;\n  let res = '';\n  // startID\n  if (data.indexOf(_psCmdStart) >= 0) {\n    parts = data.split(_psCmdStart);\n    const parts2 = parts[1].split(_psIdSeperator);\n    id = parts2[0];\n    if (parts2.length > 1) {\n      data = parts2.slice(1).join(_psIdSeperator);\n    }\n  }\n  // result;\n  if (data.indexOf(_psCmdSeperator) >= 0) {\n    parts = data.split(_psCmdSeperator);\n    res = parts[0];\n  }\n  let remove = -1;\n  for (let i = 0; i < _psCmds.length; i++) {\n    if (_psCmds[i].id === id) {\n      remove = i;\n      _psCmds[i].callback(res);\n    }\n  }\n  if (remove >= 0) {\n    _psCmds.splice(remove, 1);\n  }\n}\n\nfunction powerShellStart() {\n  if (!_psChild) {\n    _psChild = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-Command', '-'], {\n      stdio: 'pipe',\n      windowsHide: true,\n      maxBuffer: 1024 * 20000,\n      encoding: 'UTF-8',\n      env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n    });\n    if (_psChild && _psChild.pid) {\n      _psPersistent = true;\n      _psChild.stdout.on('data', function (data) {\n        _psResult = _psResult + data.toString('utf8');\n        if (data.indexOf(_psCmdSeperator) >= 0) {\n          powerShellProceedResults(_psResult);\n          _psResult = '';\n        }\n      });\n      _psChild.stderr.on('data', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('error', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('close', function () {\n        _psChild.kill();\n      });\n    }\n  }\n}\n\nfunction powerShellRelease() {\n  try {\n    if (_psChild) {\n      _psChild.stdin.write('exit' + os.EOL);\n      _psChild.stdin.end();\n      _psPersistent = false;\n    }\n  } catch (e) {\n    if (_psChild) { _psChild.kill(); }\n  }\n  _psChild = null;\n}\n\nfunction powerShell(cmd) {\n\n  if (_psPersistent) {\n    const id = Math.random().toString(36).substring(2, 12);\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        function callback(data) {\n          resolve(data);\n        }\n        _psCmds.push({\n          id,\n          cmd,\n          callback,\n          start: new Date()\n        });\n        try {\n          if (_psChild && _psChild.pid) {\n            _psChild.stdin.write(_psToUTF8 + 'echo ' + _psCmdStart + id + _psIdSeperator + '; ' + os.EOL + cmd + os.EOL + 'echo ' + _psCmdSeperator + os.EOL);\n          }\n        } catch (e) {\n          resolve('');\n        }\n      });\n    });\n\n  } else {\n    let result = '';\n\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        try {\n          const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n            stdio: 'pipe',\n            windowsHide: true,\n            maxBuffer: 1024 * 20000,\n            encoding: 'UTF-8',\n            env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n          });\n\n          if (child && !child.pid) {\n            child.on('error', function () {\n              resolve(result);\n            });\n          }\n          if (child && child.pid) {\n            child.stdout.on('data', function (data) {\n              result = result + data.toString('utf8');\n            });\n            child.stderr.on('data', function () {\n              child.kill();\n              resolve(result);\n            });\n            child.on('close', function () {\n              child.kill();\n\n              resolve(result);\n            });\n            child.on('error', function () {\n              child.kill();\n              resolve(result);\n            });\n            try {\n              child.stdin.write(_psToUTF8 + cmd + os.EOL);\n              child.stdin.write('exit' + os.EOL);\n              child.stdin.end();\n            } catch (e) {\n              child.kill();\n              resolve(result);\n            }\n          } else {\n            resolve(result);\n          }\n        } catch (e) {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n\nfunction execSafe(cmd, args, options) {\n  let result = '';\n  options = options || {};\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn(cmd, args, options);\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result += data.toString();\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp', execOptsWin);\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '').trim() : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction smartMonToolsInstalled() {\n  if (_smartMonToolsInstalled !== null) {\n    return _smartMonToolsInstalled;\n  }\n  _smartMonToolsInstalled = false;\n  if (_windows) {\n    try {\n      const pathArray = execSync('WHERE smartctl 2>nul', execOptsWin).toString().split('\\r\\n');\n      if (pathArray && pathArray.length) {\n        _smartMonToolsInstalled = pathArray[0].indexOf(':\\\\') >= 0;\n      } else {\n        _smartMonToolsInstalled = false;\n      }\n    } catch (e) {\n      _smartMonToolsInstalled = false;\n    }\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    const pathArray = execSync('which smartctl 2>/dev/null', execOptsWin).toString().split('\\r\\n');\n    _smartMonToolsInstalled = pathArray.length > 0;\n  }\n  return _smartMonToolsInstalled;\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2711',\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id', '=');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str, strict) {\n  if (typeof strict === 'undefined') { strict = false; }\n  const s = str || '';\n  let result = '';\n  for (let i = 0; i <= mathMin(s.length, 2000); i++) {\n    if (!(s[i] === undefined ||\n      s[i] === '>' ||\n      s[i] === '<' ||\n      s[i] === '*' ||\n      s[i] === '?' ||\n      s[i] === '[' ||\n      s[i] === ']' ||\n      s[i] === '|' ||\n      s[i] === '' ||\n      s[i] === '$' ||\n      s[i] === ';' ||\n      s[i] === '&' ||\n      s[i] === '(' ||\n      s[i] === ')' ||\n      s[i] === ']' ||\n      s[i] === '#' ||\n      s[i] === '\\\\' ||\n      s[i] === '\\t' ||\n      s[i] === '\\n' ||\n      s[i] === '\\'' ||\n      s[i] === '`' ||\n      s[i] === '\"' ||\n      s[i].length > 1 ||\n      (strict && s[i] === '@') ||\n      (strict && s[i] === ' ') ||\n      (strict && s[i] == '{') ||\n      (strict && s[i] == ')'))) {\n      result = result + s[i];\n    }\n  }\n  return result;\n}\n\nfunction isPrototypePolluted() {\n  const s = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let notPolluted = true;\n  let st = '';\n\n  st.__proto__.replace = stringReplace;\n  st.__proto__.toLowerCase = stringToLower;\n  st.__proto__.toString = stringToString;\n  st.__proto__.substr = stringSubstr;\n\n  notPolluted = notPolluted || (s.length !== 62);\n  const ms = Date.now();\n  if (typeof ms === 'number' && ms > 1600000000000) {\n    const l = ms % 100 + 15;\n    for (let i = 0; i < l; i++) {\n      const r = Math.random() * 61.99999999 + 1;\n      const rs = parseInt(Math.floor(r).toString(), 10);\n      const rs2 = parseInt(r.toString().split('.')[0], 10);\n      const q = Math.random() * 61.99999999 + 1;\n      const qs = parseInt(Math.floor(q).toString(), 10);\n      const qs2 = parseInt(q.toString().split('.')[0], 10);\n      notPolluted = notPolluted && (r !== q);\n      notPolluted = notPolluted && rs === rs2 && qs === qs2;\n      st += s[rs - 1];\n    }\n    notPolluted = notPolluted && st.length === l;\n    // string manipulation\n    let p = Math.random() * l * 0.9999999999;\n    let stm = st.substr(0, p) + ' ' + st.substr(p, 2000);\n    stm.__proto__.replace = stringReplace;\n    let sto = stm.replace(/ /g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '{' + st.substr(p, 2000);\n    sto = stm.replace(/{/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '*' + st.substr(p, 2000);\n    sto = stm.replace(/\\*/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '$' + st.substr(p, 2000);\n    sto = stm.replace(/\\$/g, '');\n    notPolluted = notPolluted && st === sto;\n\n    // lower\n    const stl = st.toLowerCase();\n    notPolluted = notPolluted && (stl.length === l) && stl[l - 1] && !(stl[l]);\n    for (let i = 0; i < l; i++) {\n      const s1 = st[i];\n      s1.__proto__.toLowerCase = stringToLower;\n      const s2 = stl ? stl[i] : '';\n      const s1l = s1.toLowerCase();\n      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !(s1l[1]);\n    }\n  }\n  return !notPolluted;\n}\n\nfunction hex2bin(hex) {\n  return ('00000000' + (parseInt(hex, 16)).toString(2)).substr(-8);\n}\n\nfunction getFilesInPath(source) {\n  const lstatSync = fs.lstatSync;\n  const readdirSync = fs.readdirSync;\n  const join = path.join;\n\n  function isDirectory(source) {\n    return lstatSync(source).isDirectory();\n  }\n  function isFile(source) { return lstatSync(source).isFile(); }\n\n  function getDirectories(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isDirectory);\n  }\n  function getFiles(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isFile);\n  }\n\n  function getFilesRecursively(source) {\n    try {\n      let dirs = getDirectories(source);\n      let files = dirs\n        .map(function (dir) { return getFilesRecursively(dir); })\n        .reduce(function (a, b) { return a.concat(b); }, []);\n      return files.concat(getFiles(source));\n    } catch (e) {\n      return [];\n    }\n  }\n\n  if (fs.existsSync(source)) {\n    return getFilesRecursively(source);\n  } else {\n    return [];\n  }\n}\n\nfunction decodePiCpuinfo(lines) {\n\n  // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n\n  const oldRevisionCodes = {\n    '0002': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0003': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0004': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0005': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '0006': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0007': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0008': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0009': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '000d': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '000e': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '000f': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0010': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0011': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0012': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0013': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0014': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0015': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: '512MB\tEmbest',\n      processor: 'BCM2835'\n    }\n  };\n\n  const processorList = [\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2711',\n  ];\n  const manufacturerList = [\n    'Sony UK',\n    'Egoman',\n    'Embest',\n    'Sony Japan',\n    'Embest',\n    'Stadium'\n  ];\n  const typeList = {\n    '00': 'A',\n    '01': 'B',\n    '02': 'A+',\n    '03': 'B+',\n    '04': '2B',\n    '05': 'Alpha (early prototype)',\n    '06': 'CM1',\n    '08': '3B',\n    '09': 'Zero',\n    '0a': 'CM3',\n    '0c': 'Zero W',\n    '0d': '3B+',\n    '0e': '3A+',\n    '0f': 'Internal use only',\n    '10': 'CM3+',\n    '11': '4B',\n    '12': 'Zero 2 W',\n    '13': '400',\n    '14': 'CM4'\n  };\n\n  const revisionCode = getValue(lines, 'revision', ':', true);\n  const model = getValue(lines, 'model:', ':', true);\n  const serial = getValue(lines, 'serial', ':', true);\n\n  let result = {};\n  if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {\n    // old revision codes\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: oldRevisionCodes[revisionCode].memory,\n      manufacturer: oldRevisionCodes[revisionCode].manufacturer,\n      processor: oldRevisionCodes[revisionCode].processor,\n      type: oldRevisionCodes[revisionCode].type,\n      revision: oldRevisionCodes[revisionCode].revision,\n    };\n\n  } else {\n    // new revision code\n    const revision = ('00000000' + getValue(lines, 'revision', ':', true).toLowerCase()).substr(-8);\n    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;\n    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];\n    const processor = processorList[parseInt(revision.substr(4, 1), 10)];\n    const typeCode = revision.substr(5, 2);\n\n\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: 256 * Math.pow(2, memSizeCode),\n      manufacturer,\n      processor,\n      type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : '',\n      revision: '1.' + revision.substr(7, 1),\n    };\n  }\n  return result;\n}\n\nfunction promiseAll(promises) {\n  const resolvingPromises = promises.map(function (promise) {\n    return new Promise(function (resolve) {\n      let payload = new Array(2);\n      promise.then(function (result) {\n        payload[0] = result;\n      })\n        .catch(function (error) {\n          payload[1] = error;\n        })\n        .then(function () {\n          // The wrapped Promise returns an array: 0 = result, 1 = error ... we resolve all\n          resolve(payload);\n        });\n    });\n  });\n  const errors = [];\n  const results = [];\n\n  // Execute all wrapped Promises\n  return Promise.all(resolvingPromises)\n    .then(function (items) {\n      items.forEach(function (payload) {\n        if (payload[1]) {\n          errors.push(payload[1]);\n          results.push(null);\n        } else {\n          errors.push(null);\n          results.push(payload[0]);\n        }\n      });\n\n      return {\n        errors: errors,\n        results: results\n      };\n    });\n}\n\nfunction promisify(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction promisifySave(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve) {\n      args.push(function (err, data) {\n        resolve(data);\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction linuxVersion() {\n  let result = '';\n  if (_linux) {\n    try {\n      result = execSync('uname -v').toString();\n    } catch (e) {\n      result = '';\n    }\n  }\n  return result;\n}\n\nfunction plistParser(xmlStr) {\n  const tags = ['array', 'dict', 'key', 'string', 'integer', 'date', 'real', 'data', 'boolean', 'arrayEmpty'];\n  const startStr = '<plist version';\n\n  let pos = xmlStr.indexOf(startStr);\n  let len = xmlStr.length;\n  while (xmlStr[pos] !== '>' && pos < len) {\n    pos++;\n  }\n\n  let depth = 0;\n  let inTagStart = false;\n  let inTagContent = false;\n  let inTagEnd = false;\n  let metaData = [{ tagStart: '', tagEnd: '', tagContent: '', key: '', data: null }];\n  let c = '';\n  let cn = xmlStr[pos];\n\n  while (pos < len) {\n    c = cn;\n    if (pos + 1 < len) { cn = xmlStr[pos + 1]; }\n    if (c === '<') {\n      inTagContent = false;\n      if (cn === '/') { inTagEnd = true; }\n      else if (metaData[depth].tagStart) {\n        metaData[depth].tagContent = '';\n        if (!metaData[depth].data) { metaData[depth].data = metaData[depth].tagStart === 'array' ? [] : {}; }\n        depth++;\n        metaData.push({ tagStart: '', tagEnd: '', tagContent: '', key: null, data: null });\n        inTagStart = true;\n        inTagContent = false;\n      }\n      else if (!inTagStart) { inTagStart = true; }\n    } else if (c === '>') {\n      if (metaData[depth].tagStart === 'true/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = true; }\n      if (metaData[depth].tagStart === 'false/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = false; }\n      if (metaData[depth].tagStart === 'array/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/arrayEmpty'; metaData[depth].data = []; }\n      if (inTagContent) { inTagContent = false; }\n      if (inTagStart) {\n        inTagStart = false;\n        inTagContent = true;\n        if (metaData[depth].tagStart === 'array') {\n          metaData[depth].data = [];\n        }\n        if (metaData[depth].tagStart === 'dict') {\n          metaData[depth].data = {};\n        }\n      }\n      if (inTagEnd) {\n        inTagEnd = false;\n        if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {\n          if (metaData[depth].tagEnd === '/dict' || metaData[depth].tagEnd === '/array') {\n            if (depth > 1 && metaData[depth - 2].tagStart === 'array') {\n              metaData[depth - 2].data.push(metaData[depth - 1].data);\n            }\n            if (depth > 1 && metaData[depth - 2].tagStart === 'dict') {\n              metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;\n            }\n            depth--;\n            metaData.pop();\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n          else {\n            if (metaData[depth].tagEnd === '/key' && metaData[depth].tagContent) {\n              metaData[depth].key = metaData[depth].tagContent;\n            } else {\n              if (metaData[depth].tagEnd === '/real' && metaData[depth].tagContent) { metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/integer' && metaData[depth].tagContent) { metaData[depth].data = parseInt(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/string' && metaData[depth].tagContent) { metaData[depth].data = metaData[depth].tagContent || ''; }\n              if (metaData[depth].tagEnd === '/boolean') { metaData[depth].data = metaData[depth].tagContent || false; }\n              if (metaData[depth].tagEnd === '/arrayEmpty') { metaData[depth].data = metaData[depth].tagContent || []; }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'array') { metaData[depth - 1].data.push(metaData[depth].data); }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'dict') { metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data; }\n            }\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n        }\n        metaData[depth].tagEnd = '';\n        inTagStart = false;\n        inTagContent = false;\n      }\n    } else {\n      if (inTagStart) { metaData[depth].tagStart += c; }\n      if (inTagEnd) { metaData[depth].tagEnd += c; }\n      if (inTagContent) { metaData[depth].tagContent += c; }\n    }\n    pos++;\n  }\n  return metaData[0].data;\n}\n\nfunction strIsNumeric(str) {\n  return typeof str === 'string' && !isNaN(str) && !isNaN(parseFloat(str));\n}\n\nfunction plistReader(output) {\n  const lines = output.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf(' = ') >= 0) {\n      const lineParts = lines[i].split(' = ');\n      lineParts[0] = lineParts[0].trim();\n      if (!lineParts[0].startsWith('\"')) {\n        lineParts[0] = '\"' + lineParts[0] + '\"';\n      }\n      lineParts[1] = lineParts[1].trim();\n      if (lineParts[1].indexOf('\"') === -1 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1);\n        if (!strIsNumeric(valueString)) {\n          lineParts[1] = `\"${valueString}\";`;\n        }\n      }\n      if (lineParts[1].indexOf('\"') >= 0 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/\"/g, '');\n        if (strIsNumeric(valueString)) {\n          lineParts[1] = `${valueString};`;\n        }\n      }\n      lines[i] = lineParts.join(' : ');\n    }\n    lines[i] = lines[i].replace(/\\(/g, '[').replace(/\\)/g, ']').replace(/;/g, ',').trim();\n    if (lines[i].startsWith('}') && lines[i - 1] && lines[i - 1].endsWith(',')) {\n      lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);\n    }\n  }\n  output = lines.join('');\n  let obj = {};\n  try {\n    obj = JSON.parse(output);\n  } catch (e) {\n    noop();\n  }\n  return obj;\n}\n\nfunction semverCompare(v1, v2) {\n  let res = 0;\n  const parts1 = v1.split('.');\n  const parts2 = v2.split('.');\n  if (parts1[0] < parts2[0]) { res = 1; }\n  else if (parts1[0] > parts2[0]) { res = -1; }\n  else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {\n    if (parts1[1] < parts2[1]) { res = 1; }\n    else if (parts1[1] > parts2[1]) { res = -1; }\n    else if (parts1[1] === parts2[1]) {\n      if (parts1.length >= 3 && parts2.length >= 3) {\n        if (parts1[2] < parts2[2]) { res = 1; }\n        else if (parts1[2] > parts2[2]) { res = -1; }\n      } else if (parts2.length >= 3) {\n        res = 1;\n      }\n    }\n  }\n  return res;\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.powerShellStart = powerShellStart;\nexports.powerShellRelease = powerShellRelease;\nexports.execSafe = execSafe;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\nexports.isPrototypePolluted = isPrototypePolluted;\nexports.decodePiCpuinfo = decodePiCpuinfo;\nexports.promiseAll = promiseAll;\nexports.promisify = promisify;\nexports.promisifySave = promisifySave;\nexports.smartMonToolsInstalled = smartMonToolsInstalled;\nexports.linuxVersion = linuxVersion;\nexports.plistParser = plistParser;\nexports.plistReader = plistReader;\nexports.stringReplace = stringReplace;\nexports.stringToLower = stringToLower;\nexports.stringToString = stringToString;\nexports.stringSubstr = stringSubstr;\nexports.stringTrim = stringTrim;\nexports.stringStartWith = stringStartWith;\nexports.mathMin = mathMin;\nexports.WINDIR = WINDIR;\nexports.getFilesInPath = getFilesInPath;\nexports.semverCompare = semverCompare;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// virtualbox.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 14. Docker\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nfunction vboxInfo(callback) {\n\n  // fallback - if only callback is given\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(util.getVboxmanage() + ' list vms --long', function (error, stdout) {\n          let parts = (os.EOL + stdout.toString()).split(os.EOL + 'Name:');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = ('Name:' + part).split(os.EOL);\n            const state = util.getValue(lines, 'State');\n            const running = state.startsWith('running');\n            const runningSinceString = running ? state.replace('running (since ', '').replace(')', '').trim() : '';\n            let runningSince = 0;\n            try {\n              if (running) {\n                const sinceDateObj = new Date(runningSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            const stoppedSinceString = !running ? state.replace('powered off (since', '').replace(')', '').trim() : '';\n            let stoppedSince = 0;\n            try {\n              if (!running) {\n                const sinceDateObj = new Date(stoppedSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            result.push({\n              id: util.getValue(lines, 'UUID'),\n              name: util.getValue(lines, 'Name'),\n              running,\n              started: runningSinceString,\n              runningSince,\n              stopped: stoppedSinceString,\n              stoppedSince,\n              guestOS: util.getValue(lines, 'Guest OS'),\n              hardwareUUID: util.getValue(lines, 'Hardware UUID'),\n              memory: parseInt(util.getValue(lines, 'Memory size', '     '), 10),\n              vram: parseInt(util.getValue(lines, 'VRAM size'), 10),\n              cpus: parseInt(util.getValue(lines, 'Number of CPUs'), 10),\n              cpuExepCap: util.getValue(lines, 'CPU exec cap'),\n              cpuProfile: util.getValue(lines, 'CPUProfile'),\n              chipset: util.getValue(lines, 'Chipset'),\n              firmware: util.getValue(lines, 'Firmware'),\n              pageFusion: util.getValue(lines, 'Page Fusion') === 'enabled',\n              configFile: util.getValue(lines, 'Config file'),\n              snapshotFolder: util.getValue(lines, 'Snapshot folder'),\n              logFolder: util.getValue(lines, 'Log folder'),\n              hpet: util.getValue(lines, 'HPET') === 'enabled',\n              pae: util.getValue(lines, 'PAE') === 'enabled',\n              longMode: util.getValue(lines, 'Long Mode') === 'enabled',\n              tripleFaultReset: util.getValue(lines, 'Triple Fault Reset') === 'enabled',\n              apic: util.getValue(lines, 'APIC') === 'enabled',\n              x2Apic: util.getValue(lines, 'X2APIC') === 'enabled',\n              acpi: util.getValue(lines, 'ACPI') === 'enabled',\n              ioApic: util.getValue(lines, 'IOAPIC') === 'enabled',\n              biosApicMode: util.getValue(lines, 'BIOS APIC mode'),\n              bootMenuMode: util.getValue(lines, 'Boot menu mode'),\n              bootDevice1: util.getValue(lines, 'Boot Device 1'),\n              bootDevice2: util.getValue(lines, 'Boot Device 2'),\n              bootDevice3: util.getValue(lines, 'Boot Device 3'),\n              bootDevice4: util.getValue(lines, 'Boot Device 4'),\n              timeOffset: util.getValue(lines, 'Time offset'),\n              rtc: util.getValue(lines, 'RTC'),\n            });\n          });\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } catch (e) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.vboxInfo = vboxInfo;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// wifi.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. wifi\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\n\nfunction wifiDBFromQuality(quality) {\n  return (parseFloat(quality) / 2 - 100);\n}\n\nfunction wifiQualityFromDB(db) {\n  const result = 2 * (parseFloat(db) + 100);\n  return result <= 100 ? result : 100;\n}\n\nconst _wifi_frequencies = {\n  1: 2412,\n  2: 2417,\n  3: 2422,\n  4: 2427,\n  5: 2432,\n  6: 2437,\n  7: 2442,\n  8: 2447,\n  9: 2452,\n  10: 2457,\n  11: 2462,\n  12: 2467,\n  13: 2472,\n  14: 2484,\n  32: 5160,\n  34: 5170,\n  36: 5180,\n  38: 5190,\n  40: 5200,\n  42: 5210,\n  44: 5220,\n  46: 5230,\n  48: 5240,\n  50: 5250,\n  52: 5260,\n  54: 5270,\n  56: 5280,\n  58: 5290,\n  60: 5300,\n  62: 5310,\n  64: 5320,\n  68: 5340,\n  96: 5480,\n  100: 5500,\n  102: 5510,\n  104: 5520,\n  106: 5530,\n  108: 5540,\n  110: 5550,\n  112: 5560,\n  114: 5570,\n  116: 5580,\n  118: 5590,\n  120: 5600,\n  122: 5610,\n  124: 5620,\n  126: 5630,\n  128: 5640,\n  132: 5660,\n  134: 5670,\n  136: 5680,\n  138: 5690,\n  140: 5700,\n  142: 5710,\n  144: 5720,\n  149: 5745,\n  151: 5755,\n  153: 5765,\n  155: 5775,\n  157: 5785,\n  159: 5795,\n  161: 5805,\n  165: 5825,\n  169: 5845,\n  173: 5865,\n  183: 4915,\n  184: 4920,\n  185: 4925,\n  187: 4935,\n  188: 4940,\n  189: 4945,\n  192: 4960,\n  196: 4980\n};\n\nfunction wifiFrequencyFromChannel(channel) {\n  return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;\n}\n\nfunction wifiChannelFromFrequencs(frequency) {\n  let channel = 0;\n  for (let key in _wifi_frequencies) {\n    if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {\n      if (_wifi_frequencies[key] === frequency) { channel = util.toInt(key); }\n    }\n  }\n  return channel;\n}\n\nfunction ifaceListLinux() {\n  const result = [];\n  const cmd = 'iw dev 2>/dev/null';\n  try {\n    const all = execSync(cmd).toString().split('\\n').map(line => line.trim()).join('\\n');\n    const parts = all.split('\\nInterface ');\n    parts.shift();\n    parts.forEach(ifaceDetails => {\n      const lines = ifaceDetails.split('\\n');\n      const iface = lines[0];\n      const id = util.toInt(util.getValue(lines, 'ifindex', ' '));\n      const mac = util.getValue(lines, 'addr', ' ');\n      const channel = util.toInt(util.getValue(lines, 'channel', ' '));\n      result.push({\n        id,\n        iface,\n        mac,\n        channel\n      });\n    });\n    return result;\n  } catch (e) {\n    try {\n      const all = execSync('nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null').toString();\n      const parts = all.split('\\nGENERAL.DEVICE:');\n      let i = 1;\n      parts.forEach(ifaceDetails => {\n        const lines = ifaceDetails.split('\\n');\n        const iface = util.getValue(lines, 'GENERAL.DEVICE');\n        const type = util.getValue(lines, 'GENERAL.TYPE');\n        const id = i++; // // util.getValue(lines, 'GENERAL.PATH');\n        const mac = util.getValue(lines, 'GENERAL.HWADDR');\n        const channel = '';\n        if (type.toLowerCase() === 'wifi') {\n          result.push({\n            id,\n            iface,\n            mac,\n            channel\n          });\n        }\n      });\n      return result;\n    } catch (e) {\n      return [];\n    }\n  }\n}\n\nfunction nmiDeviceLinux(iface) {\n  const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const ssid = util.getValue(lines, 'GENERAL.CONNECTION');\n    return {\n      iface,\n      type: util.getValue(lines, 'GENERAL.TYPE'),\n      vendor: util.getValue(lines, 'GENERAL.VENDOR'),\n      product: util.getValue(lines, 'GENERAL.PRODUCT'),\n      mac: util.getValue(lines, 'GENERAL.HWADDR').toLowerCase(),\n      ssid: ssid !== '--' ? ssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction nmiConnectionLinux(ssid) {\n  const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const bssid = util.getValue(lines, '802-11-wireless.seen-bssids').toLowerCase();\n    return {\n      ssid: ssid !== '--' ? ssid : null,\n      uuid: util.getValue(lines, 'connection.uuid'),\n      type: util.getValue(lines, 'connection.type'),\n      autoconnect: util.getValue(lines, 'connection.autoconnect') === 'yes',\n      security: util.getValue(lines, '802-11-wireless-security.key-mgmt'),\n      bssid: bssid !== '--' ? bssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction wpaConnectionLinux(iface) {\n  const cmd = `wpa_cli -i ${iface} status 2>&1`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const freq = util.toInt(util.getValue(lines, 'freq', '='));\n    return {\n      ssid: util.getValue(lines, 'ssid', '='),\n      uuid: util.getValue(lines, 'uuid', '='),\n      security: util.getValue(lines, 'key_mgmt', '='),\n      freq,\n      channel: wifiChannelFromFrequencs(freq),\n      bssid: util.getValue(lines, 'bssid', '=').toLowerCase()\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction getWifiNetworkListNmi() {\n  const result = [];\n  const cmd = 'nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null';\n  try {\n    const stdout = execSync(cmd, { maxBuffer: 1024 * 20000 });\n    const parts = stdout.toString().split('ACTIVE:');\n    parts.shift();\n    parts.forEach(part => {\n      part = 'ACTIVE:' + part;\n      const lines = part.split(os.EOL);\n      const channel = util.getValue(lines, 'CHAN');\n      const frequency = util.getValue(lines, 'FREQ').toLowerCase().replace('mhz', '').trim();\n      const security = util.getValue(lines, 'SECURITY').replace('(', '').replace(')', '');\n      const wpaFlags = util.getValue(lines, 'WPA-FLAGS').replace('(', '').replace(')', '');\n      const rsnFlags = util.getValue(lines, 'RSN-FLAGS').replace('(', '').replace(')', '');\n      result.push({\n        ssid: util.getValue(lines, 'SSID'),\n        bssid: util.getValue(lines, 'BSSID').toLowerCase(),\n        mode: util.getValue(lines, 'MODE'),\n        channel: channel ? parseInt(channel, 10) : null,\n        frequency: frequency ? parseInt(frequency, 10) : null,\n        signalLevel: wifiDBFromQuality(util.getValue(lines, 'SIGNAL')),\n        quality: parseFloat(util.getValue(lines, 'SIGNAL')),\n        security: security && security !== 'none' ? security.split(' ') : [],\n        wpaFlags: wpaFlags && wpaFlags !== 'none' ? wpaFlags.split(' ') : [],\n        rsnFlags: rsnFlags && rsnFlags !== 'none' ? rsnFlags.split(' ') : []\n      });\n    });\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getWifiNetworkListIw(iface) {\n  const result = [];\n  try {\n    let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`).toString().split('        Cell ');\n    if (iwlistParts[0].indexOf('resource busy') >= 0) { return -1; }\n    if (iwlistParts.length > 1) {\n      iwlistParts.shift();\n      iwlistParts.forEach(element => {\n        const lines = element.split('\\n');\n        const channel = util.getValue(lines, 'channel', ':', true);\n        const address = (lines && lines.length && lines[0].indexOf('Address:') >= 0 ? lines[0].split('Address:')[1].trim().toLowerCase() : '');\n        const mode = util.getValue(lines, 'mode', ':', true);\n        const frequency = util.getValue(lines, 'frequency', ':', true);\n        const qualityString = util.getValue(lines, 'Quality', '=', true);\n        const dbParts = qualityString.toLowerCase().split('signal level=');\n        const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;\n        const quality = db ? wifiQualityFromDB(db) : 0;\n        const ssid = util.getValue(lines, 'essid', ':', true);\n\n        // security and wpa-flags\n        const isWpa = element.indexOf(' WPA ') >= 0;\n        const isWpa2 = element.indexOf('WPA2 ') >= 0;\n        const security = [];\n        if (isWpa) { security.push('WPA'); }\n        if (isWpa2) { security.push('WPA2'); }\n        const wpaFlags = [];\n        let wpaFlag = '';\n        lines.forEach(function (line) {\n          const l = line.trim().toLowerCase();\n          if (l.indexOf('group cipher') >= 0) {\n            if (wpaFlag) {\n              wpaFlags.push(wpaFlag);\n            }\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              wpaFlag = parts[1].trim().toUpperCase();\n            }\n          }\n          if (l.indexOf('pairwise cipher') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('tkip')) { wpaFlag = (wpaFlag ? 'TKIP/' + wpaFlag : 'TKIP'); }\n              else if (parts[1].indexOf('ccmp')) { wpaFlag = (wpaFlag ? 'CCMP/' + wpaFlag : 'CCMP'); }\n              else if (parts[1].indexOf('proprietary')) { wpaFlag = (wpaFlag ? 'PROP/' + wpaFlag : 'PROP'); }\n            }\n          }\n          if (l.indexOf('authentication suites') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('802.1x')) { wpaFlag = (wpaFlag ? '802.1x/' + wpaFlag : '802.1x'); }\n              else if (parts[1].indexOf('psk')) { wpaFlag = (wpaFlag ? 'PSK/' + wpaFlag : 'PSK'); }\n            }\n          }\n        });\n        if (wpaFlag) {\n          wpaFlags.push(wpaFlag);\n        }\n\n        result.push({\n          ssid,\n          bssid: address,\n          mode,\n          channel: channel ? util.toInt(channel) : null,\n          frequency: frequency ? util.toInt(frequency.replace('.', '')) : null,\n          signalLevel: db,\n          quality,\n          security,\n          wpaFlags,\n          rsnFlags: []\n        });\n      });\n    }\n    return result;\n  } catch (e) {\n    return -1;\n  }\n}\n\nfunction parseWifiDarwin(wifiObj) {\n  const result = [];\n  if (wifiObj) {\n    wifiObj.forEach(function (wifiItem) {\n      const signalLevel = wifiItem.RSSI;\n      let security = [];\n      let wpaFlags = [];\n      if (wifiItem.WPA_IE) {\n        security.push('WPA');\n        if (wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS) {\n          wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('PSK/TKIP') === -1) { wpaFlags.push('PSK/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      if (wifiItem.RSN_IE) {\n        security.push('WPA2');\n        if (wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS) {\n          wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('TKIP/TKIP') === -1) { wpaFlags.push('TKIP/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      result.push({\n        ssid: wifiItem.SSID_STR,\n        bssid: wifiItem.BSSID,\n        mode: '',\n        channel: wifiItem.CHANNEL,\n        frequency: wifiFrequencyFromChannel(wifiItem.CHANNEL),\n        signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,\n        quality: wifiQualityFromDB(signalLevel),\n        security,\n        wpaFlags,\n        rsnFlags: []\n      });\n    });\n  }\n  return result;\n}\nfunction wifiNetworks(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        result = getWifiNetworkListNmi();\n        if (result.length === 0) {\n          try {\n            const iwconfigParts = execSync('export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL').toString().split('\\n\\n');\n            let iface = '';\n            iwconfigParts.forEach(element => {\n              if (element.indexOf('no wireless') === -1 && element.trim() !== '') {\n                iface = element.split(' ')[0];\n              }\n            });\n            if (iface) {\n              const res = getWifiNetworkListIw(iface);\n              if (res === -1) {\n                // try again after 4 secs\n                setTimeout(function (iface) {\n                  const res = getWifiNetworkListIw(iface);\n                  if (res != -1) { result = res; }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                }, 4000);\n              } else {\n                result = res;\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        } else {\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        }\n      } else if (_darwin) {\n        let cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s -x';\n        exec(cmd, { maxBuffer: 1024 * 40000 }, function (error, stdout) {\n          const output = stdout.toString();\n          result = parseWifiDarwin(util.plistParser(output));\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show networks mode=Bssid';\n        util.powerShell(cmd).then((stdout) => {\n          const ssidParts = stdout.toString('utf8').split(os.EOL + os.EOL + 'SSID ');\n          ssidParts.shift();\n\n          ssidParts.forEach(ssidPart => {\n            const ssidLines = ssidPart.split(os.EOL);\n            if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(':') >= 0) {\n              const bssidsParts = ssidPart.split(' BSSID');\n              bssidsParts.shift();\n\n              bssidsParts.forEach((bssidPart) => {\n                const bssidLines = bssidPart.split(os.EOL);\n                const bssidLine = bssidLines[0].split(':');\n                bssidLine.shift();\n                const bssid = bssidLine.join(':').trim().toLowerCase();\n                const channel = bssidLines[3].split(':').pop().trim();\n                const quality = bssidLines[1].split(':').pop().trim();\n\n                result.push({\n                  ssid: ssidLines[0].split(':').pop().trim(),\n                  bssid,\n                  mode: '',\n                  channel: channel ? parseInt(channel, 10) : null,\n                  frequency: wifiFrequencyFromChannel(channel),\n                  signalLevel: wifiDBFromQuality(quality),\n                  quality: quality ? parseInt(quality, 10) : null,\n                  security: [ssidLines[2].split(':').pop().trim()],\n                  wpaFlags: [ssidLines[3].split(':').pop().trim()],\n                  rsnFlags: []\n                });\n              });\n            }\n          });\n\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiNetworks = wifiNetworks;\n\nfunction getVendor(model) {\n  model = model.toLowerCase();\n  let result = '';\n  if (model.indexOf('intel') >= 0) { result = 'Intel'; }\n  else if (model.indexOf('realtek') >= 0) { result = 'Realtek'; }\n  else if (model.indexOf('qualcom') >= 0) { result = 'Qualcom'; }\n  else if (model.indexOf('broadcom') >= 0) { result = 'Broadcom'; }\n  else if (model.indexOf('cavium') >= 0) { result = 'Cavium'; }\n  else if (model.indexOf('cisco') >= 0) { result = 'Cisco'; }\n  else if (model.indexOf('marvel') >= 0) { result = 'Marvel'; }\n  else if (model.indexOf('zyxel') >= 0) { result = 'Zyxel'; }\n  else if (model.indexOf('melanox') >= 0) { result = 'Melanox'; }\n  else if (model.indexOf('d-link') >= 0) { result = 'D-Link'; }\n  else if (model.indexOf('tp-link') >= 0) { result = 'TP-Link'; }\n  else if (model.indexOf('asus') >= 0) { result = 'Asus'; }\n  else if (model.indexOf('linksys') >= 0) { result = 'Linksys'; }\n  return result;\n}\n\nfunction wifiConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        const networkList = getWifiNetworkListNmi();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          const wpaDetails = wpaConnectionLinux(ifaceDetail.iface);\n          const ssid = nmiDetails.ssid || wpaDetails.ssid;\n          const network = networkList.filter(nw => nw.ssid === ssid);\n          const nmiConnection = nmiConnectionLinux(ssid);\n          const channel = network && network.length && network[0].channel ? network[0].channel : (wpaDetails.channel ? wpaDetails.channel : null);\n          const bssid = network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null);\n          if (ssid && bssid) {\n            result.push({\n              id: ifaceDetail.id,\n              iface: ifaceDetail.iface,\n              model: nmiDetails.product,\n              ssid,\n              bssid: network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null),\n              channel,\n              frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n              type: nmiConnection.type ? nmiConnection.type : '802.11',\n              security: nmiConnection.security ? nmiConnection.security : (wpaDetails.security ? wpaDetails.security : null),\n              signalLevel: network && network.length && network[0].signalLevel ? network[0].signalLevel : null,\n              txRate: null\n            });\n          }\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I';\n            exec(cmd, function (error, stdout) {\n              const lines2 = stdout.toString().split('\\n');\n              if (lines.length > 10) {\n                const ssid = util.getValue(lines2, 'ssid', ':', true);\n                const bssid = util.getValue(lines2, 'bssid', ':', true);\n                const security = util.getValue(lines2, 'link auth', ':', true);\n                const txRate = util.getValue(lines2, 'lastTxRate', ':', true);\n                const channel = util.getValue(lines2, 'channel', ':', true).split(',')[0];\n                const type = '802.11';\n                const rssi = util.toInt(util.getValue(lines2, 'agrCtlRSSI', ':', true));\n                const noise = util.toInt(util.getValue(lines2, 'agrCtlNoise', ':', true));\n                const signalLevel = rssi - noise;\n                if (ssid || bssid) {\n                  result.push({\n                    id: 'Wi-Fi',\n                    iface,\n                    model,\n                    ssid,\n                    bssid,\n                    channel: util.toInt(channel),\n                    frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                    type,\n                    security,\n                    signalLevel,\n                    txRate\n                  });\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const ssid = util.getValue(lines, 'SSID', ':', true);\n              const bssid = util.getValue(lines, 'BSSID', ':', true);\n              const signalLevel = util.getValue(lines, 'Signal', ':', true);\n              const type = util.getValue(lines, 'Radio type', ':', true) || util.getValue(lines, 'Type de radio', ':', true) || util.getValue(lines, 'Funktyp', ':', true) || null;\n              const security = util.getValue(lines, 'authentication', ':', true) || util.getValue(lines, 'Authentification', ':', true) || util.getValue(lines, 'Authentifizierung', ':', true) || null;\n              const channel = util.getValue(lines, 'Channel', ':', true) || util.getValue(lines, 'Canal', ':', true) || util.getValue(lines, 'Kanal', ':', true) || null;\n              const txRate = util.getValue(lines, 'Transmit rate (mbps)', ':', true) || util.getValue(lines, 'Transmission (mbit/s)', ':', true) || util.getValue(lines, 'Empfangsrate (MBit/s)', ':', true) || null;\n              if (model && id && ssid && bssid) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  ssid,\n                  bssid,\n                  channel: util.toInt(channel),\n                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                  type,\n                  security,\n                  signalLevel,\n                  txRate: util.toInt(txRate) || null\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiConnections = wifiConnections;\n\nfunction wifiInterfaces(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          result.push({\n            id: ifaceDetail.id,\n            iface: ifaceDetail.iface,\n            model: nmiDetails.product ? nmiDetails.product : null,\n            vendor: nmiDetails.vendor ? nmiDetails.vendor : null,\n            mac: ifaceDetail.mac,\n          });\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const mac = util.getValue(lines, 'MAC Address', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            result.push({\n              id: 'Wi-Fi',\n              iface,\n              model,\n              vendor: '',\n              mac\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const macParts = lines[3].indexOf(':') >= 0 ? lines[3].split(':') : [];\n              macParts.shift();\n              const mac = macParts.join(':').trim();\n              const vendor = getVendor(model);\n              if (iface && model && id && mac) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  vendor,\n                  mac,\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiInterfaces = wifiInterfaces;\n","module.exports={\n  \"name\": \"systeminformation\",\n  \"version\": \"5.17.12\",\n  \"description\": \"Advanced, lightweight system and OS information library\",\n  \"license\": \"MIT\",\n  \"author\": \"Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)\",\n  \"homepage\": \"https://systeminformation.io\",\n  \"main\": \"./lib/index.js\",\n  \"bin\": {\n    \"systeminformation\": \"lib/cli.js\"\n  },\n  \"types\": \"./lib/index.d.ts\",\n  \"scripts\": {\n    \"test\": \"node ./test/test.js\"\n  },\n  \"files\": [\n    \"lib/\"\n  ],\n  \"keywords\": [\n    \"system information\",\n    \"sysinfo\",\n    \"monitor\",\n    \"monitoring\",\n    \"os\",\n    \"linux\",\n    \"osx\",\n    \"windows\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"cpu\",\n    \"cpuload\",\n    \"physical cores\",\n    \"logical cores\",\n    \"processor\",\n    \"cores\",\n    \"threads\",\n    \"socket type\",\n    \"memory\",\n    \"file system\",\n    \"fsstats\",\n    \"diskio\",\n    \"block devices\",\n    \"netstats\",\n    \"network\",\n    \"network interfaces\",\n    \"network connections\",\n    \"network stats\",\n    \"iface\",\n    \"printer\",\n    \"processes\",\n    \"users\",\n    \"internet\",\n    \"battery\",\n    \"docker\",\n    \"docker stats\",\n    \"docker processes\",\n    \"graphics\",\n    \"graphic card\",\n    \"graphic controller\",\n    \"gpu\",\n    \"display\",\n    \"smart\",\n    \"disk layout\",\n    \"usb\",\n    \"audio\",\n    \"bluetooth\",\n    \"wifi\",\n    \"wifinetworks\",\n    \"virtual box\",\n    \"virtualbox\",\n    \"vm\",\n    \"backend\",\n    \"hardware\",\n    \"BIOS\",\n    \"chassis\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sebhildebrandt/systeminformation.git\"\n  },\n  \"funding\": {\n    \"type\": \"Buy me a coffee\",\n    \"url\": \"https://www.buymeacoffee.com/systeminfo\"\n  },\n  \"os\": [\n    \"darwin\",\n    \"linux\",\n    \"win32\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"sunos\",\n    \"android\"\n  ],\n  \"engines\": {\n    \"node\": \">=8.0.0\"\n  }\n}\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\");\n\nmodule.exports = function (value) {\n\tif (typeof value !== \"function\") return false;\n\n\tif (!hasOwnProperty.call(value, \"length\")) return false;\n\n\ttry {\n\t\tif (typeof value.length !== \"number\") return false;\n\t\tif (typeof value.call !== \"function\") return false;\n\t\tif (typeof value.apply !== \"function\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\treturn !isPrototype(value);\n};\n","\"use strict\";\n\nvar isValue       = require(\"../value/is\")\n  , isObject      = require(\"../object/is\")\n  , stringCoerce  = require(\"../string/coerce\")\n  , toShortString = require(\"./to-short-string\");\n\nvar resolveMessage = function (message, value) {\n\treturn message.replace(\"%v\", toShortString(value));\n};\n\nmodule.exports = function (value, defaultMessage, inputOptions) {\n\tif (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));\n\tif (!isValue(value)) {\n\t\tif (\"default\" in inputOptions) return inputOptions[\"default\"];\n\t\tif (inputOptions.isOptional) return null;\n\t}\n\tvar errorMessage = stringCoerce(inputOptions.errorMessage);\n\tif (!isValue(errorMessage)) errorMessage = defaultMessage;\n\tthrow new TypeError(resolveMessage(errorMessage, value));\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\ttry {\n\t\treturn value.toString();\n\t} catch (error) {\n\t\ttry { return String(value); }\n\t\tcatch (error2) { return null; }\n\t}\n};\n","\"use strict\";\n\nvar safeToString = require(\"./safe-to-string\");\n\nvar reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n\nmodule.exports = function (value) {\n\tvar string = safeToString(value);\n\tif (string === null) return \"<Non-coercible to string value>\";\n\t// Trim if too long\n\tif (string.length > 100) string = string.slice(0, 99) + \"\";\n\t// Replace eventual new lines\n\tstring = string.replace(reNewLine, function (char) {\n\t\tswitch (char) {\n\t\t\tcase \"\\n\":\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase \"\\r\":\n\t\t\t\treturn \"\\\\r\";\n\t\t\tcase \"\\u2028\":\n\t\t\t\treturn \"\\\\u2028\";\n\t\t\tcase \"\\u2029\":\n\t\t\t\treturn \"\\\\u2029\";\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected character\");\n\t\t}\n\t});\n\treturn string;\n};\n","\"use strict\";\n\nvar isValue = require(\"../value/is\");\n\n// prettier-ignore\nvar possibleTypes = { \"object\": true, \"function\": true, \"undefined\": true /* document.all */ };\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\treturn hasOwnProperty.call(possibleTypes, typeof value);\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"%v is not a plain function\", arguments[1]);\n};\n","\"use strict\";\n\nvar isFunction = require(\"../function/is\");\n\nvar classRe = /^\\s*class[\\s{/}]/, functionToString = Function.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isFunction(value)) return false;\n\tif (classRe.test(functionToString.call(value))) return false;\n\treturn true;\n};\n","\"use strict\";\n\nvar isObject = require(\"../object/is\");\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) return false;\n\ttry {\n\t\tif (!value.constructor) return false;\n\t\treturn value.constructor.prototype === value;\n\t} catch (error) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue  = require(\"../value/is\")\n  , isObject = require(\"../object/is\");\n\nvar objectToString = Object.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return null;\n\tif (isObject(value)) {\n\t\t// Reject Object.prototype.toString coercion\n\t\tvar valueToString = value.toString;\n\t\tif (typeof valueToString !== \"function\") return null;\n\t\tif (valueToString === objectToString) return null;\n\t\t// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant\n\t\t// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case\n\t}\n\ttry {\n\t\treturn \"\" + value; // Ensure implicit coercion\n\t} catch (error) {\n\t\treturn null;\n\t}\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"Cannot use %v\", arguments[1]);\n};\n","\"use strict\";\n\n// ES3 safe\nvar _undefined = void 0;\n\nmodule.exports = function (value) { return value !== _undefined && value !== null; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\nvar WS = require('ws')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = WebSocketStream\n\nfunction buildProxy (options, socketWrite, socketEnd) {\n  var proxy = new Transform({\n    objectMode: options.objectMode\n  })\n\n  proxy._write = socketWrite\n  proxy._flush = socketEnd\n\n  return proxy\n}\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket\n\n  var isBrowser = process.title === 'browser'\n  var isNative = !!global.WebSocket\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols\n    protocols = null\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {}\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  var proxy = buildProxy(options, socketWrite, socketEnd)\n\n  if (!options.objectMode) {\n    proxy._writev = writev\n  }\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target\n  // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols)\n    } else {\n      socket = new WS(target, protocols, options)\n    }\n\n    socket.binaryType = 'arraybuffer'\n  }\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else if (isBrowser) {\n    stream = proxy\n    stream.cork()\n    socket.onopen = onopenBrowser\n  } else {\n    stream = duplexify.obj()\n    socket.onopen = onopen\n  }\n\n  stream.socket = socket\n\n  socket.onclose = onclose\n  socket.onerror = onerror\n  socket.onmessage = onmessage\n\n  proxy.on('close', destroy)\n\n  var coerceToBuffer = !options.objectMode\n\n  function socketWriteNode(chunk, enc, next) {\n    // avoid errors, this never happens unless\n    // destroy() is called\n    if (socket.readyState !== socket.OPEN) {\n      next()\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n    socket.send(chunk, next)\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch(err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEnd(done) {\n    socket.close()\n    done()\n  }\n\n  function onopen() {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onopenBrowser () {\n    stream.uncork()\n    stream.emit('connect')\n  }\n\n  function onclose() {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror(err) {\n    stream.destroy(err)\n  }\n\n  function onmessage(event) {\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  function destroy() {\n    socket.close()\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    var buffers = new Array(chunks.length)\n    for (var i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  return stream\n}\n","\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n}\n\nmodule.exports = ws\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBpbGVycy9jb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMiLCJhcHAvY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcyIsImFwcC9jb3JlL2NvcmUuanMiLCJhcHAvY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMiLCJhcHAvY29yZS9lcnJvcnMvY29tcGlsZUVycm9yLmpzIiwiYXBwL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcyIsImFwcC9jb3JlL2Vycm9ycy9lcnJvck1hbmFnZXIuanMiLCJhcHAvY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcyIsImFwcC9jb3JlL2V4ZWN1dGlvbi9jb21wb3NhYmxlTG9hZGVyLmpzIiwiYXBwL2NvcmUvZXhlY3V0aW9uL2V4ZWN1dGlvbk1hbmFnZXIuanMiLCJhcHAvY29yZS9leGVjdXRpb24vc3VwcG9ydExpYnJhcnkuanMiLCJhcHAvY29yZS9uZXR3b3JrL3BvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQuanMiLCJhcHAvY29yZS9vZmZsb2FkaW5nL29mZmxvYWRpbmdEZWNpc2lvbi5qcyIsImFwcC9jb3JlL29mZmxvYWRpbmcvb2ZmbG9hZGluZ1Jlc291cmNlcy5qcyIsImFwcC9jb3JlL3J1bm5lcnMvYXNzZW1ibHlTY3JpcHRSdW5uZXIuanMiLCJhcHAvY29yZS9ydW5uZXJzL3J1bm5lci5qcyIsImFwcC9jb3JlL3N3ZXZhU2NyaXB0L3N3ZXZhU2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY2FjaGUuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL19ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvZXF1YWwuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Zvcm1hdHMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvc2NoZW1hX29iai5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2FsbE9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvYW55T2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9kZXBlbmRlbmNpZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21heExlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21heFByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhpbXVtLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluSXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9taW5MZW5ndGguanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9taW5Qcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluaW11bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL211bHRpcGxlT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9ub3QuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9vbmVPZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcmVmLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy91bmlxdWVJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNC5qc29uIiwibm9kZV9tb2R1bGVzL2FzLWJpbmQvZGlzdC9hcy1iaW5kLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1tcXR0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JsL2JsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVpbHRpbi1zdGF0dXMtY29kZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZC9hdXRvLWJpbmQuanMiLCJub2RlX21vZHVsZXMvZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kdXBsZXhpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5kLW9mLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5LyMvY2xlYXIuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvZnJvbS9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL2lzLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvZnVuY3Rpb24vbm9vcC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL2lzLW5hbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci9pcy1uYW4vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvaXMtbmFuL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci90by1wb3MtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9faXRlcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NvcHkuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Zvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9pcy12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L21hcC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy9pcy1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2lzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1tYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL2xpYi9pdGVyYXRvci1raW5kcy5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL2xpYi9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2lzLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2xpYi9wcml2YXRlL2dlbmVyYXRlLW5hbWUuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9saWIvcHJpdmF0ZS9zZXR1cC9zdGFuZGFyZC1zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvbGliL3ByaXZhdGUvc2V0dXAvc3ltYm9sLXJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC92YWxpZGF0ZS1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2V4dC9nbG9iYWwtdGhpcy9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9leHQvZ2xvYmFsLXRoaXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0L2dsb2JhbC10aGlzL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHR0cHMtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLXRva2Vucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L21xdHQuanMiLCJub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvbnVtYmVycy5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9wYWNrZXQuanMiLCJub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L3dyaXRlVG9TdHJlYW0uanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY29ubmVjdC90Y3AuanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY29ubmVjdC90bHMuanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY29ubmVjdC93cy5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi9jb25uZWN0L3d4LmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL3N0b3JlLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL3ZhbGlkYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVpbnRlcnZhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1zaGlmdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvYXVkaW8uanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2JhdHRlcnkuanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2JsdWV0b290aC5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvY3B1LmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9kb2NrZXIuanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2RvY2tlclNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvZmlsZXN5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvZ3JhcGhpY3MuanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9pbnRlcm5ldC5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvbWVtb3J5LmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9uZXR3b3JrLmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9vc2luZm8uanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3ByaW50ZXIuanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3Byb2Nlc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvc3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi91c2IuanMiLCJub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3VzZXJzLmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi92aXJ0dWFsYm94LmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi93aWZpLmpzIiwibm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvZnVuY3Rpb24vaXMuanMiLCJub2RlX21vZHVsZXMvdHlwZS9saWIvcmVzb2x2ZS1leGNlcHRpb24uanMiLCJub2RlX21vZHVsZXMvdHlwZS9saWIvc2FmZS10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvdHlwZS9saWIvdG8tc2hvcnQtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvb2JqZWN0L2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvcGxhaW4tZnVuY3Rpb24vZW5zdXJlLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvcGxhaW4tZnVuY3Rpb24vaXMuanMiLCJub2RlX21vZHVsZXMvdHlwZS9wcm90b3R5cGUvaXMuanMiLCJub2RlX21vZHVsZXMvdHlwZS9zdHJpbmcvY29lcmNlLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvdmFsdWUvZW5zdXJlLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvdmFsdWUvaXMuanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0LXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vd3MtZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2w2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBOzs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNubEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDem1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzU4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9rQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6b0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDendDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdHhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vdmFyIHthc2MsIGFzc2VtYmx5c2NyaXB0fSA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9hc3NlbWJseXNjcmlwdC9kaXN0L3Nkay5qcycpO1xyXG4vL3ZhciBBc0JpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXMtYmluZC9kaXN0L2FzLWJpbmQuY2pzLmpzJyk7XHJcbi8vdmFyIEFzQmluZFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcy1iaW5kL2Rpc3QvdHJhbnNmb3JtLmNqcycpO1xyXG52YXIgUnVubmVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ydW5uZXJzL3J1bm5lci5qcycpO1xyXG52YXIgQ29tcGlsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBpbGVycy9jb21waWxlci5qcycpO1xyXG52YXIgQXNCaW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzLWJpbmQvZGlzdC9hcy1iaW5kLmNqcy5qcycpO1xyXG52YXIgQ29tcG9zYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zYWJsZS5qcycpO1xyXG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xyXG52YXIgQ29tcGlsZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvY29tcGlsZUVycm9yLmpzJyk7XHJcbmNvbnN0IERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qc1wiKTtcclxuY29uc3Qgb2ZmbG9hZGluZ0RlY2lzaW9uID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvb2ZmbG9hZGluZ0RlY2lzaW9uXCIpO1xyXG5cclxuLy92YXIgQXNzZW1ibHlTY3JpcHRHZXR0ZXJUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2Fzc2VtYmx5U2NyaXB0R2V0dGVyVHJhbnNmb3JtLmpzJyk7XHJcblxyXG4vKiogaW5jbHVkZSB3ZWItd29ya2VyIGxpYnJhcnkgZm9yIE5vZGVqcyAqKi9cclxuXHJcbmlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgTm9kZSB3b3JrZXIgbW9kdWxlXCIpO1xyXG4gICAgdmFyIFdvcmtlck5vZGVKUyA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy93ZWItd29ya2VyL2Nqcy9ub2RlJyk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVGhlIEFzc2VtYmx5U2NyaXB0Q29tcGlsZXIgc3VwcG9ydHMgc3RyaWN0IFR5cGVTY3JpcHRcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIENvbXBpbGVyXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBBc3NlbWJseVNjcmlwdENvbXBpbGVyKHN1cHBvcnRMaWIpIHtcclxuICAgIHRoaXMud29ya2VyID0gbnVsbDtcclxuICAgIHRoaXMuaW50ZXJuYWxHZXR0ZXJQcmVmaXggPSBcIl9pbnRlcm5hbF9nZXRfXCI7XHJcbiAgICB0aGlzLnN1cHBvcnRMaWJyYXJ5RGVjbGFyZXMgPSB0aGlzLmdlbmVyYXRlU3VwcG9ydExpYnJhcnlEZWNsYXJlcyhzdXBwb3J0TGliKTtcclxuICAgIHRoaXMuc3VwcG9ydExpYnJhcnlEb2N1bWVudGF0aW9uID0gXCJUaGUgbGliIG5hbWVzcGFjZSBjb250YWlucyBhbGwgZnVuY3Rpb24gZnJvbSB0aGUgc3VwcG9ydCBsaWJyYXJ5LlxcblwiICtcclxuICAgICAgICBcInN5bmNocm9ub3VzIGZ1bmN0aW9ucyByZXR1cm4gdGhlaXIgcmVzdWx0IGltbWVkaWF0ZWx5LCB3aGlsZSB0aGUgY2FsbGJhY2sgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIGFsbCBjdXJyZW50bHkgcnVubmluZyBBc3NlbWJseVNjcmlwdCBjb2RlIGlzIGZpbmlzaGVkLlxcblwiICtcclxuICAgICAgICBcIkNhbGxiYWNrIGZ1bmN0aW9ucyBjYW4gaGF2ZSBsZXNzIHBhcmFtZXRlcnMgdGhhbiB0aGUgbGlzdGVkIHBhcmFtZXRlcnMsIGluIHdoaWNoIGNhc2Ugb25seSB0aGUgZmlyc3QgcGFyYW1ldGVycyBhcmUgcGFzc2VkLlxcblwiICtcclxuICAgICAgICBcIkZ1bmN0aW9uczpcXG5cIjtcclxuICAgIHRoaXMucmVzb2x2ZUNvbXBpbGUgPSBudWxsO1xyXG59XHJcblxyXG4vL2luaGVyaXQgcHJvcGVydGllc1xyXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcGlsZXIucHJvdG90eXBlKTtcclxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlbWJseVNjcmlwdENvbXBpbGVyO1xyXG5cclxuLyoqXHJcbiAqIGdlbmVyYXRlcyBkZWNsYXJlIHN0YXRlbWVudHMgbmVjZXNzYXJ5LCB0byBhY2Nlc3MgSmF2YVNjcmlwdCBmdW5jdGlvbnMgZnJvbSBBc3NlbWJseVNjcmlwdFxyXG4gKiBhZGRpdGlvbmFsbHkgdGhlIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkXHJcbiAqIEBwYXJhbSBzdXBwb3J0TGliXHJcbiAqL1xyXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5nZW5lcmF0ZVN1cHBvcnRMaWJyYXJ5RGVjbGFyZXMgPSBmdW5jdGlvbiAoc3VwcG9ydExpYikge1xyXG4gICAgbGV0IGRvY3MgPSBcIlwiO1xyXG4gICAgbGV0IGRlY2xhcmVzID0gXCJuYW1lc3BhY2UgbGliIHtcXG5cIjtcclxuICAgIGZvcihsZXQgZnVuY05hbWUgaW4gc3VwcG9ydExpYi5mdW5jdGlvbnMpIHtcclxuICAgICAgICBsZXQgcmV0dXJuU2lnID0gc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmxhbmd1YWdlU3BlY2lmaWMudHlwZXNjcmlwdC5yZXR1cm5TaWcgfHwgXCJ2b2lkXCI7XHJcbiAgICAgICAgbGV0IHBhcmFtU2lnID0gc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmxhbmd1YWdlU3BlY2lmaWMudHlwZXNjcmlwdC5wYXJhbWV0ZXJTaWc7XHJcbiAgICAgICAgLy9jYWxsYmFjayBmdW5jdGlvbiBuYW1lIGlzIGZpcnN0IHBhcmFtZXRlciBmb3IgYXN5bmNocm9ub3VzIGZ1bmN0aW9uc1xyXG4gICAgICAgIGlmKHN1cHBvcnRMaWIuZnVuY3Rpb25zW2Z1bmNOYW1lXS5hc3luYykge1xyXG4gICAgICAgICAgICBwYXJhbVNpZyA9IFwiY2FsbGJhY2s6IHN0cmluZyB8IG51bGxcIiArICh0eXBlb2YgcGFyYW1TaWcgIT09IHVuZGVmaW5lZCA/IFwiLCBcIitwYXJhbVNpZyA6IFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm5TaWcgPSBcInZvaWRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jcyArPSBmdW5jTmFtZStcIjpcXG5cIitcclxuICAgICAgICAgICAgXCIgIERlc2NyaXB0aW9uOiBcIitzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0uZGVzY3JpcHRpb24rXCJcXG5cIitcclxuICAgICAgICAgICAgXCIgIFBhcmFtZXRlcnM6IFxcXCJcIitwYXJhbVNpZytcIlxcXCJcXG5cIitcclxuICAgICAgICAgICAgXCIgIFwiKyhzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0uYXN5bmM/XHJcbiAgICAgICAgICAgICAgICBcIkFzeW5jIGZ1bmN0aW9uOiBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSBcXFwiXCIrc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmxhbmd1YWdlU3BlY2lmaWMudHlwZXNjcmlwdC5yZXR1cm5TaWcrXCJcXFwiIHJlcXVpcmVkXCI6XHJcbiAgICAgICAgICAgICAgICBcIlN5bmMgZnVuY3Rpb246IHJldHVybnMgXFxcIlwiK3JldHVyblNpZytcIlxcXCJcIikrXHJcbiAgICAgICAgICAgIFwiXFxuXCI7XHJcbiAgICAgICAgZGVjbGFyZXMgKz0gXCJleHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBwYXJhbVNpZyArIFwiKTpcIiArIHJldHVyblNpZyArIFwiO1xcblwiO1xyXG4gICAgfVxyXG4gICAgZGVjbGFyZXMgKz0gXCJ9XCI7XHJcbiAgICB0aGlzLnN1cHBvcnRMaWJyYXJ5RG9jdW1lbnRhdGlvbiA9IGRvY3M7XHJcbiAgICBjb25zb2xlLmxvZyhcIlN1cHBvcnQgZnVuY3Rpb25zOlwiKTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuc3VwcG9ydExpYnJhcnlEb2N1bWVudGF0aW9uKTtcclxuICAgIGNvbnNvbGUubG9nKGRlY2xhcmVzKVxyXG4gICAgcmV0dXJuIGRlY2xhcmVzO1xyXG59XHJcblxyXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5zZXR1cCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBpZighdGhpcy5zZXR1cENvbXBsZXRlZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgQXNzZW1ibHlTY3JpcHQgY29tcGlsZXJcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluaXRXb3JrZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbXNnIHRvIHdvcmtlcicpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2V0dXBDb21wbGV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldHVwIGNvbXBsZXRlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0dXBDb21wbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21waWxlRXJyb3JcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGlsZVJlc3VsdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxmLnJlc29sdmVDb21waWxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzb2x2ZUNvbXBpbGUoZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5pbml0V29ya2VyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0eXBlb2YgdGhpcy53b3JrZXIgIT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy53b3JrZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGlmZmVyZW50IHBhdGggZm9yIE5vZGVKU1xyXG4gICAgaWYoc3dldmEuaW5Ccm93c2VyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJMb2FkIHdvcmtlciBmb3Igd2ViYnJvd3NlclwiKTtcclxuICAgICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoJy9ub2RlX21vZHVsZXMvc3dldmEtY29yZS9hcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlcldvcmtlci5qcycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWQgd29ya2VyIGZvciBOb2RlSlNcIik7XHJcbiAgICAgICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyTm9kZUpTKCdhcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlcldvcmtlci5qcycpO1xyXG4gICAgfVxyXG59XHJcbi8vIE1BXHJcbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBhc3luYyBmdW5jdGlvbiAobW9kdWxlKSB7XHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICB3aGlsZSAodGhpcy5jdXJyZW50bHlDb21waWxpbmcpIHtcclxuICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlV2FpdCA9PiBzZXRUaW1lb3V0KHJlc29sdmVXYWl0LCAxKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRseUNvbXBpbGluZyA9IHRydWU7XHJcblxyXG4gICAgLy9sb2FkIGNvbXBpbGVyXHJcbiAgICBhd2FpdCB0aGlzLnNldHVwKCk7XHJcblxyXG4gICAgbGV0IGRvbmVDb21waWxpbmcgPSBmYWxzZTtcclxuICAgIGxldCBvZmZsb2FkaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaW50ZXJ2YWxJRDtcclxuICAgIGxldCBvZExpc3QgPVsxLDEsNzBdOyAvL3RvZG86IHVzZXIgaW5wdXRcclxuICAgIGxldCBzdGFydENQVSA9cGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBsZXQgZW5kQ1BVID0gMDtcclxuICAgIGxldCBjcHVNb25pdG9yPTA7XHJcbiAgICAvLyBpbml0aWFsIG1lbSAvIGJhdHRlcnkgY2hlY2tcclxuICAgIG9mZmxvYWRpbmcgPSBhd2FpdCBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KTtcclxuICAgIGNvbnNvbGUubG9nKCdpbml0aWFsIG9mZmxvYWRpbmcgZGVjaXNpb24gPSAnLG9mZmxvYWRpbmcpO1xyXG4gICAgaWYgKG9mZmxvYWRpbmcpIHtcclxuICAgICAgICAvLyBvcHRpbWl6YXRpb246IHNwZWVkIGlzIGtleSB3ZSBkbyB0aGlzIGFmdGVyIHJlc29sdmluZyBwcm9taXNlXHJcbiAgICAgICAgLy9jbGVhckludGVydmFsKGludGVydmFsSUQpO1xyXG4gICAgICAgIC8vYWJvcnQgcnVubmluZyBjb21waWxhdGlvblxyXG4gICAgICAgIHJldHVybiAoJ29mZmxvYWRpbmcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgIC8vbW9uaXRvcmluZyB0aGUgY29tcGlsYXRpb24gcHJvY2Vzc1xyXG4gICAgICAgIG5ldyBQcm9taXNlKCBhc3luYyAocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmVnaW4gcGVyaW9kaWMgbW9uaXRvcmluZyBleGVjdXRpb24uLi4nKTtcclxuICAgICAgICAgICAgLy8gaW50ZXJ2YWwgY2hlY2tcclxuICAgICAgICAgICAgaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVuZENQVSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgY3B1TW9uaXRvciA9ICgoZW5kQ1BVIC0gc3RhcnRDUFUpLzUwMDApKjEwMDtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDUFUgVElNRT0gJywgY3B1TW9uaXRvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3B1TW9uaXRvciA+IG9kTGlzdFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTW9uaXRvcmluZyA9IENQVSBsaW1pdCBleGNlZWRlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdvZmZsb2FkaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZsb2FkaW5nID0gYXdhaXQgb2ZmbG9hZGluZ0RlY2lzaW9uKG9kTGlzdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGVyaW9kaWMgb2ZmbG9hZGluZyBkZWNpc2lvbiA9ICcsIG9mZmxvYWRpbmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZmxvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb246IHNwZWVkIGlzIGtleSB3ZSBkbyB0aGlzIGFmdGVyIHJlc29sdmluZyBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jbGVhckludGVydmFsKGludGVydmFsSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYWJvcnQgcnVubmluZyBjb21waWxhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29mZmxvYWRpbmcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIC8vIGNvbXBpbGluZyB0aGUgbW9kdWxlXHJcbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbXBpbGUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICBkb25lQ29tcGlsaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiY29tcGlsZVwiLCBzb3VyY2U6IHNlbGYucHJlcGFyZVNvdXJjZUNvZGUobW9kdWxlLnNvdXJjZSl9KTtcclxuXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG5cclxuICAgIF0pLlxyXG4gICAgdGhlbigod3IpID0+IHtcclxuXHJcbiAgICAgICAgbGV0IHdvcmtlclJlc3VsdCA9IHdyO1xyXG5cclxuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSUQpOyAvL2NsZWFyIG1vbml0b3JpbmcgaW50ZXJ2YWwgaWYgbm8gb2ZmbG9hZGluZyBuZWNlc3NhcnlcclxuICAgICAgICBjb25zb2xlLmxvZygnd29ya2VyUmVzdWx0Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2cod29ya2VyUmVzdWx0KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRseUNvbXBpbGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnJlc29sdmVDb21waWxlID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHdvcmtlclJlc3VsdC50eXBlID09PSBcImNvbXBpbGVSZXN1bHRcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT2ZmbG9hZGluZyBub3QgbmVlZGVkLiBQcm9jZWVkIGFzIG5vcm1hbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gd29ya2VyUmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAod29ya2VyUmVzdWx0ID09PSAnb2ZmbG9hZGluZycpIHtcclxuICAgICAgICAgICAgLy90b2RvOiBvZmZsb2FkaW5nIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9mZmxvYWRpbmcgbmVjZXNzYXJ5LiBDYWxsYmFjayB0cmlnZ2VyZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAnb2ZmbG9hZGluZyc7IC8vdG9kbzogaXMgU3RyaW5nIGEgZ29vZCBEVCBmb3IgcmV0dXJuID9cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih3b3JrZXJSZXN1bHQubWVzc2FnZSwgbW9kdWxlLmNvbnRleHQpOyAgLy8gQ29tcGlsZXIgRXJyb3IgaGFuZGxpbmdcclxuXHJcbiAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5wcmVwYXJlU291cmNlQ29kZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgbGV0IGdldHRlcnMgPSB0aGlzLmdlbmVyYXRlR2xvYmFsR2V0dGVycyhzb3VyY2UpO1xyXG4gICAgbGV0IHNvdXJjZVN0ciA9IHNvdXJjZS5qb2luKFwiXFxuXCIpO1xyXG4gICAgcmV0dXJuIHRoaXMuc3VwcG9ydExpYnJhcnlEZWNsYXJlcyArIHNvdXJjZVN0ciArIGdldHRlcnM7XHJcbn1cclxuXHJcbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlLmdlbmVyYXRlR2xvYmFsR2V0dGVycyA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgbGV0IGdldHRlcnMgPSBcIlwiO1xyXG4gICAgZm9yKGxldCBsaW5lIGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmKHNvdXJjZS5pbmNsdWRlcyh0aGlzLmludGVybmFsR2V0dGVyUHJlZml4KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKFwiRG8gbm90IHVzZSBcIit0aGlzLmludGVybmFsR2V0dGVyUHJlZml4K1wiIGZvciBuYW1lcyBpbiB5b3VyIHNvdXJjZSwgYXMgaXQgaXMgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZS5cIiwgXCJjb21waWxlRXJyb3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc291cmNlW2xpbmVdLmluZGV4T2YoXCJleHBvcnQgdmFyXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxldCB0bXAgPSBzb3VyY2VbbGluZV0uc3BsaXQoJz0nKVswXS5zcGxpdCgnOicpO1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiYW55cmVmXCI7XHJcbiAgICAgICAgICAgIGlmKHRtcC5sZW5ndGggPj0gMilcclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0bXBbMV0uc3BsaXQoL1tcXHM9XSsvKS5maWx0ZXIoeCA9PiB4ICE9PSBcIlwiKVswXTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcihcIkV4cG9ydGVkIHZhcmlhYmxlcyByZXF1aXJlIGFuIGV4cGxpY2l0IHR5cGUhIFxcblxcXCJcIitzb3VyY2VbbGluZV0rXCJcXFwiIGRvZXMgbm90IGNvbnRhaW4gYSB0eXBlLlwiLCBcImNvbXBpbGVFcnJvclwiKTtcclxuICAgICAgICAgICAgdG1wID0gdG1wWzBdLnNwbGl0KC9bXFxzPV0rLykuZmlsdGVyKHggPT4geCAhPT0gXCJcIik7XHJcbiAgICAgICAgICAgIGxldCBuYW1lID0gdG1wW3RtcC5sZW5ndGgtMV07XHJcbiAgICAgICAgICAgIGdldHRlcnMgKz0gXCJleHBvcnQgZnVuY3Rpb24gXCIrdGhpcy5pbnRlcm5hbEdldHRlclByZWZpeCtuYW1lK1wiKCk6XCIrdHlwZStcIiB7IHJldHVybiBcIituYW1lK1wiOyB9XFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZXR0ZXJzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VtYmx5U2NyaXB0Q29tcGlsZXI7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjb21waWxlciBsb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgY29tcGlsYXRpb24gb2YgYSBsYW5ndWFnZSwgY29tcGlsZXMgY29kZSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGJpbmFyeS5cclxuICogSXQgaGFzIHR3byBwaGFzZXM6IEEgc2V0dXAgcGhhc2UsIHdlcmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkIGFuZCBpbml0aWFsaXplZCBhbmQgYW4gb3BlcmF0aW9uYWwgcGhhc2UsIHdoaWNoIGlzIHVzZWQgdG8gY29tcGlsZSBjb2RlXHJcbiAqIFxyXG4gKiBUaGUgc2V0dXAgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UsIHdoaWxlIHRoZSBleGVjdXRpb24gY2FuIGJlIHJlcGVhdGVkIG9uIGRpZmZlcmVudCBkYXRhLlxyXG4gKiBBZGRpdGlvbmFsbHkgdGhlIHNldHVwIHNob3VsZCBvbmx5IGJlIGNhbGxlZCwgd2hlbiB0aGUgY29tcGlsZXIgaXMgbmVlZGVkLCBiZWNhdXNlIHNvbWUgZGVwZW5kZW5jaWVzIGZvciBjb21waWxpbmcgY2FuIGJlIHZlcnkgbGFyZ2VcclxuICogXHJcbiAqIFRoaXMgaXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCByZXR1cm5pbmcgdGhlIGlucHV0IHNvdXJjZSBhcyB0aGUgY29tcGlsZWQgY29kZS4gSXQgY2FuIGJlIHVzZWQgZm9yIGludGVycHJldGVkIGxhbmd1YWdlcy5cclxuICpcclxuICogQHBhcmFtIHtTdXBwb3J0TGlicmFyeX0gc3VwcG9ydExpYnJhcnkgLSBzb3VyY2UgY29kZSB0byBjb21waWxlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQ29tcGlsZXIoc3VwcG9ydExpYnJhcnkpIHtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcywgaWYgZGVwZW5kZW5jaWVzIGFyZSBsb2FkZWQuXHJcbiAgICAgKiBAbmFtZSBDb21waWxlciNzZXR1cENvbXBsZXRlZFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0dXBDb21wbGV0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERvY3VtZW50YXRpb24gZm9yIGZ1bmN0aW9ucyBpbiBzdXBwb3J0IGxpYnJhcnkgLSBzaG91bGQgaW5jbHVkZSBzcGVjaWZpY3Mgb24gbGFuZ3VhZ2Ugc3ludGF4XHJcbiAgICAgKiBBdmFpbGFibGUgYWZ0ZXIgQ29tcGlsZXIjc2V0dXAoKSBoYXMgYmVlbiBjYWxsZWQuXHJcbiAgICAgKiBAbmFtZSBDb21waWxlciNzZXR1cENvbXBsZXRlZFxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb24gPSBcIlwiO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcGlsZSB0aGUgcHJvdmlkZWQgc291cmNlIGNvZGVcclxuICogQHBhcmFtIHttb2R1bGV9IHNvdXJjZSAtIHNvdXJjZSBjb2RlIHRvIGNvbXBpbGVcclxuICogQHJldHVybiB7b2JqZWN0fSBjb250YWluaW5nIGJpbmFyeURhdGEgYW5kIG9wdGlvbmFsbHkgb3RoZXIgcHJvcGVydGllcyBvZiBzcGVjaWZpYyBjb21waWxlcnNcclxuICovXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZTtcclxufVxyXG4gICBcclxuLyoqXHJcbiAqIExvYWRzIGRlcGVuZGVuY2llc1xyXG4gKi9cclxuQ29tcGlsZXIucHJvdG90eXBlLnNldHVwID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYoIXRoaXMuc2V0dXBDb21wbGV0ZWQpIHtcclxuICAgICAgICB0aGlzLnNldHVwQ29tcGxldGVkID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcGlsZXIiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvZGVmaW5pdGlvbkVycm9yLmpzJyk7XHJcbnZhciBFeGVjdXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL0V4ZWN1dGlvbkVycm9yLmpzJyk7XHJcbnZhciBDbG9uZSA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcycpO1xyXG5cclxuLyoqXHJcbiAqIENvbXBvc2FibGVzIHByb2Nlc3MgZGF0YS4gVGhleSBjYW4gYmUgbGlua2VkIGludG8gbmV0d29ya3MuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIENvbXBvc2FibGUoKSB7XHJcbn1cclxuLyoqXHJcbiAqIEEgZGVmaW5pdGlvbiBvZiBhIEpTT04gb2JqZWN0LlxyXG4gKiBAc2VlIHtAbGluayBodHRwOi8vanNvbi1zY2hlbWEub3JnL2RvY3VtZW50YXRpb24uaHRtbH1cclxuICogQHR5cGVkZWYge09iamVjdH0gSlNPTlNjaGVtYVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgaW5pdGFsaXphdGlvbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgY29tcG9zYWJsZXMuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IGNvbXBvc2FibGVJbml0YWxpemVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZT1zb21lQ29tcG9zYWJsZV0gLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlPW1vZHVsZV0gLSBUaGUgdHlwZSBvZiB0aGUgY29tcG9zYWJsZTogJ21vZHVsZScgb3IgJ2NvbXBvc2l0aW9uJy5cclxuICogQHByb3BlcnR5IHtKU09OU2NoZW1hfSBbZGF0YUluU2NoZW1hPW51bGxdIC0gVGhlIHNjaGVtYSBvZiB0aGUgZXhwZWN0ZWQgZGF0YSBvYmplY3QgcmVjZWl2ZWQgZnJvbSBvdGhlciBjb21wb3NhYmxlcy5cclxuICogQHByb3BlcnR5IHtKU09OU2NoZW1hfSBbZGF0YU91dFNjaGVtYT1udWxsXSAtIFRoZSBzY2hlbWEgb2YgdGhlIGRhdGEgb2JqZWN0IHBhc3NlZCBvbiB0byBsYXRlciBjb21wb3NhYmxlcy5cclxuICogQHByb3BlcnR5IHtKU09OU2NoZW1hfSBbaW5wdXRTY2hlbWE9bnVsbF0gLSBUaGUgc2NoZW1hIG9mIHRoZSBpbnB1dCBvYmplY3QgcmVjZWl2ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBleGVjdGlvbi5cclxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW2RhdGFJbk5hbWVzPVsnZGF0YSddXSAtIFRoZSBuYW1lcyBvZiB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyBvZiB0aGUgcmVjZWl2ZWQgZGF0YSBvYmplY3QuXHJcbiAqIElmIHRoZXJlIGlzIG9ubHkgb25lIGVsZW1lbnQsIHRoZSBhcnJheSBpcyBpZ25vcmVkIGFuZCB0aGUgd2hvbGUgZGF0YSBvYmplY3QgaXMgdGFrZW4gKG5vIHByb3BlcnR5IG5hbWVzIG5lZWRlZCkuXHJcbiAqIE11bHRpcGxlIHByb3BlcnRpZXMgYXJlIG5lZWRlZCwgaWYgeW91IHdhbnQgdG8gcmVjZWl2ZSBkYXRhIGZyb20gbXVsdGlwbGUgb3RoZXIgY29tcG9zYWJsZXMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFtkYXRhT3V0TmFtZXM9WydyZXN1bHQnXV0gLSBUaGUgbmFtZXMgb2YgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgb2YgdGhlIHByb2R1Y2VkIGRhdGEgb2JqZWN0LlxyXG4gKiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBlbGVtZW50LCB0aGUgYXJyYXkgaXMgaWdub3JlZCBhbmQgdGhlIHdob2xlIGRhdGEgb2JqZWN0IGlzIHRha2VuIChubyBwcm9wZXJ0eSBuYW1lcyBuZWVkZWQpLlxyXG4gKiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGFyZSBuZWVkZWQsIGlmIHlvdSB3YW50IHRvIHNlbmQgZGF0YSB0byBtdWx0aXBsZSBvdGhlciBjb21wb3NhYmxlcy5cclxuICpcclxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW2lucHV0TmFtZXM9W11dIC0gVGhlIG5hbWVzIG9mIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIG9mIHRoZSBpbnB1dCBvYmplY3QuXHJcbiAqIElmIHRoZXJlIGlzIG9ubHkgb25lIGVsZW1lbnQsIHRoZSBhcnJheSBpcyBpZ25vcmVkIGFuZCB0aGUgd2hvbGUgaW5wdXQgb2JqZWN0IGlzIHRha2VuIChubyBwcm9wZXJ0eSBuYW1lcyBuZWVkZWQpLlxyXG4gKi9cclxuXHJcbi8qKiBJbml0aWFsaXplcyB0aGUgb2JqZWN0IHdpdGggYSBwcm9wZXJ0eSBvYmplY3QuXHJcbiAgKiBOb3QgZGVmaW5lZCBQcm9wZXJ0aWVzIHdpbGwgZ2V0IGEgZGVmYXVsdCB2YWx1ZS5cclxuICogIEBwcm90ZWN0ZWRcclxuICogIEBwYXJhbSB7Y29tcG9zYWJsZUluaXRhbGl6ZXJ9IGluaXRpYWxpemF0aW9uT2JqZWN0IC0gVGhlIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBjb21wb3NhYmxlLlxyXG4gKi9cclxuQ29tcG9zYWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChpbml0aWFsaXphdGlvbk9iamVjdCkge1xyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICduYW1lJywgJ3NvbWVDb21wb3NhYmxlJyk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ3R5cGUnLCAnbW9kdWxlJyk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2RhdGFJblNjaGVtYScsIG51bGwpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdkYXRhT3V0U2NoZW1hJywgbnVsbCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2lucHV0U2NoZW1hJywgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdkYXRhSW5OYW1lcycsIFtdKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnZGF0YU91dE5hbWVzJywgW10pO1xyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdpbnB1dE5hbWVzJywgW10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdW50IG9mIGV4cGVjdGVkIHByb3BlcnRpZXMgZm9yIHRoZSByZWNlaXZlZCBkYXRhIG9iamVjdC5cclxuICAgICAqIEBuYW1lIENvbXBvc2FibGUjZGF0YUluXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGFJbiA9IHRoaXMuZGF0YUluTmFtZXMubGVuZ3RoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBbW91bnQgb2YgZXhwZWN0ZWQgcHJvcGVydGllcyBmb3IgdGhlIHByb2R1Y2VkIGRhdGEgb2JqZWN0LlxyXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlI2RhdGFPdXRcclxuICAgICogQHR5cGUge251bWJlcn1cclxuICAgICovXHJcbiAgICB0aGlzLmRhdGFPdXQgPSB0aGlzLmRhdGFPdXROYW1lcy5sZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFtb3VudCBvZiBleHBlY3RlZCBwcm9wZXJ0aWVzIGZvciB0aGUgcmVjZWl2ZWQgaW5wdXQgb2JqZWN0XHJcbiAgICAqIEBuYW1lIENvbXBvc2FibGUjaW5wdXRJblxyXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIHRoaXMuaW5wdXRJbiA9IHRoaXMuaW5wdXROYW1lcy5sZW5ndGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBjb250ZXh0IG9mIHRoZSBjb21wb3NhYmxlIHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlI2NvbnRleHRcclxuICAgICogQHR5cGUge251bWJlcn1cclxuICAgICovXHJcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnWycgKyB0aGlzLm5hbWUgKyAnXSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBpbnRlcm5hbCB2YXJpYWJsZXMuIFNldHMgYWxzbyBkZWZhdWx0IHZhbHVlcy5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge2NvbXBvc2FibGVJbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zYWJsZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHZhbHVlIHRvIHNldC4gVGhlIG5hbWUgbXVzdCBiZSB0aGUgc2FtZSBib3RoIGZvciAndGhpcycgYW5kIGluaXRpYWxpemF0aW9uT2JqZWN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdFZhbHVlIC0gQSBkZWZhdWx0IHZhbHVlIGlzIHNldCwgaWYgaW5pdGlhbGl6YXRpb25PYmplY3QgZG9lcyBub3QgY29udGFpbiBzdWNoIGEgcHJvcGVydHkga2V5LlxyXG4gKi9cclxuQ29tcG9zYWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGluaXRpYWxpemF0aW9uT2JqZWN0LFxyXG4gICAgcHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgaWYgKGluaXRpYWxpemF0aW9uT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgIHZhciBvYmogPSBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBpbnRlcm5hbCBmdW5jdGlvbnMuIFNldHMgYWxzbyBkZWZhdWx0IHZhbHVlcy5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge2NvbXBvc2FibGVJbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zYWJsZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHZhbHVlIHRvIHNldC4gVGhlIG5hbWUgbXVzdCBiZSB0aGUgc2FtZSBib3RoIGZvciAndGhpcycgYW5kIGluaXRpYWxpemF0aW9uT2JqZWN0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRBcmd1bWVudHNDb3VudCAtIFRoZSBhbW91bnQgb2YgYXJndW1lbnRzIHRoZSBleHBlY3RlZCBmdW5jdGlvbiBuZWVkcyB0byBoYXZlLiBPbiBtaXNtYXRjaCBhbiBlcnJvciBpcyB0aHJvd24uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlZmF1bHRWYWx1ZSAtIEEgZGVmYXVsdCB2YWx1ZSBpcyBzZXQsIGlmIGluaXRpYWxpemF0aW9uT2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gc3VjaCBhIHByb3BlcnR5IGtleS5cclxuICovXHJcbkNvbXBvc2FibGUucHJvdG90eXBlLmluaXRpYWxpemVGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbml0aWFsaXphdGlvbk9iamVjdCxcclxuICAgIHByb3BlcnR5LCBleHBlY3RlZEFyZ3VtZW50c0NvdW50LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGlmIChpbml0aWFsaXphdGlvbk9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAvL2NoZWNrIGlmIGl0IGlzIHJlYWxseSBhIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy90aGUgZXhwZWN0ZWQgZnVuY3Rpb25zICh3aGljaCBjYW4gYmUgZGVmaW5lZCBieSB0aGUgY29tcG9zYWJsZSBjcmVhdG9ycykgaGF2ZSBhIGZpeGVkIHNpZ25hdHVyZSAoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgLy9zbyBjaGVjayBoZXJlIGZvciB2YWxpZGF0aW9uLlxyXG4gICAgICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldLmxlbmd0aCA+PSBleHBlY3RlZEFyZ3VtZW50c0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdmdW5jdGlvbiBcIicgKyBwcm9wZXJ0eSArICdcIiByZXF1aXJlcyBhdCBsZWFzdCAnICtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3VtZW50c0NvdW50ICsgJyBhcmd1bWVudHMsIGJ1dCBwcm92aWRlcyBvbmx5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBmb3Igbm93IGlnbm9yZSwgYXMgc29tZSBmdW5jdGlvbnMgYXJlIG9wdGlvbmFsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdcIicgKyBwcm9wZXJ0eSArICdcIiBpcyByZXNlcnZlZCBmb3IgZnVuY3Rpb25zLCBidXQgbm90IGRlZmluZWQgYXMgb25lJyxcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENsb25lcyB0aGUgY3VycmVudCBjb21wb3NhYmxlIGFuZCBvdmVyd3JpdGVzL2FkZHMgYWxsIHRoZSBwcm9wZXJ0aWVzIHNwZWNpZmllZCBpbiBhbiBleHRlbmRlciBvYmplY3QuXHJcbiAqIFRoaXMgYWxsb3dzIHNvbWUgc29ydCBvZiBjb21wb3NhYmxlIGluaGVyaXRhbmNlLlxyXG4gKiBAdGhpcyBDb21wb3NhYmxlXHJcbiAqIEBwYXJhbSB7Q29tcG9zYWJsZX0gZXh0ZW5kZXIgLSBUaGUgcGFydGlhbCBjb21wb3NhYmxlIGZyb20gd2hpY2ggdG8gdGFrZSB0aGUgbmV3IHZhbHVlcy5cclxuICogQHJldHVybnMge0NvbXBvc2FibGV9IFRoZSBjbG9uZWQgYW5kIGV4dGVuZGVkIGNvbXBvc2FibGUgb2JqZWN0LlxyXG4gKi9cclxuQ29tcG9zYWJsZS5wcm90b3R5cGUuZXh0ZW5kV2l0aCA9IGZ1bmN0aW9uIChleHRlbmRlcikge1xyXG4gICAgdmFyIGNsb25lZCA9IENsb25lKHRoaXMpO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGV4dGVuZGVyKSB7XHJcbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGNsb25lICdleHRlbmRzJyBhcyBpdCBpcyBhbiBpbmRpY2F0b3IsIHRoYXQgYSBjb21wb3NhYmxlIHdhbnRzIHRvIGV4dGVuZCBhbm90aGVyLiBJLmUuIFdoYXQgd2UgYXJlIGRvaW5nIGhlcmUgOilcclxuICAgICAgICBpZiAoZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT0gJ2V4dGVuZHMnKSB7XHJcbiAgICAgICAgICAgIGNsb25lZFtrZXldID0gZXh0ZW5kZXJba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBjb250ZXh0IGR1cmluZyB0aGUgZXhlY3V0aW9uLiBJdCB1c2VzIHRoZSBwYXJlbnQncyBjb250ZXh0IGFuZCB0aGUgYWxpYXMsIHRoZSBwYXJlbnQgaGFzIGdpdmVuIHRoaXMgY29tcG9zYWJsZS5cclxuICogbG9va3MgbGlrZTogQ29tcG9zaXRpb25bY29tcG9zaXRpb24xXS5Nb2R1bGVbbW9kdWxlMV1cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSBwYXJlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyAtIFRoZSBhbGlhcyAobmFtZSkgdXNlZCBpbiB0aGUgcGFyZW50IGZvciB0aGlzIGNvbXBvc2FibGUuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVwZGF0ZWQgY29udGV4dC5cclxuICovXHJcbkNvbXBvc2FibGUucHJvdG90eXBlLmdldE5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXMpIHtcclxuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvL2FsaWFzIGlzIG9wdGlvbmFsLCBzbyBjaGVjayBpZiBpdCBpcyBkZWZpbmVkXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbGlhcyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYWxpYXMgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWFzID0gJzogJyArIGFsaWFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGV4dCArICcuJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICdbJyArIHRoaXMubmFtZSArIGFsaWFzICsgJ10nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzLCBpZiBhIGdpdmVuIG9iamVjdCBoYXMgdGhlIGV4cGVjdGVkIHN0cnVjdHVyZSAodHlwZWNoZWNrKSBjb21wYXRpYmxlIHRvIHRoaXMgY29tcG9zYWJsZS5cclxuICogSWYgYXZhaWxhYmxlLCBpdCB1c2VzIHRoZSBwcm92aWRlZCBKU09OIHNjaGVtYSwgb3RoZXJ3aXNlIChub2NoIHNjaG1lbWEgYXZhaWxhYmxlKSBpdCBvbmx5IGNoZWNrcywgaWYgdGhlIG9iamVjdCBoYXMgYWxsIHJlcXVpcmVkIHByb3BlcnR5IGtleXMuIERlZmluZWQgYnkgdGhlICpOYW1lcyBhcnJheXMgKHNlZSB7QGxpbmsgY29tcG9zYWJsZUluaXRhbGl6ZXJ9KS5cclxuICogXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBvYmplY3QsIG5lZWRlZCB0byBzZWxlY3QgdGhlIGNvcnJlY3QgdHlwZSBkZWZpbml0aW9uLiBVc2UgJ2RhdGFJbicsICdkYXRhT3V0JyAsICdpbnB1dCcgcmVzcGVjdGl2ZWx5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0LCB0aGF0IHNob3VsZCBiZSB2YWxpZGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUsIGlmIHRoZSBvYmplY3QgaXMgY29tcGF0aWJsZSB0byB0aGlzIGNvbXBvc2FibGUgcmVnYXJkaW5nIHRoZSBnaXZlbiB0eXBlLlxyXG4gKi9cclxuQ29tcG9zYWJsZS5wcm90b3R5cGUudmFsaWRhdGVUeXBlcyA9IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcclxuICAgIHZhciB0eXBlTmFtZXMgPSB0aGlzW3R5cGUgKyAnTmFtZXMnXTtcclxuICAgIHZhciB0eXBlU2NoZW1hID0gdGhpc1t0eXBlICsgJ1NjaGVtYSddO1xyXG4gICAgXHJcbiAgICAvL2lmIHByb3BlcnRpZXMgYXJlIGFsbCBwcmVzZW50IGFuZCBhIHNjaGVtYSBpcyBwcm92aWRlZCwgd2UgY2FuIHBlcmZvcm0gYSBtb3JlIGRldGFpbGVkIGNoZWNrXHJcbiAgICBpZiAodHlwZVNjaGVtYSAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vdXNlIHRoZSB2YWxpZGF0b3IgbGlicmFyeSBvbiB0aGUgb2JqZWN0XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHZhbGlkID0gc3dldmEuQWp2LnZhbGlkYXRlKHR5cGVTY2hlbWEsIG9iaik7XHJcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihuZXcgRXhlY3V0aW9uRXJyb3IoJ09iamVjdCBkb2VzIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gJyArIHR5cGUgKyAnU2NoZW1hOiAnICsgc3dldmEuQWp2LmVycm9yc1RleHQoc3dldmEuQWp2LmVycm9ycyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBvYmopKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGlnbm9yZSwgYmVjYXVzZSBhbiBpbnZhbGlkIHNjaGVtYSBsaWtlIGdlbmVyYXRlZCBieSBBc3NlbWJseVNjcmlwdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc291cmNlIGFuZFxyXG4gICAgICAgICAgICBhbHJlYWR5IG1hdGNoZXMgdGhlIGlucHV0L291dHB1dCBkYXRhLiBDb25zaWRlciBhZGRpbmcgdGhlIGN1c3RvbSB0eXBlcyB0byB0aGUgdmFsaWRhdG9yLCBpZiB0aGlzIGlzIG5vdCB0aGVcclxuICAgICAgICAgICAgY2FzZSBmb3IgZnV0dXJlIGFkZGVkIGxhbmd1YWdlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0byBzdGFydCB0aGUgZGF0YSBwcm9jZXNzaW5nLiBIZXJlIG9ubHkgYSBkdW1teSBpcyBkZWZpbmVkLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoYSBkYXRhIG9iamVjdCByZWNlaXZlZC5cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCByZWNlaXZlZC5cclxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSAtIFRoZSBwcm9jZXNzZWQgZGF0YS5cclxuICovXHJcbkNvbXBvc2FibGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcmVzb2x2ZSgwKTtcclxuICAgIH0pO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zYWJsZTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ29tcG9zYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zYWJsZS5qcycpO1xyXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9tb2R1bGUuanMnKTtcclxudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xyXG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgaG93IGEgY29tcG9zYWJsZSBpcyBsaW5rZWQgdG8gYW5vdGhlclxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBsaW5rVHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gLSBUaGUgYWxpYXMvbmFtZSBvZiB0aGUgdGFyZ2V0IGNvbXBvc2FibGUgKGkuZS4gdW5kZXIgd2hpY2gga2V5IGl0IGlzIGRlZmluZWQgaW4gdGhlIGNvbXBvc2FibGVzIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2l0aW9uKVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBtYXBwaW5nIC0gSG93IGRhdGFPdXQgYW5kIGRhdGFJbiBvZiB0d28gY29tcG9zYWJsZXMgYXJlIG1hcHBlZCB0byBlYWNoIG90aGVyLlxyXG4gKiBJZiBubyBtYXBwaW5nIGlzIHNwZWNpZmllZCwgdGhlIHdob2xlIGRhdGFPdXQgb2JqZWN0IGlzIHRha2VuIGFzIHRoZSBkYXRhSW4gb2JqZWN0LlxyXG4gKiBJZiBhIHN0cmluZyBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSwgaXQgaXMgbWFwcGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBkYXRhSW4gcHJvcGVydHkuXHJcbiAqIElmIGEgZGljdGlvbmFyeSBpcyBzcGVjaWZpZWQsIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgZGF0YU91dCBwcm9wZXJ0eSBhbmQgdGhldmFsdWUgdGhlIGRhdGFJbiBwcm9wZXJ0eSBpdCBpcyBtYXBwZWQgdG8uXHJcbiAqIEFsbCBzdHJpbmcgdmFsdWVzIG11c3QgYmUgdXNpbmcgdGhlIGdpdmVuIHZhbHVlcyBvZiB0aGUgZGF0YUluTmFtZXMgYW5kIGRhdGFPdXROYW1lcyBhcnJheXMgZGVmaW5lZCBpbiB0aGUgY29tcG9zYWJsZS5cclxuICovXHJcblxyXG4vKipcclxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gbWFwIHRoZSBpbnB1dCBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uIHRvIHRoZSBpbnB1dCBvYmplY3Qgb2YgaW5kaXZpZHVhbCBjb21wb3NhYmxlcy5cclxuICogQmFzaWNhbGx5IHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2ggY29tcG9zYWJsZSBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGVuIHVzZWQgYXMgaXRzIGlucHV0IG9iamVjdC5cclxuICogRm9yIGV4YW1wbGUgeW91IGNhbiB1c2UgYW4gaW5wdXQgb2JqZWN0LCB3aGVyZSB5b3Ugc3BlY2lmeSBpbiBkZXRhaWwgZm9yIGV2ZXJ5IGNvbXBvc2FibGUgdGhlIHZhbHVlLCB0aGVuIHlvdSBjb3VsZCBzaW1wbHlcclxuICogcmV0dXJuIGlucHV0W2NvbXBvc2FibGVOYW1lXTtcclxuICogXHJcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cclxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxyXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcclxuICogYWN0cyBhcyBbXS5cclxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICogXHJcbiAqIEBjYWxsYmFjayBDb21wb3NpdGlvbn5tYXBJbnB1dEZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIGNvbXBvc2l0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZSByZXF1ZXN0aW5nIGFuIGlucHV0IG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBjb21wb3NhYmxlcyAtIEEgZGljdGlvbmFyeSBvZiB0aGUgY29tcG9zYWJsZXMgdXNlZCBieSB0aGUgY29tcG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWJzIC0gQSBsaWJyYXJ5IG9iamVjdCBwcm92aWRlcyBhY2Nlc3MgdG8gbGlicyBmcm9tIHdpdGhpbiB0aGUgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgdmFsdWUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdGluZyBjb21wb3NhYmxlIGFzIHRoZSBpbnB1dCBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgdXNlciBkZWZpbmVhYmxlIGZ1bmN0aW9uIHRvIG1hcCB0aGUgZGF0YSBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uIHRvIHRoZSBkYXRhIG9iamVjdCBvZiBpbmRpdmlkdWFsIGNvbXBvc2FibGVzLlxyXG4gKiBCYXNpY2FsbHkgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaCBjb21wb3NhYmxlIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZW4gdXNlZCBhcyBpdHMgZGF0YSBvYmplY3QuXHJcbiAqIEZvciBleGFtcGxlIHlvdSBjYW4gdXNlIGEgZGF0YSBvYmplY3QsIHdoZXJlIHlvdSBzcGVjaWZ5IGluIGRldGFpbCBmb3IgZXZlcnkgY29tcG9zYWJsZSB0aGUgdmFsdWUsIHRoZW4geW91IGNvdWxkIHNpbXBseVxyXG4gKiByZXR1cm4gZGF0YVtjb21wb3NhYmxlTmFtZV07XHJcbiAqIFxyXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXHJcbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcclxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXHJcbiAqIGFjdHMgYXMgW10uXHJcbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIFxyXG4gKiBAY2FsbGJhY2sgQ29tcG9zaXRpb25+bWFwRGF0YUluRnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2l2ZW4gdG8gdGhlIGNvbXBvc2l0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZSByZXF1ZXN0aW5nIGEgZGF0YSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gY29tcG9zYWJsZXMgLSBBIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2FibGVzIHVzZWQgYnkgdGhlIGNvbXBvc2l0aW9uLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEEgbGlicmFyeSBvYmplY3QgcHJvdmlkZXMgYWNjZXNzIHRvIGxpYnMgZnJvbSB3aXRoaW4gdGhlIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RpbmcgY29tcG9zYWJsZSBhcyB0aGUgZGF0YSBvYmplY3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgdXNlciBkZWZpbmVhYmxlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgcmVzdWx0aW5nIGRhdGEgb2JqZWN0IG9mIHRoZSBkYXRhIHByb2Nlc3NpbmcgcGlwZWxpbmUuXHJcbiAqIFlvdSBjb3VsZCBmb3IgZXhhbXBsZSBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIHJlbW92ZSBzb21lLCBjb252ZXJ0IHZhbHVlcyBldGMuXHJcbiAqIFxyXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXHJcbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcclxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXHJcbiAqIGFjdHMgYXMgW10uXHJcbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIFxyXG4gKiBAY2FsbGJhY2sgQ29tcG9zaXRpb25+bWFwRGF0YU91dEZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgLSBUaGUgZGF0YSBvYmplY3QgcHJvZHVjZWQgYnkgdGhlIGNvbXBvc2FibGVzIHdpdGhvdXQgb3V0Z29pbmcgbGlua3MgKGVuZCBvZiBkYXRhIHByb2Nlc3NpbmcpLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHZhbHVlIHRoZSBjb21wb3NpdGlvbiByZXR1cm5zIGFzIHRoZSBkYXRhcHJvY2Vzc2luZyByZXN1bHQuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgaW5pdGFsaXphdGlvbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgY29tcG9zYWJsZXMuXHJcbiAqIEB0eXBlZGVmIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gY29tcG9zaXRpb25Jbml0YWxpemVyXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gW2NvbXBvc2FibGVzPXt9XSAtIEEgZGljdGlvbmFyeSBvZiBhbGwgY29tcG9zYWJsZXMgdXNlZCBieSB0aGUgY29tcG9zaXRpb24uIFxyXG4gKiBUaGUga2V5IHJlcHJlc2VudHMgdGhlIGludGVybmFsIGFsaWFzLCB0aGUgdmFsdWUgcmVwcmVzZW50cyBcclxuICogdGhlIGNvbXBvc2FibGUgbmFtZSwgd2hpY2ggaXMgdXNlZCB0byBsb2FkIHRoZSBjb21wb3NhYmxlIGluZm9ybWF0aW9uLlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgQXJyYXkuPGxpbmtUeXBlPj59IFtsaW5rcz17fV0gLSBBIGRpY3Rpb25hcnkgZGVzY3JpYmluZyBhbiBlZGdlIGxpc3Qgb2YgaG93IHRoZSBjb21wb3NhYmxlcyBhcmUgbGlua2VkLlxyXG4gKiBUaGUga2V5IGRlc2NyaWJlcyB0aGUgb3JpZ2luIGNvbXBvc2FibGUsIHRoZSB2YWx1ZSBkZXNjcmliZXMgYW4gYXJyYXkgb2YgdGFyZ2V0IGNvbXBvc2FibGVzIHdpdGggbWFwcGluZyBpbmZvcm1hdGlvbiBvZiB0aGUgZGF0YSBwcm9wZXJ0aWVzLlxyXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0aW9ufm1hcElucHV0RnVuY3Rpb259IFttYXBJbnB1dF0gLSBBIGZ1bmN0aW9uIHRvIG1hcCB0aGUgaW5wdXQgb2JqZWN0IG9mIHRoZSBjb21wb3NpdGlvbiB0byB0aGUgaW5wdXQgb2JqZWN0IG9mIGluZGl2aWR1YWwgY29tcG9zYWJsZXMuXHJcbiAqIFRoZSBkZWZhdWx0IHJlcXVpcmVzIGFuIGlucHV0IG9iamVjdCwgd2hlcmUgZWFjaCBwcm9wZXJ0eSBjb3JyZXNwb25kcyB0byBhIGNvbXBvc2FibGUgYWxpYXMvbmFtZSBhbmQgbWFwcyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIHRoaXMgY29tcG9zYWJsZSBpbnB1dC5cclxuICogQHByb3BlcnR5IHtDb21wb3NpdGlvbn5tYXBEYXRhSW5GdW5jdGlvbn0gW21hcERhdGFJbl0gLSBBIGZ1bmN0aW9uIHRvIG1hcCB0aGUgZGF0YSBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uIHRvIHRoZSBkYXRhIG9iamVjdCBvZiBpbmRpdmlkdWFsIGNvbXBvc2FibGVzLlxyXG4gKiBUaGUgZGVmYXVsdCByZXF1aXJlcyBhIGRhdGEgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGEgY29tcG9zYWJsZSBhbGlhcy9uYW1lIGFuZCBtYXBzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gdGhpcyBjb21wb3NhYmxlIGRhdGEuXHJcbiAqIEBwcm9wZXJ0eSB7Q29tcG9zaXRpb25+bWFwRGF0YU91dEZ1bmN0aW9ufSBbbWFwRGF0YU91dF0gLSBBIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgcmVzdWx0aW5nIGRhdGEgb2JqZWN0IG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIG1ha2luZyBpdCBhdmFpbGFibGUuXHJcbiAqIFRoZSBkZWZhdWx0IGRvZXMgbm90IGNoYW5nZSB0aGUgb3V0cHV0IG9iamVjdC5cclxuICovXHJcblxyXG4vKipcclxuICogQSBjb21wb3NpdGlvbiBjYW4gY29uc2lzdCBvZiBtdWx0aXBsZSBvdGhlciBjb21wb3NpdGlvbnMgb3IgY29tcG9zYWJsZXMuXHJcbiAqIEl0IG9yY2hpc3RyYXRlcyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjb21wb3NhYmxlcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIENvbXBvc2FibGVcclxuICogQHBhcmFtIHtjb21wb3NpdGlvbkluaXRhbGl6ZXJ9IGluaXRpYWxpemF0aW9uT2JqZWN0IC0gVGhlIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBjb21wb3NpdGlvbi5cclxuICogXHJcbiAqL1xyXG5mdW5jdGlvbiBDb21wb3NpdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgbWFuYWdlcikge1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2NvbXBvc2FibGVzJywge30pO1xyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdsaW5rcycsIHt9KTtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ21hcElucHV0JywgNCwgZnVuY3Rpb24gKGlucHV0LCBjb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZXMsIGxpYnMpIHtcclxuICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFtjb21wb3NhYmxlTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdtYXBEYXRhSW4nLCA0LCBmdW5jdGlvbiAoZGF0YSwgY29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGVzLCBsaWJzKSB7XHJcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2NvbXBvc2FibGVOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ21hcERhdGFPdXQnLCAyLCBmdW5jdGlvbiAob3V0cHV0LCBsaWJzKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0pO1xyXG4gICAgLy9jYWxsIHRvIHRoZSBwYXJlbnQgY2xhc3MgaW5pdGFsaXphdGlvbiBmdW5jdGlvblxyXG4gICAgdGhpcy5pbml0aWFsaXplKGluaXRpYWxpemF0aW9uT2JqZWN0KTtcclxuXHJcbiAgICAvKipcclxuICAgICogSW5kaWNhdGVzLCBpZiB0aGUgY29tcG9zaXRpb24gaXMgcmVhZHkgdG8gdXNlLiBUaGlzIGlzIGltcG9ydGFudCwgYXMgcmVxdWlyZWQgY29tcG9zYWJsZXMgbWlnaHQgbmVlZCB0byBiZSBsb2FkZWQgZmlyc3QuXHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICogQG5hbWUgQ29tcG9zaXRpb24jaXNSZWFkeVxyXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcclxufVxyXG4vL2luaGVyaXQgcHJvcGVydGllc1xyXG5Db21wb3NpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvc2FibGUucHJvdG90eXBlKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHN0YXJ0cyB0byByZWN1cnNpdmVseSBsb2FkIGNvbXBvc2FibGVzIHJlcXVpcmVkIGJ5IHRoaXMgY29tcG9zaXRpb24uXHJcbiAqIFNlZSB7QGxpbmsgQ29tcG9zYWJsZUxvYWRlcn0gZm9yIG1vcmUgZGV0YWlscyBvbiBoZSBsb2FkaW5nIHByb2Nlc3MuXHJcbiAqIFdoZW4gZmluaXNoZWQgYWxsIHJlcXVpcmVkIGNvbXBvc2FibGVzIGFyZSBpbiBtZW1vcnkgYW5kIGNhbiBiZSB1c2VkLlxyXG4gKiBBcyBsb2FkaW5nIGlzIGFzeW5jIGl0IHJldHVybnMgYSBwcm9taXNlLiBcclxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEFuIGVtcHR5IHByb21pc2UsIHNpZ25hbGluZyB0aGF0IGV2ZXJ5dGhpbmcgd2FzIGxvYWRlZC5cclxuICovXHJcbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5sb2FkQ29tcG9zYWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vY29sbGVjdHMgYW4gYXJyYXkgb2YgbG9hZGluZyBwcm9taXNlcywgd2hpY2ggaXMgdGhlbiBmaWxsZWRcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VsZi5jb21wb3NhYmxlcykge1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZvciBlYWNoIHJlcXVpcmVkIGNvbXBvc2FibGUgdGhlIGNvbXBvc2FibGUgaXMgbG9hZGVkIHVzaW5nIHRoZSBzcGVjaWZpZWQgbmFtZSBvZiBpdFxyXG4gICAgICAgICAgICAgICAgLy90aGUgbmFtZSBpdHNlbGYgYWN0cyBhcyBhIHBhcnQgb2YgYSBVUkxcclxuICAgICAgICAgICAgICAgIC8vYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2FibGVzIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2l0aW9uIGlzIHBhc3NlZCwgc28gdGhlXHJcbiAgICAgICAgICAgICAgICAvL3N0cmluZyB2YWx1ZXMgKG5hbWVzKSBvZiB0aGUgcmVxdWlyZWQgY29tcG9zaXRpb25zIGFyZSBsYXRlciByZXBsYWNlZCB3aXRoIHRoZSBjb21vc2l0aW9uIG9iamVjdHMsXHJcbiAgICAgICAgICAgICAgICAvL3doaWNoIGNhbiB0aGVuIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb21wb3NhYmxlc1trZXldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3dldmEuQ29tcG9zYWJsZUxvYWRlci5sb2FkKHNlbGYuY29tcG9zYWJsZXNba2V5XSwgc2VsZi5jb21wb3NhYmxlcywga2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9vdGhlcndpc2UgY3JlYXRlIGZyb20gZ2l2ZW4gb2JqZWN0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWxmLmNvbXBvc2FibGVzW2tleV0udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlPT0nbW9kdWxlJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZXNba2V5XSA9IG5ldyBNb2R1bGUoc2VsZi5jb21wb3NhYmxlc1trZXldLCBzZWxmLm1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlc1trZXldID0gbmV3IENvbXBvc2l0aW9uKHNlbGYuY29tcG9zYWJsZXNba2V5XSwgc2VsZi5tYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2ludm9rZSBhbGwgcHJvbWlzZXMgYW5kIHdhaXQgZm9yIHRoZW0gdG8gZmluaXNoXHJcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL3doZW4gYWxsIHByb21pc2VzIGFyZSBmaW5pc2hlZCwgYWxsIGNvbXBvbmVudHMgYXJlIGxvYWRlZCwgc28gdGhlIGNvbXBvc2l0aW9uIGlzIHJlYWR5IHRvIGJlIHVzZWRcclxuICAgICAgICAgICAgc2VsZi5pc1JlYWR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vaW1wb3J0YW50OiBhcyB3ZSBhcmUgZGVhbGluZyBoZXJlIHdpdGggYXN5bmMgb3BlcmF0aW9ucywgb25lIG1pZ2h0IHRyeSB0byBleGVjdXRlIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlXHJcbiAgICAgICAgICAgIC8vaXQgaXMgcmVhZHkgdG8gYmUgdXNlZC4gSW4gdGhpcyBjYXNlIHRoZSBleGVjdXRpb24gaXMgZGVsYXllZCBhbmQgaW5kaWNhdGVkICh3YW50c1RvRXhlY3V0ZT10cnVlKVxyXG4gICAgICAgICAgICAvL25vdyBpZiB0aGUgbG9hZGluZyBpcyBmaW5pc2hlZCwgaXQgY2FuIGRpcmVjdGx5IHN0YXJ0IHRoZSBleGVjdXRpb24gZGlyZWN0bHkgaXRzZWxmLCB1c2luZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcclxuICAgICAgICAgICAgLy9ubyBwb2xsaW5nIG5lZWRlZCA6KVxyXG4gICAgICAgICAgICBpZiAoc2VsZi53YW50c1RvRXhlY3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlU3RhcnRlckNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vb2sgYWxsIGxvYWRlZCwgbm93IHdlIGNhbiBhbmFseXplIGdyYXBoIGFuZCBjaGVjayBmb3IgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICBzZWxmLmFuYWx5emVMaW5rR3JhcGgoKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9pbmRpY2F0ZSB0byB0aGUgb3V0c2lkZSwgdGhhdCB3ZSBhcmUgZG9uZSB3aXRoIGV2ZXJ5dGhpbmcgYW5kIHRoZSBjb21wb3NpdGlvbiBjYW4gYmUgdXNlZFxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFsbCBjb21wb3NhYmxlczogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dCwgc2VsZi5jb21wb3NhYmxlcykpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MsIGlmIGFsbCB0aGUgZGF0YSBhIGNvbXBvc2FibGUgcmVxdWlyZXMgaXMgYWxyZWFkeSBhdmFpbGFibGUuXHJcbiAqIEFzIGNvbXBvc2FibGVzIGFyZSBleGVjdXRlZCBpbiBhIGdyYXBoLCBzb21lIGNvbXBvc2FibGVzIGRlcGVuZCBvbiB0aGUgY2FsY3VsYXRpb25zIG9mIG90aGVycyBhbmQgaGF2ZSB0byB3YWl0IGZvciB0aGUgZGF0YS5cclxuICogXHJcbiAqIEZvciB0aGlzIHB1cnBvc2UsIHRoZSB7QGxpbmsgQ29tcG9zYWJsZSNkYXRhSW59IHByb3BlcnR5IGlzIHVzZWQgYXMgYSBjb3VudCwgdGhhdCBoYXMgdG8gYmUgcmVhY2hlZFxyXG4gKiBieSB0aGUgYW1vdW50IG9mIHByb3BlcnRpZXMgc3RvcmVkIGZvciB0aGlzIGNvbXBvc2FibGUgaW4ge0BsaW5rcyBDb21wb3NpdGlvbiNwYXJhbWV0ZXJzfS5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgYWxpYXMgb2YgdGhlIGNvbXBvc2FibGUgb2JqZWN0LCBmb3Igd2hpY2ggdGhlIGNoZWNrIHNob3VsZCBiZSBwZXJmb3JtZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLCBpZiBhbGwgZGF0YSByZXF1aXJlZCBmb3IgdGhlIGNvbXBvc2FibGUgaXMgYXZhaWxhYmxlLlxyXG4gKi9cclxuQ29tcG9zaXRpb24ucHJvdG90eXBlLmhhc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAoY29tcG9zYWJsZU5hbWUpIHtcclxuICAgIC8vaG93IG1hbnkgcGFyYW1ldGVycyBkb2VzIHRoZSBjb21wb3NhYmxlIG5lZWQ/XHJcbiAgICBcclxuICAgIHZhciBwYXJhbWV0ZXJzTmVlZGVkID0gW107XHJcbiAgICBpZih0eXBlb2YgdGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlTmFtZV0uZGF0YUluQ29ubmVjdGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHBhcmFtZXRlcnNOZWVkZWQgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGVOYW1lXS5kYXRhSW5Db25uZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIC8vaWYgaXQgZG9lcyBub3QgbmVlZCBhbnksIHdlIGFyZSBnb29kIGhlcmVcclxuICAgIGlmIChwYXJhbWV0ZXJzTmVlZGVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL2lmIHdlIGFyZSBzdGlsbCBoZXJlLCBpdCBuZWVkcyBhdCBsZWFzdCBvbmVcclxuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XHJcbiAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICAvL25vdCBlbm91Z2hcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnNOZWVkZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNOZWVkZWRbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlTmFtZV1bcGFyYW1ldGVyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgbmV3IGRhdGEgdG8gdGhlIGF2YWlsYWJsZSBwb29sIG90aGVyIGNvbXBvc2FibGVzIHVzZS5cclxuICogVGhpcyBhbGxvd3MgZGVwZW5kYW50IGNvbXBvc2FibGVzIHRvIGZldGNoIHRoZSBkYXRhIGFuZCBzdGFydCBleGVjdXRpb24uXHJcbiAqIEl0IHNhdmVzIHRoZSBkYXRhIGFzIGEgc3Via2V5IG9mIGEgc3Via2V5IG9mIHtAbGlua3MgQ29tcG9zaXRpb24jcGFyYW1ldGVyc306XHJcbiAqIHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlXVtwcm9wZXJ0eV0gPSB2YWx1ZVxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb3NhYmxlTmFtZSAtIFRoZSBhbGlhcyBvZiB0aGUgY29tcG9zYWJsZSBvYmplY3QgZm9yIHdoaWNoIHRoZSBkYXRhIGlzIGludGVuZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBzYXZlIHRoZSBkYXRhIGFzLCB0aGUgdmFsdWUgbXVzdCBjb3JyZXNwb25kIHRvIGEgdmFsdWUgZGVmaW5lZFxyXG4gKiBpbiB7QGxpbmtzIENvbXBvc2FibGUjZGF0YUluTmFtZXN9ICh3ZSBuZWVkIGNvcnJlY3QgbWFwcGluZykuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW58c3RyaW5nfG51bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGRhdGEgdG8gYWRkLlxyXG4gKi9cclxuQ29tcG9zaXRpb24ucHJvdG90eXBlLmFkZFBhcmFtZXRlciA9IGZ1bmN0aW9uIChjb21wb3NhYmxlTmFtZSwgcHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICAvL2lmIG5vIGtleSBmb3IgY29tcG9zYWJsZSBwcmVzZW50LCBjcmVhdGUgb25lXHJcbiAgICBpZiAoIXRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlTmFtZSkpIHtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnNbY29tcG9zYWJsZU5hbWVdID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0aGUgY29tcG9zaXRpb24sIHNvIGl0IGNhbiBiZSBleGVjdXRlZCBhZ2Fpbi5cclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuQ29tcG9zaXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307ICAgIFxyXG4gICAgdGhpcy5vdXRwdXQgPSB7fTtcclxuICAgIHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbXBvc2FibGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgY29tcG9zYWJsZToga2V5LFxyXG4gICAgICAgICAgICAgICAgY2xlYXJlZDogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MsIGlmIHRoZSBjb21wb3NhYmxlIGdyYXBoIG9mIHRoZSBjb21wb3NpdGlvbiBjb250YWlucyBjeWNsZXMgKGVuZCB0aGVyZWZvcmUgaXMgbm90IGEgREFHKS5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdGFydGluZ05vZGVBcnJheSAtIEFuIGFycmF5IHdpdGggdGhlIGFsaWFzZXMgb2YgYWxsIGNvbXBvc2FibGVzLCB0aGF0IGRvIG5vdCBoYXZlIGFuIGluY29taW5nIGVkZ2UvbGluay5cclxuICogVGhleSBhcmUgY29uc2lkZXJlZCBhcyB0aGUgZmlyc3Qgbm9kZXMsIHRoYXQgZ2V0IGV4ZWN1dGVkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGdyYXBoIGNvbnRhaW5zIGN5Y2xlcy5cclxuICovXHJcbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5oYXNDeWNsZXMgPSBmdW5jdGlvbiAoc3RhcnRpbmdOb2RlQXJyYXkpIHtcclxuICAgIHZhciBub2RlcyA9IHt9O1xyXG4gICAgdmFyIGVkZ2VzID0ge307XHJcblxyXG4gICAgLy9maXJzdCBjcmVhdGUgYSBjb3B5IG9mIHRoZSBjb21wb3NhYmxlcyBpbiB0aGUgY29tcG9zaXRpb24gKG5vZGVzKVxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcG9zYWJsZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIG5vZGVzW2tleV0gPSB7fVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vY3JlYXRlIGEgY29weSBvZiB0aGUgbGlua3Mgd2l0aG91dCBtYXBwaW5nIGluZm9ybWF0aW9uIChlZGdlcylcclxuICAgIGZvciAodmFyIGZyb21Ob2RlIGluIHRoaXMubGlua3MpIHtcclxuICAgICAgICBpZiAodGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShmcm9tTm9kZSkpIHtcclxuICAgICAgICAgICAgZWRnZXNbZnJvbU5vZGVdID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBmcm9tRW5kcG9pbnQgaW4gdGhpcy5saW5rc1tmcm9tTm9kZV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmtzW2Zyb21Ob2RlXS5oYXNPd25Qcm9wZXJ0eShmcm9tRW5kcG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdG9Ob2RlIGluIHRoaXMubGlua3NbZnJvbU5vZGVdW2Zyb21FbmRwb2ludF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua3NbZnJvbU5vZGVdW2Zyb21FbmRwb2ludF0uaGFzT3duUHJvcGVydHkodG9Ob2RlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2Zyb21Ob2RlXS5wdXNoKHRvTm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKmZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5rc1trZXldLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlZGdlc1trZXldLnB1c2godGhpcy5saW5rc1trZXldW2ldLnRvKTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgLy9LYWhuJ3MgYWxnb3JpdGhtXHJcbiAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmdcclxuICAgIHZhciBMID0gW107XHJcbiAgICB2YXIgUyA9IHN0YXJ0aW5nTm9kZUFycmF5LnNsaWNlKCk7XHJcbiAgICB2YXIgdW5pcXVlTCA9IHRydWU7XHJcbiAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIG4gPSBTLnBvcCgpO1xyXG5cclxuICAgICAgICAvL3NvcnRpbmcgb25seSB3b3JrcywgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUhXHJcbiAgICAgICAgaWYgKEwuaW5kZXhPZihuKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHVuaXF1ZUwgPSBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEwucHVzaChuKTtcclxuICAgICAgICBpZiAoZWRnZXMuaGFzT3duUHJvcGVydHkobikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlc1tuXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBlZGdlc1tuXVtpXTtcclxuICAgICAgICAgICAgICAgIGVkZ2VzW25dLnNwbGljZShpLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpLS07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0luY29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZWRnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGVkZ2VzW2tleV0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGdlc1trZXldW2tdID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSW5jb21pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNJbmNvbWluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0luY29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUy5wdXNoKG0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW25dLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlZGdlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL2lmIGVkZ2VzIGV4aXN0LCBvciBMIGhhcyBub24gdW5pcXVlIGVsZW1lbnRzOiB0aGVyZSBpcyBhIGN5Y2xlXHJcbiAgICBpZiAoT2JqZWN0LmtleXMoZWRnZXMpLmxlbmd0aCA+IDAgfHwgIXVuaXF1ZUwpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzLCBpZiB0aGUgc2NoZW1hcyBvZiB0d28gb2JqZWN0cyBhcmUgY29tcGF0aWJsZS5cclxuICogVHdvIG9iamVjdHMgYXJlIGNvbXBhdGlibGUsIGlmIG9uZSBvZiB0aGVtIGhhcyBubyBzY2hlbWEgZGVmaW5pdGlvbiwgb3IgaWYgdGhlIGZpcnN0IHNjaGVtYSBpcyBpZGVudGljYWwgdG8gdGhlIHNlY29uZCBvbmUgaW4gYSByZWN1cnNpdmUgY29tcGFyaXNvbi5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqMU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlyc3Qgb2JqZWN0IChmcm9tKS4gT25seSB1c2VkIGZvciBlcnJvciBvdXRwdXQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmoyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZWNvbmQgb2JqZWN0ICh0bykuIE9ubHkgdXNlZCBmb3IgZXJyb3Igb3V0cHV0LlxyXG4gKiBAcGFyYW0ge0pTT05TY2hlbWF9IG9iajFTY2hlbWEgLSBUaGUgc2NoZW1hIG9mdGhlIGZpcnN0IG9iamVjdC5cclxuICogQHBhcmFtIHtKU09OU2NoZW1hfSBvYmoyU2NoZW1hIC0gVGhlIHNjaGVtYSBvZnRoZSBzZWNvbmQgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hcHBpbmdGcm9tXSAtIFRoZSByZWxldmFudCBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBmaXJzdCBvYmplY3QgKHNvdXJjZS9mcm9tKS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFttYXBwaW5nVG9dIC0gVGhlIHJlbGV2YW50IHByb3BlcnR5IG5hbWUgb2YgdGhlIHNlY29uZCBvYmplY3QgKHRhcmdldC90bykuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlLCBpZiB0aGUgb2JqZWN0IHdpdGggb2JqMVNjaGVtYSBjYW4gYmUgdXNlZCwgd2hlcmUgb2JqMlNjaGVtYSBpcyByZXF1aXJlZC4gXHJcbiAqL1xyXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuY2hlY2tTY2hlbWFDb21wYXRpYmlsaXR5ID0gZnVuY3Rpb24gKG9iajFOYW1lLCBvYmoyTmFtZSwgb2JqMVNjaGVtYSwgb2JqMlNjaGVtYSwgbWFwcGluZ0Zyb20sIG1hcHBpbmdUbykge1xyXG4gICAgLy9zY2hlbWFzIGFyZSBvcHRpb25hbCAobnVsbCksIHNvIGdpdmUgdGhlIGJlbmVmaXQgb2YgdGhlIGRvdWJ0XHJcbiAgICBpZiAob2JqMVNjaGVtYSA9PSBudWxsIHx8IG9iajJTY2hlbWEgPT0gbnVsbCkgeyBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vdXNlIHRvIHN0b3JlIGVycm9yIG1lc3NhZ2VzXHJcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xyXG5cclxuICAgIC8vZnVuY3Rpb24gZm9yIHJlY3Vyc2lvbiwgZGVhbHMgd2l0aCB0aGUgbWV0YSBpbmZvcm1hdGlvbiBsZXZlbCAodHlwZSwgcHJvcGVydGllcywgcmVxdWlyZWQsIGV0Yykgb2YgdGhlIEpTT05TY2hlbWFcclxuICAgIC8vbGV2ZWwgaW5kaWNhdGVzIHRoZSBwb3BlcnR5IGNoYWluIGFuZCBpcyB1c2VkIGZvciBlcnJvciBtZXNzYWdlc1xyXG4gICAgZnVuY3Rpb24gbWV0YUxldmVsKGxldmVsLCBmcm9tLCB0bykge1xyXG4gICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSB0YXJnZXQga2V5cyAob2JqMlNjaGVtYSlcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcclxuICAgICAgICAgICAgLy90aGUgc291cmNlIChvYmoxU2NoZW1hKSBtdXN0IGhhdmUgYWxsIGtleXMgdGhlIHRhcmdldCBoYXNcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2l0ZW1zJyAmJiBrZXkgIT09ICdyZXF1aXJlZCcgJiYgIWZyb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtaXNzaW5nIHByb3BlcnR5IFwiJyArIGtleSArICdcIidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXksIHByb2NlZWQgdG8gdGhlIG1ldGEtbGV2ZWxcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2l0ZW1zJyAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbWV0YUxldmVsKGxldmVsICsgJy4nICsga2V5LCBmcm9tW2tleV0sIHRvW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgcHJvY2VlZCB3aXRoIHRoZSByZWN1cnNpb24gdXNpbmcgdGhlIHByb3BlcnR5TGV2ZWxcclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAncHJvcGVydGllcycgJiYgZnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5TGV2ZWwobGV2ZWwgKyAnLicgKyBrZXksIGZyb21ba2V5XSwgdG9ba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB3ZSBnZXQgdG8gdGhlIHJlcXVpcmVkIGFycmF5Li4uXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3JlcXVpcmVkJyAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vc3BlY2lhbDogcmVxdWlyZWQgYXJyYXkgb3JkZXIgc2hvdWxkIGJlIGlnbm9yZWRcclxuICAgICAgICAgICAgICAgIGZyb21ba2V5XS5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB0b1trZXldLnNvcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IGNoZWNrIGlmIHRoZSBsZW5ndGggaXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tW2tleV0ubGVuZ3RoICE9PSB0b1trZXldLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhcnJheSBsZW5ndGggZGlmZmVyZW50IGZvciBcIicgKyBrZXkgKyAnXCIgJyArIGZyb21ba2V5XS50b1N0cmluZygpICsgJyAhPSAnICsgdG9ba2V5XS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbVtrZXldLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21ba2V5XVtpXSAhPT0gdG9ba2V5XVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhcnJheSBlbGVtZW50IGRpZmZlcmVuY2UgZm9yIFwiJyArIGtleSArICdcIiAoICcgKyBmcm9tW2tleV1baV0gKyAnICE9ICcgKyB0b1trZXldW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnICkgJyArIGZyb21ba2V5XS50b1N0cmluZygpICsgJyAhPSAnICsgdG9ba2V5XS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB3ZSBnZXQgc29tZXRoaW5nIGVsc2UsIHdlIGNvbXBhcmUgdGhlIHZhbHVlc1xyXG4gICAgICAgICAgICAvL3RoaXMgc2hvdWxkIGJlIGFsbCBwcmltaXRpdmUgdHlwZXMsIGJ1dCBJJ20gbm90IHN1cmUgaWYgSSBkaWRuJ3QgbWlzcyBhbnkgcG9zc2libGUgbm9uLXByaW1pdGl2ZVxyXG4gICAgICAgICAgICAvL2luIHRoZSBhYm92ZSBpZi1lbHNlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20uaGFzT3duUHJvcGVydHkoa2V5KSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbVtrZXldICE9PSB0b1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZXF1YWwgcHJvcGVydHkgdmFsdWUgXCInICsga2V5ICsgJ1wiICggJyArIGZyb21ba2V5XSArICcgIT0gJyArIHRvW2tleV0gKyAnICknXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvL2Z1bmN0aW9uIGZvciByZWN1cnNpb24sIGRlYWxpbmcgd2l0aCB0aGUgZW51bWVyYXRpb24gb2YgcHJvcGVydHkga2V5cyBvZiBhIHNjaGVtYVxyXG4gICAgZnVuY3Rpb24gcHJvcGVydHlMZXZlbChsZXZlbCwgZnJvbSwgdG8pIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcclxuICAgICAgICAgICAgLy9mcm9tIG11c3QgaGF2ZSBhdCBsZWFzdCBhbGwga2V5cyB0byBoYXNcclxuICAgICAgICAgICAgaWYgKCFmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyBwcm9wZXJ0eSBcIicgKyBrZXkgKyAnXCInXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb250aW51ZSwgYnkgY2hlY2tpbmcgdGhlIG1ldGEtbGV2ZWwgb2YgZWFjaCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoIW1ldGFMZXZlbChsZXZlbCArICcuJyArIGtleSwgZnJvbVtrZXldLCB0b1trZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgLy9oZWxwZXIgZnVuY3Rpb24sIHRoYXQgaGVscHMgdG8gbmFycm93IHRoZSBzY29wZSwgaWYgYSBtYXBwaW5nVG8vbWFwcGluZ0Zyb20gaXMgZ2l2ZW5cclxuICAgIC8vaXQgYmFzaWNhbGx5IHRyYXZlcnNlcyB0aGUgc2NoZW1hIHRvIHRoZSBkZXNpcmVkIG1hcHBpbmcgcHJvcGVydHkgYW5kIHJldHVybnMgaXQgYXMgdGhlIG5ldyBzY2hlbWFcclxuICAgIGZ1bmN0aW9uIHNjb3BlT25NYXBwaW5nKHNjaGVtYSwgbWFwcGluZykge1xyXG4gICAgICAgIHZhciBoYXNTY2hlbWEgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KCdwcm9wZXJ0aWVzJykpIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG1hcHBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hLnByb3BlcnRpZXNbbWFwcGluZ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NvcHkgdGhlIG9yaWdpbmFsIHNjaGVtYXMgZm9yIGVycm9yIG91dHB1dCAod2UgbWlnaHQgbW9kaWZ5IG91ciByZWZlcmVuY2UgbGF0ZXIgdG8gbmFycm93IHRoZSBzY29wZSwgYnV0IFxyXG4gICAgLy93ZSBzdGlsbCB3YW50IHRvIHNob3cgdGhlIGZ1bGwgc2NoZW1hIGZvciB0aGUgZXJyb3IgbWVzc2FnZVxyXG4gICAgdmFyIE9yaWdpbmFsT2JqMVNjaGVtYSA9IG9iajFTY2hlbWE7IFxyXG4gICAgdmFyIE9yaWdpbmFsT2JqMlNjaGVtYSA9IG9iajJTY2hlbWE7XHJcblxyXG4gICAgLy9tYXBwaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHNjaGVjayBpZiB0aGV5IGFyZSBkZWZpbmVkIGFuZCBuYXJyb3cgdGhlIHNjb3Blc1xyXG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nVG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBzY29wZU9uTWFwcGluZyhvYmoyU2NoZW1hLCBtYXBwaW5nVG8pO1xyXG4gICAgICAgIGlmICh0ZW1wKSB7XHJcbiAgICAgICAgICAgIG9iajJTY2hlbWEgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbDogJycsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29tcG9zYWJsZSBcIicgKyBvYmoyTmFtZSArICdcIiBoYXMgbm8gc2NoZW1hIGZvciBwcm9wZXJ0eSBcIicgKyBtYXBwaW5nVG8gKyAnXCIgcHJvdmlkZWQgYnkgY29tcG9zYWJsZSBcIicgKyBvYmoxTmFtZSArICdcIidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG1hcHBpbmdGcm9tID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciB0ZW1wID0gc2NvcGVPbk1hcHBpbmcob2JqMVNjaGVtYSwgbWFwcGluZ0Zyb20pO1xyXG4gICAgICAgIGlmICh0ZW1wKSB7XHJcbiAgICAgICAgICAgIG9iajFTY2hlbWEgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbDogJycsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29tcG9zYWJsZSBcIicgKyBvYmoxTmFtZSArICdcIiBoYXMgbm8gc2NoZW1hIGZvciBwcm9wZXJ0eSBcIicgKyBtYXBwaW5nRnJvbSArICdcIiByZXF1aXJlZCBieSBjb21wb3NhYmxlIFwiJyArIG9iajJOYW1lICsgJ1wiJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vaWYgd2UgZGlkbid0IGhhdmUgYW4gZXJyb3IgeWV0LCB3ZSBjYW4gc3RhcnQgdGhlIHJlY3Vyc2lvblxyXG4gICAgXHJcbiAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbWV0YUxldmVsKCcnLCBvYmoxU2NoZW1hLCBvYmoyU2NoZW1hKTtcclxuICAgIH1cclxuXHJcbiAgICAvL291dHB1dCBhbiBlcnJvciBtZXNzYWdlXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICB2YXIgcmVsZXZhbnRNYXBwaW5nID0gJyc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nRnJvbSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG1hcHBpbmdUbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmVsZXZhbnRNYXBwaW5nID0gJyBmb3IgdGhlIG1hcHBpbmcgXCInICsgbWFwcGluZ0Zyb20gKyAnXCIgLT4gXCInICsgbWFwcGluZ1RvICsgJ1wiJztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXBwaW5nVG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJlbGV2YW50TWFwcGluZyA9ICcgZm9yIHRoZSBtYXBwaW5nIFwiJyArIG1hcHBpbmdUbyArICdcIic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmF1bHR5T2JqZWN0ID0ge307XHJcbiAgICAgICAgZmF1bHR5T2JqZWN0W29iajFOYW1lXSA9IE9yaWdpbmFsT2JqMVNjaGVtYTtcclxuICAgICAgICBmYXVsdHlPYmplY3Rbb2JqMk5hbWVdID0gT3JpZ2luYWxPYmoyU2NoZW1hO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdTY2hlbWFzIG9mIFwiJyArIG9iajFOYW1lICsgJ1wiIGFuZCBcIicgKyBvYmoyTmFtZSArICdcIiBpbmNvbXBhdGlibGUnICsgcmVsZXZhbnRNYXBwaW5nICsgJzogJ1xyXG4gICAgICAgICAgICArIGVycm9yLmxldmVsICsgJzogJyArIGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQsIGZhdWx0eU9iamVjdCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogU3RhdGljYWxseSBhbmFseXplcyB0aGUgZ3JhcGggYmVmb3JlIGV4ZWN1dGlvbi5cclxuICogQ2hlY2tzIGZvciBjb21wYXRhYmlsaXR5IG9mIGNvbXBvc2FibGVzLCBhYnNlbmNlIG9mIGN5Y2xlcyBpbiB0aGUgbGlua2FnZSBkZWZpbml0aW9uIGV0Yy5cclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuQ29tcG9zaXRpb24ucHJvdG90eXBlLmFuYWx5emVMaW5rR3JhcGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEZhbHNlLCBpZiBubyBlcnJvcnMgaW4gdGhlIGxpbmsgZ3JhcGggZGVmaW5pdGlvbiB3ZXJlIGRldGVjdGVkLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQG5hbWUgQ29tcG9zaXRpb24jaW52YWxpZExpbmtHcmFwaFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBhbGwgdGhlIGFsaWFzZXMgb2YgdGhlIGNvbXBvc2FibGVzLCB0aGF0IGhhdmUgbm8gaW5nb2luZyBsaW5rLCBpLmUuIHRoZSAnc3RhcnQnXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAbmFtZSBDb21wb3NpdGlvbiNzdGFydGluZ0NvbXBvc2FibGVzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcG9zYWJsZXMpO1xyXG4gICAgLyoqXHJcbiAgICAqIERpY3Rpb25hcnkgb2YgYWxsIHRoZSBhbGlhc2VzIG9mIHRoZSBjb21wb3NhYmxlcywgdGhhdCBoYXZlIG5vIG91dGdvaW5nIGxpbmssIGkuZS4gdGhlICdlbmQnXHJcbiAgICAqIERpY3Rpb25hcnksIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBzb21lIGxvb2t1cHMgb2YgdGhlIGtleSB2YWx1ZXMgbGF0ZXIgb24uXHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICogQG5hbWUgQ29tcG9zaXRpb24jc3RhcnRpbmdDb21wb3NhYmxlc1xyXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cclxuICAgICovXHJcbiAgICB0aGlzLmVuZGluZ0NvbXBvc2FibGVzID0ge307XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb21wb3NhYmxlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRpbmdDb21wb3NhYmxlc1trZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9maW5kIHN0YXJ0aW5nQ29tcG9zYWJsZXMgdGhhdCBoYXZlIG5vIGluZ29pbmcgZWRnZXNcclxuICAgIC8vZmluZCBlbmRpbmdDb21wb3NhYmxlcyB0aGF0IGhhdmUgbm8gb3V0Z29pbmcgZWRnZXNcclxuICAgXHJcblxyXG4gICAgZm9yICh2YXIgZnJvbU5vZGUgaW4gdGhpcy5saW5rcykge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGZyb21Ob2RlKSkge1xyXG4gICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgZnJvbUVuZHBvaW50IGluIHRoaXMubGlua3NbZnJvbU5vZGVdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rc1tmcm9tTm9kZV0uaGFzT3duUHJvcGVydHkoZnJvbUVuZHBvaW50KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0b05vZGUgaW4gdGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XS5oYXNPd25Qcm9wZXJ0eSh0b05vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9FbmRwb2ludCA9IHRoaXMubGlua3NbZnJvbU5vZGVdW2Zyb21FbmRwb2ludF1bdG9Ob2RlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbGlua2luZyB0byBleGlzdGluZyBjb21wb3NhYmxlIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KHRvTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdDb21wb3NhYmxlIFwiJyArIGZyb21Ob2RlICsgJ1wiIGxpbmtzIHRvIHVuZGVmaW5lZCBjb21wb3NhYmxlIFwiJyArIHRvTm9kZSArICdcIiEnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wb3NhYmxlIGhhcyBubyBzdWNoIGRhdGFPdXQsIGl0IHRyaWVzIHRvIG1hcCB0byBhbm90aGVyIGNvbXBvc2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1tmcm9tTm9kZV0uZGF0YU91dE5hbWVzLmluZGV4T2YoZnJvbUVuZHBvaW50KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvbXBvc2FibGUgXCInICsgZnJvbU5vZGUgKyAnXCIgbWFwcyB1bmRlZmluZWQgZGF0YU91dCBcIicgKyBmcm9tRW5kcG9pbnQgKyAnXCIgdG8gY29tcG9zYWJsZSBcIicgKyB0b05vZGUgKyAnXCIhJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQsIHRoaXMuY29tcG9zYWJsZXNbZnJvbU5vZGVdLmRhdGFPdXROYW1lcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRMaW5rR3JhcGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcG9zYWJsZSBoYXMgbm8gc3VjaCBkYXRhSW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbk5hbWVzLmluZGV4T2YodG9FbmRwb2ludCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdDb21wb3NhYmxlIFwiJyArIGZyb21Ob2RlICsgJ1wiIGxpbmtzIHRvIHVuZGVmaW5lZCBkYXRhSW4gXCInICsgdG9FbmRwb2ludCArICdcIiBvZiBjb21wb3NhYmxlIFwiJyArIHRvTm9kZSArICdcIiEnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbk5hbWVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZGl0aW9uYWxseSBjaGVjayBmb3Igc2NoZW1hIGNvbXBhdGliaWxpdHkgKG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2FibGVzW2Zyb21Ob2RlXS5kYXRhT3V0U2NoZW1hICYmIHRoaXMuY29tcG9zYWJsZXNbdG9Ob2RlXS5kYXRhSW5TY2hlbWEgIT0gbnVsbCkgey8vc2NoZW1hcyBhcmUgb3B0aW9uYWwsIHNvIG9ubHkgY2hlY2sgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXRpYmxlU2NoZW1hcyA9IHRoaXMuY2hlY2tTY2hlbWFDb21wYXRpYmlsaXR5KGZyb21Ob2RlLCB0b05vZGUsIHRoaXMuY29tcG9zYWJsZXNbZnJvbU5vZGVdLmRhdGFPdXRTY2hlbWEsIHRoaXMuY29tcG9zYWJsZXNbdG9Ob2RlXS5kYXRhSW5TY2hlbWEsZnJvbUVuZHBvaW50LCB0b0VuZHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXRpYmxlU2NoZW1hcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkTGlua0dyYXBoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbkNvbm5lY3RlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbkNvbm5lY3RlZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluQ29ubmVjdGVkW3RvRW5kcG9pbnRdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG9uZSBjb21wb3NhYmxlIEEgcG9pbnRzIHRvIGNvbXBvc2FibGUgQiwgdGhlbiBCIGNhbm5vdCBiZSBzdGFydGluZ0NvbXBvc2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wSW5kZXggPSB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMuaW5kZXhPZih0b05vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydGluZ0NvbXBvc2FibGVzLnNwbGljZShwcm9wSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBvbmUgY29tcG9zYWJsZSBBIHBvaW50cyB0byBjb21wb3NhYmxlIEIsIHRoZW4gQSBjYW5ub3QgYmUgZW5kaW5nQ29tcG9zYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRpbmdDb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShmcm9tTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5lbmRpbmdDb21wb3NhYmxlc1tmcm9tTm9kZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgXHJcblxyXG4gICAgLy9jaGVjayBmb3IgY3ljbGVzXHJcbiAgICB2YXIgaGFzQ3ljbGVzID0gdGhpcy5oYXNDeWNsZXModGhpcy5zdGFydGluZ0NvbXBvc2FibGVzKTtcclxuICAgIGlmIChoYXNDeWNsZXMpIHtcclxuICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignVGhlcmUgYXJlIGN5Y2xlcyBpbiB0aGUgbGlua2FnZSBvZiBjb21wb3NhYmxlcyEnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgdGhpcy5saW5rcykpO1xyXG4gICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9leHRyYWN0IGltcGxpY2l0IGluZm9ybWF0aW9uXHJcbiAgICB0aGlzLmRhdGFJbiA9IHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7XHJcbiAgICB0aGlzLmRhdGFPdXQgPSBPYmplY3Qua2V5cyh0aGlzLmVuZGluZ0NvbXBvc2FibGVzKS5sZW5ndGg7XHJcblxyXG4gICAgdGhpcy5kYXRhSW5OYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5kYXRhT3V0TmFtZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXNbdGhpcy5zdGFydGluZ0NvbXBvc2FibGVzW2ldXS5kYXRhSW5OYW1lcy5sZW5ndGg+MCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFJbk5hbWVzLnB1c2godGhpcy5zdGFydGluZ0NvbXBvc2FibGVzW2ldKTtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmVuZGluZ0NvbXBvc2FibGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kaW5nQ29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFPdXROYW1lcy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjb21wb3NhYmxlcywgYXMgc29vbiBhcyB0aGV5IGNhbiBiZSBleGVjdXRlZCAoaGF2ZSBhbGwgcmVxdWlyZWQgZGF0YSBhdmFpbGFibGUpXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4ZWN1dGlvbiBjb250ZXh0LCBzZWUge0BsaW5rIENvbXBvc2FibGUjY29udGV4dH1cclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuQ29tcG9zaXRpb24ucHJvdG90eXBlLmNvbXBvc2FibGVRdWV1ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICBcclxuICAgIC8va2VlcCBhbiBhcnJheSBvZiBhbGwgY29tcG9zYWJsZXNcclxuICAgIC8vZXhlY3V0ZWQgY29tcG9zYWJsZXMgZ2V0IG1hcmtlZFxyXG4gICAgLypcclxuICAgIGNvbnNvbGUubG9nKFwiQ1FFIDogY29udGV4dCA9XCIpO1xyXG4gICAgY29uc29sZS5sb2coY29udGV4dCk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkNRRSA6IHRoaXMgPVwiKTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMpO1xyXG4gICAgY29uc29sZS5sb2coXCJDUUUgOiB1bmNsZWFyZWRDb21wb3NhYmxlcyA9XCIpO1xyXG4gICAgY29uc29sZS5sb2codGhpcy51bmxjZWFyZWRDb21wb3NhYmxlcyk7XHJcbiAgICAqL1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAvL3NraXAgYWxyZWFkeSBleGVjdXRlZCBjb21wb3NhYmxlc1xyXG4gICAgICAgIGlmICh0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNsZWFyZWQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb3NhYmxlTmFtZSA9IHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY29tcG9zYWJsZTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICAvL2NoZWNrIGlmIGNvbXBvc2FibGUgaGFzIGFsbCBkYXRhIGl0IGRlcGVuZHMgb24gYXZhaWxhYmxlXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUGFyYW1ldGVycyhjb21wb3NhYmxlTmFtZSkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vZmlsbCBkYXRhIGFuZCBpbnB1dCBmb3IgbmV4dCBjb21wb3NhYmxlIGNhbGxcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlTmFtZV07XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy5tYXBJbnB1dCh0aGlzLmlucHV0LCBjb21wb3NhYmxlTmFtZSwgdGhpcy5jb21wb3NhYmxlcywgc3dldmEubGlicyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9ub3QgY29udGludWVkID0gY29tcG9zYWJsZU5hbWUgY2FuIGJlIGV4ZWN1dGVkIChoYXMgZGF0YSB2YWlsYWJsZSlcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgLy9jbG9zdXJlIGZ1bmN0aW9uLCB0byBnZXQgdGhlIGN1cnJlbnQgY29tcG9zYWJsZSBmb3IgZWFjaCBmdW5jdGlvblxyXG4gICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKGNvbXBvc2FibGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGNvbXBvc2FibGUgZG9lcyBub3QgcHJvdmlkZSBkYXRhIHRvIG90aGVyIGNvbXBvc2FibGVzIChlbmQgb2YgZXhlY3V0aW9uIGNoYWluKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZW5kaW5nQ29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENsZWFyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgaGF2ZSBvbmx5IG9uZSBvdXRwdXQgY29tcG9zYWJsZSwgd2UgZG8gbm90IG5lZWQgYSBuYW1lZCBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBjcmVhdGUgYSBwcm9wZXJ0eSB1c2luZyB0aGUgZW5kaW5nLWNvbXBvc2FibGUgYWxpYXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2VsZi5lbmRpbmdDb21wb3NhYmxlcykubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm91dHB1dFtjb21wb3NhYmxlTmFtZV0gPSBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm91dHB1dCA9IG91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhpcyB3YXMgdGhlIGxhc3QgY29tcG9zYWJsZSAoYWxsIGhhdmUgYmVlbiBleGVjdXRlZClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlbGYudW5sY2VhcmVkQ29tcG9zYWJsZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnVubGNlYXJlZENvbXBvc2FibGVzW2tdLmNsZWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbENsZWFyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoaXMgd2FzIHRoZSBsYXN0IGVuZGluZ0NvbXBvc2FibGUsIGZpbmlzaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDbGVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZUZpbmlzaGVkQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vaWYgY29tcG9zYWJsZSBwcm92aWRlcyBkYXRhIHRvIG90aGVyIGNvbXBvc2FibGVzIFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGlua3NbY29tcG9zYWJsZU5hbWVdKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcm9tRW5kcG9pbnQgaW4gc2VsZi5saW5rc1tjb21wb3NhYmxlTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXS5oYXNPd25Qcm9wZXJ0eShmcm9tRW5kcG9pbnQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvTm9kZSBpbiBzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXVtmcm9tRW5kcG9pbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXVtmcm9tRW5kcG9pbnRdLmhhc093blByb3BlcnR5KHRvTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0VuZHBvaW50ID0gc2VsZi5saW5rc1tjb21wb3NhYmxlTmFtZV1bZnJvbUVuZHBvaW50XVt0b05vZGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkUGFyYW1ldGVyKHRvTm9kZSwgdG9FbmRwb2ludCwgb3V0cHV0W2Zyb21FbmRwb2ludF0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9yZWN1cnNpdmUgZXhlY3V0aW9uIG9mIHRoZSBuZXh0IGNvbXBvc2FibGVzLCBhcyB0aGlzIG9uZSBqdXN0IGZpbmlzaGVkIGFuZCBwcm9iYWJseSByZXNvbHZlZCBzb21lIGRhdGEgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHNlbGYucGFyYW1ldGVycylcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLm1hbmFnZXIuYWRkUmVleGVjdXRpb25MaXN0ZW5lcihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLm5lZWRzUmVsb2FkaW5nVmlzdWFsaXphdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJhbWV0ZXJzID0gcmVzdWx0Lm1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLnBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEub3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubXF0dF9jbGllbnQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEuY2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKHJlc3VsdC5sYXN0UmV0dXJuZWREYXRhKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZm9yICh2YXIga2V5IGluIHNlbGYuY29tcG9zYWJsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBpZihzZWxmLmNvbXBvc2FibGVzW2tleV0ubmFtZSA9PSByZXN1bHQubmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIHZhciBvdXRwdXQgPSAgc2VsZi5jb21wb3NhYmxlc1trZXldLmRhdGFPdXROYW1lc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzZWxmLmNvbXBvc2FibGVzW2tleV0uZGF0YUluTmFtZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNlbGYucGFyYW1ldGVyc1trZXldW3NlbGYuY29tcG9zYWJsZXNba2V5XS5kYXRhSW5OYW1lc1tpXV0gPSByZXN1bHQubGFzdFJldHVybmVkRGF0YVtvdXRwdXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudW5sY2VhcmVkQ29tcG9zYWJsZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS51bmNsZWFyZWRDb21wb3NhYmxlc0Nsb25lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24uYXBwbHkoc2VsZiwgW3NlbGYuY29udGV4dF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNvbXB1dGluZyBkZW1vIHJlc3VsdCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5tcXR0X21vZHVsZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZVF1ZXVlRXhlY3V0aW9uLmFwcGx5KHNlbGYsIFtjb250ZXh0XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vbWFyayBjb21wb3NhYmxlIGFzIGNsZWFyZWRcclxuICAgICAgICBpZiAoIXRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY2xlYXJlZCkge1xyXG5cclxuICAgICAgICAgICAgLy9SZXRyaWV2ZSBEYXRhIG5lZWRlZCBmb3IgdGhlIEFTWU5DIGNhbGxzIG9mIHRoZSBNUVRUIG5vZGVzXHJcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIGN1cnJlbnQgbm9kZSBhYm91dCB0byBiZSBjbGVhcmVkIGlzIGFuIE1RVFQgbm9kZVxyXG4gICAgICAgICAgdmFyIG1xdHRfc3dldmFfcGFyYW1ldGVycyA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbXBvc2FibGVzW3RoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY29tcG9zYWJsZV0uc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgc2VsZi5tcXR0X21vZHVsZV9uYW1lID0gdGhpcy5jb21wb3NhYmxlc1t0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNvbXBvc2FibGVdLm5hbWU7XHJcbiAgICAgICAgICAgIG1xdHRfc3dldmFfcGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgICBtb2R1bGVfbmFtZTogdGhpcy5jb21wb3NhYmxlc1t0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNvbXBvc2FibGVdLm5hbWUsXHJcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGlzLnBhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxyXG4gICAgICAgICAgICAgICAgdW5jbGVhcmVkQ29tcG9zYWJsZXNDbG9uZTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzKSksXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzOiB0aGlzLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLm1xdHRfY2xpZW50XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5tcXR0X21vZHVsZV9uYW1lID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jbGVhcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9leGVjdXRlIGNvbXBvc2FibGVcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlTmFtZV0uZXhlY3V0ZShkYXRhLCBpbnB1dCwgY29udGV4dCwgY29tcG9zYWJsZU5hbWUsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgdGhpcy5wcm9ncmVzcylcclxuICAgICAgICAgICAgICAgIC50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vYSA9PiBjb25zb2xlLmxvZyhhKSlcclxuICAgICAgICAgICAgICAgICAgICBmdW5jKGNvbXBvc2FibGVOYW1lKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2Vycm9yIGlzIGxvZ2dlZCBlYXJsaWVyLCBidXQgaG93IHRvIGhhbmRsZT9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICBcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgY29tcG9zYWJsZSwgaW5pdGlhbGl6ZXMgcmVxdWlyZWQgZGF0YS4gVXNlIHRoaXMgZnVuY3Rpb24gaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBhIGNvbXBvc2FibGUhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgcmVsZXZhbnQgdG8gdGhlIHByb2Nlc3NpbmcuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGluZm9ybWF0aW9uIG9uIGhvdyB0byBwcm9jZXNzIHRoZSBkYXRhLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIEV4ZWN1dGlvbiBjb250ZXh0LiBTZWUge0BsaW5rIENvbXBvc2FibGUjY29udGV4dH0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWxpYXNdIC0gTmFtZSwgdW5kZXIgd2hpY2ggdGhlIGNvbXBvc2FibGUgaXMga25vd24gdG8gaXRzIHBhcmVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2dyZXNzXSAtIENhbGxiYWNrIGZvciBwcm9ncmVzcyB0cmFja2luZywgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZHVsZSBmaW5pc2hlcyBleGVjdXRpb24uXHJcbiAqL1xyXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dCwgY29udGV4dCwgYWxpYXMsIHByb2dyZXNzKSB7XHJcbiAgICBcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICBjb250ZXh0ID0gdGhpcy5nZXROZXdDb250ZXh0KGNvbnRleHQsIGFsaWFzKTtcclxuICAgIHRoaXMucmVzZXQoKTtcclxuICAgIFxyXG4gICAgdGhpcy5wcm9ncmVzcyA9IHByb2dyZXNzO1xyXG4gICAgXHJcbiAgICAvL3JldHVybiBhIHByb21pc2UsIHNpbmNlIGV4ZWN1dGlvbiBpcyBhc3luY1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAvL2RvIG5vdCBib3RoZXIgZXhlY3V0aW5nLCBpZiBsaW5rIGdyYXBoIGRlZmluaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHByb3ZpZGVkIGRhdGEgb3IgaW5wdXQgb2JqZWN0IGRvIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2NoZW1hIGRlZmluaXRpb25zXHJcbiAgICAgICAgaWYgKCFzZWxmLmludmFsaWRMaW5rR3JhcGggJiYgc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhSW4nLCBkYXRhKSAmJiBzZWxmLnZhbGlkYXRlVHlwZXMoJ2lucHV0JywgaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIC8vZWFjaCBzdGFydGluZyBjb21wb3NhYmxlIGhhcyBhbiBvd24gZGF0YSBwYXJ0XHJcbiAgICAgICAgICAgIC8vdXNlIHVzZXItZGVmaW5hYmxlIHtAbGluayBDb21wb3NpdGlvbn5tYXBEYXRhSW5GdW5jdGlvbn0gdG8gbWFwIHRoZSBkYXRhIHRvIHRoZSBzdGFydGluZyBjb21wb3NhYmxlc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvc2FibGVOYW1lID0gc2VsZi5zdGFydGluZ0NvbXBvc2FibGVzW2ldOyAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXSA9IHNlbGYubWFwRGF0YUluKHNlbGYuZGF0YSwgY29tcG9zYWJsZU5hbWUsIHNlbGYuY29tcG9zYWJsZXMsIHN3ZXZhLmxpYnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2RlZmluZSBjYWxsYmFjayBmb3Igd2hlbiBleGVjdXRpb24gaXMgZmluaXNoZWRcclxuICAgICAgICAgICAgc2VsZi5leGVjdXRlRmluaXNoZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5ldyBFeGVjdXRpb25FcnJvcignU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQ6ICcgKyBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LCBlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBubyBlcnJvclxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91c2UgdXNlci1kZWZpbmFibGUge0BsaW5rIENvbXBvc2l0aW9ufm1hcERhdGFPdXRGdW5jdGlvbn0gdG8gY3JlYXRlIHRoZSBmaW5hbCBvdXRwdXQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYubWFwRGF0YU91dChzZWxmLm91dHB1dCwgc3dldmEubGlicyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy92YWxpZGF0ZSBvdXRwdXQgdXNpbmcgcHJvdmlkZWQgc2NoZW1hXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YU91dCcsIHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZi5uZWVkc1JlbG9hZGluZ1Zpc3VhbGl6YXRpb24gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWFuYWdlci5zZW5kRGF0YVRvVmlzdWFsaXphdGlvbihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2FsbCBjb21wb3NhYmxlcyBhcmUgbG9hZGVkLCBzbyBleGVjdXRpb24gY2FuIHN0YXJ0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmlzUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZVF1ZXVlRXhlY3V0aW9uLmFwcGx5KHNlbGYsIFtjb250ZXh0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vZGVsYXkgZXhlY3V0aW9uIHRvIHtAbGluayBDb21wb3NpdGlvbiNsb2FkQ29tcG9zYWJsZXN9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy93ZSB3YW50IHRvIGV4ZWN1dGUsIGJ1dCBjYW5ub3Q6IHRlbGwgc28gdGhlIGluaXRpYWxpemF0aW9uL2xvYWRpbmcgcGFydFxyXG4gICAgICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvL2V4ZWN1dGUgdmlhIGNhbGxiYWNrLCBhcyBzb29uIGFzIGxvYWRpbmcgZmluaXNoZWRcclxuICAgICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZVN0YXJ0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24uYXBwbHkoc2VsZiwgW2NvbnRleHRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRpb247IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENvbXBvc2FibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMnKTtcclxuLy92YXIgQ29tcG9zaXRpb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2l0aW9uLmpzJyk7XHJcbnZhciBEZWZpbml0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9kZWZpbml0aW9uRXJyb3IuanMnKTtcclxudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBIVFRQIHJlcXVlc3QgYXMgYSBwcm9taXNlLiBJdCBpcyB1c2VkIHRvIGNhbGwgYSByZW1vdGUgc2VydmljZSB1c2luZyBpdHMgQVBJLlxyXG4gKlxyXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXHJcbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcclxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXHJcbiAqIGFjdHMgYXMgW10uXHJcbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEBjYWxsYmFjayBNb2R1bGV+cmVxdWVzdEZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cclxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBbiBvYmplY3QgYWxsb3dpbmcgYWNjZXNzIHRvIGxpYnJhcmllcyBpbnNpZGUgdGhlIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBoYW5kbGUgZXJyb3JzIGZyb20gZmFpbGVkIHNlcnZpY2UgY2FsbHMuXHJcbiAqXHJcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cclxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxyXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcclxuICogYWN0cyBhcyBbXS5cclxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogQGNhbGxiYWNrIE1vZHVsZX5yZXF1ZXN0RXJyb3JGdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gdGhlIHNlcnZpY2UgY2FsbC5cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEFuIG9iamVjdCBhbGxvd2luZyBhY2Nlc3MgdG8gbGlicmFyaWVzIGluc2lkZSB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHJlc3BvbnNlIG9mIHRoZSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXHJcbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcclxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXHJcbiAqIGFjdHMgYXMgW10uXHJcbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEBjYWxsYmFjayBNb2R1bGV+cmVxdWVzdEVycm9yRnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIHRoZSBzZXJ2aWNlIGNhbGwuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cclxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBbiBvYmplY3QgYWxsb3dpbmcgYWNjZXNzIHRvIGxpYnJhcmllcyBpbnNpZGUgdGhlIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBkbyBhbGwgY29tcHV0YXRpb24gbG9jYWxseSwgbm8gc2VydmljZSBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cclxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxyXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcclxuICogYWN0cyBhcyBbXS5cclxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogQGNhbGxiYWNrIE1vZHVsZX5jb21wdXRlRnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEFuIG9iamVjdCBhbGxvd2luZyBhY2Nlc3MgdG8gbGlicmFyaWVzIGluc2lkZSB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgaW5pdGFsaXphdGlvbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgbW9kdWxlcy5cclxuICogQHR5cGVkZWYge2NvbXBvc2FibGVJbml0YWxpemVyfSBtb2R1bGVJbml0YWxpemVyXHJcbiAqIEBwcm9wZXJ0eSB7TW9kdWxlfnJlcXVlc3RGdW5jdGlvbn0gW3JlcXVlc3RdIC0gQ3JlYXRlcyBhIEhUVFAgcmVxdWVzdCB0byBjYWxsIHRoZSBhcHByb3ByaWF0ZSBzZXJ2aWNlLlxyXG4gKiBAcHJvcGVydHkge01vZHVsZX5yZXF1ZXN0RXJyb3JGdW5jdGlvbn0gW3JlcXVlc3RdIC0gSWYgdGhpcyBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaXQgaXMgdXNlZCB0byBoYW5kbGUgZXJyb3JzLCBpZiB0aGUgc2VydmljZSBjYWxsIHdhcyB1bnN1Y2Nlc3NmdWwuXHJcbiAqIEBwcm9wZXJ0eSB7TW9kdWxlfnJlc3BvbnNlRnVuY3Rpb259IFtyZXF1ZXN0XSAtIEZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgdGhlIHNlcnZpY2UgcmVzcG9uc2UgdG8gYmUgdXNlZCBsYXRlciBvbi5cclxuICogQHByb3BlcnR5IHtNb2R1bGV+Y29tcHV0ZUZ1bmN0aW9ufSBbcmVxdWVzdF0gLSBJZiBwcm92aWRlZCwgbm8gc2VydmljZSBpcyBjYWxsZWQsIGJ1dCBhbGwgY29tcHV0YXRpb24gaXMgcGVyZm9ybWVkIGxvY2FsbHkgaW4gdGhpcyBmdW5jdGlvbi5cclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogQSBtb2R1bGUgaXMgdGhlIHNtYWxsZXN0IHVuaXQgb2YgZXhlY3V0aW9uLlxyXG4gKiBJdCBzZXJ2ZXMgYXMgYW4gZW52ZWxvcGUgdG8gYSBzZXJ2aWNlIGNhbGwgYW5kIGNhbiBvcHRpb25hbGx5IGRvIGFsbCBjb21wdXRhdGlvbnMgbG9jYWxseSB3aWh0b3V0IGEgcmVtb3RlIHNlcnZpY2UuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBDb21wb3NhYmxlXHJcbiAqIEBwYXJhbSB7bW9kdWxlSW5pdGFsaXplcn0gaW5pdGlhbGl6YXRpb25PYmplY3QgLSBUaGUgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGNvbXBvc2l0aW9uLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gTW9kdWxlKGluaXRpYWxpemF0aW9uT2JqZWN0LCBtYW5hZ2VyKSB7XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbGl6ZShpbml0aWFsaXphdGlvbk9iamVjdCk7XHJcblxyXG4gICAgLy8gZ2VuZXJhbCBub2RlIHR5cGVcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3J1bicsIDMsIG51bGwpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdsYW5ndWFnZScsICd0eXBlc2NyaXB0Jyk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdzb3VyY2UnLCBudWxsKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnYmluYXJ5JywgbnVsbCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2JpbmFyeUhhc2gnLCBudWxsKTtcclxuXHJcbiAgICAvKnRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAncmVxdWVzdEVycm9yJywgMywgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdyZXNwb25zZScsIDMsXHJcbiAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSwgaW5wdXQsIGxpYnMpIHtcclxuICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgb2JqW3RoaXMuZGF0YU91dE5hbWVzWzBdXSA9IHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSk7Ki9cclxuXHJcbiAgICAvLyBub3cgdGhlIGFzeW5jaHJvbm91cyBub2RlIHR5cGVcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3N1YnNjcmliZScsIDMsIG51bGwpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdvbkNvbm5lY3QnLCAzLCBudWxsKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnb25TdWJzY3JpcHRpb24nLCAzLCBudWxsKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnb25NZXNzYWdlUmVjZWl2ZWQnLCA0LCBudWxsKTtcclxufVxyXG5cclxuLy9pbmhlcml0IHByb3BlcnRpZXNcclxuTW9kdWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9zYWJsZS5wcm90b3R5cGUpO1xyXG5Nb2R1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlO1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5sYXN0UmV0dXJuZWREYXRhID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDYWxscyB0aGUgc2VydmljZSB1c2luZyB0aGUgY3JlYXRlZCBIVFRQIHJlcXVlc3QgcmVjZWl2ZWQgZnJvbSB7QGxpbmsgTW9kdWxlfnJlcXVlc3RGdW5jdGlvbn0uXHJcbiAqXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHBhcmFtIHtQcm9taXNlfSByZXF1ZXN0IC0gVGhlIGFzeW5jIHNlcnZpY2UgY2FsbC5cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGRhdGEgaW5wdXQgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB3aXRoIHRoZSByZXNwb25zZSBvYmplY3QuXHJcbiAqL1xyXG5Nb2R1bGUucHJvdG90eXBlLmNhbGxTZXJ2aWNlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGlucHV0KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICByZXF1ZXN0XHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlc3BvbnNlKHJlc3BvbnNlLCBpbnB1dCwgc3dldmEubGlicykpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgYSBmdW5jdGlvbiB0byBkZWFsIHdpdGggZXJyb3JzIGZyb20gc2VydmljZSBkaXJlY3RseS4uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlcXVlc3RFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5yZXF1ZXN0RXJyb3IocmVzcG9uc2UsIGlucHV0LCBzd2V2YS5saWJzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBvbmUgc3Vic2NyaWJlcyB0byBhIHRvcGljIG9uIGEgbWVzc2FnZSBxdWV1ZS5cclxuICpcclxuICogQHBhcmFtIHN1YnNjcmliZVxyXG4gKiBAcGFyYW0gaW5wdXRcclxuICovXHJcbk1vZHVsZS5wcm90b3R5cGUuY2FsbFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGRhdGEsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgaW5wdXQpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGlmIChzdWJzY3JpYmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGllbnQgPSBzdWJzY3JpYmU7XHJcbiAgICAgICAgICAgIG1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLmNsaWVudCA9IGNsaWVudDtcclxuICAgICAgICAgICAgY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vbkNvbm5lY3QoY2xpZW50LCBpbnB1dCwgc3dldmEubGlicyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5sYXN0UmV0dXJuZWREYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RSZXR1cm5lZERhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsaWVudC5vbignbWVzc2FnZScsIGZ1bmN0aW9uICh0b3BpYywgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1xdHRfc3dldmFfcGFyYW1ldGVycyAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubXF0dF9zd2V2YV9wYXJhbWV0ZXJzID0gbXF0dF9zd2V2YV9wYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmV0dXJuZWREYXRhID0gc2VsZi5vbk1lc3NhZ2VSZWNlaXZlZChzZWxmLmxhc3RSZXR1cm5lZERhdGEsIHRvcGljLCBtZXNzYWdlLCBzd2V2YS5saWJzKTtcclxuICAgICAgICAgICAgICAgIC8vIG5vdyBub3RpZnkgdGhlIGV4ZWN1dGlvbiBtYW5hZ2VyXHJcbiAgICAgICAgICAgICAgICBzZWxmLm1hbmFnZXIub25Nb2R1bGVVcGRhdGUoc2VsZik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHJlc29sdmUoc2VsZi5vblN1YnNjcmlwdGlvbihkYXRhLCBpbnB1dCwgc3dldmEubGlicykpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGVycm9ycyBmcm9tIHNlcnZpY2UgZGlyZWN0bHkuLi5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlcXVlc3RFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlcXVlc3RFcnJvcihyZXNwb25zZSwgaW5wdXQsIHN3ZXZhLmxpYnMpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBtb2R1bGUsIGkuZS4gcGVyZm9ybXMgdGhlIGNvbXB1dGF0aW9uIGVpdGhlciBieSBjYWxsaW5nIGEgc2VydmljZSBvciBsb2NhbGx5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHJlbGV2YW50IHRvIHRoZSBwcm9jZXNzaW5nLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gcHJvY2VzcyB0aGUgZGF0YS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBFeGVjdXRpb24gY29udGV4dC4gU2VlIHtAbGluayBDb21wb3NhYmxlI2NvbnRleHR9LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FsaWFzXSAtIE5hbWUsIHVuZGVyIHdoaWNoIHRoZSBjb21wb3NhYmxlIGlzIGtub3duIHRvIGl0cyBwYXJlbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9ncmVzc10gLSBDYWxsYmFjayBmb3IgcHJvZ3Jlc3MgdHJhY2tpbmcsIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2R1bGUgZmluaXNoZXMgZXhlY3V0aW9uLlxyXG4gKi9cclxuTW9kdWxlLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0LCBjb250ZXh0LCBhbGlhcywgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzLCBwcm9ncmVzcykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc29sZS5sb2coXCJjb250ZXh0ID09PVwiKTtcclxuICAgIGNvbnNvbGUubG9nKGNvbnRleHQpO1xyXG4gICAgY29uc29sZS5sb2coXCJNb2R1bGUgdG8gYmUgZXhlY3V0ZWQgPVwiKTtcclxuICAgIGNvbnNvbGUubG9nKHNlbGYpO1xyXG4gICAgY29udGV4dCA9IHRoaXMuZ2V0TmV3Q29udGV4dChjb250ZXh0LCBhbGlhcyk7XHJcblxyXG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcclxuICAgICAgICBpbnB1dCA9IHt9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQcm9taXNlIHRvIGFib3J0IGlmIG9mZmxvYWRpbmcgaXMgbmVjZXNzYXJ5XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vYmVnaW4gcHJvbWlzZVxyXG4gICAgICAgIC8vb25seSBleGVjdXRlLCBpZiBkYXRhIGFuZCBpbnB1dCBvYmplY3RzIGFyZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbmFsIHNjaGFtYXNcclxuICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhSW4nLCBkYXRhKSAmJiBzZWxmLnZhbGlkYXRlVHlwZXMoJ2lucHV0JywgaW5wdXQpKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklucHV0IGRhdGEgZm9yIFwiICsgYWxpYXMgKyBcIjogXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLnNvdXJjZSAhPSBudWxsKSB7IC8vVE9ETzogdHlwZW9mIHNlbGYucnVuID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgYSBjb21wdXRhdGlvbiBmdW5jdGlvbiBpcyBkZWZpbmVkLCB0aGVuIHNraXAgc2VydmljZSBjYWxscyBhbmQgY29tcHV0ZSBsb2NhbGx5XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVYRUNVVEUgXCIgKyBzZWxmLm5hbWUgKyBcIltcIiArIGFsaWFzICsgXCJdIFVTSU5HOiBcIiArIHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0uZXhlYyhzZWxmLCBkYXRhLCBpbnB1dCwge3NpZ25hbH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09IE9GRkxPQURJTkcgPT09IE1PRFVMRSBFWEVDVVRJT04gQkVHSU5TIEhFUkVcclxuICAgICAgICAgICAgICAgIHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0uZXhlYyhzZWxmLCBkYXRhLCBpbnB1dCkudGhlbigocmVzdWx0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzdWx0IGRhdGEgZm9yIFwiICsgYWxpYXMgKyBcIjogXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09J29mZmxvYWRpbmcnKXtcclxuICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2ZmbG9hZGluZycpIC8vdG9kbzogcmVzb2x2ZSBvciByZWplY3QgaGVyZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogTUFQIGNvcnJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHJlc3VsdCA9IHNlbGYucnVuKGRhdGEsIGlucHV0LCBzd2V2YS5saWJzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhT3V0JywgcmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlcG9ydCBwcm9ncmVzcywgaWYgY2FsbGJhY2sgaXMgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MoYWxpYXMsIHNlbGYubmFtZSwgY29udGV4dCxyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgbW9kdWxlIGV4ZWN1dGlvbiBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZsb2FkaW5nIGNhbGxiYWNrIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBzdWJzY3JpYmluZyB0byBhbiBhc3luY2hyb25vdXMgbWVzc2FnZSBxdWV1ZVxyXG4gICAgICAgICAgICB2YXIgY2xpZW50O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLmNsaWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudCA9IHNlbGYuc3Vic2NyaWJlKGRhdGEsIGlucHV0LCBzd2V2YS5saWJzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuY2FsbFN1YnNjcmlwdGlvbihjbGllbnQsIGRhdGEsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgaW5wdXQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgLy92YWxpZGF0ZSBvdXRwdXRcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnZhbGlkYXRlVHlwZXMoJ2RhdGFPdXQnLCBvdXRwdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXBvcnQgcHJvZ3Jlc3MsIGlmIGNhbGxiYWNrIGlzIGRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MoYWxpYXMsIHNlbGYubmFtZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhc3RSZXR1cm5lZERhdGEgPSBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LCBlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYucmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFuIEhUVFAgcmVxdWVzdCBub2RlLCBjYWxsIHNlcnZpY2UgdXNpbmcgYW4gSFRUUCByZXF1ZXN0XHJcblxyXG4gICAgICAgICAgICBzZWxmLmNhbGxTZXJ2aWNlKHNlbGYucmVxdWVzdChkYXRhLCBpbnB1dCwgc3dldmEubGlicyksIGlucHV0KS50aGVuKGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvdXRwdXQgaXMgYWxyZWFkeSB0aGUgSFRUUCByZXNwb25zZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFsaWRhdGUgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhT3V0Jywgb3V0cHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVwb3J0IHByb2dyZXNzLCBpZiBjYWxsYmFjayBpcyBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKGFsaWFzLCBzZWxmLm5hbWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LCBlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlOyIsIi8vZ2xvYmFsIG9iamVjdCBpbml0aWFsaXphdGlvblxyXG52YXIgZ2xvYmFsT2JqZWN0O1xyXG5cclxudmFyIGluQnJvd3NlciA9IGZhbHNlO1xyXG5cclxudHJ5IHtcclxuICAgIGlmICh3aW5kb3cpIHtcclxuICAgICAgICBnbG9iYWxPYmplY3QgPSB3aW5kb3c7XHJcbiAgICAgICAgaW5Ccm93c2VyID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5jYXRjaCAoZSkge1xyXG4gICAgZ2xvYmFsT2JqZWN0ID0gZ2xvYmFsO1xyXG59XHJcblxyXG4vL3ByZXZlbnQgbG9hZGluZyBldmVyeXRoaW5nIHR3aWNlIG9uIGVkaXRvci1wYWdlXHJcbmlmKCFnbG9iYWxPYmplY3Quc3dldmEpIHtcclxuICAgIGdsb2JhbE9iamVjdC5zd2V2YSA9IHt9O1xyXG5cclxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5pbkJyb3dzZXIgPSBpbkJyb3dzZXI7XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLmFzeW5jbXF0dCA9IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9hc3luYy1tcXR0Jyk7XHJcblxyXG4gICAgdmFyIEFqdiA9IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qcycpO1xyXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLkFqdiA9IG5ldyBBanYoKTtcclxuXHJcbiAgICB2YXIgQ29tcG9zYWJsZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL2V4ZWN1dGlvbi9jb21wb3NhYmxlTG9hZGVyLmpzJyk7XHJcbiAgICBnbG9iYWxPYmplY3Quc3dldmEuQ29tcG9zYWJsZUxvYWRlciA9IG5ldyBDb21wb3NhYmxlTG9hZGVyKCcnKTtcclxuXHJcbiAgICBnbG9iYWxPYmplY3Quc3dldmEuRXhlY3V0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL2V4ZWN1dGlvbi9leGVjdXRpb25NYW5hZ2VyLmpzJyk7XHJcblxyXG4gICAgdmFyIEVycm9yTWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL2Vycm9ycy9lcnJvck1hbmFnZXIuanMnKTtcclxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5FcnJvck1hbmFnZXIgPSBuZXcgRXJyb3JNYW5hZ2VyKCk7XHJcblxyXG4gICAgdmFyIFN3ZXZhU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vYXBwL2NvcmUvc3dldmFTY3JpcHQvc3dldmFTY3JpcHQuanMnKTtcclxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdCA9IG5ldyBTd2V2YVNjcmlwdCgpO1xyXG5cclxuICAgIHZhciBBc3NlbWJseVNjcmlwdFJ1bm5lciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL3J1bm5lcnMvYXNzZW1ibHlTY3JpcHRSdW5uZXIuanMnKTtcclxuXHJcbiAgICAvKlxyXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLmF4aW9zID0gcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2Rpc3QvYXhpb3MubWluLmpzJyk7XHJcbiAgICBnbG9iYWxPYmplY3Quc3dldmEubGlicyA9IHtcclxuICAgICAgICBheGlvczogZ2xvYmFsT2JqZWN0LnN3ZXZhLmF4aW9zLFxyXG4gICAgICAgIG1xdHQ6IGdsb2JhbE9iamVjdC5zd2V2YS5hc3luY21xdHQsXHJcbiAgICAgICAgZ2V0OiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuZ2V0LFxyXG4gICAgICAgIHNldDogZ2xvYmFsT2JqZWN0LnN3ZXZhLlN3ZXZhU2NyaXB0LnNldCxcclxuICAgICAgICAvL21xdHRjbGllbnQ6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5jbGllbnQsXHJcbiAgICAgICAgLy9tcXR0c3Vic2NyaWJlOiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuc3Vic2NyaWJlLFxyXG4gICAgICAgIGFkZGRhdGE6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5hZGRkYXRhXHJcbiAgICB9Ki9cclxuXHJcbiAgICBnbG9iYWxPYmplY3Quc3dldmEucnVubmVycyA9IHt9O1xyXG5cclxuICAgIHZhciB0eXBlc2NyaXB0ID0gbmV3IEFzc2VtYmx5U2NyaXB0UnVubmVyKCk7XHJcbiAgICBnbG9iYWxPYmplY3Quc3dldmEucnVubmVyc1t0eXBlc2NyaXB0LmlkXSA9IHR5cGVzY3JpcHQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT2JqZWN0LnN3ZXZhOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTd2V2YUVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcycpO1xyXG4vKipcclxuICogQW4gZXhlY3V0aW9uIGVycm9yIHNob3VsZCBiZSB1c2VkLCBpZiB0aGUgZXJyb3Igb2NjdXJlZCBkdXJpbmcgZXhlY3V0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgU3dldmFFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gRXhlY3V0aW9uRXJyb3IobWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KSB7XHJcbiAgICBTd2V2YUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KTtcclxuICAgIHRoaXMubmFtZSA9ICdFeGVjdXRpb25FcnJvcic7XHJcbn1cclxuRXhlY3V0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTd2V2YUVycm9yLnByb3RvdHlwZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVycm9yIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xyXG4vKipcclxuICogQSBjb21waWxlIGVycm9yIHNob3VsZCBiZSB1c2VkLCBpZiAgdGhlIGVycm9yIHdhcyB0aHJvd24gYnkgdGhlIGNvbXBpbGVyLCBiZWZvcmUgYWN0dWFsIGV4ZWN1dGlvbiBhbmQgdmFsaWRhdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIERlZmluaXRpb25FcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gQ29tcGlsZUVycm9yKG1lc3NhZ2UsIGNvbnRleHQsIGZhdWx0eU9iamVjdCkge1xyXG4gICAgRGVmaW5pdGlvbkVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KTtcclxuICAgIHRoaXMubmFtZSA9ICdDb21waWxlRXJyb3InO1xyXG59XHJcbkNvbXBpbGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlZmluaXRpb25FcnJvci5wcm90b3R5cGUpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlRXJyb3I7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN3ZXZhRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9zd2V2YUVycm9yLmpzJyk7XHJcbi8qKlxyXG4gKiBBIGRlZmluaXRpb24gZXJyb3Igc2hvdWxkIGJlIHVzZWQsIGlmICB0aGUgZXJyb3Igb2NjdXJlZCBiZWNhdXNlIG9mIGluY29tcGF0aWJsZSBkZWZpbml0aW9ucyBvZiBjb21wb3NhYmxlcywgaS5lLiBiZWZvcmUgYWN0dWFsIGV4ZWN1dGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFN3ZXZhRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIERlZmluaXRpb25FcnJvcihtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpIHtcclxuICAgIFN3ZXZhRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpO1xyXG4gICAgdGhpcy5uYW1lID0gJ0RlZmluaXRpb25FcnJvcic7XHJcbn1cclxuRGVmaW5pdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3dldmFFcnJvci5wcm90b3R5cGUpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWZpbml0aW9uRXJyb3I7IiwiJ3VzZSBzdHJpY3QnO1xyXG4vKipcclxuICogQWdncmVnYXRlcyB7QGxpbmsgU3dldmFFcnJvcn0gbWVzc2FnZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXJyb3JNYW5hZ2VyKCkge1xyXG4gICAgLyoqXHJcbiAgICAqIEFuIGFycmF5IHN0b3JpbmcgdGhlIGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgKiBAbmFtZSBFcnJvck1hbmFnZXIjcXVldWVcclxuICAgICogQHR5cGUge0FycmF5LjxFcnJvcj59XHJcbiAgICAqL1xyXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG59XHJcbi8qKlxyXG4gKiBSZXNldHMgdGhlIEVycm9yTWFuYWdlci5cclxuICovXHJcbkVycm9yTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnF1ZXVlID0gW107XHJcbn1cclxuLyoqXHJcbiAqIEFwcGVuZHMgZXJyb3JzIHRvIHRoZSBpbnRlcm5hbCBxdWV1ZSwgbG9ncyB0aGVtIGFuZCByZXR1cm5zIHRoZSBlcnJvciBvYmplY3RcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB7RXJyb3J9IC0gVGhlIGVycm9yIG9iamVjdC5cclxuICovXHJcbkVycm9yTWFuYWdlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgIHRoaXMucXVldWUucHVzaChlcnJvcik7XHJcbiAgICBjb25zb2xlLmxvZyhlcnJvci50b1N0cmluZygpKTtcclxuICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG4vKipcclxuICogR2V0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgc3RvcmVkIGVycm9ycy5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBBbGwgc3RvcmVkIGVycm9ycyBzZXBhcmF0ZWQgYnkgYSBsaW5lYnJlYWsuXHJcbiAqL1xyXG5FcnJvck1hbmFnZXIucHJvdG90eXBlLmdldExvZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdCArPSB0aGlzLnF1ZXVlW2ldLnRvU3RyaW5nKCkgKyAnXFxuJztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtFcnJvcn0gLSBUaGUgbGFzdCBlcnJvciB0aGF0IHdhcyByZWNvcmRlZC5cclxuICovXHJcbkVycm9yTWFuYWdlci5wcm90b3R5cGUuZ2V0TGFzdEVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlW3RoaXMucXVldWUubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcnJvck1hbmFnZXI7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEFuIGVycm9yIG9iamVjdCB3aXRoIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEVycm9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2U6IFdoYXQgd2VudCB3cm9uZz9cclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBUaGUgZXhlY3V0aW9uIGNvbnRleHQsIGluIHdoYXQgY29tcG9zYWJsZSBkaWQgdGhlIGVycm9yIG9jY3VyP1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhdWx0eU9iamVjdF0gLSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvciBjYXVzZS5cclxuICovXHJcbmZ1bmN0aW9uIFN3ZXZhRXJyb3IobWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KSB7XHJcbiAgICAvKipcclxuICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yIG9iamVjdC5cclxuICAgICogQG5hbWUgU3dldmFFcnJvciNuYW1lXHJcbiAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gJ1N3ZXZhRXJyb3InO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgZXJyb3IgbWVzc2FnZS5cclxuICAgICogQG5hbWUgU3dldmFFcnJvciNtZXNzYWdlXHJcbiAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnRGVmYXVsdCBNZXNzYWdlJztcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGNhbGxzdGFjayBvZiB0aGUgZXJyb3IuXHJcbiAgICAqIEBuYW1lIFN3ZXZhRXJyb3Ijc3RhY2tcclxuICAgICogQHR5cGUge09iamVjdH1cclxuICAgICovXHJcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGV4ZWN1dGlvbiBjb250ZXh0IG9mIHRoZSBlcnJvciAoaW4gd2hpY2ggY29tcG9zYWJsZSBpdCBvY2N1cmVkKS5cclxuICAgICogQG5hbWUgU3dldmFFcnJvciNjb250ZXh0XHJcbiAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHJcbiAgIFxyXG4gICAgaWYgKGZhdWx0eU9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvL3NoYWxsb3cgY29weTogc2hvdWxkIHByb3ZpZGUgZW5vdWdoIGluZm9ybWF0aW9uIGFuZCBzYXZlIFJBTVxyXG4gICAgICAgIC8vY29weSBpcyBuZWVkZWQsIGFzIHdlIG5lZWQgdGhlIG9iamVjdCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZSBlcnJvciBvY2N1cnJlZFxyXG4gICAgICAgIHRoaXMuZmF1bHR5T2JqZWN0ID0gZmF1bHR5T2JqZWN0O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZhdWx0eU9iamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvL21ha2UgZnVuY3Rpb25zIHRvIHN0cmluZ3MgICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5mYXVsdHlPYmplY3QgPSBmYXVsdHlPYmplY3QudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhdWx0eU9iamVjdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGZhdWx0eU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZhdWx0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYXVsdHlPYmplY3Rba2V5XSA9IGZhdWx0eU9iamVjdFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5mYXVsdHlPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGVycm9yLlxyXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI3RpbWVcclxuICAgICogQHR5cGUge251bWJlcn1cclxuICAgICovXHJcbiAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBcIitjb250ZXh0K1wiIGNyZWF0ZWQhIFN0YWNrdHJhY2U6XCIpO1xyXG4gICAgY29uc29sZS50cmFjZSgpO1xyXG59XHJcbi8vaW5oZXJpdCBwcm9wZXJ0aWVzXHJcblN3ZXZhRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcclxuICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgdmFsdWU6IHRoaXMuY29uc3RydWN0b3IsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9XHJcbn0pO1xyXG4vKipcclxuICogQHJldHVybnMge3N0cmluZ30gLSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgdGltZXN0YW1wLlxyXG4gKi9cclxuU3dldmFFcnJvci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWUpLnRvTG9jYWxlVGltZVN0cmluZygpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgZXJyb3Igb2JqZWN0IHRvIHN0cmluZyBpbmNsdWRpbmcgcmVsZXZhbnQgaW5mb3JtYXRpb24gKHRpbWVzdGFtcCwgbmFtZSwgY29udGV4dCwgbWVzc2FnZSwgYWRkaXRpb25hbCBpbmZvcm1hdGlvbikuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvci5cclxuICovXHJcblN3ZXZhRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGZhdWx0eU9iamVjdCA9ICcnO1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmZhdWx0eU9iamVjdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvL3RyYW5zZm9ybSBvYmplY3QgdG8gcHJldHR5IHByaW50ZWQgc3RyaW5nICh3aXRoIGlkZW50YXRpb24pLlxyXG4gICAgICAgIGZhdWx0eU9iamVjdCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZmF1bHR5T2JqZWN0LCBudWxsLCA0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhdWx0eU9iamVjdCA9IHRoaXMuZmF1bHR5T2JqZWN0LnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvL2NvbnN0cnVjdCBzdHJpbmdcclxuICAgIHJldHVybiAnWycgKyB0aGlzLmdldFRpbWUoKSArICddIFN3ZXZhRXJyb3IgJyArIHRoaXMubmFtZSArICcgaW4gJyArIHRoaXMuY29udGV4dCArICc6ICcgKyB0aGlzLm1lc3NhZ2UgKyAnXFxuJ1xyXG4gICAgICAgICsgZmF1bHR5T2JqZWN0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gU3dldmFFcnJvcjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9tb2R1bGUuanMnKTtcclxudmFyIENvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcycpO1xyXG52YXIgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvZGVmaW5pdGlvbkVycm9yLmpzJyk7XHJcblxyXG4vKipcclxuICogUmVzcG9uc2libGUgZm9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgY29tcG9zYWJsZXMgZnJvbSBhIHdlYiBhZGRyZXNzLlxyXG4gKiBMb2FkZWQgY29tcG9zYWJsZXMgYXJlIHN0b3JlZCBpbiBhbiBpbnRlcm5hbCBkaWN0aW9uYXJ5LCBzbyB0aGV5IG9ubHkgbmVlZCB0byBiZSBkb3dubG9hZGVkIG9uY2UuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VQYXRoPScnXSAtIFRoZSBiYXNlIGFkZHJlc3MgZnJvbSB3aGljaCB0byBkb3dubG9hZCB0aGUgY29tcG9zYWJsZS4gR2V0cyBwcmVwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXg9Lmpzb25dIC0gVGhlIHN1ZmZpeCB0aGF0IGdldHMgYXBwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIENvbXBvc2FibGVMb2FkZXIoYmFzZVBhdGgsIHN1ZmZpeCkge1xyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBiYXNlIGFkZHJlc3MgZnJvbSB3aGljaCB0byBkb3dubG9hZCB0aGUgY29tcG9zYWJsZS4gR2V0cyBwcmVwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cclxuICAgICogQG5hbWUgQ29tcG9zYWJsZUxvYWRlciNiYXNlUGF0aFxyXG4gICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgKi9cclxuICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aCB8fCAnJztcclxuICAgIC8qKlxyXG4gICAgKiBUaGUgc3VmZml4IHRoYXQgZ2V0cyBhcHBlbmRlZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lLlxyXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlTG9hZGVyI3N1ZmZpeFxyXG4gICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgKi9cclxuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4IHx8ICcnO1xyXG4gICAgLyoqXHJcbiAgICAqIERpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2FibGUgbmFtZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbXBvc2FibGUgb2JqZWN0cy5cclxuICAgICogQG5hbWUgQ29tcG9zYWJsZUxvYWRlciNjb21wb3NhYmxlc1xyXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENvbXBvc2FibGU+fVxyXG4gICAgKi9cclxuICAgIHRoaXMuY29tcG9zYWJsZXMgPSB7fTtcclxuICAgIC8qKlxyXG4gICAgKiBEaWN0aW9uYXJ5IG9mIGEgd2FpdGluZyBsaXN0LCB3aGVyZSBsb2FkZWQgY29tcG9zYWJsZXMgY2FuIGJlIGFzc2lnbmVkIHRvIGV4dGVybmFsIG9iamVjdHNcclxuICAgICogQG5hbWUgQ29tcG9zYWJsZUxvYWRlciN3YWl0aW5nTGlzdFxyXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XHJcbiAgICAqL1xyXG4gICAgdGhpcy53YWl0aW5nTGlzdCA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbnVtYmVyIG9mIHN0b3JlZCBjb21wb3NhYmxlcy5cclxuICovXHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb21wb3NhYmxlcykubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlIHRvIHJldHVybi5cclxuICogQHJldHVybnMge0NvbXBvc2FibGV9IC0gVGhlIGNvbXBvc2FibGUgb2JqZWN0LlxyXG4gKi9cclxuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXBvc2FibGVzW25hbWVdO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wb3NhYmxlIG9iamVjdHMgY2FuIGJlIGRpcmVjdGx5IGFkZGVkLCB3aXRob3V0IGhhdmluZyB0byBkb3dubG9hZCB0aGVtLlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGUuZy4gZm9yIHJhcGlkIHByb3RvdHlwaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlIHRvIGFkZC5cclxuICogQHBhcmFubSB7Q29tcG9zYWJsZX0gY29tcG9zYWJsZSAtIFRoZSBjb21wb3NhYmxlIHRvIGFkZC5cclxuICovXHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBjb21wb3NhYmxlKSB7XHJcbiAgICB0aGlzLmNvbXBvc2FibGVzW25hbWVdID0gY29tcG9zYWJsZTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9zYWJsZSBpbnRvIGEgZnVsbCBjb21wb3NhYmxlIG9iamVjdC5cclxuICogU2luY2UgY29tcG9zYWJsZXMgY2FuIGhhdmUgY3VzdG9tIGZ1bmN0aW9ucyBkZWZpbmVkLCBhbmQgSlNPTiBkb2VzIG5vdCBzdXBwb3J0IGZ1bmN0aW9ucywgd2UgY2Fubm90IHVzZSBKU09OLnBhcnNlLlxyXG4gKiBJbnN0ZWFkIGZ1bmN0aW9ucyBhcmUgZW5jb2RlZCBhcyBzdHJpbmcgYXJyYXlzIGluIEpTT04gYW5kIHRoZW4gYXNzZW1ibGVkLlxyXG4gKiB7QGxpbmsgU3dldmFTY3JpcHR9IGlzIHVzZWQgdG8gc2FuaXRpemUgdGhlIGZ1bmN0aW9ucy5cclxuICpcclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIG9iamVjdCBvZiB0aGUgY29tcG9zYWJsZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiBleGVjdXRpb24gKGZvciBlcnJvciBtZXNzYWdlcykuXHJcbiAqIEByZXR1cm5zIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gLSBDb21wb3NhYmxlIGluaXRhbGl6YXRpb24gb2JqZWN0LlxyXG4gKi9cclxuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuY29udmVydFRvT2JqZWN0ID0gZnVuY3Rpb24gKGpzb24sIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHQgPSBqc29uO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGpzb24pIHtcclxuICAgICAgICBpZiAoanNvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgLy9kZWNvZGUgYmFzZTY0IGVuY29kZWQgYmluYXJpZXNcclxuICAgICAgICAgICAgaWYoa2V5ID09PSAnYmluYXJ5JyAmJiAhKGpzb25ba2V5XSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvKmNvbnNvbGUubG9nKGpzb24pXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coanNvbltrZXldKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHR5cGVvZiBqc29uW2tleV0pKi9cclxuICAgICAgICAgICAgICAgIGxldCBiaW5hcnlMaXN0ID0gYXRvYihqc29uW2tleV0pO1xyXG4gICAgICAgICAgICAgICBqc29uW2tleV0gPSBuZXcgVWludDhBcnJheShiaW5hcnlMaXN0LnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgbWFwcGluZyBmdW5jdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3NvdXJjZScgJiYgKGpzb25ba2V5XSAhPT0gbnVsbCAmJiB0eXBlb2YganNvbltrZXldWzBdID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBTdHJpbmcoanNvbltrZXldWzBdKTtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgc3RyaW5nIGFycmF5IHN0YXJ0cyB3aXRoICdmdW5jdGlvbicgLT4gYXNzZW1ibGUgZnVuY3Rpb24gaW50byBvYmplY3RcclxuICAgICAgICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoJ2Z1bmN0aW9uJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHNhbml0aXplIHRoZSBzY3JpcHQgdG8gcHJldmVudCBtYWxpY2lvdXMgY29kZSBleGVjdXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAgICAganNvbltrZXldID0gc3dldmEuU3dldmFTY3JpcHQuc2FuaXRpemUoanNvbltrZXldLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdDb3VsZCBub3Qgc2FuaXRpemUgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIHdoZW4gbG9hZGluZyBcIicgKyBjb250ZXh0ICsgJ1wiOiAnICsgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHNlbGYuY29udmVydEpzb25Ub0NvZGUoanNvbikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qLy9UT0RPOiBjb25zaWRlciByZW1vdmluZyBtYXBwaW5nIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc291cmNlJyAmJiB0eXBlb2YganNvbltrZXldWzBdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhqc29uW2tleV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBzdHJpbmcgYXJyYXkgc3RhcnRzIHdpdGggJ2Z1bmN0aW9uJyAtPiBhc3NlbWJsZSBmdW5jdGlvbiBpbnRvIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignZnVuY3Rpb24nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2FuaXRpemUgdGhlIHNjcmlwdCB0byBwcmV2ZW50IG1hbGljaW91cyBjb2RlIGV4ZWN1dGlvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBqc29uW2tleV0gPSBzd2V2YS5Td2V2YVNjcmlwdC5zYW5pdGl6ZShqc29uW2tleV0uam9pbignXFxuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvdWxkIG5vdCBzYW5pdGl6ZSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgd2hlbiBsb2FkaW5nIFwiJyArIGNvbnRleHQgKyAnXCI6ICcgKyBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgc2VsZi5jb252ZXJ0SnNvblRvQ29kZShqc29uKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSovXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb25ba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGpzb25ba2V5XSA9IHRoaXMuY29udmVydFRvT2JqZWN0KGpzb25ba2V5XSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vL1RPRE86IHJlcGxhY2UgZGVmYXVsdCBtb2R1bGVzXHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmdldERlZmF1bHRNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJ7XFxuICAgIHR5cGU6IFxcJ21vZHVsZVxcJyxcXG4gICAgbmFtZTogXFwnbW9kdWxlMVxcJyxcXG4gICAgZGVzY3JpcHRpb246IFxcJ0Egc2ltcGxlIG1vZHVsZSB0ZW1wbGF0ZS5cXCcsXFxuICAgIGRhdGFJbk5hbWVzOiBbJ2luJ10sXFxuICAgIGRhdGFJblNjaGVtYToge30sXFxuICAgIGRhdGFPdXROYW1lczpbXFwncmVzdWx0XFwnXSxcXG4gICAgZGF0YU91dFNjaGVtYToge30sXFxuICAgIGlucHV0TmFtZXM6IFsnaW5wdXQnXSxcXG4gICAgaW5wdXRTY2hlbWE6IHt9LFxcbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZGF0YSwgaW5wdXQsIGxpYnMpIHtcXG4gICAgICAgIHJldHVybiBsaWJzLmF4aW9zLmdldChcXCdodHRwOlxcL1xcL2xvY2FsaG9zdDo4MDgwXFwvZXhhbXBsZVxcL2NhbGNcXC9hZGRcXC9cXCcpO1xcbiAgICB9LFxcbiAgICByZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBpbnB1dCwgbGlicykge1xcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OnJlc3BvbnNlLmRhdGEgfVxcbiAgICB9ICAgIFxcbn1cIjtcclxufVxyXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJ7XFxuICAgIHR5cGU6IFxcJ2NvbXBvc2l0aW9uXFwnLFxcbiAgICBuYW1lOiBcXCdjb21wb3NpdGlvbjFcXCcsXFxuICAgIGRhdGFJbk5hbWVzOiBbXSxcXG4gICAgZGF0YUluU2NoZW1hOiB7fSxcXG4gICAgZGF0YU91dE5hbWVzOltcXCdyZXN1bHRcXCddLFxcbiAgICBkYXRhT3V0U2NoZW1hOiB7fSxcXG4gICAgaW5wdXROYW1lczogW10sXFxuICAgIGlucHV0U2NoZW1hOiB7fSxcXG4gICAgbWFwRGF0YUluOiBmdW5jdGlvbiAoZGF0YSwgY29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGVzLCBsaWJzKSB7XFxuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlTmFtZSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gbGlicy5nZXQoZGF0YSwgY29tcG9zYWJsZU5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0sXFxuICAgIG1hcERhdGFPdXQ6IGZ1bmN0aW9uIChvdXRwdXQsIGxpYnMpIHtcXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XFxuICAgIH0sXFxuICAgIG1hcElucHV0OiBmdW5jdGlvbiAoaW5wdXQsIG1vZHVsZU5hbWUsIG1vZHVsZXMsIGxpYnMpIHtcXG4gICAgICAgIGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShtb2R1bGVOYW1lKSkge1xcbiAgICAgICAgICAgIHJldHVybiBsaWJzLmdldChpbnB1dCwgbW9kdWxlTmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbn1cIjtcclxufVxyXG5cclxuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuY29udmVydENvZGVUb0pzb24gPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICBcclxuICAgIHZhciByZXN1bHQgPSAnJ1xyXG4gICAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KC9cXHI/XFxuLyk7XHJcbiAgIFxyXG4gICAgdmFyIHJlZ2V4RnVuY3Rpb24gPSBuZXcgUmVnRXhwKC9eXFxzKihcXHcpK1xccyo6XFxzKmZ1bmN0aW9uLyk7XHJcbiAgICB2YXIgcmVnZXhQcm9wZXJ0eSA9IG5ldyBSZWdFeHAoL15cXHMqKFxcdykrXFxzKi8pO1xyXG5cclxuICAgIHZhciBmdW5jTGluZXMgPSBmYWxzZTtcclxuICAgIHZhciBmdW5jTGluZXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgdmFyIGJyYWNlQ291bnQgPSAwO1xyXG4gICAgdmFyIGZ1bmNMaW5lc0p1c3RGaW5pc2hlZD0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7ICAgICAgICBcclxuICAgICAgICBpZiAoIWZ1bmNMaW5lcykge1xyXG4gICAgICAgICAgICBpZiAoZnVuY0xpbmVzSnVzdEZpbmlzaGVkICYmIGxpbmUuaW5kZXhPZignOicpID49IDApIHtcclxuICAgICAgICAgICAgICAgIGZ1bmNMaW5lc0p1c3RGaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsXFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXhGdW5jdGlvbi50ZXN0KGxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jTGluZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpbmUuaW5kZXhPZignZnVuY3Rpb24nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZVBhcnQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4UHJvcGVydHkuZXhlYyhsaW5lUGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVQYXJ0ID0gbGluZVBhcnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1wiJyArIGxpbmVQYXJ0LnNsaWNlKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgKyAnXCInICsgbGluZVBhcnQuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluZVBhcnQgPSBsaW5lUGFydC5yZXBsYWNlKC8nL2csICdcIicpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lUGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1tcIicgKyBsaW5lLnNsaWNlKGluZGV4KSArICdcIixcXG4nO1xyXG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzRmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhQcm9wZXJ0eS5leGVjKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnXCInICsgbGluZS5zbGljZShtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpICsgJ1wiJyArIGxpbmUuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvJy9nLCAnXCInKTsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZSArICdcXG4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmdW5jTGluZXMpIHtcclxuICAgICAgICAgICAgdmFyIGluUXVvdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpblNpbmdsZVF1b3RlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbmUubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gbGluZVtrXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnXCInICYmICFpblNpbmdsZVF1b3Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGspICsgJ1xcXFwnICsgbGluZS5zbGljZShrKTtcclxuICAgICAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09ICdcXCcnICYmICFpblF1b3Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluUXVvdGVzID0gIWluU2luZ2xlUXVvdGVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSAneycgJiYgIWluUXVvdGVzICYmICFpblNpbmdsZVF1b3Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyYWNlQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gJ30nICYmICFpblF1b3RlcyAmJiAhaW5TaW5nbGVRdW90ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmFjZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZ1bmNMaW5lc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jTGluZXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgnXFxcXG4nLCAnXFxcXFxcXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2VDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCAmJiBsaW5lLmluZGV4T2YoJywnKSA+PSBsaW5lLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbGluZS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcIicgKyBsaW5lICsgJ1wiJyArICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcIicgKyBsaW5lICsgJ1wiJyArICcsJyArICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYnJhY2VDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jTGluZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZ1bmNMaW5lc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11cXG4nO1xyXG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzSnVzdEZpbmlzaGVkPXRydWU7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXN1bHQuaW5kZXhPZigneycpICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICd7JyArIHJlc3VsdCArICd9JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNvbnZlcnRKc29uVG9Db2RlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgZnVuY3Rpb24gZ2V0U3BhY2VzKHNwYWNlcykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCBsZXZlbCwgc3BhY2VzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG5cclxuICAgICAgICB2YXIgaWRlbnQgPSBnZXRTcGFjZXMobGV2ZWwgKiBzcGFjZXMpO1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgdmFyIGtleVN0cmluZyA9IChrZXkuaW5kZXhPZignICcpID49IDApID8gKCdcXCcnICsga2V5ICsgJ1xcJycpIDoga2V5O1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gaWRlbnQgKyBrZXlTdHJpbmcgKyAnOiAnO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtrZXldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXCcnICsgb2JqZWN0W2tleV0gKyAnXFwnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Rba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlDb250ZW50ID0gJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Rba2V5XS5sZW5ndGggPiAwICYmIHR5cGVvZiBvYmplY3Rba2V5XVswXSA9PT0gJ3N0cmluZycgJiYgb2JqZWN0W2tleV1bMF0udHJpbSgpLmluZGV4T2YoJ2Z1bmN0aW9uJykgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RlY29kZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxMZXZlbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2JqZWN0W2tleV0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gb2JqZWN0W2tleV1ba10udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignfScpID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbExldmVsLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsTGV2ZWwgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsTGV2ZWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSAoayA9PSAwID8gJycgOiBpZGVudCkgKyBnZXRTcGFjZXMoc3BhY2VzICogaW50ZXJuYWxMZXZlbCkgKyBsaW5lICsgKGsgPj0gb2JqZWN0W2tleV0ubGVuZ3RoIC0gMSA/ICcnIDogJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCAmJiBsaW5lLmluZGV4T2YoJ3snKSA9PSBsaW5lLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbExldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGFycmF5Q29udGVudCArIGlkZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvYmplY3Rba2V5XS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvYmplY3Rba2V5XVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSBpZGVudCArIGdldFNwYWNlcyhzcGFjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSAnXFwnJyArIGVsZW1lbnQgKyAnXFwnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSAne1xcbicgKyBzdHJpbmdpZnkob2JqZWN0W2tleV0sIGxldmVsICsgMSwgc3BhY2VzKSArIGlkZW50ICsgJ30nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IG9iamVjdFtrZXldLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbnRlbnQgKz0gJywnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9ICdcXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnW1xcbicgKyBhcnJheUNvbnRlbnQgKyBpZGVudCArICddJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3tcXG4nICsgc3RyaW5naWZ5KG9iamVjdFtrZXldLCBsZXZlbCArIDEsIHNwYWNlcykgKyBpZGVudCArICd9JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcJycgKyBvYmplY3Rba2V5XSArICdcXCcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3tcXG4nK3N0cmluZ2lmeShvYmosIDEsIDQpKyd9JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiwgdGhhdCBhc3NpZ25zIHRoZSBjb21wb3NhYmxlcyB0byB0aGUgaW50ZXJuYWwgZGljdGlvbmFyeSBhbmQgb3B0aW9uYWxseSB0byBleHRlcm5hbCBvYmplY3RzIHdpdGggYSBzcGVjaWZpZWQgcHJvcGVydHkuXHJcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlyZWN0bHkgZmlsbCBhbm90aGVyIGV4dGVybmFsIGRpY3Rpb25hcnkgb2YgY29tcG9zYWJsZXMsIGxpa2UgdGhlIHtAbGluayBDb21wb3NpdGlvbn0gY29tcG9zYWJsZSBkaWN0aW9uYXJ5LlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUuXHJcbiAqIEBwYXJhbSB7Q29tcG9zYWJsZX0gY29tcG9zYWJsZSAtIFRoZSBjb21wb3NhYmxlIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IFthc3NpZ25Ub09iamVjdF0gLSBUaGUgZXh0ZXJuYWwgb2JqZWN0IHRvIHdpY2ggdGhlIGNvbXBvc2FibGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIFRoZSBwb3JwZXJ0eSBvZiB0aGUgZXh0ZXJuYWwgb2JqZWN0IHRvIHdpY2ggdGhlIGNvbXBvc2FibGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvLlxyXG4gKi9cclxuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuYXNzaWduTG9hZGVkQ29tcG9zYWJsZXMgPSBmdW5jdGlvbiAobmFtZSwgY29tcG9zYWJsZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgICB0aGlzLmNvbXBvc2FibGVzW25hbWVdID0gY29tcG9zYWJsZTtcclxuXHJcbiAgICAvL2NoZWNrIGlmIHRoZSBvcHRpb25hbCBhc3NpZ25Ub09iamVjdCBpcyBnaXZlblxyXG4gICAgaWYgKHR5cGVvZiBhc3NpZ25Ub09iamVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgYXNzaWduVG9PYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGFzc2lnblRvT2JqZWN0W3Byb3BlcnR5XSA9IGNvbXBvc2FibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9kZWFsIHdpdGggd2FpdGluZ2xpc3Q6IGFzIHRoZSBjYWxsZXIgaGFzIHRvIHdhaXQgZm9yICd0aGVuJyB3ZSwgY2FuIHNldCB0aGUgcmVxdWlyZWQgdmFsdWVzIG5vdyB3aXRoIHNvbWUgZGVsYXlcclxuICAgIGlmICh0aGlzLndhaXRpbmdMaXN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgLy9mb3IgZWFjaCBvYmplY3QsIHRoYXQgd2FpdHMgZm9yIHRoZSBjb21wb3NhYmxlIHRvIGJlIGFzc2lnbmVkIHRvXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmdMaXN0W25hbWVdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhc3NpZ25UbyA9IHRoaXMud2FpdGluZ0xpc3RbbmFtZV1baV0uYXNzaWduVG87XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gdGhpcy53YWl0aW5nTGlzdFtuYW1lXVtpXS5wcm9wO1xyXG5cclxuICAgICAgICAgICAgYXNzaWduVG9bcHJvcF0gPSBjb21wb3NhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlbW92ZSBlbGVtZW50IGZyb20gdGhlIHdhaXRpbmdMaXN0XHJcbiAgICAgICAgZGVsZXRlIHRoaXMud2FpdGluZ0xpc3RbbmFtZV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIExvYWRzIGEgY29tcG9zYWJsZSBieSB0aGUgZ2l2ZW4gbmFtZSBmcm9tIGEgd2ViIHJlc291cmNlLlxyXG4gKiBJZiBubyBiYXNlUGF0aCB3YXMgZ2l2ZW4gaW4gdGhlIGNvbnN0cnVjdG9yLCB1c2UgdGhlIGZ1bGwgd2ViIGFkZHJlc3MgYXMgdGhlIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXNzaWduVG9PYmplY3RdIC0gVGhlIGV4dGVybmFsIG9iamVjdCB0byB3aWNoIHRoZSBjb21wb3NhYmxlIHNob3VsZCBiZSBhc3NpZ25lZCB0by5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBUaGUgcG9ycGVydHkgb2YgdGhlIGV4dGVybmFsIG9iamVjdCB0byB3aWNoIHRoZSBjb21wb3NhYmxlIHNob3VsZCBiZSBhc3NpZ25lZCB0by5cclxuICogQHJldHVybnMge1Byb21pc2U8Q29tcG9zYWJsZT59IC0gVGhlIGxvYWRlZCBjb21wb3NhYmxlIG9iamVjdC5cclxuICovXHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy9yZXR1cm4gYSBwcm9taXNlLCBzaW5jZSBsb2FkaW5nIGlzIGFuc3luY2hyb251b3VzXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vY2hlY2sgaWYgdGhlIG5hbWUgd2FzIGFscmVhZHkgbG9hZGVkIG9yIGlzIGN1cnJlbnRseSBiZWluZyBsb2FkZWRcclxuICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAvL3dlIGhhdmUgb25seSBvdXIgcGxhY2Vob2xkZXIsIG5vIHJlYWwgdmFsdWUgeWV0XHJcbiAgICAgICAgICAgIC8vdGhpcyBtZWFucyB0aGUgY29tcG9zYWJsZSBpcyBjdXJyZW50bHkgcmVxdWVzdGVkLCBidXQgbm90IGxvYWRlZFxyXG4gICAgICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlc1tuYW1lXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy9wdXQgaW4gd2FpdGluZ2xpc3QsIHdoaWNoIGlzIGNoZWNrZWQgYWZ0ZXIgZWFjaCBsb2FkXHJcbiAgICAgICAgICAgICAgICAvL2J1dCBvbmx5LCBpZiBpdCBuZWVkcyB0byBiZSBhc3NpZ25lZCBleHRlcm5hbGx5XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFzc2lnblRvT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBhc3NpZ25Ub09iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLndhaXRpbmdMaXN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYud2FpdGluZ0xpc3RbbmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53YWl0aW5nTGlzdFtuYW1lXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduVG86IGFzc2lnblRvT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9sb2FkIGZyb20gZGljdGlvbmFyeVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLmNvbXBvc2FibGVzW25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXNzaWduVG9PYmplY3QgIT09ICd1bmRlZmluZWQnICYmIGFzc2lnblRvT2JqZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduVG9PYmplY3RbcHJvcGVydHldID0gc2VsZi5jb21wb3NhYmxlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5jb21wb3NhYmxlc1tuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vbm90IGFscmVhZHkgaW4gZGljdGlvbmFyeSwgbmVlZHMgdG8gYmUgbG9hZGVkXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vc2V0IGtleSBhbmQgcHJldmVudCB1bm5lY2Vzc2FyeSBsb2Fkcywgd2hpbGUgbG9hZGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXHJcbiAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAvL2NvbnN0cnVjdCB1cmxcclxuICAgICAgICAgICAgdmFyIHVybCA9IHNlbGYuYmFzZVBhdGggKyBuYW1lICsgc2VsZi5zdWZmaXg7XHJcblxyXG4gICAgICAgICAgICBzd2V2YS5heGlvcy5nZXQodXJsKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vY29udmVydCB0aGUgcmVzcG9uc2UgSlNPTiB0byBhbiBhY3R1YWwgY29tcG9zYWJsZVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvc2FibGUgPSBzZWxmLmNvbnZlcnRUb09iamVjdChyZXNwb25zZS5kYXRhLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgLy9jbG9zdWUgZnVuY3Rpb24sIGR1bW15XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIChjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMsIHJlaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMoY29tcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmMoY29tcG9zYWJsZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgY29tcG9zYWJsZSBqdXN0IGV4dGVuZHMgZXhpc3Rpbmcgb25lXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zYWJsZS5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VDb21wb3NhYmxlTmFtZSA9IGNvbXBvc2FibGUuZXh0ZW5kcztcclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBhIGNsb3N1cmUgdG8gbG9hZCB0aGUgYmFzZSBjb21wb3NhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmMyID0gZnVuY3Rpb24gKGJhc2VDb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcywgcmVqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWQoYmFzZUNvbXBvc2FibGVOYW1lKS50aGVuKGZ1bmN0aW9uIChjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9leHRlbmQgbG9hZGVkIGNvbXBvc2FibGUgd2l0aCBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMoY29tcC5leHRlbmRXaXRoKGNvbXBvc2FibGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAvL2FkanVzdCBpbnRlcm5hbCBwcm9taXNlIHRvIGxvYWQgdGhlIGJhc2UgY29tcG9zYWJsZSBmaXJzdCwgYmVmb3JlIGV4dGVuZGluZyBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jMihiYXNlQ29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFByb21pc2UudGhlbihmdW5jdGlvbiAoY29tcG9zYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nIGFzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsb2FkZWQgJyArIGNvbXBvc2FibGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgbG9hZGVkIGNvbXBvc2FibGUgaXMgYSBtb2R1bGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zYWJsZS50eXBlID09ICdtb2R1bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3RydWN0IE1vZHVsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NhYmxlID0gbmV3IE1vZHVsZShjb21wb3NhYmxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXNzaWduTG9hZGVkQ29tcG9zYWJsZXMobmFtZSwgY29tcG9zYWJsZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29tcG9zYWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBsb2FkZWQgY29tcG9zYWJsZSBpcyBhIGNvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3RydWN0IENvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2FibGUgPSBuZXcgQ29tcG9zaXRpb24oY29tcG9zYWJsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFzc2lnbkxvYWRlZENvbXBvc2FibGVzKG5hbWUsIGNvbXBvc2FibGUsIGFzc2lnblRvT2JqZWN0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9hZCBjb21wb3NhYmxlcyByZXF1aXJlZCBmb3IgdGhlIGNvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2FibGUubG9hZENvbXBvc2FibGVzKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvbXBvc2FibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KHNlbGYuYmFzZVBhdGggKyBuYW1lICsgc2VsZi5zdWZmaXgpOyAvL2NvdWxkIG5vdCBsb2FkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGRpY3Rpb25hcmllcy5cclxuICovXHJcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jb21wb3NhYmxlcyA9IHt9O1xyXG4gICAgdGhpcy53YWl0aW5nTGlzdCA9IHt9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zYWJsZUxvYWRlcjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xyXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9tb2R1bGUuanMnKTtcclxudmFyIENvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcycpO1xyXG5cclxuLy9NQVxyXG4vLysrKysrKysrKyBHbG9iYWwgVmFyaWFibGVzICsrKysrKysrK1xyXG4vL2ZvciBQMlAgbmV0d29ya2luZ1xyXG4vLyBUT2RPOiBkbyB3ZSByZXF1aXJlIHRoaXMgP1xyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcclxuY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuY29uc3QgcG90ZW50aWFsT2ZmbG9hZGluZ1RhcmdldCA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL3BvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQuanNcIik7XHJcblxyXG4vLyAqKioqIFAyUCBuZXR3b3JrICoqKipcclxuXHJcblxyXG4vKipcclxuIGxldCBwZWVyID0gbmV3IFBlZXIoeyAvL25lZWRzIGJpYiBpbXBvcnQgaW4gZnJvbnRlbmQgIVxyXG4gICAgaG9zdDpcImxvY2FsaG9zdFwiLFxyXG4gICAgcG9ydDo5MDAwLFxyXG4gICAgcGF0aDpcIi9kaXNjb3ZlcnlcIlxyXG59KTtcclxuXHJcbiAvL0V2ZW50LWJhc2VkIHNjcmlwdFxyXG4gLy8rKysrKysrKysgREVWSUNFIGlzIFBPVCArKysrKysrKytcclxuIHBlZXIub24oJ2Nvbm5lY3Rpb24nLCAoY29ubmVjdGlvbikgPT4ge1xyXG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ3BlZXIpe1xyXG4gICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdpc1BlZXInKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIFJPTEU6ICcgKyBkYXRhKycgZnJvbSBkZXZpY2U6ICcgKyBjb25uZWN0aW9uLnBlZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxufSk7XHJcblxyXG4gZW1pdHRlci5vbignaXNQZWVyJyxwb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0KCkpO1xyXG4gKiovXHJcbi8vKysrKysrKysrIERFVklDRSBpcyBEUEQgKysrKysrKysrXHJcbmZ1bmN0aW9uIGxpc3RPZlBlZXJzKCkgeyAvLyB1c2VkIHRvIGJyb2FkY2FzdCByb2xlcyBhbmQgZm9yIGZyb250ZW5kICFcclxuICAgIGxldCBsaXN0ID0gW107XHJcbiAgICBwZWVyLmxpc3RBbGxQZWVycygocGVlcklkcykgPT4ge1xyXG4gICAgICAgIHBlZXJJZHNcclxuICAgICAgICAgICAgLmZpbHRlcigocGVlcklkKSA9PiBwZWVySWQgIT09IHBlZXIuaWQpIC8vIEZpbHRlciBvdXQgZGV2aWNlIElEXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChwZWVySWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChwZWVySWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJyb2FkY2FzdFRvRGlzY292ZXJ5TmV0d29yaygpIHtcclxuICAgIHBlZXIubGlzdEFsbFBlZXJzKChwZWVySWRzKSA9PiB7XHJcbiAgICAgICAgcGVlcklkc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChwZWVySWQpID0+IHBlZXJJZCAhPT0gcGVlci5pZCkgLy8gRmlsdGVyIG91dCBkZXZpY2UgSURcclxuICAgICAgICAgICAgLmZvckVhY2goKHBlZXJJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IHBlZXIuY29ubmVjdChwZWVySWQpO1xyXG4gICAgICAgICAgICAgICAgY29ubi5vbignb3BlbicsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGlzY292ZXJlZCBQZWVyOiAnICsgcGVlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uLnNlbmQoJ3BlZXInKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29ubi5vbignZXJyb3InLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY292ZXJpbmcgUGVlciA6ICcgKyBwZWVySWQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gKioqKiBFTkQgUDJQIG5ldHdvcmsgKioqKlxyXG5cclxuXHJcbi8qKlxyXG4gKiBBbiBFeGVjdXRpb25NYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0aGUgZXhlY3V0aW9uIHByb2Nlc3Mgb2YgY29tcG9zaXRpb25zIGFuZCBtb2R1bGVzLlxyXG4gKiBJdCBoYXMgdHdvIHBoYXNlczogQSBzZXR1cCBwaGFzZSwgd2VyZSBhbGwgZGVwZW5kZW5jaWVzIGFyZSBsb2FkZWQgYW5kIGluaXRpYWxpemVkIGFuZCBhbiBleGVjdXRpb24gcGhhc2UsXHJcbiAqIHRoYXQgZXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIGJ5IHByb3ZpZGluZyBkYXRhIGFuZCBpbnB1dCBvYmplY3RzIHRvIHRoZW0uXHJcbiAqXHJcbiAqIFRoZSBzZXR1cCBuZWVkcyB0byBiZSBkb25lIG9ubHkgb25jZSwgd2hpbGUgdGhlIGV4ZWN1dGlvbiBjYW4gYmUgcmVwZWF0ZWQgb24gZGlmZmVyZW50IGRhdGEuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gTmFtZSBvZiB0aGUgZXhlY3V0aW9uIG1hbmFnZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBFeGVjdXRpb25NYW5hZ2VyKG5hbWUpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRXhlY3V0aW9uTWFuYWdlcic7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFtb3VudCBvZiBob3cgbWFueSBtb2R1bGVzIGFyZSB1c2VkIGN1cnJlbnRseS5cclxuICAgICAqIEBuYW1lIEV4ZWN1dGlvbk1hbmFnZXIjbW9kdWxlc1RvdGFsXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vZHVsZXNUb3RhbCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIEFtb3VudCBvZiBob3cgbWFueSBtb2R1bGVzIGhhdmUgZmluaXNoZWQgZXhlY3V0aW9uLlxyXG4gICAgICogQG5hbWUgRXhlY3V0aW9uTWFuYWdlciNtb2R1bGVzRG9uZVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2R1bGVzRG9uZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHRvIHRyYWNrIHByb2dyZXNzLCBnZXRzIGNhbGxlZCBldmVyeXRpbWUgYSBtb2R1bGUgZmluaXNoZXMuXHJcbiAgICAgKiBAbmFtZSBFeGVjdXRpb25NYW5hZ2VyI3Byb2dyZXNzQ2FsbGJhY2tcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrID0gbnVsbDtcclxuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyYWNrIHByb2dyZXNzLlxyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICovXHJcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdXBkYXRlIHZpc3VhbGl6YXRpb24gb24gTVFUVCBkYXRhIHJlY2VpdmVkIGFmdGVyIHJlZXhlY3V0aW5nIHRoZSBzd2V2YS1ncmFwaC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIHZpc3VhbGl6YXRpb24uXHJcbiAqL1xyXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1RVFREYXRhUmVjaWV2ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gY2FsbGJhY2s7XHJcbn07XHJcblxyXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kRGF0YVRvVmlzdWFsaXphdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgIGlmICh0aGlzLnVwZGF0ZVZpc3VhbGl6YXRpb25Ob3RpZmllciAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyKHJlc3VsdCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIGFueSBhc3luY2hyb25vdXMgbm9kZSByZS1leGVjdXRlcyBwYXJ0cyBvZiB0aGUgY29tcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKi9cclxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkUmVleGVjdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgbW9kdWxlX25hbWUpIHtcclxuICAgIGlmICh0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzW2tleV0ubW9kdWxlX25hbWUgPT09IG1vZHVsZV9uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzLnNwbGljZShrZXksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMucHVzaCh7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgICAgICAgbW9kdWxlX25hbWU6IG1vZHVsZV9uYW1lXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChtb2R1bGVfbmFtZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBtb2R1bGVfbmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW9kdWxlVXBkYXRlID0gZnVuY3Rpb24gKG1vZHVsZSkge1xyXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0ubW9kdWxlX25hbWUgPT09IG1vZHVsZS5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMubW9kdWxlX25hbWUpIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0uY2FsbGJhY2sobW9kdWxlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhbGwgcmVxdWlyZWQgY29tcG9zYWJsZXMsIGxvYWRzIGRlcGVuZGVuY2llcywgdmFsaWRhdGVzLlxyXG4gKlxyXG4gKiAoSUYpIFBBUlNFIHBpcGVsaW5lIHRvIEpTIG9iamVjdCBzZWxmIGdsb2FibCB0byB0aGUgZXhlY3V0aW9uTWFuYWdlciAhXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xDb21wb3NhYmxlPn0gZXhlY3V0aW9uQXJyYXkgLSBBcnJheSBvZiBjb21wb3NhYmxlcyB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUHVyZU9iamVjdD1mYWxzZV0gLSBTZXQgdGhpcyB0byB0cnVlLCBpZiBwYXNzaW5nIHB1cmUgSmF2YVNjcmlwdCBPYmplY3RzIGFuZCBub3QganVzdCBKU09OLlxyXG4gKi9cclxuLy9HbG9iYWwgdmFyaWFibGUgbmFtZXNcclxuXHJcbmxldCBpbnRlcm1lZGlhdGVQaXBlbGluZTtcclxubGV0IGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0cztcclxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoZXhlY3V0aW9uQXJyYXksIGlzUHVyZU9iamVjdCkge1xyXG4gICAgaW50ZXJtZWRpYXRlUGlwZWxpbmUgPSBleGVjdXRpb25BcnJheTtcclxuICAgIC8qY29uc29sZS5sb2coJy8vLy8vIEV4ZWMuIG1hbmFnZXIgc2V0dXAgaW5wdXRzIC8vLy8vLycpO1xyXG4gICAgY29uc29sZS5sb2coJ2V4ZWN1dGlvbkFycmF5Jyk7XHJcbiAgICBjb25zb2xlLmxvZyhleGVjdXRpb25BcnJheSk7XHJcbiAgICBjb25zb2xlLmxvZygnaXNQdXJlT2JqZWN0Jyk7XHJcbiAgICBjb25zb2xlLmxvZyhpc1B1cmVPYmplY3QpO1xyXG4gICAgY29uc29sZS5sb2coJ2ludGVybWVkLiBwaXAnKTtcclxuICAgIGNvbnNvbGUubG9nKGludGVybWVkaWF0ZVBpcGVsaW5lKTsqL1xyXG5cclxuICAgIC8vaW50ZXJuYWwgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNvdW50IGhvdyBtYW55IG1vZHVsZXMgYXJlIGN1cnJlbnRseSB1c2VkXHJcbiAgICBmdW5jdGlvbiBjb3VudE1vZHVsZXMoY29tcG9zYWJsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9zYWJsZS5jb21wb3NhYmxlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb3NhYmxlLmNvbXBvc2FibGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zYWJsZS5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhrZXksIGNvbXBvc2FibGUuY29tcG9zYWJsZXNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gY291bnRNb2R1bGVzKGNvbXBvc2FibGUuY29tcG9zYWJsZXNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnVVBEQVRFRCBDb21wb3NhYmxlID0nLCBjb21wb3NhYmxlKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk51bWJlciBvZiBzZXQgdXAgbm9kZXMgaW4gQ29tcG9zYWJsZTogXCIgKyBjb3VudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5lZWRzTG9hZGluZyA9IFtdO1xyXG4gICAgdGhpcy5jb21wb3NhYmxlcyA9IHt9O1xyXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy53YW50c1RvRXhlY3V0ZSA9IGZhbHNlO1xyXG4gICAgLy9pZiBpdCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgb25lXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhlY3V0aW9uQXJyYXkpKSB7XHJcbiAgICAgICAgZXhlY3V0aW9uQXJyYXkgPSBbZXhlY3V0aW9uQXJyYXldO1xyXG4gICAgfVxyXG4gICAgdmFyIG5hbWVzID0gW107XHJcbiAgICAvL2ZvciBlYWNoIGNvbXBvc2FibGUsIHRoYXQgd2lsbCBiZSBleGVjdXRlZFxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25BcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjb21wb3NhYmxlID0gZXhlY3V0aW9uQXJyYXlbaV07XHJcbiAgICAgICAgLy9pZiBjb21wb3NhYmxlIGlzIHByb3ZpZGVkIGFzIHN0cmluZywgaS5lLiBuYW1lIGl0IG5lZWRzIHRvIGJlIGxvYWRlZFxyXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9zYWJsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZXMucHVzaChjb21wb3NhYmxlKTtcclxuICAgICAgICAgICAgbmVlZHNMb2FkaW5nLnB1c2goc3dldmEuQ29tcG9zYWJsZUxvYWRlci5sb2FkKGNvbXBvc2FibGUsIHRoaXMuY29tcG9zYWJsZXMsIGNvbXBvc2FibGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9vdGhlcndpc2UgYSBjb21wb3NhYmxlIG9iamVjdCBpcyBnaXZlblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzUHVyZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWlzUHVyZU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9zYWJsZSA9IHN3ZXZhLkNvbXBvc2FibGVMb2FkZXIuY29udmVydFRvT2JqZWN0KGNvbXBvc2FibGUsICdKU09OJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb21wb3NhYmxlLnR5cGUgPT09ICdtb2R1bGUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0gPSBuZXcgTW9kdWxlKGNvbXBvc2FibGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlLm5hbWVdID0gbmV3IENvbXBvc2l0aW9uKGNvbXBvc2FibGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgLy9jb21wb3NhYmxlcyBvZiBhIGNvbXBvc2l0aW9uIG5lZWQgYWxzbyB0byBiZSBsb2FkZWRcclxuICAgICAgICAgICAgICAgIG5lZWRzTG9hZGluZy5wdXNoKHRoaXMuY29tcG9zYWJsZXNbY29tcG9zYWJsZS5uYW1lXS5sb2FkQ29tcG9zYWJsZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmFtZXMucHVzaChjb21wb3NhYmxlLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvL25vdyB3YWl0IGZvciBldmVyeXRoaW5nIHRvIGxvYWRcclxuICAgIFByb21pc2UuYWxsKG5lZWRzTG9hZGluZykudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnUkFXIFBpcGxpbmUgLyBVc2VyIElucHV0PScsIGNvbXBvc2FibGUpO1xyXG4gICAgICAgIC8vbGV0J3MgY2hlY2ssIGhvdyBtYW55IG1vZHVsZXMgYXJlIHVzZWQgaW4gdG90YWwgdG8gaGF2ZSBhIHJvdWdoIGVzdGltYXRlIGZvciBwcm9ncmVzcyB0cmFja2luZ1xyXG4gICAgICAgIHZhciBtb2R1bGVDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25BcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBtb2R1bGVDb3VudCArPSBjb3VudE1vZHVsZXMoc3dldmEuQ29tcG9zYWJsZUxvYWRlci5nZXQobmFtZXNbaV0pKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYubW9kdWxlc1RvdGFsID0gbW9kdWxlQ291bnQ7XHJcbiAgICAgICAgc2VsZi5tb2R1bGVzRG9uZSA9IDA7XHJcblxyXG4gICAgICAgIC8vY29tcG9zYWJsZXMgc2hvdWxkIG5vdyBjb250YWluIGV2ZXJ5dGhpbmdcclxuICAgICAgICBzZWxmLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdhbGwgbG9hZGVkJyk7XHJcbiAgICAgICAgLy9pZiB3ZSB3YW50IHRvIGV4ZWN1dGUsIGJlZm9yZSBzZXR1cCBpcyByZWFkeSwgaXQgaXMgZGVsYXllZCBhbmQgY29udGludWVkIGZyb20gaGVyZVxyXG4gICAgICAgIGlmIChzZWxmLndhbnRzVG9FeGVjdXRlKSB7XHJcbiAgICAgICAgICAgIHNlbGYud2FudHNUb0V4ZWN1dGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2VsZi5leGVjdXRlQ2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdDb3VsZCBub3QgbG9hZCBhbGwgbW9kdWxlczogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZSwgZXJyb3IpKTtcclxuICAgICAgICB9KTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCBwcm9ncmVzcyBzdGF0ZSBhbmQgY2FsbHMgdGhlIG9wdGlvbmFsbHkgcmVnaXN0ZXJlZCBwcm9ncmVzc0NhbGxiYWNrLlxyXG4gKiBJdCBjb3VudHMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIG1vZHVsZXMgdGhhdCBoYXZlIGZpbmlzaGVkIGV4ZWN1dGlvbi5cclxuICpcclxuICogKElGKSBUT0RPOiB1cGRhdGUgaXQgdG8gbW9kdWxlcyBkb25lIGxvY2FsbHkgYW5kIG9mbG9hZGVkIG1vZHVsZXNcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIC0gVGhlIGFsaWFzIG9mIHRoZSBtb2R1bGUsIHVuZGVyIHdoaWNoIGl0IGlzIGtub3duIHRvIHRoZSBwYXJlbnQgY29tcG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1vZHVsZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBUaGUgY29udGV4dCB1bmRlciB3aGljaCB0aGUgbW9kdWxlIGlzIGV4ZWN1dGVkIChpdHMgcGFyZW50cykuXHJcbiAqL1xyXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9ncmVzc1VwZGF0ZSA9IGZ1bmN0aW9uIChhbGlhcywgbmFtZSwgY29udGV4dCxyZXN1bHQpIHtcclxuICAgIGlmIChyZXN1bHQ9PT0nb2ZmbG9hZGluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT0ZGTE9BRElORyBmbGFnIGNhdGNoZWQgaW4gRXhlYyBtYW5hZ2VyICEnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWxpYXM6JylcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYWxpYXMpOyAvLyBub2RlIDFcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ25hbWU6JylcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSk7IC8vbW9kdWxlIDFcclxuICAgICAgICAgICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU0VORCBUSElTIFBpcGVsaW5lIHRvICcpXHJcbiAgICAgICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy9jb25zaWRlciByZXN1bHQgYXMgbGlua2VkIG5vZGVzIGlucHV0XHJcbiAgICAgICAgbGV0IG5vZGVMaW5rcyA9IGludGVybWVkaWF0ZVBpcGVsaW5lLmxpbmtzO1xyXG4gICAgICAgIGxldCBtb2R1bGVSZXN1bHQgPSByZXN1bHQub3V0O1xyXG5cclxuICAgICAgICBpZiAobm9kZUxpbmtzLmhhc093blByb3BlcnR5KGFsaWFzKSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdZRVNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1MnKVxyXG4gICAgICAgICAgICBsZXQgbGlua3NBcnJheSA9T2JqZWN0LmVudHJpZXMobm9kZUxpbmtzW2FsaWFzXS5vdXQpWzBdO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhsaW5rc0FycmF5KTtcclxuXHJcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0c1tsaW5rc0FycmF5WzBdXT17XHJcbiAgICAgICAgICAgICAgICBcIm51bVwiOm1vZHVsZVJlc3VsdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHMpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc2lkZXIgcmVzdWx0IGFzIG5vZGUgb3V0cHV0XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGVUNLS0tLS0tLS0tLS0tLS0tLS0snKVxyXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHNbYWxpYXNdPXtcclxuICAgICAgICAgICAgICAgIFwib3V0XCI6bW9kdWxlUmVzdWx0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qY29uc29sZS5sb2coJy8vLy8vLy8vLy8vLy8nKTtcclxuICAgICAgICBsZXQgZm9ybWF0dGVkQWxpYXMgPSAnXCInICsgYWxpYXMgKyAnXCInO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBhbGlhcyk7IC8vIG5vZGUgMVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGludGVybWVkaWF0ZVBpcGVsaW5lLmxpbmtzKTsgLy8gbm9kZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCcvLy8vLy8vLy8vLy8vJyk7XHJcbiAgICAgICAgLy8vLmFsaWFzLm91dDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGVPdXRwdXRMaW5rKTtcclxuICAgICAgICBsZXQgZm9ybWF0dGVkT2JqID0ge1xyXG4gICAgICAgICAgICBcIk5vZGUyXCI6IHtcclxuICAgICAgICAgICAgICAgIFtvYmpbXCJOb2RlMlwiXV06XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9Ki9cclxuICAgICAgICAvL2RlbGV0ZSBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlcy5hbGlhcztcclxuICAgICAgICBjb25zb2xlLmxvZygncHJvZ3Jlc3MgYmFyIHJlc3VsdCA9Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0Lm91dCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSBwaXBlbGluZSA9Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdpbnRlcm1lZGlhdGUgcGlwZWxpbmUgcmVzdWx0cyA9Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzKTtcclxuICAgICAgICAvL3RvZG86dXBkYXRlIGludGVybWVkaWF0ZSBwaXBlbGluZSB3aXRoIHJlc3VsdFxyXG5cclxuICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2sgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZXNEb25lKys7XHJcblxyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMubW9kdWxlc0RvbmUgLyArdGhpcy5tb2R1bGVzVG90YWw7XHJcblxyXG4gICAgICAgIC8vbWFrZSBhIHZhbHVlIDAtMTAwIGFuZCBjdXQgb2ZmIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrKChwcm9ncmVzcyAqIDEwMCkudG9GaXhlZCgwKSk7XHJcbiAgICAgICAgLy9UT0RPIHNlbmQgdGhpcyB0byBmcm9udGVuZFxyXG4gICAgfX1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIHRoYXQgd2VyZSBpbml0YWxpemVkIGR1cmluZyB7QGxpbmsgRXhlY3V0aW9uTWFuYWdlciNzZXR1cH0uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgZXhlY3V0aW9uLiBJZiBtdWx0aXBsZSBjb21wb3NhYmxlcyB3aWxsIGJlIGV4ZWN1dGVkLFxyXG4gKiB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lcyBtdXN0IGNvcnJlc3BvbmQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZXMgZm9yIGEgY29ycmVjdCBtYXBwaW5nIG9mIHRoZSBkYXRhLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGZvciB0aGUgZXhlY3V0aW9uLiBJZiBtdWx0aXBsZSBjb21wb3NhYmxlcyB3aWxsIGJlIGV4ZWN1dGVkLFxyXG4gKiB0aGUgaW5wdXQgcHJvcGVydHkgbmFtZXMgbXVzdCBjb3JyZXNwb25kIHRvIHRoZSBjb21wb3NhYmxlIG5hbWVzIGZvciBhIGNvcnJlY3QgbWFwcGluZyBvZiB0aGUgaW5wdXQuXHJcbiAqL1xyXG5cclxuXHJcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gQXJyYXkgb2YgZXhlY3V0aW9ucywgd2hpY2ggYXJlIHJlcHJlc2VudGluZyBNb2R1bGVzIChub2RlcykuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHZhciBleGVjdXRpb25zID0gW107XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHM9ZGF0YTtcclxuICAgIC8vZm9yIGFib3J0aW5nIHRoZSBleGVjdXRpb24gb2YgSlMgcHJvbWlzZVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBFeGVjIE1hbmFnZXIgaW5wdXRzIC8vLy8vLy8vLy8vLy8vXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJkYXRhXCIpO1xyXG4gICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICBjb25zb2xlLmxvZyhcImlucHV0XCIpO1xyXG4gICAgY29uc29sZS5sb2coaW5wdXQpO1xyXG4gICAgY29uc29sZS5sb2coJ3NlbGYnKTtcclxuICAgIGNvbnNvbGUubG9nKHNlbGYpO1xyXG4gICAgY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSBQaXBlbGluZScpO1xyXG4gICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmUpO1xyXG4gICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cIik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAvL2Nsb3N1cmUgZnVuY3Rpb25cclxuICAgICAgICAvL2NvbXBvc2FibGVzIGlzIHRoZSBwaXBlbGluZVxyXG4gICAgICAgIC8vZXhlY3V0aW9ucyBpcyB0aGUgbGlzdCBvZiBwcm9taXNlcyBNb2R1bGUgdG8gYmUgZXhlY3V0ZWRcclxuICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIChjb21wb3NhYmxlcywgZXhlY3V0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBmdW5jIGlucHV0cyAvLy8vLy8vLy8vLy8vL1wiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbXBvc2FibGVzPSAnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coY29tcG9zYWJsZXMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW9ucz0gJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4ZWN1dGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1wiKTtcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb25seU9uZUNvbXBvc2FibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG9ubHkgb25lIGNvbXBvc2FibGUgd2lsbCBiZSBleGVjdXRlZCwgYmVjYXVzZSB0aGVuIHlvdSBkb24ndCBnbyBpbnRvIHRoZSBsb29wLlxyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbXBvc2FibGVzKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmx5T25lQ29tcG9zYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvc2FibGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vIGlmIGNvbmRpdGlvbiAvLy8vLy8vLy8vLy8vL1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBvc2FibGVzW2tleV09ICcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb21wb3NhYmxlc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2lucHV0W2tleV0gJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGlucHV0W2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygna2V5PSAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NlbGYucHJvZ3Jlc3NVcGRhdGUuYmluZChzZWxmKT0gJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNlbGYucHJvZ3Jlc3NVcGRhdGUuYmluZChzZWxmKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seU9uZUNvbXBvc2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSBmdW5jdGlvbiBpcyBkZWZpbmVkIGluIG1vZHVsZS5qc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9ucy5wdXNoKGNvbXBvc2FibGVzW2tleV0uZXhlY3V0ZShkYXRhLCBpbnB1dCwgJycsIGtleSwgc2VsZi5wcm9ncmVzc1VwZGF0ZS5iaW5kKHNlbGYpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiID09PT09PSBPbmx5IE9uZSBDb21wb3NhYmxlID09PT0gXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PT0gT0ZGTE9BRElORyA9PT0gTU9EVUxFIEVYRUNVVElPTiBJUyBJTklUSUFMSVpFRCAhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25zLnB1c2goY29tcG9zYWJsZXNba2V5XS5leGVjdXRlKGRhdGFba2V5XSwgaW5wdXRba2V5XSB8fCB7fSwgJycsIGtleSwgc2VsZi5wcm9ncmVzc1VwZGF0ZS5iaW5kKHNlbGYpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiID09PT09PSBNb3JlIHRoYW4gMSBjb21wb3NhYmxlID09PT0gXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBsb29wIHRvIG1vbml0b3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgcGlwZWxpbmUgYW5kIHVwZGF0ZSB0aGUgb2ZmbG9hZGluZyBwaXBlbGluZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdG9kbzogaW1wbGVtZW50IGEgbG9vcCB0aGF0IHVwZGF0ZXMgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBwaXBlbGluZSBlYWNoIHRpbWUgYSBtb2R1bGUgaXMgZXhlY3V0ZWRcclxuICAgICAgICAgICAgICAgIC8vICggcHJvbWlzZSBpcyBmdWxsZmlsbGVkKSBhbmQgc3RvcHMgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgcGlwZWxpbmUgaWYgb25lIHByb21pc2UgaXMgcmVqZWN0ZWRcclxuICAgICAgICAgICAgICAgIC8vbW9uaXRvclByb21pc2VzKGV4ZWN1dGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVMU0UgTk8gT0ZGTE9BRElORyAuLi5cclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYWxsIHRoZSBleGVjdXRpb24gUHJvbWlzZXMgaGF2ZSByZXNvbHZlZC4uLlxyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoZXhlY3V0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhbGwgcHJvbWlzZXMgcmVzb2x2ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25seU9uZUNvbXBvc2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmx5T25lQ29tcG9zYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ1NvbWV0aGluZyB1bmV4cGVjdGVkIGhhcHBlbmVkOiAnICsgcmVzdWx0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSwgcmVzdWx0cykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmlzUmVhZHkpIHtcclxuICAgICAgICAgICAgZnVuYyhzZWxmLmNvbXBvc2FibGVzLCBleGVjdXRpb25zLCByZXNvbHZlLCByZWplY3QpKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuZXhlY3V0ZUNhbGxiYWNrID0gZnVuYyhzZWxmLmNvbXBvc2FibGVzLCBleGVjdXRpb25zLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vYWxpYXNcclxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUucnVuID0gRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZTtcclxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25NYW5hZ2VyXHJcblxyXG5cclxuLypcclxuXHJcbi8vLy8vLy8vLy8vLy8vICBFWFBFUlQgTU9ERSAgLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8vIGlucHV0cyBhcmUgZXh0cmFjdGVkIGZyb20gZGV2aWNlXHJcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmRldmljZU1vbml0b3JpbmdJbmRleCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgIGFzeW5jIGZ1bmN0aW9uIGRldmljZU1vbml0b3JpbmdJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvL3RoaXMud2luZG93ID0gd2luZG93O1xyXG4gICAgICAgICAgICBsZXQgbWV0cmljcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy9IYXJkd2FyZSBtZXRyaWNzIGluIExpbnV4IGVudmlyb25tZW50czpcclxuICAgICAgICAgICAgbGV0IGNwdSA9IGF3YWl0IGN1cnJlbnRDUFV1c2FnZSgpXHJcbiAgICAgICAgICAgIGxldCBtZW0gPSBhd2FpdCBjdXJyZW50TWVtb3J5dXNhZ2UoKVxyXG4gICAgICAgICAgICBsZXQgc3RvcmFnZSA9IGF3YWl0IGF2YWlsYWJsZVN0b3JhZ2UoKVxyXG4gICAgICAgICAgICBsZXQgYmF0dGVyeSA9IGF3YWl0IGF2YWlsYWJsZUJhdHRlcnkoKVxyXG4gICAgICAgICAgICBsZXQgY2hhcmdpbmcgPSBhd2FpdCBpc0NoYXJnaW5nKClcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3B1XCIsY3B1LFwiXFxuIG1lbVwiLCBtZW0sIFwiXFxuIHN0b3JhZ2VcIiwgc3RvcmFnZSwgXCJcXG4gYmF0dGVyeVwiLCBiYXR0ZXJ5LCBcIlxcbiBjaGFyZ2luZ1wiLCBjaGFyZ2luZyk7XHJcbiAgICAgICAgICAgIHJlc29sdmUobWV0cmljcy5wdXNoKGNwdSwgbWVtLCBzdG9yYWdlLGJhdHRlcnksY2hhcmdpbmcpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL2ZvciB3aW5kb3dzIHRlc3RpbmcgcHVycG9zZXNcclxuICAgICAgICAgICAgbGV0IGNwdSA9IDYwOyAvL2F2ZyBmcmVlIGNwdSB2YWx1ZSBmb3IgMyBtZWFzdXJlbWVudHMgaW4gJVxyXG4gICAgICAgICAgICBsZXQgbWVtID0gMTAwMDAwOyAvLyBhdmlsYWJsZSBmcmVlIG1lbSB2YWx1ZSBpbiBieXRlc1xyXG4gICAgICAgICAgICBsZXQgc3RvcmFnZSA9IDIwMDAwMDA7IC8vIGF2aWxhYmxlIGZyZWUgc3RvcmFnZSB2YWx1ZSBpbiBieXRlc1xyXG4gICAgICAgICAgICBsZXQgYmF0dGVyeSA9IDgwO1xyXG4gICAgICAgICAgICBsZXQgY2hhcmdpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY3B1XCIsY3B1LFwiXFxuIG1lbVwiLCBtZW0sIFwiXFxuIHN0b3JhZ2VcIiwgc3RvcmFnZSwgXCJcXG4gYmF0dGVyeVwiLCBiYXR0ZXJ5LCBcIlxcbiBjaGFyZ2luZ1wiLCBjaGFyZ2luZyk7XHJcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChjcHUsIG1lbSwgc3RvcmFnZSwgYmF0dGVyeSwgY2hhcmdpbmcpXHJcbiAgICAgICAgICAgIHJlc29sdmUobWV0cmljcyk7XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IGRldmljZU1vbml0b3JpbmdJbmRleCgpO1xyXG5cclxufVxyXG4qL1xyXG5cclxuLypcclxuLy9pbnB1dHMgYXJlIGV4dHJhY3RlZCBmcm9tIGZyb250ZW5kIC0+IHVzZXIgaW5wdXQgaW4gYmFja2VuZFxyXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5vZmZsb2FkaW5nRGVjaXNpb24gPSBhc3luYyBmdW5jdGlvbiAob2RfQ1BVLCBvZF9tZW0sIG9kX2JhdHRlcnkpIHtcclxuICAgIGFzeW5jIGZ1bmN0aW9uIG9mZmxvYWRpbmdEZWNpc3Npb24od3BuLCBvZF9DUFUsIG9kX21lbSwgb2RfYmF0dGVyeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRtaSA9IGF3YWl0IEV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmRldmljZU1vbml0b3JpbmdJbmRleCgpO1xyXG4gICAgICAgICAgICBsZXQgZGVjaXNpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy9bMF06Y3B1XHJcbiAgICAgICAgICAgIC8vWzFdOiBtZW1vcnlcclxuICAgICAgICAgICAgLy9bMl06IHN0b3JhZ2VcclxuICAgICAgICAgICAgLy9kbWlbM106IGJhdHRlcnlcclxuICAgICAgICAgICAgLy9kbWlbNF06IGlzIGNoYXJnaW5nXHJcbiAgICAgICAgICAgIGlmIChvZF9DUFUgPT09IDAgfHwgb2RfbWVtID09PSAwIHx8IG9kX2JhdHRlcnkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGRlY2lzaW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3cG5bMF0gPiAoZG1pWzBdICogb2RfQ1BVKSB8fCB3cG5bMV0gPiAoZG1pWzFdICogb2RfbWVtKSB8fCBkbWlbM10gPCBvZF9iYXR0ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBkZWNpc2lvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZShkZWNpc2lvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IG9mZmxvYWRpbmdEZWNpc3Npb24oW3N3ZXZhLkNvbXBvc2FibGVMb2FkZXJbJ3RvdGFsQ1BVUmVxJ10sIHN3ZXZhLkNvbXBvc2FibGVMb2FkZXJbJ3RvdGFsTWVtUmVxJ11dLCBvZF9DUFUsIG9kX21lbSwgb2RfYmF0dGVyeSk7XHJcblxyXG59XHJcbiovXHJcblxyXG4vLy8vLy8vLy8vLy8vLyAgRU5EICBFWFBFUlQgTU9ERSAgLy8vLy8vLy8vLy8vLy9cclxuIiwiLyoqXHJcbiAqIENyZWF0ZXMgaW5zdGFuY2Ugb2Ygc3VwcG9ydCBsaWJyYXJ5XHJcbiAqXHJcbiAqIEFsbG93IGxvYWRpbmcgZnVuY3Rpb25hbGl0eSBzZXBhcmF0ZWx5LCBkZXBlbmRpbmcgb24gd2hhdCBpcyBuZWVkZWQgZm9yIGEgc3BlY2lmaWMgcnVubmVyXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFN1cHBvcnRMaWJyYXJ5KCkge1xyXG4gICAgdGhpcy5mdW5jdGlvbnMgPSB7fTtcclxufVxyXG5cclxuU3VwcG9ydExpYnJhcnkucHJvdG90eXBlLmxvYWRUZXN0U3luYyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5mdW5jdGlvbnMudGVzdCA9IHtcclxuICAgICAgICBhc3luYzogZmFsc2UsXHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpYzoge1xyXG4gICAgICAgICAgICB0eXBlc2NyaXB0OiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTaWc6IFwidXJsOiBzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jOiBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuU3VwcG9ydExpYnJhcnkucHJvdG90eXBlLmxvYWRMb2dnZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZnVuY3Rpb25zLmxvZyA9IHtcclxuICAgICAgICBkZXNjcmlwdGlvbjogXCJMb2cgdGhlIHRleHQgdG8gdGhlIGJyb3dzZXIgY29uc29sZVwiLFxyXG4gICAgICAgIGFzeW5jOiBmYWxzZSxcclxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljOiB7XHJcbiAgICAgICAgICAgIHR5cGVzY3JpcHQ6IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlclNpZzogXCJ0ZXh0OiBzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJ2b2lkXCJcclxuICAgICAgICAgICAgfX0sXHJcbiAgICAgICAgZnVuYzogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGV4dCk7XHJcbiAgICAgICAgfX07XHJcbn1cclxuU3VwcG9ydExpYnJhcnkucHJvdG90eXBlLmxvYWRIVFRQID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZ1bmN0aW9ucy5odHRwUmVxdWVzdCA9IHtcclxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTZW5kIGEgSFRUUChTKSByZXF1ZXN0IHVzaW5nIHRoZSBmZXRjaCBhcGkuIFJldHVybnMgc3RhdHVzPS0xIG9uIHRpbWVvdXQhXCIsXHJcbiAgICAgICAgYXN5bmM6IHRydWUsXHJcbiAgICAgICAgbGFuZ3VhZ2VTcGVjaWZpYzp7XHJcbiAgICAgICAgICAgIHR5cGVzY3JpcHQ6IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlclNpZzogXCJ1cmw6IHN0cmluZywgaGVhZGVyczpzdHJpbmcgPSBudWxsIHwgbnVsbCwgbWV0aG9kOnN0cmluZyA9ICdHRVQnIHwgbnVsbCwgYm9keTpzdHJpbmcgPSBudWxsIHwgbnVsbCwgY2FjaGU6c3RyaW5nID0gJ25vLXN0b3JlJyB8IG51bGwsIHRpbWVvdXQ6aTMyID0gNTAwMFwiLFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuU2lnOiBcInRleHQ6IHN0cmluZywgc3RhdHVzOiBpbnRcIlxyXG4gICAgICAgIH19LFxyXG4gICAgICAgIGZ1bmM6IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGhlYWRlcnMsIG1ldGhvZCwgYm9keSwgY2FjaGUsIHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgbGV0IGluaXQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmKGhlYWRlcnMgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGluaXQuaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmKG1ldGhvZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaW5pdC5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgICAgIGlmKGJvZHkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGluaXQuYm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgIGlmKGNhY2hlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpbml0LmNhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGluaXQuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XHJcblxyXG4gICAgICAgICAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICAgICAgbGV0IHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgaW5pdC5zaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcclxuXHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVTUE9OU0U6XCIpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbdGV4dCwgcmVzcG9uc2Uuc3RhdHVzXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIlRJTUVPVVRcIiwgLTFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfX07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VwcG9ydExpYnJhcnk7IiwiXHJcbmNvbnN0IGF2YWlsYWJsZU9mZmxvYWRpbmdSZXNvdXJjZXMgPSByZXF1aXJlKFwiLi4vb2ZmbG9hZGluZy9vZmZsb2FkaW5nUmVzb3VyY2VzLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGVlcihpZCwgY2FsbGJhY2sgPSAoKSA9PiB7XHJcbn0pIHtcclxuICAgIGxldCBwZWVyID0gbmV3IFBlZXIoaWQsIHtcclxuICAgICAgICBob3N0OiBcImxvY2FsaG9zdFwiLFxyXG4gICAgICAgIHBvcnQ6IDkwMDAsXHJcbiAgICAgICAgcGF0aDogXCIvbXlhcHBcIixcclxuICAgIH0pO1xyXG4gICAgcGVlci5vbignb3BlbicsIGZ1bmN0aW9uIChJRCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNeSBwZWVyIElEIGlzOiAnICsgSUQpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9KTtcclxuICAgIHBlZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xyXG4gICAgfSk7XHJcbiAgICBwZWVyLm9uKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbiAoSUQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygncGVlciBJRCAnICsgSUQrJyBkaXNjb25uZWN0ZWQnKTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHBlZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQoKSB7XHJcbiAgICBsZXQgcGVlciA9IGNyZWF0ZVBlZXIoJycsICgpID0+IHtcclxuICAgICAgICBwZWVyLm9uKCdjb25uZWN0aW9uJywgKGNvKT0+e1xyXG4gICAgICAgICAgICAvLyBQZWVyIGlzIGNob3NlbiAhXHJcbiAgICAgICAgICAgIGNvLm9uKCdkYXRhJywgKGRhdGEpPT57XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIFBpcGVsaW5lIGFuZCBzZW5kIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IGlzIHRoZXJlIGEgd2F5IHRvIGNoZWNrIGlmIHJlY2VpdmVkIGRhdGUgaXMgcmVhbGx5IGEgcGlwZWxpbmUgPyB5ZXNcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogdXNlciBpbnB1dCA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2V0dXAgYW5kIHByb2Nlc3MgdGhlIHBpcGVsaW5lXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzUGlwZWxpbmUoKS50aGVuKChyZXN1bHQpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIHBpcGVsaW5lIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvLnNlbmQocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHBlZXIuY29ubmVjdCgnc291cmNlJyk7XHJcbiAgICAgICAgY29ubmVjdGlvbi5vbignb3BlbicsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nvbm5lY3RlZCB0byBwZWVyOiAnK2Nvbm5lY3Rpb24ucGVlcik7XHJcblxyXG4gICAgICAgICAgICAvL1RPRE86IGdldCBpbnB1dCBmcm9tIGV4ZWN1dGlvbiBtYW5hZ2VyIEdFVCBmcm9udGVuZC5cclxuICAgICAgICAgICAgLy9pbnB1dCBvZmZsb2FkaW5nIHJlc291cmNlcyBsaW1pdHMgTVVTVCBiZSBnbG9iYWwgdmFsdWUgZnJvbSB1c2VyIGlucHV0IChmcm9udGVuZClcclxuICAgICAgICAgICAgYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlcyhvckxpc3QpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmKCFpc05hTihyZXN1bHQpKXtcclxuICAgICAgICAgICAgICAgICAgICAvL3B1c2ggc3RyaW5nICdkbWknIGFzIGxhc3QgZW50cnkgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2RtaScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIGRtaSBhcyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChyZXN1bHQpO31cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Ub2RvIDogY2xvc2UgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy9UT0RPOiBwcm9jZXNzIHBpcGVsaW5lIGluIGV4ZVxyXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzUGlwZWxpbmUocmVjZWl2ZWRQaXBlbGluZSl7XHJcbiAgICAvL1RPRE86IGV4dHJhY3QgaW50ZXJtZWRpYXRlIHJlc3VsdCBmcm9tIHBpcGVsaW5lIHdpdGggYSBuZXcga2V5IGluIHRoZSBvYmplY3RcclxuICAgIC8vaW5wdXQgPSByZWNlaXZlZFBpcGVsaW5lLlxyXG4gICAgbGV0IG1hbmFnZXIgPSBuZXcgc3dldmEuRXhlY3V0aW9uTWFuYWdlcigpO1xyXG4gICAgbWFuYWdlci5zZXR1cChyZWNlaXZlZFBpcGVsaW5lKTtcclxuICAgIHJldHVybiBhd2FpdCBtYW5hZ2VyLmV4ZWN1dGUoaW5wdXQse30pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQiLCJcclxuXHJcbi8vUXVlc3Rpb246IHNob3VsZCBpIGRlY2xhcmUgc2kgb3V0c2lkZSBvciBpbiB0aGUgZnVuY3Rpb24/XHJcbi8qXHJcbi8vIG91dHB1dCBmb3JtYXQgRE1JID0gW2NwdSAlLG1lbSAlLGJhdHRlcnkgJV1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGRldmljZU1vbml0b3JpbmdJbmRleCgpIHtcclxuICAgICAgICBsZXQgbGlzdE9mTWV0cmljcyA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgY3B1ID0gYXdhaXQgc2kuY3VycmVudExvYWQoKS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBnZXR0aW5nIG1lbW9yeScpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBtZW0gPSBhd2FpdCBzaS5tZW0oKS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBnZXR0aW5nIG1lbW9yeScpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBtZW1SU1MgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcblxyXG4gICAgICAgIC8vT3B0aW9uYWw6IGNvbnN0IHN0b3JhZ2UgPSBhd2FpdCBzaS5mc1NpemUoKTtcclxuICAgICAgICBjb25zdCBiYXR0ZXJ5ID0gYXdhaXQgc2kuYmF0dGVyeSgpLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGdldHRpbmcgbWVtb3J5Jyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlzdE9mTWV0cmljcy5wdXNoKGNwdS5hdmdMb2FkLnRvRml4ZWQoMiksICgobWVtUlNTLnJzcy9tZW0uYXZhaWxhYmxlKSoxMDApLnRvRml4ZWQoMiksYmF0dGVyeS5wZXJjZW50KTtcclxuICAgICAgICAvL09wdGlvbmFsOiBjb25zdCBzdGF0dXMgPSBiYXR0ZXJ5LmlzY2hhcmdpbmdcclxuICAgICAgICByZXR1cm4gbGlzdE9mTWV0cmljcztcclxuXHJcbiAgICAvL3RvZG86IGVycm9yIGhhbmRsaW5nXHJcbiAgICB9XHJcblxyXG4vL3doaWxlIGZhbHNlIGNvbnRpbnVlIGV4ZWN1dGluZyBwaXBlbGluZVxyXG4vLyBpZiBvZCA9IFRSVUUsIGFib2FyZCBleGVjdXRpb24gb2YgcHJvbWlzZSBhbmQgb2ZmbG9hZFxyXG5cclxuLy9pbnB1dCBvZmZsb2FkaW5nRGVjaXNpb25MaXN0ID0gW2NwdSAlLCBtZW0gJSwgYmF0dGVyeSAlXVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gb2ZmbG9hZGluZ0RlY2lzaW9uMihvZExpc3QpIHtcclxuICAgIGlmIChvZExpc3RbMF0gPT09IDAgfHwgb2RMaXN0WzFdID09PSAwIHx8IG9kTGlzdFsyXSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IC8vIGNhc2UgMVxyXG4gICAgbGV0IGRtaUxpc3QgPSBhd2FpdCBkZXZpY2VNb25pdG9yaW5nSW5kZXgoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhkbWlMaXN0KTtcclxuICAgICAgICByZXR1cm4gKGRtaUxpc3RbMF0gPCBvZExpc3RbMF0gfHxcclxuICAgICAgICAgICAgZG1pTGlzdFsxXSA8IG9kTGlzdFsxXSB8fFxyXG4gICAgICAgICAgICBkbWlMaXN0WzJdIDwgb2RMaXN0WzJdKTsgLy9jYXNlIDJcclxuXHJcblxyXG5cclxufVxyXG4qL1xyXG5cclxuLy8gT3B0aW1pemVkIERNSSBmdW5jdGlvbjpcclxuLy8gVE9ETyA6IHJlcXVpcmUgbm90IHdvcmtpbmcgaW4gV0VCIGVudmlyb25tZW50ICFcclxuXHJcblxyXG5cclxuXHJcblxyXG5hc3luYyBmdW5jdGlvbiBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KSB7XHJcbiAgICBpZiAob2RMaXN0WzBdID09PSAwIHx8IG9kTGlzdFsxXSA9PT0gMCB8fCBvZExpc3RbMl0gPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGxldCBjcHVMb2FkID0gMDtcclxuICAgIGxldCBtZW1Vc2FnZSA9IDA7XHJcbiAgICBsZXQgYmF0dGVyeVBlcmNlbnQgPSAwO1xyXG4gICAgbGV0IG9mZmxvYWRpbmcgPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vQnJvd3NlciBlbnZpcm9ubWVudFxyXG5cclxuICAgICAgICBtZW1Vc2FnZSA9IChwZXJmb3JtYW5jZS5tZW1vcnkudXNlZEpTSGVhcFNpemUgLyBwZXJmb3JtYW5jZS5tZW1vcnkuanNIZWFwU2l6ZUxpbWl0KSAqIDEwMDtcclxuICAgICAgICBsZXQgYmF0dGVyeSA9IGF3YWl0IG5hdmlnYXRvci5nZXRCYXR0ZXJ5KCk7XHJcbiAgICAgICAgYmF0dGVyeVBlcmNlbnQgPSBiYXR0ZXJ5LmxldmVsICogMTAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL05vZGVKUyBlbnZpcm9ubWVudFxyXG4gICAgICAgIGxldCBzaSA9IHJlcXVpcmUoJ3N5c3RlbWluZm9ybWF0aW9uJyk7XHJcblxyXG4gICAgICAgIGF3YWl0IChbXHJcbiAgICAgICAgICAgIHNpLmN1cnJlbnRMb2FkKCksXHJcbiAgICAgICAgICAgIHNpLm1lbSgpLFxyXG4gICAgICAgICAgICBzaS5iYXR0ZXJ5KClcclxuICAgICAgICBdKS50aGVuKChbY3B1LCBtZW0sIGJhdHRlcnldKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtZW1SU1MgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgICAgICAgIG1lbVVzYWdlID0gKG1lbVJTUy5yc3MgLyBtZW0uYXZhaWxhYmxlKSAqIDEwMDtcclxuICAgICAgICAgICAgY3B1TG9hZCA9IGNwdS5hdmdMb2FkO1xyXG4gICAgICAgICAgICBiYXR0ZXJ5UGVyY2VudCA9IGJhdHRlcnkucGVyY2VudDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NwdSA9ICcsY3B1TG9hZCwgJ21lbSA9ICcsbWVtVXNhZ2UsJ2JhdHRlcnkgPSAnLGJhdHRlcnlQZXJjZW50KTtcclxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZCB3aGlsZSBtb25pdG9yaW5nIGRldmljZTogJyArIGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAgICAgICAgIGlmIChjcHVMb2FkID4gb2RMaXN0WzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTW9uaXRvcmluZyA9IENQVSBsaW1pdCBleGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgb2ZmbG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVtVXNhZ2UgPiBvZExpc3RbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNb25pdG9yaW5nID0gTWVtb3J5IGxpbWl0IGV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICBvZmZsb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXR0ZXJ5UGVyY2VudCA8IG9kTGlzdFsyXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01vbml0b3JpbmcgPSBCYXR0ZXJ5IGxpbWl0IGV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgICAgICBvZmZsb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgIHJldHVybiBvZmZsb2FkaW5nO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gb2ZmbG9hZGluZ0RlY2lzaW9uXHJcblxyXG5cclxuXHJcbi8vZm9yIHRlc3RpbmcgcHVycG9zZXNcclxuXHJcbi8vIFVTRVIgSW5wdXQgb2RMaXN0ID0gW0xpbWl0X2NwdSAlLCBMaW1pdF9tZW0gJSwgTGltaXRfYmF0dGVyeSAlXVxyXG5cclxuLy9sZXQgdGltZSA9MDtcclxubGV0IGk9MDtcclxubGV0IG9kTGlzdCA9WzEwLDEwLDYwXTtcclxubGV0IHN0YXJ0VGltZSA9IG51bGw7XHJcbmxldCBlbmRUaW1lID1udWxsO1xyXG5sZXQgYXZnTGlzdD1bXSA7XHJcblxyXG5cclxuc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgIHN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcbiAgICAgICBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KS50aGVuICgocmVzdWx0KT0+e1xyXG4gICAgICAgZW5kVGltZSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgY29uc29sZS5sb2coJ01vbml0b3JpbmcgUm91bmQgIycraSk7XHJcbiAgICAgICBpKys7XHJcbiAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgY29uc29sZS5sb2coJ0VsYXBzZWQgdGltZTogJysoZW5kVGltZVswXSAqIDEwMDAgKyBlbmRUaW1lWzFdIC8gMTAwMDAwMCkudG9GaXhlZCgyKSsgJyBtcycpO1xyXG4gICB9KTtcclxuXHJcblxyXG59LDE1MDApO1xyXG5cclxuXHJcblxyXG4iLCJcclxuXHJcbi8vaW5wdXQgb3JsOiBvZmZsb2FkaW5nIFJlc291cmNlcyBMaW1pdHMgPSBbT1JjcHUgJSAsT1JtZW0gJSAsT1JiYXR0ZXJ5ICUsIGlzQ2hhcmdpbmcgKGJpbmFyeSldXHJcblxyXG5jb25zdCBzaSA9IHJlcXVpcmUoXCJzeXN0ZW1pbmZvcm1hdGlvblwiKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGF2YWlsYWJsZU9mZmxvYWRpbmdSZXNvdXJjZXMob3JMaXN0KSB7XHJcbiAgICBpZiAob3JMaXN0WzBdID09PSAwIHx8IG9yTGlzdFsxXSA9PT0gMCB8fCBvckxpc3RbMl0gPT09IDApIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgbGV0IGxpc3RPZk1ldHJpY3MgPVtdO1xyXG5cclxuXHJcbiAgICBjb25zdCBbY3B1LCBtZW0sIGJhdHRlcnldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHNpLmN1cnJlbnRMb2FkKCksXHJcbiAgICAgICAgc2kubWVtKCksXHJcbiAgICAgICAgc2kuYmF0dGVyeSgpXHJcbiAgICBdKS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkIHdoaWxlIG1vbml0b3JpbmcgZGV2aWNlIHdpdGggcGFja2FnZSBzeXN0ZW1pbmZvcm1hdGlvbjogJyArIGVycik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjcHVMb2FkID0gY3B1LmF2Z0xvYWQ7XHJcblxyXG4gICAgY29uc3QgZnJlZU1lbSA9ICAoMS0obWVtLmF2YWlsYWJsZS9tZW0udG90YWwpKSoxMDA7IC8vZnJlZSBtZW1vcnkgaW4gcGVyY2VudFxyXG4gICAgY29uc3QgYmF0dGVyeVVzYWdlID0gYmF0dGVyeS5wZXJjZW50OyAvLyBiYXR0ZXJ5IHVzYWdlIGluIHBlcmNlbnRcclxuICAgIGNvbnN0IGJhdHRlcnlJc0NoYXJnaW5nID0gYmF0dGVyeS5hY0Nvbm5lY3RlZDsgLy9iYXR0ZXJ5IGlzIGNoYXJnaW5nIHdoZW4gVFJVRVxyXG5cclxuICAgIGlmICggY3B1TG9hZCA8IG9yTGlzdFswXSB8fCAvL2N1cnJlbnQgY3B1IGxvYWQgaXMgbGVzcyB0aGFuIHVzZXIgaW5wdXRcclxuICAgICAgICBmcmVlTWVtID49b3JMaXN0WzFdIHx8IC8vIGN1cnJlbnQgZnJlZSBtZW1vcnkgaXMgYmlnZ2VyIHRoYW4gdXNlciBpbnB1dFxyXG4gICAgICAgIGJhdHRlcnlVc2FnZSA+PSBvckxpc3RbMl0gfHwgLy8gY3VycmVudCBiYXR0ZXJ5IGlzIGJpZ2dlciB0aGFuIHVzZXIgaW5wdXRcclxuICAgICAgICBiYXR0ZXJ5SXNDaGFyZ2luZyA9PT0gb3JMaXN0WzNdXHJcbiAgICApXHJcbiAgICB7XHJcbiAgICAgICAgLy9PdXRwdXQgbWV0cmljcyBpbiBwZXJjZW50ICVcclxuICAgICAgICBsaXN0T2ZNZXRyaWNzLnB1c2goY3B1TG9hZCxmcmVlTWVtLGJhdHRlcnlVc2FnZSxiYXR0ZXJ5SXNDaGFyZ2luZyk7XHJcbiAgICAgICAgcmV0dXJuKGxpc3RPZk1ldHJpY3MpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgcmV0dXJuIE5hTlxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbi8vZm9yIHRlc3RpbmcgcHVycG9zZXNcclxuXHJcbi8vIFVTQUdFIGV4YW1wbGU6IGlucHV0IGlzIG9kTGlzdFxyXG5cclxuLypcclxuXHJcbmNvbnN0IHN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xyXG5hdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzKFsxMCwxMCwxMCx0cnVlXSkudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICBjb25zdCBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnRUaW1lKTtcclxuICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICBjb25zb2xlLmxvZygnRWxhcHNlZCB0aW1lOiAnKyhlbmRUaW1lWzBdICogMTAwMCArIGVuZFRpbWVbMV0gLyAxMDAwMDAwKS50b0ZpeGVkKDIpKyAnIG1zJyk7XHJcblxyXG59KTtcclxuXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlcyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBc0JpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXMtYmluZC9kaXN0L2FzLWJpbmQuY2pzLmpzJyk7XHJcbnZhciBSdW5uZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3J1bm5lcnMvcnVubmVyLmpzJyk7XHJcbnZhciBDb21waWxlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcGlsZXJzL2Fzc2VtYmx5U2NyaXB0Q29tcGlsZXIuanMnKTtcclxudmFyIENvbXBvc2FibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMnKTtcclxudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcclxudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL0V4ZWN1dGlvbkVycm9yLmpzJyk7XHJcbnZhciBTdXBwb3J0TGlicmFyeSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXhlY3V0aW9uL3N1cHBvcnRMaWJyYXJ5LmpzJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFBhcmFtZXRlcnMgaW4gdGhlIEFzc2VtYmx5U2NyaXB0IHJ1biBmdW5jdGlvbiBzdGFydGluZyB3aXRoIHRoaXMgc3RyaW5nIGFyZSB1c2VkIGZvciB0aGUgdXNlciBpbnB1dHMuXHJcbiAqL1xyXG5jb25zdCB1c2VySW5wdXRTZXBhcmF0b3IgPSBcImlucHV0X1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBBc3NlbWJseVNjcmlwdCBydW5uZXIgc3VwcG9ydHMgc3RyaWN0IFR5cGVTY3JpcHRcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFJ1bm5lclxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gQXNzZW1ibHlTY3JpcHRSdW5uZXIoKSB7XHJcbiAgICB0aGlzLnN1cHBvcnRMaWIgPSBuZXcgU3VwcG9ydExpYnJhcnkoKTtcclxuICAgIHRoaXMuc3VwcG9ydExpYi5sb2FkSFRUUCgpO1xyXG4gICAgdGhpcy5zdXBwb3J0TGliLmxvYWRMb2dnZXIoKTtcclxuICAgIHRoaXMuc3VwcG9ydExpYi5sb2FkVGVzdFN5bmMoKTtcclxuICAgIHRoaXMuY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIodGhpcy5zdXBwb3J0TGliKTtcclxufVxyXG5cclxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmdldEhUTUxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBkZXNjcmlwdGlvbiA9IFwiRmluZCB0aGUgb2ZmaWNpYWwgQXNzZW1ibHlTY3JpcHQgZG9jdW1lbnRhdGlvbiBvbiA8YSBocmVmPSdodHRwczovL3d3dy5hc3NlbWJseXNjcmlwdC5vcmcvaW50cm9kdWN0aW9uLmh0bWwnIHRhcmdldD0nX2JsYW5rJz5hc3NlbWJseXNjcmlwdC5vcmc8L2E+LlxcblwiICtcclxuICAgICAgICBcIlRoZSBleHBvcnRlZCA8Yj5ydW48L2I+IGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHBhcmFtZXRlcnMgYXMgZGF0YSBpbnB1dHMgYW5kIHJldHVybmVkIGRhdGEgYXMgYW4gb3V0cHV0IGNhbGxlZCA8Yj5vdXQ8L2I+LiBVc2VyIGlucHV0cyBoYXZlIHRvIGJlIHByZWZpeGVkIHdpdGggPGI+aW5wdXRfPC9iPiBhbmQgYmUgdGhlIGZpcnN0IHBhcmFtZXRlcnMuXFxuXCIgK1xyXG4gICAgICAgIFwiQWRkaXRpb25hbCBvdXRwdXRzIGFyZSBnZW5lcmF0ZWQgZm9yIGV4cG9ydGVkIGdsb2JhbCB2YXJpYWJsZXMuIFRoaXMgYWxsb3dzIHJldHVybmluZyB2YWx1ZXMgcmVzdWx0aW5nIGZyb20gYXN5bmNocm9ub3VzIGNhbGxiYWNrcy5cXG5cIiArXHJcbiAgICAgICAgXCJJZiB0aGUgPGI+cnVuPC9iPiBmdW5jdGlvbiBoYXMgdGhlIHJldHVybiB0eXBlIFxcXCJ2b2lkXFxcIiBubyBkZWZhdWx0IG91dHB1dCBpcyBnZW5lcmF0ZWQuXFxuXCI7XHJcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcblwiICsgdGhpcy5jb21waWxlci5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb247XHJcblxyXG4gICAgLy9IVE1MIG5ldyBsaW5lc1xyXG4gICAgZGVzY3JpcHRpb24ucmVwbGFjZUFsbChcIlxcblwiLCBcIjxicj5cIik7XHJcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbn07XHJcblxyXG4vL2luaGVyaXQgcHJvcGVydGllc1xyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJ1bm5lci5wcm90b3R5cGUpO1xyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlbWJseVNjcmlwdFJ1bm5lcjtcclxuXHJcbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5uYW1lID0gXCJUeXBlU2NyaXB0ICh1c2luZyBBc3NlbWJseVNjcmlwdClcIjtcclxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmlkID0gXCJ0eXBlc2NyaXB0XCI7XHJcblxyXG4vLz09PSBPRkZMT0FESU5HID09PSBNb2R1bGUgPT4gQVNDIGNvZGUgdG8gV0FTTSBiaW5hcnlcclxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLnByZXBhcmUgPSBhc3luYyBmdW5jdGlvbiAobW9kdWxlLCBjYWxsYmFja0xpc3QgPSBbXSkge1xyXG4gICAgbGV0IGRlZmluaXRpb25EYXRhID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIW1vZHVsZS5iaW5hcnkgfHwgbW9kdWxlLmJpbmFyeS5sZW5ndGggPT09IDAgfHwgbW9kdWxlLmJpbmFyeUhhc2ggIT09IHRoaXMuY2FsY3VsYXRlQmluYXJ5SGFzaChtb2R1bGUuYmluYXJ5KSkge1xyXG4gICAgICAgIG1vZHVsZS5iaW5hcnlIYXNoID0gbnVsbDtcclxuICAgICAgICAvLyBtb25pdG9yZWQgY29tcGlsYXRpb24gaW4gQVNDY29tcGlsZXIuanNcclxuICAgICAgICBsZXQgY29tcGlsZXJSZXN1bHQgPSBhd2FpdCB0aGlzLmNvbXBpbGVyLmNvbXBpbGUobW9kdWxlKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBpbGVyUmVzdWx0Jyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBpbGVyUmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKGNvbXBpbGVyUmVzdWx0ID09PSAnb2ZmbG9hZGluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vdG9kbzogT2ZmbG9hZGluZyBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib2ZmbG9hZGluZyBpbnRlcmNlcHRlZCBpbiBBU0NSdW5uZXIucHJlcGFyZSgpXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZmxvYWRpbmcnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlLmJpbmFyeSA9IGNvbXBpbGVyUmVzdWx0LmJpbmFyeURhdGE7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuYmluYXJ5SGFzaCA9IHRoaXMuY2FsY3VsYXRlQmluYXJ5SGFzaChtb2R1bGUuYmluYXJ5KTtcclxuICAgICAgICAgICAgICAgIGRlZmluaXRpb25EYXRhID0gY29tcGlsZXJSZXN1bHQuZGVmaW5pdGlvbkRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBhd2FpdCBBc0JpbmQuaW5zdGFudGlhdGUobW9kdWxlLmJpbmFyeSwge1xyXG4gICAgICAgIG1vZHVsZTogdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uRGVzY3JpcHRpb24oY2FsbGJhY2tMaXN0KVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb25EYXRhICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhU2NoZW1hKG1vZHVsZSwgbW9kdWxlSW5zdGFuY2UsIGRlZmluaXRpb25EYXRhKTtcclxuXHJcbiAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2U7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogIHdyYXBwZXIgZm9yXHJcbiAqL1xyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZ2VuZXJhdGVGdW5jdGlvbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrTGlzdCkge1xyXG4gICAgbGV0IGZ1bmN0aW9ucyA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGZ1bmNOYW1lIGluIHRoaXMuc3VwcG9ydExpYi5mdW5jdGlvbnMpIHtcclxuICAgICAgICBsZXQgZnVuY0Rlc2MgPSB0aGlzLnN1cHBvcnRMaWIuZnVuY3Rpb25zW2Z1bmNOYW1lXTtcclxuICAgICAgICBsZXQgZnVuY3Rpb25SZWZlcmVuY2U7XHJcblxyXG4gICAgICAgIGlmIChmdW5jRGVzYy5hc3luYykge1xyXG4gICAgICAgICAgICAvL3BhcmFtcyBoYXMgY2FsbGJhY2sgbmFtZSBhcyBmaXJzdCBhcmd1bWVudCBmb2xsb3dlZCBieSByZWd1bGFyIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgZnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiAoLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2tOYW1lID0gcGFyYW1zWzBdO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2U6IGZ1bmNEZXNjLmZ1bmMoLi4ucGFyYW1zKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZnVuY05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tOYW1lOiBjYWxsYmFja05hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jRGVzYy5mdW5jO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb25zW1wibGliLlwiICsgZnVuY05hbWVdID0gZnVuY3Rpb25SZWZlcmVuY2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb25zO1xyXG59XHJcblxyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChtb2R1bGUsIGRhdGEsIGlucHV0KSB7XHJcblxyXG4gICAgbGV0IGNhbGxiYWNrTGlzdCA9IFtdO1xyXG4gICAgLypcclxuICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBBU0MgcnVubmVyIGlucHV0cyAvLy8vLy8vLy8vLy8vL1wiKTtcclxuICAgIGNvbnNvbGUubG9nKFwibW9kdWxlXCIpO1xyXG4gICAgY29uc29sZS5sb2cobW9kdWxlKTtcclxuICAgIGNvbnNvbGUubG9nKFwiZGF0YVwiKTtcclxuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgY29uc29sZS5sb2coXCJpbnB1dFwiKTtcclxuICAgIGNvbnNvbGUubG9nKGlucHV0KTtcclxuICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xyXG4gICAgICovXHJcbiAgICAvL2NvbXBpbGUgYW5kIHVwZGF0ZSBzY2hlbWFcclxuICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IHRoaXMucHJlcGFyZShtb2R1bGUsIGNhbGxiYWNrTGlzdCk7XHJcbiAgICBjb25zb2xlLmxvZygnaW5zdGFuY2UnKTtcclxuICAgIGNvbnNvbGUubG9nKGluc3RhbmNlKTtcclxuICAgIGlmIChpbnN0YW5jZSA9PT0gJ29mZmxvYWRpbmcnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmcgaW50ZXJjZXB0ZWQgaW4gQVNDUnVubmVyLmV4ZWMoKScpO1xyXG4gICAgICAgIHJldHVybiAnb2ZmbG9hZGluZyc7XHJcblxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ21vZHVsZSBwcmVwYXJlZD0gJyk7XHJcbiAgICBjb25zb2xlLmxvZyhtb2R1bGUpO1xyXG5cclxuICAgIGxldCBwcmVwYXJlZFBhcmFtcyA9IFtdO1xyXG4gICAgaWYgKG1vZHVsZS5pbnB1dE5hbWVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgcHJlcGFyZWRQYXJhbXMgPSBwcmVwYXJlZFBhcmFtcy5jb25jYXQodGhpcy5maW5kUGFyYW1Bc3NpZ25tZW50KG1vZHVsZS5pbnB1dE5hbWVzLCBpbnB1dCwgbW9kdWxlLmNvbnRleHQpKTtcclxuICAgIGlmIChtb2R1bGUuZGF0YUluTmFtZXMubGVuZ3RoID4gMClcclxuICAgICAgICBwcmVwYXJlZFBhcmFtcyA9IHByZXBhcmVkUGFyYW1zLmNvbmNhdCh0aGlzLmZpbmRQYXJhbUFzc2lnbm1lbnQobW9kdWxlLmRhdGFJbk5hbWVzLCBkYXRhLCBtb2R1bGUuY29udGV4dCkpO1xyXG5cclxuICAgIC8vTW9kdWxlIGlucHV0XHJcbiAgICBjb25zb2xlLmxvZygnTW9kdWxlIHNvdXJjZSBjb2RlIGlucHV0Jyk7XHJcbiAgICBjb25zb2xlLmxvZyhwcmVwYXJlZFBhcmFtcyk7XHJcblxyXG4gICAgLy8gcmV0dXJuVmFsdWUgcmV0dXJucyB0aGUgcmVzdWx0IGZyb20gdGhlIGJpbmFyeSBleGVjdXRpb24gb2YgdGhlIFdBU00gbW9kdWxlXHJcbiAgICAvL3RvZG8gZXhlY3V0ZSB0aGlzIGFmdGVyIGNoZWNraW5nIERNSSAhIGlmKCkgZWxzZSAuLi5cclxuICAgIC8vIFRPRE8gUHJvbWlzZS5SYWNlIGhlcmUhISEhISEhIVxyXG4gICAgbGV0IHJldHVyblZhbHVlID0gaW5zdGFuY2UuZXhwb3J0cy5ydW4oLi4ucHJlcGFyZWRQYXJhbXMpO1xyXG4gICAgY29uc29sZS5sb2coJ3JldHVyblZhbHVlID0gJyk7XHJcbiAgICBjb25zb2xlLmxvZyhyZXR1cm5WYWx1ZSk7XHJcblxyXG4gICAgLy9maW5pc2ggZXhlY3V0aW5nIGFsbCBhc3luY2hyb25vdXMgZnVuY3Rpb25zICggaWYgY2FsbGJhY2sgZnVuY3Rpb25zIGFyZSBuZWVkZWQgYnkgdGhlIG1vZHVsZSApXHJcbiAgICB3aGlsZSAoY2FsbGJhY2tMaXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlJlbWFpbmluZyBDYWxsYmFjazogXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGNhbGxiYWNrTGlzdFswXSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy90b2RvOiBtb25pdG9yIHRoaXM/XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrTGlzdFswXS5wcm9taXNlO1xyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4ZWN1dGlvbkVycm9yKFwiRXJyb3IgaW4gc3VwcG9ydCBmdW5jdGlvbiBcIiArIGNhbGxiYWNrTGlzdFswXS5mdW5jTmFtZSArIFwiIHdpdGggcGFyYW1ldGVycyBcIiArIGNhbGxiYWNrTGlzdFswXS5wYXJhbXMgKyBcIiFcIiwgbW9kdWxlLmNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xyXG5cclxuICAgICAgICAgICAgbGV0IGNhbGxiYWNrRGVzY3JpcHRvciA9IGluc3RhbmNlLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zW2NhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWVdO1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRGVzY3JpcHRvcilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWZpbml0aW9uRXJyb3IoXCJDYWxsYmFjayBmdW5jdGlvbiB3aXRoIG5hbWUgXCIgKyBjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lICsgXCIgbm90IGZvdW5kIVwiLCBtb2R1bGUuY29udGV4dCk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWUgIT0gbnVsbCAmJiBjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYXRjaCBudW1iZXIgb2YgcGFyYW1ldGVycyBvZiBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWxsYmFja1BhcmFtQ291bnQgPSBjYWxsYmFja0Rlc2NyaXB0b3IucGFyYW1ldGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXBhcmVkUmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGNhbGxiYWNrUGFyYW1Db3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnNbY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RvZG86IGRvIHNvbWV0aGluZyB3aXRoIGNhbGxiYWNrIHJldHVybnM/XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlID0gaW5zdGFuY2UuZXhwb3J0c1tjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lXSguLi5wcmVwYXJlZFJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYWxsYmFjayByZXR1cm46IFwiICsgcmV0dXJuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRpb25FcnJvcihcIkVycm9yIHdoaWxlIGNhbGxpbmcgY2FsbGJhY2sgZnVuY3Rpb24gXCIgKyBjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lICsgXCIgd2l0aCBwYXJhbWV0ZXJzICdcIiArIHJlc3VsdCArIFwiJyFcIiwgbW9kdWxlLmNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrTGlzdC5zaGlmdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdE91dHB1dERhdGEoaW5zdGFuY2UsIHJldHVyblZhbHVlKTtcclxufVxyXG5cclxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmNvbGxlY3RPdXRwdXREYXRhID0gZnVuY3Rpb24gKG1vZHVsZUluc3RhbmNlLCByZXR1cm5WYWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHt9O1xyXG5cclxuICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzdWx0Lm91dCA9IHJldHVyblZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ0FzQmluZCcpO1xyXG4gICAgY29uc29sZS5sb2coQXNCaW5kKTtcclxuICAgIGNvbnNvbGUubG9nKCdtb2R1bGVJbnN0YW5jZScpO1xyXG4gICAgY29uc29sZS5sb2cobW9kdWxlSW5zdGFuY2UpO1xyXG5cclxuXHJcbiAgICBmb3IgKGxldCBleHBvcnRlZE9iaiBpbiBtb2R1bGVJbnN0YW5jZS5leHBvcnRzKSB7XHJcbiAgICAgICAgaWYgKG1vZHVsZUluc3RhbmNlLmV4cG9ydHNbZXhwb3J0ZWRPYmpdIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuR2xvYmFsICYmICFleHBvcnRlZE9iai5zdGFydHNXaXRoKFwiX19cIikpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2V4cG9ydGVkT2JqXSA9IG1vZHVsZUluc3RhbmNlLmV4cG9ydHNbdGhpcy5jb21waWxlci5pbnRlcm5hbEdldHRlclByZWZpeCArIGV4cG9ydGVkT2JqXSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCdyZXN1bHQnKTtcclxuICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZmluZFBhcmFtQXNzaWdubWVudCA9IGZ1bmN0aW9uIChuYW1lcywgdmFsdWVzLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcHJlcGFyZWRQYXJhbXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgaW4gbmFtZXMpIHtcclxuICAgICAgICBsZXQgbWF0Y2hGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnB1dE5hbWUgaW4gdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gPT09IGlucHV0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVkUGFyYW1zLnB1c2godmFsdWVzW2lucHV0TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbWF0Y2hGb3VuZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIk1pc21hdGNoIGJldHdlZW4gcmVjZWl2ZWQgYW5kIGV4cGVjdGVkIHBhcmFtZXRlcnMhXFxuRXhwZWN0ZWQgXFxcIlwiICsgbmFtZXNbaV0gKyBcIlxcXCIsIGJ1dCBub3QgY29udGFpbmVkIGluIHJlY2VpdmVkIHBhcmFtZXRlcnM6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbXM7XHJcbn1cclxuXHJcblxyXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUucGFyc2VBc3NlbWJseVNjcmlwdFZhcmlhYmxlTmFtZXMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbkRhdGEpIHtcclxuICAgIGxldCBwYXJhbU5hbWVzID0gQXJyYXkoKTtcclxuICAgIGxldCBsaW5lcyA9IGRlZmluaXRpb25EYXRhLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgZm9yIChsZXQgbGluZSBpbiBsaW5lcykge1xyXG4gICAgICAgIGlmIChsaW5lc1tsaW5lXS5pbmRleE9mKFwiZXhwb3J0IGZ1bmN0aW9uIHJ1blwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gbGluZXNbbGluZV0uc3Vic3RyaW5nKGxpbmVzW2xpbmVdLmluZGV4T2YoJygnKSArIDEsIGxpbmVzW2xpbmVdLmluZGV4T2YoJyknKSkuc3BsaXQoJywgJyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1OYW1lID0gcGFyYW1zW2ldLnN1YnN0cmluZygwLCBwYXJhbXNbaV0uaW5kZXhPZihcIjpcIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtTmFtZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtTmFtZXM7XHJcbn1cclxuXHJcbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5jcmVhdGVEYXRhU2NoZW1hID0gZnVuY3Rpb24gKG1vZHVsZSwgbW9kdWxlSW5zdGFuY2UsIGRlZmluaXRpb25EYXRhKSB7XHJcbiAgICBsZXQgcnVuID0gbW9kdWxlSW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnMucnVuO1xyXG5cclxuICAgIC8vdmVyaWZ5IGVudHJ5cG9pbnQgZXhpc3RzXHJcbiAgICBpZiAocnVuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIk1pc3NpbmcgZW50cnlwb2ludDogZXhwb3J0ZWQgZnVuY3Rpb24gbmFtZWQgcnVuIGlzIHJlcXVpcmVkLCBhcyBhbiBlbnRyeXBvaW50LlwiLCBtb2R1bGUuY29udGV4dCk7XHJcblxyXG4gICAgLy9pbnB1dHNcclxuICAgIC8vcGFyc2UgcGFyYW1ldGVyIG5hbWVzIG9mIHJ1biBmdW5jdGlvbiAtIHJlcGxhY2UsIGlmIEFzc2VtYmx5U2NyaXB0IEFQSSwgdG8gYWNjZXNzIHBhcmFtZXRlciBuYW1lcyBiZWNvbWVzIGF2YWlsYWJsZVxyXG4gICAgbGV0IHBhcmFtTmFtZXMgPSB0aGlzLnBhcnNlQXNzZW1ibHlTY3JpcHRWYXJpYWJsZU5hbWVzKGRlZmluaXRpb25EYXRhKTtcclxuXHJcbiAgICBpZiAocnVuLnBhcmFtZXRlcnMubGVuZ3RoICE9PSBwYXJhbU5hbWVzLmxlbmd0aClcclxuICAgICAgICB0aHJvdyBuZXcgRGVmaW5pdGlvbkVycm9yKFwiUGFyYW1ldGVyIGxlbmd0aCBtaXNtYXRjaCEgUGFyYW1ldGVycyBjb3VsZCBub3QgYmUgcGFyc2VkIGZ1bGx5IVwiLCBtb2R1bGUuY29udGV4dCk7XHJcblxyXG4gICAgbW9kdWxlLmRhdGFJbk5hbWVzID0gW107XHJcbiAgICBtb2R1bGUuaW5wdXROYW1lcyA9IFtdO1xyXG4gICAgbW9kdWxlLmRhdGFJblNjaGVtYSA9IHt0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiB7fX07XHJcbiAgICBtb2R1bGUuaW5wdXRTY2hlbWEgPSB7dHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczoge319O1xyXG5cclxuICAgIGZvciAobGV0IGkgaW4gcnVuLnBhcmFtZXRlcnMpIHtcclxuICAgICAgICBpZiAocGFyYW1OYW1lc1tpXS5zdGFydHNXaXRoKHVzZXJJbnB1dFNlcGFyYXRvcikpIHtcclxuICAgICAgICAgICAgbW9kdWxlLmlucHV0TmFtZXMucHVzaChwYXJhbU5hbWVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIG1vZHVsZS5pbnB1dFNjaGVtYS5wcm9wZXJ0aWVzW3BhcmFtTmFtZXNbaV1dID0ge3R5cGU6IHJ1bi5wYXJhbWV0ZXJzW2ldfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtb2R1bGUuZGF0YUluTmFtZXMucHVzaChwYXJhbU5hbWVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhSW5TY2hlbWEucHJvcGVydGllc1twYXJhbU5hbWVzW2ldXSA9IHt0eXBlOiBydW4ucGFyYW1ldGVyc1tpXX07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vb3V0cHV0c1xyXG4gICAgbW9kdWxlLmRhdGFPdXROYW1lcyA9IFtdO1xyXG4gICAgbW9kdWxlLmRhdGFPdXRTY2hlbWEgPSB7dHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczoge319O1xyXG4gICAgZm9yIChsZXQgZXhwb3J0ZWRPYmogaW4gbW9kdWxlSW5zdGFuY2UuZXhwb3J0cykge1xyXG4gICAgICAgIGlmIChtb2R1bGVJbnN0YW5jZS5leHBvcnRzW2V4cG9ydGVkT2JqXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkdsb2JhbCAmJiAhZXhwb3J0ZWRPYmouc3RhcnRzV2l0aChcIl9fXCIpKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0TmFtZXMucHVzaChleHBvcnRlZE9iaik7XHJcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0U2NoZW1hLnByb3BlcnRpZXNbZXhwb3J0ZWRPYmpdID0ge3R5cGU6IG1vZHVsZUluc3RhbmNlLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zW3RoaXMuY29tcGlsZXIuaW50ZXJuYWxHZXR0ZXJQcmVmaXggKyBleHBvcnRlZE9ial19XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJ1bi5yZXR1cm5UeXBlICE9PSAndm9pZCcpIHtcclxuICAgICAgICBpZiAoIW1vZHVsZS5kYXRhT3V0TmFtZXMuaW5jbHVkZXMoJ291dCcpKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0TmFtZXMucHVzaCgnb3V0Jyk7XHJcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0U2NoZW1hLnByb3BlcnRpZXNbJ291dCddID0ge3R5cGU6IHJ1bi5yZXR1cm5UeXBlfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWZpbml0aW9uRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIGNhbGxlZCAnb3V0JyEgRG8gbm90IHVzZSAnb3V0JyBhcyBhIG5hbWUgZm9yIGV4cG9ydGVkIHZhcmlhYmxlcyFcIiwgbW9kdWxlLmNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXNzZW1ibHlTY3JpcHRSdW5uZXI7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgcnVubmVyIGV4ZWN1dGVzIHRoZSBjb21waWxlZCBjb2RlIG1hZGUgYXZhaWxhYmxlIGJ5IHRoZSBjb21waWxlciBhbmQgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIG1hdGNoaW5nIGNvbXBpbGVyXHJcbiAqIEl0IGhhcyB0d28gcGhhc2VzOiBBIHNldHVwIHBoYXNlLCB3ZXJlIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgYW5kIGFuIG9wZXJhdGlvbmFsIHBoYXNlLCB3aGljaCBpcyB1c2VkIHRvIGNvbXBpbGUgY29kZVxyXG4gKiBUaGUgc2V0dXAgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UsIHdoaWxlIHRoZSBleGVjdXRpb24gY2FuIGJlIHJlcGVhdGVkIG9uIGRpZmZlcmVudCBkYXRhLlxyXG4gKiBcclxuICogVGhpcyBpcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHdoaWNoIHNob3VsZCBiZSBzdWJjbGFzc2VkIGZvciBlYWNoIHN1cHBvcnRlZCBsYW5ndWFnZVxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuZnVuY3Rpb24gUnVubmVyKCkge1xyXG4gICAgLyoqXHJcbiAgICAqIERldGVybWluZXMsIGlmIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkLlxyXG4gICAgKiBAbmFtZSBFeGVjdXRpb25NYW5hZ2VyI21vZHVsZXNUb3RhbFxyXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICB0aGlzLnNldHVwQ29tcGxldGVkID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW4gdGhlIHByb3ZpZGVkIGJpbmFyeSBvciBzb3VyY2UgY29kZVxyXG4gKiBAcGFyYW0ge21vZHVsZX0gbW9kdWxlIC0gbW9kdWxlIGNvbnRhaW5pbmcgc291cmNlIGNvZGUvYmluYXJ5IHRvIHJ1blxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGRhdGEgcGFzc2VkIHRvIHRoZSBwcm9jZXNzaW5nIG5vZGVcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gaW5wdXRzIHBhc3NlZCB0byB0aGUgcHJvY2Vzc2luZyBub2RlXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuUnVubmVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG1vZHVsZSwgZGF0YSwgaW5wdXQpIHtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByZXBhcmUgdGhlIHByb3ZpZGVkIG1vZHVsZSBmb3IgZXhlY3V0aW9uOlxyXG4gKiAtIGNvbXBpbGUsIGlmIG5vdCBhbHJlYWR5IGNvbXBpbGVkXHJcbiAqIC0gdXBkYXRlIHJlZmVyZW5jZXMgdG8gYmluYXJ5L2hhc2hcclxuICogLSB1cGRhdGUgZGF0YSBzY2hlbWVzXHJcbiAqIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHZhbGlkYXRlIG5ldyBzb3VyY2UgY29kZSB3aGlsZSBlZGl0aW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7bW9kdWxlfSBtb2R1bGUgLSBtb2R1bGUgY29udGFpbmluZyBzb3VyY2UgY29kZS9iaW5hcnkgdG8gcnVuXHJcbiAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgcmVhZHkgdG8gZXhlY3V0ZVxyXG4gKiBAdGhyb3dzIENvbXBpbGVFcnJvclxyXG4gKlxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcblJ1bm5lci5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChtb2R1bGUpIHt9XHJcblxyXG4vKipcclxuICogRW5kIHVzZXIgZnJpZW5kbHkgTmFtZVxyXG4gKi9cclxuUnVubmVyLnByb3RvdHlwZS5uYW1lID0gXCJBYnN0cmFjdCBSdW5uZXJcIlxyXG5cclxuLyoqXHJcbiAqIElEIHVzZWQgaW50ZXJuYWxseSwgdG8gaWRlbnRpZnkgcnVubmVyc1xyXG4gKi9cclxuUnVubmVyLnByb3RvdHlwZS5pZCA9IFwiYWJzdHJhY3RfcnVubmVyXCJcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJuIERlc2NyaXB0aW9uIG9mIHRoZSBydW5uZXIgaW5jbHVkaW5nIGEgbGluayB0byB0aGUgb2ZmaWNpYWwgZG9jdW1lbnRhdGlvbiBhbmQgc3VwcG9ydCBsaWJyYXJ5IGV4cGxhbmF0aW9uIGFzIGh0bWwuXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuUnVubmVyLnByb3RvdHlwZS5nZXRIVE1MRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIEhhc2ggdXNlZCB0byBjb21wYXJlIGJpbmFyaWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYmluYXJ5IC0gYmluYXJ5IHRvIGhhc2hcclxuICogQHJldHVybiBoYXNoXHJcbiAqXHJcbiAqL1xyXG5SdW5uZXIucHJvdG90eXBlLmNhbGN1bGF0ZUJpbmFyeUhhc2ggPSBmdW5jdGlvbiAoYmluYXJ5KSB7XHJcbiAgICBsZXQgaGFzaCA9IDA7XHJcbiAgICBmb3IobGV0IGkgaW4gYmluYXJ5KSB7XHJcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA4KS1oYXNoKStiaW5hcnlbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBkYXRhIHNjaGVtYSBiYXNlZCBvbiBzb3VyY2UvYmluYXJ5IGFuZCB3cml0ZSByZXN1bHRzIHRvIHRoZSBtb2R1bGVcclxuICogVGhlIHByb3BlcnRpZXMgZGF0YUluU2NoZW1hLCBkYXRhT3V0U2NoZW1hLCBpbnB1dFNjaGVtYSwgZGF0YUluTmFtZXMsIGRhdGFPdXROYW1lcywgaW5wdXROYW1lcyBvZiB0aGUgbW9kdWxlIGNhbiBiZSB3cml0dGVuXHJcbiAqIENhbGxlZCBhdXRvbWF0aWNhbGx5LCB3aGVuIG5ldyBzb3VyY2UgaXMgY29tcGlsZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBtYW51YWxseSByZWdlbmVyYXRlIGRhdGEgc2NoZW1hXHJcbiAqXHJcbiAqIEBwYXJhbSB7bW9kdWxlfSBtb2R1bGUgLSBtb2R1bGUgY29udGFpbmluZyBzb3VyY2UgY29kZS9iaW5hcnlcclxuICpcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5SdW5uZXIucHJvdG90eXBlLmNyZWF0ZURhdGFTY2hlbWEgPSBmdW5jdGlvbiAobW9kdWxlKSB7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUnVubmVyIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgSnNUb2tlbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtdG9rZW5zL2luZGV4LmpzJyk7XHJcbi8qKlxyXG4gKiBSZXNwb25zaWJsZSB0byB2ZXJpZnkgaWYgYSBzdHJpbmcgY29tcGxpZXMgdG8gYSBzYWZlICBKYXZhU2NyaXB0IHN1YnNldC5cclxuICogQSBibGFja2xpc3QgdXNlZCB0byBlbnN1cmUgbm8gaGFybWZ1bCBvcGVyYXRpb24gY2FuIGJlIHBlcmZvcm1lZCBieSB1c2VyIGRlZmluZWQgc2NyaXB0cy5cclxuICogQ3VycmVudGx5IHRoZSBmb2xsb3dpbmcgdG9rZW5zIGFyZSBmb3JiaWRkZW46XHJcbiAqIGFyZ3VtZW50cywgY2FsbGVlLCBjYWxsZXIsIGNvbnN0cnVjdG9yLCBldmFsLCBwcm90b3R5cGUsIHN0YWNrLCB1bndhdGNoLCB2YWx1ZU9mLCB3YXRjaCwgX19wcm90b19fLCBfX3BhcmVudF9fLCAndGhpcycsIHdpbmRvdywgZG9jdW1lbnQsICdbJywgJ10nLCBGdW5jdGlvbiwgJ3dpdGgnLCB1bmV2YWwsIHRvU291cmNlLCBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbFxyXG4gKiBVc2Uge0BsaW5rIFN3ZXZhU2NyaXB0I2dldH0gYXMgYSByZXBsYWNlbWVudCBmb3IgW10uXHJcbiAqIFxyXG4gKiBBZGRpdGlvbmFsbHkgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbWFza2VkLlxyXG4gKiBAY29uc3RydWN0b3IgXHJcbiAqL1xyXG5mdW5jdGlvbiBTd2V2YVNjcmlwdCgpIHtcclxuICAgIC8qKlxyXG4gICAgKiBMaXN0IG9mIGZvcmJpZGRlbiB0b2tlbnMsIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgSmF2YVNjcmlwdCBzdWJzZXQuXHJcbiAgICAqIEBuYW1lIFN3ZXZhU2NyaXB0I2ZvcmJpZGRlbkxpc3RcclxuICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBib29sZWFuPn1cclxuICAgICovXHJcbiAgICB0aGlzLmZvcmJpZGRlbkxpc3QgPSB7XHJcbiAgICAgICAgYXJndW1lbnRzOiB0cnVlLFxyXG4gICAgICAgIGNhbGxlZTogdHJ1ZSxcclxuICAgICAgICBjYWxsZXI6IHRydWUsXHJcbiAgICAgICAgY29uc3RydWN0b3I6IHRydWUsXHJcbiAgICAgICAgZXZhbDogdHJ1ZSxcclxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXHJcbiAgICAgICAgc3RhY2s6IHRydWUsXHJcbiAgICAgICAgdW53YXRjaDogdHJ1ZSxcclxuICAgICAgICB2YWx1ZU9mOiB0cnVlLFxyXG4gICAgICAgIHdhdGNoOiB0cnVlLFxyXG5cclxuICAgICAgICBfX3Byb3RvX186IHRydWUsXHJcbiAgICAgICAgX19wYXJlbnRfXzogdHJ1ZSxcclxuICAgICAgICAndGhpcyc6IHRydWUsXHJcbiAgICAgICAgd2luZG93OiB0cnVlLFxyXG4gICAgICAgIGRvY3VtZW50OiB0cnVlLFxyXG4gICAgICAgICdbJzogdHJ1ZSxcclxuICAgICAgICAnXSc6IHRydWUsXHJcbiAgICAgICAgRnVuY3Rpb246IHRydWUsXHJcbiAgICAgICAgJ3dpdGgnOiB0cnVlLFxyXG4gICAgICAgIHVuZXZhbDogdHJ1ZSxcclxuICAgICAgICB0b1NvdXJjZTogdHJ1ZSxcclxuICAgICAgICBzZXRUaW1lb3V0OiB0cnVlLFxyXG4gICAgICAgIHNldEludGVydmFsOiB0cnVlXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogTGlzdCBvZiBhbGxvd2VkIGdsb2JhbCB2YXJpYWJsZXMsIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXNrZWQuXHJcbiAgICAqIFRoaXMgaXMgY3VycmVudGx5OiBNYXRoLCBjb25zb2xlIFxyXG4gICAgKiBAbmFtZSBTd2V2YVNjcmlwdCNhbGxvd2VkR2xvYmFsc1xyXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fVxyXG4gICAgKi9cclxuICAgIHRoaXMuYWxsb3dlZEdsb2JhbHMgPSB7XHJcbiAgICAgICAgTWF0aDogdHJ1ZSxcclxuICAgICAgICBjb25zb2xlOiB0cnVlLFxyXG4gICAgICAgICd0cnVlJzogdHJ1ZSxcclxuICAgICAgICAnZmFsc2UnOiB0cnVlXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyBpZiBhIEphdmFTY3JpcHQgY29kZSBjb21wbGllcyB0byB0aGUgc2FmZXIgSmF2YVNjcmlwdCBzdWJzZXQuXHJcbiAqIERvZXMgbm90IHJld3JpdGUgb3IgY2hhbmdlIHRoZSBjb2RlLCB0aGVyZWZvciB5b3Ugc2hvdWxkIERFTlkgYW55dGhpbmcsIHRoYXQgaXMgY29uc2lkZXJlZCBoYXJtZnVsIGJ5IHRoaXMgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIFRoZSBKYXZhU2NyaXB0IGNvZGUgdG8gdmVyaWZ5IGZvciBzYWZldHkuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlLCBpZiB0aGUgY29kZSBkb2VzIG5vdCBjb250YWluIGZvcmJpZGRlbiB0b2tlbnMuXHJcbiAqL1xyXG5Td2V2YVNjcmlwdC5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy9nZXQgYW4gYXJyYXkgb2YgdG9rZW5zIHVzaW5nIHRoZSB0b2tlbml6ZXIgKGV4dGVybmFsIGxpYnJhcnkpXHJcbiAgICAgICAgdmFyIHRva2VucyA9IGNvZGUubWF0Y2goSnNUb2tlbnMpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6IGUubWVzc2FnZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgXHJcbiAgICAvL2NoZWNrIGZvciBlYWNoIHRva2VuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXS50cmltKCk7XHJcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy9pZiB0b2tlbiBub24gZW1wdHk6IGlzIGl0IGluIHRoZSBibGFja2xpc3Q/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmJpZGRlbkxpc3QuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgdXNhZ2Ugb2YgJyArIHRva2VuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvL2lmIG5vIHJldHVybiByZWFjaGVkIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGVyZSB3YXMgbm8gZm9yYmlkZGVuIHRva2VuIHByZXNlbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgZXJyb3I6ICcnXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgdGhlIGZvcmJpZGRlbiBbXSBhY2Nlc3NvciwgYnkgY2hlY2tpbmcgdGhlIHByb3BlcnR5IG5hbWUgZHVyaW5nIHJ1bnRpbWUuXHJcbiAqIElmIGEgZm9yYmlkZGVuIHByb3BlcnR5IChzZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSkgaXMgdXNlZCwgdGhlIHByb3BlcnR5IGlzIG5vdCBhY2Nlc3NlZC5cclxuICogXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlcXVpcmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmcm9tLlxyXG4gKiByZXR1cm5zIHtPYmplY3R8Ym9vbGVhbnxzdHJpbmd8bnVtYmVyfSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGFuIGlsbGVnYWwgcHJvcGVydHkgbmFtZSBpcyB1c2VkIG51bGwuXHJcbiAqL1xyXG5Td2V2YVNjcmlwdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcclxuICAgIHZhciBmb3JiaWRkZW5MaXN0ID0ge1xyXG4gICAgICAgIGFyZ3VtZW50czogdHJ1ZSxcclxuICAgICAgICBjYWxsZWU6IHRydWUsXHJcbiAgICAgICAgY2FsbGVyOiB0cnVlLFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cnVlLFxyXG4gICAgICAgIGV2YWw6IHRydWUsXHJcbiAgICAgICAgcHJvdG90eXBlOiB0cnVlLFxyXG4gICAgICAgIHN0YWNrOiB0cnVlLFxyXG4gICAgICAgIHVud2F0Y2g6IHRydWUsXHJcbiAgICAgICAgdmFsdWVPZjogdHJ1ZSxcclxuICAgICAgICB3YXRjaDogdHJ1ZSxcclxuXHJcbiAgICAgICAgX19wcm90b19fOiB0cnVlLFxyXG4gICAgICAgIF9fcGFyZW50X186IHRydWUsXHJcbiAgICAgICAgJ3RoaXMnOiB0cnVlLFxyXG4gICAgICAgIHdpbmRvdzogdHJ1ZSxcclxuICAgICAgICBkb2N1bWVudDogdHJ1ZSxcclxuICAgICAgICAnWyc6IHRydWUsXHJcbiAgICAgICAgJ10nOiB0cnVlLFxyXG4gICAgICAgIEZ1bmN0aW9uOiB0cnVlLFxyXG4gICAgICAgICd3aXRoJzogdHJ1ZSxcclxuICAgICAgICB1bmV2YWw6IHRydWUsXHJcbiAgICAgICAgdG9Tb3VyY2U6IHRydWUsXHJcbiAgICAgICAgc2V0VGltZW91dDogdHJ1ZSxcclxuICAgICAgICBzZXRJbnRlcnZhbDogdHJ1ZVxyXG4gICAgfVxyXG4gICAgLy9pZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgY2hlY2sgZm9yIGJlaW5nIGluIHRoZSBibGFja2xpc3RcclxuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3Qud2luZG93ICYmICFmb3JiaWRkZW5MaXN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvL251bWJlcnMgYXJlIG5vdCBjaGVja2VkIGZvciBiZWluZyBpbiB0aGUgYmxhY2tsaXN0XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5lcnJvcignSWxsZWdhbCBwcm9wZXJ0eSBuYW1lOiAnICsgcHJvcGVydHkpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcblN3ZXZhU2NyaXB0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIHZhciBmb3JiaWRkZW5MaXN0ID0ge1xyXG4gICAgICAgIGFyZ3VtZW50czogdHJ1ZSxcclxuICAgICAgICBjYWxsZWU6IHRydWUsXHJcbiAgICAgICAgY2FsbGVyOiB0cnVlLFxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cnVlLFxyXG4gICAgICAgIGV2YWw6IHRydWUsXHJcbiAgICAgICAgcHJvdG90eXBlOiB0cnVlLFxyXG4gICAgICAgIHN0YWNrOiB0cnVlLFxyXG4gICAgICAgIHVud2F0Y2g6IHRydWUsXHJcbiAgICAgICAgdmFsdWVPZjogdHJ1ZSxcclxuICAgICAgICB3YXRjaDogdHJ1ZSxcclxuXHJcbiAgICAgICAgX19wcm90b19fOiB0cnVlLFxyXG4gICAgICAgIF9fcGFyZW50X186IHRydWUsXHJcbiAgICAgICAgJ3RoaXMnOiB0cnVlLFxyXG4gICAgICAgIHdpbmRvdzogdHJ1ZSxcclxuICAgICAgICBkb2N1bWVudDogdHJ1ZSxcclxuICAgICAgICAnWyc6IHRydWUsXHJcbiAgICAgICAgJ10nOiB0cnVlLFxyXG4gICAgICAgIEZ1bmN0aW9uOiB0cnVlLFxyXG4gICAgICAgICd3aXRoJzogdHJ1ZSxcclxuICAgICAgICB1bmV2YWw6IHRydWUsXHJcbiAgICAgICAgdG9Tb3VyY2U6IHRydWUsXHJcbiAgICAgICAgc2V0VGltZW91dDogdHJ1ZSxcclxuICAgICAgICBzZXRJbnRlcnZhbDogdHJ1ZVxyXG4gICAgfVxyXG4gICAgLy9pZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgY2hlY2sgZm9yIGJlaW5nIGluIHRoZSBibGFja2xpc3RcclxuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3Qud2luZG93ICYmICFmb3JiaWRkZW5MaXN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbGxlZ2FsIHByb3BlcnR5IG5hbWU6ICcgKyBwcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9udW1iZXJzIGFyZSBub3QgY2hlY2tlZCBmb3IgYmVpbmcgaW4gdGhlIGJsYWNrbGlzdFxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTYW5pdGl6ZXMgZ2l2ZW4gSmF2YXNjcmlwdCBjb2RlIGJ5IHZlcmlmeWluZyBpZiBpdCBpcyBhIHNhZmVyIHN1YnNldCBvZiBKYXZhU2NyaXB0IGFuZCBtYXNraW5nIGdsb2JhbCB2YXJpYWJsZXMuXHJcbiAqIHtAbGluayBTd2V2YVNjcmlwdCN2ZXJpZnl9IGlzIHBlcmZvcm1lZCBpbnRlcm5hbGx5LCBzbyB5b3UgZG8gbm90IG5lZWQgdG8gdmVyaWZ5IGV4cGxpY2l0bHkgYmVmb3JlaGFuZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBUaGUgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBzYW5pdGl6ZS5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3JDYWxsYmFjayAtIEEgY2FsbGJhY2sgY2FsbGVkLCB3aGVuIGFuIGVycm9yIG9jY3VycywgaGFzIGEgc3RyaW5nIGFzIGEgcGFyYW1ldGVyIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAqIEByZXR1cm5ze2Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24sIHRoYXQgY2FuIGJlIGV4ZWN1dGVkXHJcbiAqL1xyXG5Td2V2YVNjcmlwdC5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAoY29kZSwgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgLy9hbGwgaW4gb25lIGxpbmVcclxuICAgIC8vY29kZSA9IGNvZGUucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSwgXCJcIik7IFxyXG4gICBcclxuICAgIHZhciBlcnJvciA9ICcnO1xyXG4gICAgLy9maXJzdCBtYWtlIHN1cmUgaXQgaXMgdmFsaWQgU3dldmFTY3JpcHRcclxuICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52ZXJpZnkoY29kZSk7ICAgIFxyXG4gICAgaWYgKHZhbGlkYXRpb24udmFsaWQpIHsgICAgICAgIFxyXG4gICAgICAgIHZhciBhbGxvd2VkR2xvYmFscyA9IHRoaXMuYWxsb3dlZEdsb2JhbHM7XHJcbiAgICAgICAgLy9nZXQgYWxsIGdsb2JhbCB2YXJpYWJsZXMgZXhjZXB0IHRoZSBleGNlcHRpb25zIHdlIGRlZmluZWQgaW4ge0BsaW5rIFN3ZXZhU2NyaXB0I2FsbG93ZWRHbG9iYWxzfVxyXG4gICAgICAgIHZhciBnbG9iYWxzID0gT2JqZWN0LmtleXMod2luZG93KS5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gIWFsbG93ZWRHbG9iYWxzLmhhc093blByb3BlcnR5KG9iailcclxuICAgICAgICB9KS5qb2luKCcsJyk7XHJcbiAgICAgICAgLy93ZSB3YW50IHRvIHNoYWRvdyBhbGwgZ2xvYmFsIHZhcmlhYmxlcyBleGNlcHQgdGhlIG9uZXMgd2UgYWxsb3csIGJ5IGRlY2xhcmluZyB0aGVtIGFzIGxvY2FsIHZhcmlhYmxlc1xyXG4gICAgICAgIC8vaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yNjkxNzkzOC9yZXZpc2lvbnNcclxuICAgICAgICAvL3ZhciBmdW5jUmVnID0gL2Z1bmN0aW9uICpcXCgoW14oKV0qKVxcKVsgXFxuXFx0XSp7KC4qKX0vZ21pO1xyXG4gICAgICAgIHZhciBmdW5jUmVnID0gL2Z1bmN0aW9uXFxzKlxcKChbXigpXSopXFwpXFxzXFx7KCgufFxcbikqKVxcfS9nbWk7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY1JlZy5leGVjKGNvZGUpO1xyXG4gICAgICAgXHJcbiAgICAgICAgLy93ZSBleHRyYWN0IGZ1bnRpb24gaGVhZGVyIChkZWNybGFyYXRpb24gd2l0aCBwYXJhbWV0ZXJzKSBhbmQgYm9keVxyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9lbmZvcmNlIHN0cmljdCBiZWhhdmlvciwgc2hhZG93IGdsb2JhbHMsIGFwcGVuZCB2ZXJpZmllZCBjb2RlXHJcbiAgICAgICAgICAgIHZhciBmbl90ZXh0ID0gJ1widXNlIHN0cmljdFwiOyB2YXIgJyArIGdsb2JhbHMgKyAnOycgKyBtYXRjaFsyXSArICc7JztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBmbiA9IG5ldyBGdW5jdGlvbihtYXRjaFsxXS5zcGxpdCgnLCcpLCBmbl90ZXh0KTsvL2dlbmVyYXRlIHNhbml0aXplZCBmdW5jdGlvblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IgPSAnTm90IGEgdmFsaWQgSlMgZnVuY3Rpb24nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVycm9yID0gdmFsaWRhdGlvbi5lcnJvcjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTd2V2YVNjcmlwdDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21waWxlU2NoZW1hID0gcmVxdWlyZSgnLi9jb21waWxlJylcbiAgICAsIHJlc29sdmUgPSByZXF1aXJlKCcuL2NvbXBpbGUvcmVzb2x2ZScpXG4gICAgLCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuICAgICwgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21waWxlL3NjaGVtYV9vYmonKVxuICAgICwgc3RhYmxlU3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdGFibGUtc3RyaW5naWZ5JylcbiAgICAsIGZvcm1hdHMgPSByZXF1aXJlKCcuL2NvbXBpbGUvZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqdjtcblxudmFyIE1FVEFfU0NIRU1BX0lEID0gJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hJztcbnZhciBTQ0hFTUFfVVJJX0ZPUk1BVCA9IC9eKD86KD86W2Etel1bYS16MC05Ky0uXSo6KT9cXC9cXC8pP1teXFxzXSokL2k7XG5mdW5jdGlvbiBTQ0hFTUFfVVJJX0ZPUk1BVF9GVU5DKHN0cikge1xuICAgIHJldHVybiBTQ0hFTUFfVVJJX0ZPUk1BVC50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBVc2FnZTogYEFqdihvcHRzKWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gYWp2IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEFqdihvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFqdikpIHJldHVybiBuZXcgQWp2KG9wdHMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5fc2NoZW1hcyA9IHt9O1xuICAgIHRoaXMuX3JlZnMgPSB7fTtcbiAgICB0aGlzLl9mb3JtYXRzID0gZm9ybWF0cyh0aGlzLm9wdHMuZm9ybWF0KTtcbiAgICB0aGlzLl9jYWNoZSA9IHRoaXMub3B0cy5jYWNoZSB8fCBuZXcgQ2FjaGU7XG4gICAgdGhpcy5fbG9hZGluZ1NjaGVtYXMgPSB7fTtcblxuICAgIC8vIHRoaXMgaXMgZG9uZSBvbiBwdXJwb3NlLCBzbyB0aGF0IG1ldGhvZHMgYXJlIGJvdW5kIHRvIHRoZSBpbnN0YW5jZVxuICAgIC8vICh3aXRob3V0IHVzaW5nIGJpbmQpIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCB3aXRob3V0IHRoZSBpbnN0YW5jZVxuICAgIHRoaXMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICB0aGlzLmNvbXBpbGUgPSBjb21waWxlO1xuICAgIHRoaXMuY29tcGlsZUFzeW5jID0gY29tcGlsZUFzeW5jO1xuICAgIHRoaXMuYWRkU2NoZW1hID0gYWRkU2NoZW1hO1xuICAgIHRoaXMuYWRkTWV0YVNjaGVtYSA9IGFkZE1ldGFTY2hlbWE7XG4gICAgdGhpcy52YWxpZGF0ZVNjaGVtYSA9IHZhbGlkYXRlU2NoZW1hO1xuICAgIHRoaXMuZ2V0U2NoZW1hID0gZ2V0U2NoZW1hO1xuICAgIHRoaXMucmVtb3ZlU2NoZW1hID0gcmVtb3ZlU2NoZW1hO1xuICAgIHRoaXMuYWRkRm9ybWF0ID0gYWRkRm9ybWF0O1xuICAgIHRoaXMuZXJyb3JzVGV4dCA9IGVycm9yc1RleHQ7XG5cbiAgICB0aGlzLl9jb21waWxlID0gX2NvbXBpbGU7XG5cbiAgICBhZGRJbml0aWFsU2NoZW1hcygpO1xuICAgIGlmICh0aGlzLm9wdHMuZm9ybWF0cykgYWRkSW5pdGlhbEZvcm1hdHMoKTtcblxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgZGF0YSB1c2luZyBzY2hlbWFcbiAgICAgKiBTY2hlbWEgd2lsbCBiZSBjb21waWxlZCBhbmQgY2FjaGVkICh1c2luZyBzZXJpYWxpemVkIEpTT04gYXMga2V5LiBbanNvbi1zdGFibGUtc3RyaW5naWZ5XShodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svanNvbi1zdGFibGUtc3RyaW5naWZ5KSBpcyB1c2VkIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFLZXlSZWYga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgICAqIEBwYXJhbSAge0FueX0gZGF0YSB0byBiZSB2YWxpZGF0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB2YWxpZGF0aW9uIHJlc3VsdC4gRXJyb3JzIGZyb20gdGhlIGxhc3QgdmFsaWRhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBpbiBgYWp2LmVycm9yc2AgKGFuZCBhbHNvIGluIGNvbXBpbGVkIHNjaGVtYTogYHNjaGVtYS5lcnJvcnNgKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIGRhdGEpIHtcbiAgICAgICAgdmFyIHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2ID0gZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpIHRocm93IG5ldyBFcnJvcignbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIicgKyBzY2hlbWFLZXlSZWYgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFPYmogPSBfYWRkU2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB2ID0gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IF9jb21waWxlKHNjaGVtYU9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBzZWxmLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdmFsaWRhdGluZyBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hKSB7XG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBfYWRkU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hIHdpdGggYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgbWlzc2luZyBzY2hlbWFzLlxuICAgICAqIGBsb2FkU2NoZW1hYCBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHNjaGVtYSB1cmkgYW5kIG5vZGUtc3R5bGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIG5vZGUtc3R5bGUgY2FsbGJhY2ssIGl0IGlzIGFsd2F5cyBjYWxsZWQgd2l0aCAyIHBhcmFtZXRlcnM6IGVycm9yIChvciBudWxsKSBhbmQgdmFsaWRhdGluZyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21waWxlQXN5bmMoc2NoZW1hLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NoZW1hT2JqO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NoZW1hT2JqID0gX2FkZFNjaGVtYShzY2hlbWEpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hT2JqLnZhbGlkYXRlKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCwgc2NoZW1hT2JqLnZhbGlkYXRlKTsgfSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdHMubG9hZFNjaGVtYSAhPSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBfY29tcGlsZUFzeW5jKHNjaGVtYSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaGVtYSwgY2FsbGJhY2ssIGZpcnN0Q2FsbCkge1xuICAgICAgICB2YXIgdmFsaWRhdGU7XG4gICAgICAgIHRyeSB7IHZhbGlkYXRlID0gY29tcGlsZShzY2hlbWEpOyB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmIChlLm1pc3NpbmdTY2hlbWEpIGxvYWRNaXNzaW5nU2NoZW1hKGUpO1xuICAgICAgICAgICAgZWxzZSBkZWZlckNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVyQ2FsbGJhY2sobnVsbCwgdmFsaWRhdGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKGUpIHtcbiAgICAgICAgICAgIHZhciByZWYgPSBlLm1pc3NpbmdTY2hlbWE7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcmVmc1tyZWZdIHx8IHNlbGYuX3NjaGVtYXNbcmVmXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdTY2hlbWEgJyArIHJlZiArICcgaXMgbG9hZGVkIGJ1dCcgKyBlLm1pc3NpbmdSZWYgKyAnY2Fubm90IGJlIHJlc29sdmVkJykpO1xuICAgICAgICAgICAgdmFyIF9jYWxsYmFja3MgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgICAgICAgaWYgKF9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9jYWxsYmFja3MgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXSA9IFtfY2FsbGJhY2tzLCBzY2hlbWFMb2FkZWRdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc1tfY2FsbGJhY2tzLmxlbmd0aF0gPSBzY2hlbWFMb2FkZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl0gPSBzY2hlbWFMb2FkZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRzLmxvYWRTY2hlbWEocmVmLCBmdW5jdGlvbiAoZXJyLCBzY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jYWxsYmFja3MgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FsbGJhY2tzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2tzKGVyciwgc2NoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPF9jYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc1tpXShlcnIsIHNjaCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNjaGVtYUxvYWRlZChlcnIsIHNjaCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNlbGYuX3JlZnNbcmVmXSB8fCBzZWxmLl9zY2hlbWFzW3JlZl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNjaGVtYShzY2gsIHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2NvbXBpbGVBc3luYyhzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWZlckNhbGxiYWNrKGVyciwgdmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdENhbGwpIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVyciwgdmFsaWRhdGUpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgY2FsbGJhY2soZXJyLCB2YWxpZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc2NoZW1hIHNjaGVtYSBvciBhcnJheSBvZiBzY2hlbWFzLiBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpe1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykgYWRkU2NoZW1hKHNjaGVtYVtpXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuIGtleS9pZCBoYXZlICMgaW5zaWRlP1xuICAgICAgICBrZXkgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleSB8fCBzY2hlbWEuaWQpO1xuICAgICAgICBjaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB2YXIgc2NoZW1hT2JqID0gc2VsZi5fc2NoZW1hc1trZXldID0gX2FkZFNjaGVtYShzY2hlbWEsIF9za2lwVmFsaWRhdGlvbik7XG4gICAgICAgIHNjaGVtYU9iai5tZXRhID0gX21ldGE7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAgKiByZW1vdmVBZGRpdGlvbmFsIG9wdGlvbiBpcyBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBvcHRpb25hbCBzY2hlbWEga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGFkZFNjaGVtYShzY2hlbWEsIGtleSwgX3NraXBWYWxpZGF0aW9uLCB0cnVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHNjaGVtYVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHZhciAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWEgfHwgTUVUQV9TQ0hFTUFfSUQ7XG4gICAgICAgIHZhciBjdXJyZW50VXJpRm9ybWF0ID0gc2VsZi5fZm9ybWF0cy51cmk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHMudXJpID0gdHlwZW9mIGN1cnJlbnRVcmlGb3JtYXQgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gU0NIRU1BX1VSSV9GT1JNQVRfRlVOQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogU0NIRU1BX1VSSV9GT1JNQVQ7XG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHMudXJpID0gY3VycmVudFVyaUZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBpbGVkIHNjaGVtYSBmcm9tIHRoZSBpbnN0YW5jZSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleVJlZiBga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIChgc2NoZW1hLmlkYCBvciByZXNvbHZlZCBpZCkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHNjaGVtYSB2YWxpZGF0aW5nIGZ1bmN0aW9uICh3aXRoIHByb3BlcnR5IGBzY2hlbWFgKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKGtleVJlZik7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYU9iaikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuIHNjaGVtYU9iai52YWxpZGF0ZSB8fCBfY29tcGlsZShzY2hlbWFPYmopO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIGdldFNjaGVtYShzY2hlbWFPYmopO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBfZ2V0U2NoZW1hT2JqKGtleVJlZikge1xuICAgICAgICBrZXlSZWYgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleVJlZik7XG4gICAgICAgIHJldHVybiBzZWxmLl9zY2hlbWFzW2tleVJlZl0gfHwgc2VsZi5fcmVmc1trZXlSZWZdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhY2hlZCBzY2hlbWFcbiAgICAgKiBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFLZXlSZWYga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FjaGUuZGVsKHNjaGVtYU9iai5qc29uU3RyKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHZhciBqc29uU3RyID0gc3RhYmxlU3RyaW5naWZ5KHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FjaGUuZGVsKGpzb25TdHIpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNjaGVtYUtleVJlZi5pZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3JlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX2FkZFNjaGVtYShzY2hlbWEsIHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSBzaG91bGQgYmUgb2JqZWN0Jyk7XG4gICAgICAgIHZhciBqc29uU3RyID0gc3RhYmxlU3RyaW5naWZ5KHNjaGVtYSk7XG4gICAgICAgIHZhciBjYWNoZWQgPSBzZWxmLl9jYWNoZS5nZXQoanNvblN0cik7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgICAgICAgdmFyIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZChzY2hlbWEuaWQpO1xuICAgICAgICBpZiAoaWQpIGNoZWNrVW5pcXVlKGlkKTtcblxuICAgICAgICB2YXIgb2sgPSBza2lwVmFsaWRhdGlvbiB8fCBzZWxmLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgIHx8IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ3NjaGVtYSBpcyBpbnZhbGlkOicgKyBlcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRzLnZhbGlkYXRlU2NoZW1hID09ICdsb2cnKSBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxSZWZzID0gcmVzb2x2ZS5pZHMuY2FsbChzZWxmLCBzY2hlbWEpO1xuXG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBuZXcgU2NoZW1hT2JqZWN0KHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgbG9jYWxSZWZzOiBsb2NhbFJlZnMsXG4gICAgICAgICAgICBqc29uU3RyOiBqc29uU3RyLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaWRbMF0gIT0gJyMnKSBzZWxmLl9yZWZzW2lkXSA9IHNjaGVtYU9iajtcbiAgICAgICAgc2VsZi5fY2FjaGUucHV0KGpzb25TdHIsIHNjaGVtYU9iaik7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYU9iajtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIF9jb21waWxlKHNjaGVtYU9iaiwgcm9vdCkge1xuICAgICAgICBpZiAoc2NoZW1hT2JqLmNvbXBpbGluZykge1xuICAgICAgICAgICAgc2NoZW1hT2JqLnZhbGlkYXRlID0gY2FsbFZhbGlkYXRlO1xuICAgICAgICAgICAgY2FsbFZhbGlkYXRlLnNjaGVtYSA9IHNjaGVtYU9iai5zY2hlbWE7XG4gICAgICAgICAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxWYWxpZGF0ZS5yb290ID0gcm9vdCA/IHJvb3QgOiBjYWxsVmFsaWRhdGU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFZhbGlkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYU9iai5jb21waWxpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjdXJyZW50UkEgPSBzZWxmLm9wdHMucmVtb3ZlQWRkaXRpb25hbDtcbiAgICAgICAgaWYgKGN1cnJlbnRSQSAmJiBzY2hlbWFPYmoubWV0YSkgc2VsZi5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHY7XG4gICAgICAgIHRyeSB7IHYgPSBjb21waWxlU2NoZW1hLmNhbGwoc2VsZiwgc2NoZW1hT2JqLnNjaGVtYSwgcm9vdCwgc2NoZW1hT2JqLmxvY2FsUmVmcyk7IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJBKSBzZWxmLm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9IGN1cnJlbnRSQTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYU9iai52YWxpZGF0ZSA9IHY7XG4gICAgICAgIHNjaGVtYU9iai5yZWZzID0gdi5yZWZzO1xuICAgICAgICBzY2hlbWFPYmoucmVmVmFsID0gdi5yZWZWYWw7XG4gICAgICAgIHNjaGVtYU9iai5yb290ID0gdi5yb290O1xuICAgICAgICByZXR1cm4gdjtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gc2NoZW1hT2JqLnZhbGlkYXRlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGVycm9yc1RleHQoZXJyb3JzLCBvcHRzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBzZWxmLmVycm9ycztcbiAgICAgICAgaWYgKCFlcnJvcnMpIHJldHVybiAnTm8gZXJyb3JzJztcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fCAnLCAnO1xuICAgICAgICB2YXIgZGF0YVZhciA9IG9wdHMuZGF0YVZhciB8fCAnZGF0YSc7XG5cbiAgICAgICAgdmFyIHRleHQgPSBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uKHR4dCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPyB0eHQgKyBkYXRhVmFyICsgZS5kYXRhUGF0aCArICcgJyArIGUubWVzc2FnZSArIHNlcGFyYXRvciA6IHR4dDtcbiAgICAgICAgfSwgJycpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCAtc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09ICdzdHJpbmcnKSBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0cy5tZXRhICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG1ldGFTY2hlbWEgPSByZXF1aXJlKCcuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbicpO1xuICAgICAgICAgICAgYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLl9yZWZzWydodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSddID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0c1NjaGVtYXMgPSBzZWxmLm9wdHMuc2NoZW1hcztcbiAgICAgICAgaWYgKCFvcHRzU2NoZW1hcykgcmV0dXJuO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpIGFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIga2V5IGluIG9wdHNTY2hlbWFzKSBhZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYub3B0cy5mb3JtYXRzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gc2VsZi5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgICAgICBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHNlbGYuX3NjaGVtYXNbaWRdIHx8IHNlbGYuX3JlZnNbaWRdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMnKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIENhY2hlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWNoZSgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gQ2FjaGVfcHV0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBDYWNoZV9nZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiBDYWNoZV9kZWwoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlW2tleV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL2FsbCByZXF1aXJlcyBtdXN0IGJlIGV4cGxpY2l0IGJlY2F1c2UgYnJvd3NlcmlmeSB3b24ndCB3b3JrIHdpdGggZHluYW1pYyByZXF1aXJlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICckcmVmJzogcmVxdWlyZSgnLi4vZG90anMvcmVmJyksXG4gIGFueU9mOiByZXF1aXJlKCcuLi9kb3Rqcy9hbnlPZicpLFxuICBmb3JtYXQ6IHJlcXVpcmUoJy4uL2RvdGpzL2Zvcm1hdCcpLFxuICBtYXhMZW5ndGg6IHJlcXVpcmUoJy4uL2RvdGpzL21heExlbmd0aCcpLFxuICBtaW5JdGVtczogcmVxdWlyZSgnLi4vZG90anMvbWluSXRlbXMnKSxcbiAgbWluaW11bTogcmVxdWlyZSgnLi4vZG90anMvbWluaW11bScpLFxuICBvbmVPZjogcmVxdWlyZSgnLi4vZG90anMvb25lT2YnKSxcbiAgcmVxdWlyZWQ6IHJlcXVpcmUoJy4uL2RvdGpzL3JlcXVpcmVkJyksXG4gIGRlcGVuZGVuY2llczogcmVxdWlyZSgnLi4vZG90anMvZGVwZW5kZW5jaWVzJyksXG4gIGl0ZW1zOiByZXF1aXJlKCcuLi9kb3Rqcy9pdGVtcycpLFxuICBtYXhQcm9wZXJ0aWVzOiByZXF1aXJlKCcuLi9kb3Rqcy9tYXhQcm9wZXJ0aWVzJyksXG4gIG1pbkxlbmd0aDogcmVxdWlyZSgnLi4vZG90anMvbWluTGVuZ3RoJyksXG4gIG11bHRpcGxlT2Y6IHJlcXVpcmUoJy4uL2RvdGpzL211bHRpcGxlT2YnKSxcbiAgcGF0dGVybjogcmVxdWlyZSgnLi4vZG90anMvcGF0dGVybicpLFxuICB1bmlxdWVJdGVtczogcmVxdWlyZSgnLi4vZG90anMvdW5pcXVlSXRlbXMnKSxcbiAgYWxsT2Y6IHJlcXVpcmUoJy4uL2RvdGpzL2FsbE9mJyksXG4gIGVudW06IHJlcXVpcmUoJy4uL2RvdGpzL2VudW0nKSxcbiAgbWF4SXRlbXM6IHJlcXVpcmUoJy4uL2RvdGpzL21heEl0ZW1zJyksXG4gIG1heGltdW06IHJlcXVpcmUoJy4uL2RvdGpzL21heGltdW0nKSxcbiAgbWluUHJvcGVydGllczogcmVxdWlyZSgnLi4vZG90anMvbWluUHJvcGVydGllcycpLFxuICBub3Q6IHJlcXVpcmUoJy4uL2RvdGpzL25vdCcpLFxuICBwcm9wZXJ0aWVzOiByZXF1aXJlKCcuLi9kb3Rqcy9wcm9wZXJ0aWVzJyksXG4gIHZhbGlkYXRlOiByZXF1aXJlKCcuLi9kb3Rqcy92YWxpZGF0ZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKVxuICAgICwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYilcbiAgICAsIGk7XG5cbiAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFyckEgIT0gYXJyQikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoYltrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgIGlmKCFlcXVhbChhW2tleXNbaV1dLCBiW2tleXNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgREFURSA9IC9eXFxkXFxkXFxkXFxkLShcXGRcXGQpLShcXGRcXGQpJC87XG52YXIgREFZUyA9IFswLDMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtcbnZhciBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZDpcXGRcXGQpJC87XG52YXIgSE9TVE5BTUUgPSAvXlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KFxcLlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KSokL2k7XG52YXIgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QFxcLz9dfCVbMC05YS1mXXsyfSkqKT8oPzpcXCMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QFxcLz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRzO1xuXG5mdW5jdGlvbiBmb3JtYXRzKG1vZGUpIHtcbiAgbW9kZSA9IG1vZGUgPT0gJ2Z1bGwnID8gJ2Z1bGwnIDogJ2Zhc3QnO1xuICByZXR1cm4gdXRpbC5jb3B5KGZvcm1hdHNbbW9kZV0pO1xufVxuXG5cbmZvcm1hdHMuZmFzdCA9IHtcbiAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICBkYXRlOiAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLFxuICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgJ2RhdGUtdGltZSc6IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3QgXVswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkOlxcZFxcZCkkL2ksXG4gIC8vIHVyaTogaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9pcy1teS1qc29uLXZhbGlkL2Jsb2IvbWFzdGVyL2Zvcm1hdHMuanNcbiAgdXJpOiAvXig/OlthLXpdW2EtejAtOSstLl0qKT8oPzpcXDp8XFwvKVxcLz9bXlxcc10qJC9pLFxuICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDEzMjMvdXNpbmctYS1yZWd1bGFyLWV4cHJlc3Npb24tdG8tdmFsaWRhdGUtYW4tZW1haWwtYWRkcmVzcyNhbnN3ZXItODgyOTM2M1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxsZnVsIHZpb2xhdGlvbicpXG4gIGVtYWlsOiAvXlthLXowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG4gIGhvc3RuYW1lOiBIT1NUTkFNRSxcbiAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICAvLyBvcHRpbWl6ZWQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzQ5Ny9yZWd1bGFyLWV4cHJlc3Npb24tdGhhdC1tYXRjaGVzLXZhbGlkLWlwdjYtYWRkcmVzc2VzXG4gIGlwdjY6IC9eXFxzKig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs3fSg/OlswLTlhLWZdezEsNH18OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs2fSg/OjpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwyfSl8Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NH0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwzfSl8KD86KD86OlswLTlhLWZdezEsNH0pPzooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXszfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDR9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwyfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsyfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDV9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwzfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsxfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw0fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/OjooPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw3fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNX06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoPzolLispP1xccyokL2ksXG4gIHJlZ2V4OiByZWdleFxufTtcblxuXG5mb3JtYXRzLmZ1bGwgPSB7XG4gIGRhdGU6IGRhdGUsXG4gICdkYXRlLXRpbWUnOiBkYXRlX3RpbWUsXG4gIHVyaTogdXJpLFxuICBlbWFpbDogL15bYS16MC05ISMkJSYnKitcXC89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnJyorXFwvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICByZWdleDogcmVnZXhcbn07XG5cblxuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1vbnRoID0gK21hdGNoZXNbMV07XG4gIHZhciBkYXkgPSArbWF0Y2hlc1syXTtcbiAgcmV0dXJuIG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgJiYgZGF5ID49IDEgJiYgZGF5IDw9IERBWVNbbW9udGhdO1xufVxuXG5cbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgZGF0ZVRpbWUgPSBzdHIudG9Mb3dlckNhc2UoKS5zcGxpdCgndCcpO1xuICBpZiAoIWRhdGUoZGF0ZVRpbWVbMF0pKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1hdGNoZXMgPSBkYXRlVGltZVsxXS5tYXRjaChUSU1FKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGhvdXIgPSBtYXRjaGVzWzFdO1xuICB2YXIgbWludXRlID0gbWF0Y2hlc1syXTtcbiAgdmFyIHNlY29uZCA9IG1hdGNoZXNbM107XG4gIHJldHVybiBob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTk7XG59XG5cblxuZnVuY3Rpb24gaG9zdG5hbWUoc3RyKSB7XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzQjc2VjdGlvbi0zLjVcbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gMjU1ICYmIEhPU1ROQU1FLnRlc3Qoc3RyKTtcbn1cblxuXG52YXIgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98XFw6LztcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5cblxuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIGVxdWFsID0gcmVxdWlyZSgnLi9lcXVhbCcpO1xuXG50cnkgeyB2YXIgYmVhdXRpZnkgPSByZXF1aXJlKCcnICsgJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7IH0gY2F0Y2goZSkge31cblxudmFyIFJVTEVTID0gcmVxdWlyZSgnLi9ydWxlcycpXG4gICwgdmFsaWRhdGVHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9kb3Rqcy92YWxpZGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7XG5cblxuZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUsIGV2aWw6IHRydWUgKi9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCByZWZWYWwgPSBbIHVuZGVmaW5lZCBdIFxuICAgICwgcmVmcyA9IHt9XG4gICAgLCBwYXR0ZXJucyA9IFtdXG4gICAgLCBwYXR0ZXJuc0hhc2ggPSB7fTtcblxuICByb290ID0gcm9vdCB8fCB7IHNjaGVtYTogc2NoZW1hLCByZWZWYWw6IHJlZlZhbCwgcmVmczogcmVmcyB9O1xuXG4gIHZhciBmb3JtYXRzID0gdGhpcy5fZm9ybWF0cztcblxuICByZXR1cm4gbG9jYWxDb21waWxlKHNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuXG5cbiAgZnVuY3Rpb24gbG9jYWxDb21waWxlKF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAgIHZhciBpc1Jvb3QgPSAhX3Jvb3QgfHwgKF9yb290ICYmIF9yb290LnNjaGVtYSA9PSBfc2NoZW1hKTtcbiAgICBpZiAoX3Jvb3Quc2NoZW1hICE9IHJvb3Quc2NoZW1hKVxuICAgICAgcmV0dXJuIGNvbXBpbGUuY2FsbChzZWxmLCBfc2NoZW1hLCBfcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuXG4gICAgdmFyIHZhbGlkYXRlQ29kZSA9IHZhbGlkYXRlR2VuZXJhdG9yKHtcbiAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgc2NoZW1hOiBfc2NoZW1hLFxuICAgICAgaXNSb290OiBpc1Jvb3QsXG4gICAgICBiYXNlSWQ6IGJhc2VJZCxcbiAgICAgIHJvb3Q6IF9yb290LFxuICAgICAgc2NoZW1hUGF0aDogJycsXG4gICAgICBlcnJvclBhdGg6ICdcIlwiJyxcbiAgICAgIFJVTEVTOiBSVUxFUyxcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUdlbmVyYXRvcixcbiAgICAgIHV0aWw6IHV0aWwsXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgcmVzb2x2ZVJlZjogcmVzb2x2ZVJlZixcbiAgICAgIHVzZVBhdHRlcm46IHVzZVBhdHRlcm4sXG4gICAgICBvcHRzOiBzZWxmLm9wdHMsXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzXG4gICAgfSk7XG5cbiAgICB2YWxpZGF0ZUNvZGUgPSByZWZzQ29kZShyZWZWYWwpICsgcGF0dGVybnNDb2RlKHBhdHRlcm5zKSArIHZhbGlkYXRlQ29kZTtcblxuICAgIGlmIChzZWxmLm9wdHMuYmVhdXRpZnkpIHtcbiAgICAgIHZhciBvcHRzID0gc2VsZi5vcHRzLmJlYXV0aWZ5ID09PSB0cnVlID8geyBpbmRlbnRfc2l6ZTogMiB9IDogc2VsZi5vcHRzLmJlYXV0aWZ5O1xuICAgICAgaWYgKGJlYXV0aWZ5KSB2YWxpZGF0ZUNvZGUgPSBiZWF1dGlmeSh2YWxpZGF0ZUNvZGUsIG9wdHMpO1xuICAgICAgZWxzZSBjb25zb2xlLmVycm9yKCdcIm5wbSBpbnN0YWxsIGpzLWJlYXV0aWZ5XCIgdG8gdXNlIGJlYXV0aWZ5IG9wdGlvbicpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuICoqKiBcXG4nLCB2YWxpZGF0ZUNvZGUpO1xuICAgIHZhciB2YWxpZGF0ZTtcbiAgICAvLyB0cnkge1xuICAgICAgZXZhbCh2YWxpZGF0ZUNvZGUpO1xuICAgICAgcmVmVmFsWzBdID0gdmFsaWRhdGU7XG4gICAgLy8gfSBjYXRjaChlKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTonLCB2YWxpZGF0ZUNvZGUpO1xuICAgIC8vICAgdGhyb3cgZTtcbiAgICAvLyB9XG5cbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBfc2NoZW1hO1xuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgdmFsaWRhdGUucmVmcyA9IHJlZnM7XG4gICAgdmFsaWRhdGUucmVmVmFsID0gcmVmVmFsO1xuICAgIHZhbGlkYXRlLnJvb3QgPSBpc1Jvb3QgPyB2YWxpZGF0ZSA6IF9yb290O1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihiYXNlSWQsIHJlZiwgaXNSb290KSB7XG4gICAgcmVmID0gcmVzb2x2ZS51cmwoYmFzZUlkLCByZWYpO1xuICAgIHZhciByZWZJbmRleCA9IHJlZnNbcmVmXTtcbiAgICB2YXIgX3JlZlZhbCwgcmVmQ29kZTtcbiAgICBpZiAocmVmSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgX3JlZlZhbCA9IHJlZlZhbFtyZWZJbmRleF07XG4gICAgICByZWZDb2RlID0gJ3JlZlZhbFsnICsgcmVmSW5kZXggKyAnXSc7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgfVxuICAgIGlmICghaXNSb290KSB7XG4gICAgICB2YXIgcm9vdFJlZklkID0gcm9vdC5yZWZzW3JlZl07XG4gICAgICBpZiAocm9vdFJlZklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3JlZlZhbCA9IHJvb3QucmVmVmFsW3Jvb3RSZWZJZF07XG4gICAgICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYsIF9yZWZWYWwpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmQ29kZSA9IGFkZExvY2FsUmVmKHJlZik7XG4gICAgdmFyIHYgPSByZXNvbHZlLmNhbGwoc2VsZiwgbG9jYWxDb21waWxlLCByb290LCByZWYpO1xuICAgIGlmICghdikge1xuICAgICAgdmFyIGxvY2FsU2NoZW1hID0gbG9jYWxSZWZzICYmIGxvY2FsUmVmc1tyZWZdO1xuICAgICAgaWYgKGxvY2FsU2NoZW1hKSB7XG4gICAgICAgIHYgPSByZXNvbHZlLmlubGluZVJlZihsb2NhbFNjaGVtYSwgc2VsZi5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgICAgICA/IGxvY2FsU2NoZW1hXG4gICAgICAgICAgICA6IGNvbXBpbGUuY2FsbChzZWxmLCBsb2NhbFNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2KSB7XG4gICAgICByZXBsYWNlTG9jYWxSZWYocmVmLCB2KTtcbiAgICAgIHJldHVybiByZXNvbHZlZFJlZih2LCByZWZDb2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMb2NhbFJlZihyZWYsIHYpIHtcbiAgICB2YXIgcmVmSWQgPSByZWZWYWwubGVuZ3RoO1xuICAgIHJlZlZhbFtyZWZJZF0gPSB2O1xuICAgIHJlZnNbcmVmXSA9IHJlZklkO1xuICAgIHJldHVybiAncmVmVmFsJyArIHJlZklkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUxvY2FsUmVmKHJlZiwgdikge1xuICAgIHZhciByZWZJZCA9IHJlZnNbcmVmXTtcbiAgICByZWZWYWxbcmVmSWRdID0gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVkUmVmKHNjaGVtYSwgY29kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnXG4gICAgICAgICAgICA/IHsgc2NoZW1hOiBzY2hlbWEsIGNvZGU6IGNvZGUgfVxuICAgICAgICAgICAgOiBjb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlUGF0dGVybihyZWdleFN0cikge1xuICAgIHZhciBpbmRleCA9IHBhdHRlcm5zSGFzaFtyZWdleFN0cl07XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gcGF0dGVybnNIYXNoW3JlZ2V4U3RyXSA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgIHBhdHRlcm5zW2luZGV4XSA9IHJlZ2V4U3RyO1xuICAgIH1cbiAgICByZXR1cm4gJ3BhdHRlcm4nICsgaW5kZXg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBwYXR0ZXJuc0NvZGUocGF0dGVybnMpIHtcbiAgcmV0dXJuIF9hcnJDb2RlKHBhdHRlcm5zLCBwYXR0ZXJuQ29kZSk7XG59XG5cblxuZnVuY3Rpb24gcGF0dGVybkNvZGUoaSwgcGF0dGVybnMpIHtcbiAgcmV0dXJuICd2YXIgcGF0dGVybicgKyBpICsgJyA9IG5ldyBSZWdFeHAoJyArIHV0aWwudG9RdW90ZWRTdHJpbmcocGF0dGVybnNbaV0pICsgJyk7Jztcbn1cblxuXG5mdW5jdGlvbiByZWZzQ29kZShyZWZWYWwpIHtcbiAgcmV0dXJuIF9hcnJDb2RlKHJlZlZhbCwgcmVmQ29kZSk7XG59XG5cblxuZnVuY3Rpb24gcmVmQ29kZShpLCByZWZWYWwpIHtcbiAgcmV0dXJuIHJlZlZhbFtpXSA/ICd2YXIgcmVmVmFsJyArIGkgKyAnID0gcmVmVmFsWycgKyBpICsgJ107JyA6ICcnO1xufVxuXG5cbmZ1bmN0aW9uIF9hcnJDb2RlKGFyciwgc3RhdGVtZW50KSB7XG4gIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuICcnO1xuICB2YXIgY29kZSA9ICcnO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKVxuICAgIGNvZGUgKz0gc3RhdGVtZW50KGksIGFycik7XG4gIHJldHVybiBjb2RlO1xufVxuXG5cbi8qKlxuICogRnVuY3Rpb25zIGJlbG93IGFyZSB1c2VkIGluc2lkZSBjb21waWxlZCB2YWxpZGF0aW9ucyBmdW5jdGlvblxuICovXG5cbnZhciB1Y3MybGVuZ3RoID0gdXRpbC51Y3MybGVuZ3RoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbiAgLCBlcXVhbCA9IHJlcXVpcmUoJy4vZXF1YWwnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIFNjaGVtYU9iamVjdCA9IHJlcXVpcmUoJy4vc2NoZW1hX29iaicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7XG5cbnJlc29sdmUubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbnJlc29sdmUuZnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbnJlc29sdmUudXJsID0gcmVzb2x2ZVVybDtcbnJlc29sdmUuaWRzID0gcmVzb2x2ZUlkcztcbnJlc29sdmUuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuXG5mdW5jdGlvbiByZXNvbHZlKGNvbXBpbGUsIHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZl07XG4gIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHRoaXMuX3JlZnNbcmVmVmFsXSkgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgIGVsc2UgcmV0dXJuIHJlc29sdmUuY2FsbCh0aGlzLCBjb21waWxlLCByb290LCByZWZWYWwpO1xuICB9XG4gIFxuICByZWZWYWwgPSByZWZWYWwgfHwgdGhpcy5fc2NoZW1hc1tyZWZdO1xuICBpZiAocmVmVmFsIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KVxuICAgIHJldHVybiBpbmxpbmVSZWYocmVmVmFsLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgICAgICA/IHJlZlZhbC5zY2hlbWFcbiAgICAgICAgICAgIDogcmVmVmFsLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcblxuICB2YXIgcmVzID0gX3Jlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICB2YXIgc2NoZW1hLCB2LCBiYXNlSWQ7XG4gIGlmIChyZXMpIHtcbiAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICB9XG5cbiAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdClcbiAgICB2ID0gc2NoZW1hLnZhbGlkYXRlIHx8IGNvbXBpbGUuY2FsbCh0aGlzLCBzY2hlbWEuc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gIGVsc2UgaWYgKHNjaGVtYSlcbiAgICB2ID0gaW5saW5lUmVmKHNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgID8gc2NoZW1hXG4gICAgICAgIDogY29tcGlsZS5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuXG4gIHJldHVybiB2O1xufVxuXG5cbmZ1bmN0aW9uIF9yZXNvbHZlKHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBwID0gdXJsLnBhcnNlKHJlZiwgZmFsc2UsIHRydWUpXG4gICAgLCByZWZQYXRoID0gX2dldEZ1bGxQYXRoKHApXG4gICAgLCBiYXNlSWQgPSBnZXRGdWxsUGF0aChyb290LnNjaGVtYS5pZCk7XG4gIGlmIChyZWZQYXRoICE9PSBiYXNlSWQpIHtcbiAgICB2YXIgaWQgPSBub3JtYWxpemVJZChyZWZQYXRoKTtcbiAgICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tpZF07XG4gICAgaWYgKHR5cGVvZiByZWZWYWwgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZXNvbHZlUmVjdXJzaXZlLmNhbGwodGhpcywgcm9vdCwgcmVmVmFsLCBwKTtcbiAgICB9IGVsc2UgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgICAgaWYgKCFyZWZWYWwudmFsaWRhdGUpIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgIHJvb3QgPSByZWZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZlZhbCA9IHRoaXMuX3NjaGVtYXNbaWRdO1xuICAgICAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgICAgICBpZiAoIXJlZlZhbC52YWxpZGF0ZSkgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICAgICAgICBpZiAoaWQgPT0gbm9ybWFsaXplSWQocmVmKSlcbiAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHJlZlZhbCwgcm9vdDogcm9vdCwgYmFzZUlkOiBiYXNlSWQgfTtcbiAgICAgICAgcm9vdCA9IHJlZlZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyb290LnNjaGVtYSkgcmV0dXJuO1xuICAgIGJhc2VJZCA9IGdldEZ1bGxQYXRoKHJvb3Quc2NoZW1hLmlkKTtcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBiYXNlSWQsIHJvb3Quc2NoZW1hLCByb290KTtcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlUmVjdXJzaXZlKHJvb3QsIHJlZiwgcGFyc2VkUmVmKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHJlcyA9IF9yZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgaWYgKHJlcykge1xuICAgIHZhciBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHZhciBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICBpZiAoc2NoZW1hLmlkKSBiYXNlSWQgPSByZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLmlkKTtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwYXJzZWRSZWYsIGJhc2VJZCwgc2NoZW1hLCByb290KTtcbiAgfVxufVxuXG5cbnZhciBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IHV0aWwudG9IYXNoKFsncHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycsICdlbnVtJ10pO1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHBhcnNlZFJlZi5oYXNoID0gcGFyc2VkUmVmLmhhc2ggfHwgJyc7XG4gIGlmIChwYXJzZWRSZWYuaGFzaC5zbGljZSgwLDIpICE9ICcjLycpIHJldHVybjtcbiAgdmFyIHBhcnRzID0gcGFyc2VkUmVmLmhhc2guc3BsaXQoJy8nKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydCA9IHVuZXNjYXBlRnJhZ21lbnQocGFydCk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFbcGFydF07XG4gICAgICBpZiAoIXNjaGVtYSkgYnJlYWs7XG4gICAgICBpZiAoc2NoZW1hLmlkICYmICFQUkVWRU5UX1NDT1BFX0NIQU5HRVtwYXJ0XSkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS5pZCk7XG4gICAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgdmFyICRyZWYgPSByZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICB2YXIgcmVzID0gX3Jlc29sdmUuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHNjaGVtYSA9IHJlcy5zY2hlbWE7XG4gICAgICAgICAgcm9vdCA9IHJlcy5yb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hICE9IHJvb3Quc2NoZW1hKVxuICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCByb290OiByb290LCBiYXNlSWQ6IGJhc2VJZCB9O1xufVxuXG5cbnZhciBTSU1QTEVfSU5MSU5FRCA9IHV0aWwudG9IYXNoKFtcbiAgJ3R5cGUnLCAnZm9ybWF0JywgJ3BhdHRlcm4nLFxuICAnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsXG4gICdtYXhQcm9wZXJ0aWVzJywgJ21pblByb3BlcnRpZXMnLFxuICAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLFxuICAnbWF4aW11bScsICdtaW5pbXVtJyxcbiAgJ3VuaXF1ZUl0ZW1zJywgJ211bHRpcGxlT2YnLFxuICAncmVxdWlyZWQnLCAnZW51bScgXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0KSB7XG4gIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2hlY2tOb1JlZihzY2hlbWEpO1xuICBlbHNlIGlmIChsaW1pdCkgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrTm9SZWYoc2NoZW1hKSB7XG4gIHZhciBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IHNjaGVtYVtpXTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnICYmICFjaGVja05vUmVmKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgdmFyIGNvdW50ID0gMCwgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKTtcbiAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIEluZmluaXR5O1xuICAgICAgaWYgKFNJTVBMRV9JTkxJTkVEW2tleV0pIGNvdW50Kys7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaXRlbSA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKSArIDE7XG4gICAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cblxuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgICAgICAgLnJlcGxhY2UoL34xL2csICcvJylcbiAgICAgICAgICAucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgoaWQsIG5vcm1hbGl6ZSkge1xuICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSkgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHZhciBwID0gdXJsLnBhcnNlKGlkLCBmYWxzZSwgdHJ1ZSk7XG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5cblxuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgcmV0dXJuIChwLnByb3RvY29sfHwnJykgKyAocC5wcm90b2NvbD8nLy8nOicnKSArIChwLmhvc3R8fCcnKSArIChwLnBhdGh8fCcnKSAgKyAnIyc7XG59XG5cblxudmFyIFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCAnJykgOiAnJztcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHJldHVybiB1cmwucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlSWRzKHNjaGVtYSkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYS5pZCk7XG4gIHZhciBsb2NhbFJlZnMgPSB7fTtcbiAgX3Jlc29sdmVJZHMuY2FsbCh0aGlzLCBzY2hlbWEsIGdldEZ1bGxQYXRoKGlkLCBmYWxzZSksIGlkKTtcbiAgcmV0dXJuIGxvY2FsUmVmcztcblxuICBmdW5jdGlvbiBfcmVzb2x2ZUlkcyhzY2hlbWEsIGZ1bGxQYXRoLCBiYXNlSWQpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspXG4gICAgICAgIF9yZXNvbHZlSWRzLmNhbGwodGhpcywgc2NoZW1hW2ldLCBmdWxsUGF0aCsnLycraSwgYmFzZUlkKTtcbiAgICBlbHNlIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaWQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGlkID0gYmFzZUlkID0gYmFzZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gdXJsLnJlc29sdmUoYmFzZUlkLCBzY2hlbWEuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplSWQoc2NoZW1hLmlkKTtcblxuICAgICAgICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tpZF07XG4gICAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZlZhbF07XG4gICAgICAgIGlmIChyZWZWYWwgJiYgcmVmVmFsLnNjaGVtYSkge1xuICAgICAgICAgIGlmICghZXF1YWwoc2NoZW1hLCByZWZWYWwuc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZCAhPSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICBpZiAoaWRbMF0gPT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWZzW2lkXSAmJiAhZXF1YWwoc2NoZW1hLCBsb2NhbFJlZnNbaWRdKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBcIicgKyBpZCArICdcIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYScpO1xuICAgICAgICAgICAgbG9jYWxSZWZzW2lkXSA9IHNjaGVtYTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3JlZnNbaWRdID0gZnVsbFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpXG4gICAgICAgIF9yZXNvbHZlSWRzLmNhbGwodGhpcywgc2NoZW1hW2tleV0sIGZ1bGxQYXRoKycvJytlc2NhcGVGcmFnbWVudChrZXkpLCBiYXNlSWQpO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcnVsZU1vZHVsZXMgPSByZXF1aXJlKCcuL19ydWxlcycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgUlVMRVMgPSBtb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyB0eXBlOiAnbnVtYmVyJyxcbiAgICBydWxlczogWyAnbWF4aW11bScsICdtaW5pbXVtJywgJ211bHRpcGxlT2YnXSB9LFxuICB7IHR5cGU6ICdzdHJpbmcnLFxuICAgIHJ1bGVzOiBbICdtYXhMZW5ndGgnLCAnbWluTGVuZ3RoJywgJ3BhdHRlcm4nLCAnZm9ybWF0JyBdIH0sXG4gIHsgdHlwZTogJ2FycmF5JyxcbiAgICBydWxlczogWyAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLCAndW5pcXVlSXRlbXMnLCAnaXRlbXMnIF0gfSxcbiAgeyB0eXBlOiAnb2JqZWN0JyxcbiAgICBydWxlczogWyAnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJywgJ3JlcXVpcmVkJywgJ2RlcGVuZGVuY2llcycsICdwcm9wZXJ0aWVzJyBdIH0sXG4gIHsgcnVsZXM6IFsgJyRyZWYnLCAnZW51bScsICdub3QnLCAnYW55T2YnLCAnb25lT2YnLCAnYWxsT2YnIF0gfVxuXTtcblxuUlVMRVMuYWxsID0gWyAndHlwZScsICdhZGRpdGlvbmFsUHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycgXTtcblxuXG5SVUxFUy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5ydWxlcyA9IGdyb3VwLnJ1bGVzLm1hcChmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgIFJVTEVTLmFsbC5wdXNoKGtleXdvcmQpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXl3b3JkOiBrZXl3b3JkLFxuICAgICAgY29kZTogcnVsZU1vZHVsZXNba2V5d29yZF1cbiAgICB9O1xuICB9KTtcbn0pO1xuXG5SVUxFUy5hbGwgPSB1dGlsLnRvSGFzaChSVUxFUy5hbGwpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU9iamVjdDtcblxuZnVuY3Rpb24gU2NoZW1hT2JqZWN0KG9iaikge1xuICAgIHV0aWwuY29weShvYmosIHRoaXMpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiBjb3B5LFxuICBjaGVja0RhdGFUeXBlOiBjaGVja0RhdGFUeXBlLFxuICBjaGVja0RhdGFUeXBlczogY2hlY2tEYXRhVHlwZXMsXG4gIHRvSGFzaDogdG9IYXNoLFxuICBnZXRQcm9wZXJ0eTogZ2V0UHJvcGVydHksXG4gIGVzY2FwZVF1b3RlczogZXNjYXBlUXVvdGVzLFxuICB1Y3MybGVuZ3RoOiB1Y3MybGVuZ3RoLFxuICB2YXJPY2N1cmVuY2VzOiB2YXJPY2N1cmVuY2VzLFxuICB2YXJSZXBsYWNlOiB2YXJSZXBsYWNlLFxuICBjbGVhblVwQ29kZTogY2xlYW5VcENvZGUsXG4gIGNsZWFuVXBWYXJFcnJvcnM6IGNsZWFuVXBWYXJFcnJvcnMsXG4gIHNjaGVtYUhhc1J1bGVzOiBzY2hlbWFIYXNSdWxlcyxcbiAgc3RhYmxlU3RyaW5naWZ5OiByZXF1aXJlKCdqc29uLXN0YWJsZS1zdHJpbmdpZnknKSxcbiAgdG9RdW90ZWRTdHJpbmc6IHRvUXVvdGVkU3RyaW5nLFxuICBnZXRQYXRoRXhwcjogZ2V0UGF0aEV4cHIsXG4gIGdldFBhdGg6IGdldFBhdGhcbn07XG5cblxuZnVuY3Rpb24gY29weShvLCB0bykge1xuICB0byA9IHRvIHx8IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gbykgdG9ba2V5XSA9IG9ba2V5XTtcbiAgcmV0dXJuIHRvO1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIG5lZ2F0ZSkge1xuICB2YXIgRVFVQUwgPSBuZWdhdGUgPyAnICE9PSAnIDogJyA9PT0gJ1xuICAgICwgQU5EID0gbmVnYXRlID8gJyB8fCAnIDogJyAmJiAnXG4gICAgLCBPSyA9IG5lZ2F0ZSA/ICchJyA6ICcnXG4gICAgLCBOT1QgPSBuZWdhdGUgPyAnJyA6ICchJztcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIGNhc2UgJ251bGwnOiByZXR1cm4gZGF0YSArIEVRVUFMICsgJ251bGwnO1xuICAgIGNhc2UgJ2FycmF5JzogcmV0dXJuIE9LICsgJ0FycmF5LmlzQXJyYXkoJyArIGRhdGEgKyAnKSc7XG4gICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuICcoJyArIE9LICsgZGF0YSArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIm9iamVjdFwiJyArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE5PVCArICdBcnJheS5pc0FycmF5KCcgKyBkYXRhICsgJykpJztcbiAgICBjYXNlICdpbnRlZ2VyJzogcmV0dXJuICcodHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCJudW1iZXJcIicgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9UICsgJygnICsgZGF0YSArICcgJSAxKSknO1xuICAgIGRlZmF1bHQ6IHJldHVybiAndHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCInICsgZGF0YVR5cGUgKyAnXCInO1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhKSB7XG4gIHN3aXRjaCAoZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCB0cnVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciB0eXBlcyA9IHRvSGFzaChkYXRhVHlwZXMpO1xuICAgICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb2RlID0gdHlwZXMubnVsbCA/ICcoJzogJyghJyArIGRhdGEgKyAnIHx8ICc7XG4gICAgICAgIGNvZGUgKz0gJ3R5cGVvZiAnICsgZGF0YSArICcgIT09IFwib2JqZWN0XCIpJztcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5udW1iZXIpIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgICAgZm9yICh2YXIgdCBpbiB0eXBlcylcbiAgICAgICAgY29kZSArPSAoY29kZSA/ICcgJiYgJyA6ICcnICkgKyBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHRydWUpO1xuXG4gICAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgdmFyIGhhc2ggPSB7fTtcbiAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIGhhc2g7XG59XG5cblxudmFyIElERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbnZhciBTSU5HTEVfUVVPVEUgPSAvJ3xcXFxcL2c7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIElERU5USUZJRVIudGVzdChrZXkpXG4gICAgICAgICAgPyAnLicgKyBrZXlcbiAgICAgICAgICA6IFwiWydcIiArIGtleS5yZXBsYWNlKFNJTkdMRV9RVU9URSwgJ1xcXFwkJicpICsgXCInXVwiO1xufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVF1b3RlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFNJTkdMRV9RVU9URSwgJ1xcXFwkJicpO1xufVxuXG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgdmFyIGxlbmd0aCA9IDBcbiAgICAsIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIHBvcyA9IDBcbiAgICAsIHZhbHVlO1xuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKys7XG4gICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodmFsdWUgJiAweEZDMDApID09IDB4REMwMCkgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG5mdW5jdGlvbiB2YXJPY2N1cmVuY2VzKHN0ciwgZGF0YVZhcikge1xuICBkYXRhVmFyICs9ICdbXjAtOV0nO1xuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChuZXcgUmVnRXhwKGRhdGFWYXIsICdnJykpO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbn1cblxuXG5mdW5jdGlvbiB2YXJSZXBsYWNlKHN0ciwgZGF0YVZhciwgZXhwcikge1xuICBkYXRhVmFyICs9ICcoW14wLTldKSc7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGRhdGFWYXIsICdnJyksIGV4cHIgKyAnJDEnKTtcbn1cblxuXG52YXIgRU1QVFlfRUxTRSA9IC9lbHNlXFxzKntcXHMqfS9nXG4gICwgRU1QVFlfSUZfTk9fRUxTRSA9IC9pZlxccypcXChbXildK1xcKVxccypcXHtcXHMqXFx9KD8hXFxzKmVsc2UpL2dcbiAgLCBFTVBUWV9JRl9XSVRIX0VMU0UgPSAvaWZcXHMqXFwoKFteKV0rKVxcKVxccypcXHtcXHMqXFx9XFxzKmVsc2UoPyFcXHMqaWYpL2c7XG5mdW5jdGlvbiBjbGVhblVwQ29kZShvdXQpIHtcbiAgcmV0dXJuIG91dC5yZXBsYWNlKEVNUFRZX0VMU0UsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoRU1QVFlfSUZfTk9fRUxTRSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShFTVBUWV9JRl9XSVRIX0VMU0UsICdpZiAoISgkMSkpJyk7XG59XG5cblxudmFyIEVSUk9SU19SRUdFWFAgPSAvW152XFwuXWVycm9ycy9nXG4gICwgUkVNT1ZFX0VSUk9SUyA9IC92YXIgZXJyb3JzID0gMDt8dmFyIHZFcnJvcnMgPSBudWxsO3x2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOy9nXG4gICwgUkVUVVJOX1ZBTElEID0gJ3JldHVybiBlcnJvcnMgPT09IDA7J1xuICAsIFJFVFVSTl9UUlVFID0gJ3ZhbGlkYXRlLmVycm9ycyA9IG51bGw7IHJldHVybiB0cnVlOyc7XG5cbmZ1bmN0aW9uIGNsZWFuVXBWYXJFcnJvcnMob3V0KSB7XG4gIHZhciBtYXRjaGVzID0gb3V0Lm1hdGNoKEVSUk9SU19SRUdFWFApO1xuICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gb3V0LnJlcGxhY2UoUkVNT1ZFX0VSUk9SUywgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKFJFVFVSTl9WQUxJRCwgUkVUVVJOX1RSVUUpO1xuICBlbHNlXG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiB0b1F1b3RlZFN0cmluZyAoc3RyKSB7XG4gIHJldHVybiAnXFwnJyArIGVzY2FwZVF1b3RlcyhzdHIpICsgJ1xcJyc7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aEV4cHIgKGN1cnJlbnRQYXRoLCBleHByLCBqc29uUG9pbnRlcnMsIGlzTnVtYmVyKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzXG4gICAgICAgICAgICAgID8gJ1xcJy9cXCcgKyAnICsgZXhwciArIChpc051bWJlciA/ICcnIDogJy5yZXBsYWNlKC9+L2csIFxcJ34wXFwnKS5yZXBsYWNlKC9cXFxcLy9nLCBcXCd+MVxcJyknKVxuICAgICAgICAgICAgICA6IChpc051bWJlciA/ICdcXCdbXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXVxcJycgOiAnXFwnW1xcXFxcXCdcXCcgKyAnICsgZXhwciArICcgKyBcXCdcXFxcXFwnXVxcJycpO1xuICByZXR1cm4gam9pblBhdGhzKGN1cnJlbnRQYXRoLCBwYXRoKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRQYXRoIChjdXJyZW50UGF0aCwgcHJvcCwganNvblBvaW50ZXJzKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzXG4gICAgICAgICAgICAgID8gdG9RdW90ZWRTdHJpbmcoJy8nICsgcHJvcC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSlcbiAgICAgICAgICAgICAgOiB0b1F1b3RlZFN0cmluZyhnZXRQcm9wZXJ0eShwcm9wKSk7XG4gIHJldHVybiBqb2luUGF0aHMoY3VycmVudFBhdGgsIHBhdGgpO1xufVxuXG5cbmZ1bmN0aW9uIGpvaW5QYXRocyAoYSwgYikge1xuICBpZiAoYSA9PSAnXCJcIicpIHJldHVybiBiO1xuICByZXR1cm4gKGEgKyAnICsgJyArIGIpLnJlcGxhY2UoLycgXFwrICcvZywgJycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbGxPZihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2FsbE9mJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2FsbE9mJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcy5zbGljZSgwLCAtMSkpO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYW55T2YoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydhbnlPZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdhbnlPZicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpLFxuICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5vRW1wdHlTY2hlbWEgPSAkc2NoZW1hLmV2ZXJ5KGZ1bmN0aW9uKCRzY2gpIHtcbiAgICByZXR1cm4gaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpO1xuICB9KTtcbiAgaWYgKCRub0VtcHR5U2NoZW1hKSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgdmFyICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJHZhbGlkKSArICcgfHwgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnOyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgIH1cbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnYW55T2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHNvbWUgc2NoZW1hIGluIGFueU9mXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSBlbHNlIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2RlcGVuZGVuY2llcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2RlcGVuZGVuY2llcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdkZXBlbmRlbmNpZXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRzY2hlbWFEZXBzID0ge30sXG4gICAgJHByb3BlcnR5RGVwcyA9IHt9O1xuICBmb3IgKCRwcm9wZXJ0eSBpbiAkc2NoZW1hKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eV07XG4gICAgdmFyICRkZXBzID0gQXJyYXkuaXNBcnJheSgkc2NoKSA/ICRwcm9wZXJ0eURlcHMgOiAkc2NoZW1hRGVwcztcbiAgICAkZGVwc1skcHJvcGVydHldID0gJHNjaDtcbiAgfVxuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7JztcbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRwcm9wZXJ0eURlcHMpIHtcbiAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YSkgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpKSArICcgIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICRkZXBzID0gJHByb3BlcnR5RGVwc1skcHJvcGVydHldO1xuICAgIG91dCArPSAnIGlmICggJztcbiAgICB2YXIgYXJyMSA9ICRkZXBzO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJGRlcCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkZGVwID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgb3V0ICs9ICcgfHwgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArIChpdC51dGlsLmdldFByb3BlcnR5KCRkZXApKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gJykgeyAgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ2RlcGVuZGVuY2llcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGhhdmUgJztcbiAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0aWVzICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgd2hlbiBwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJyBpcyBwcmVzZW50XFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbjogJyArICgkZGVwcy5sZW5ndGgpICsgJywgZGVwczogXFwnJztcbiAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnLCBwcm9wZXJ0eTogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBoYXZlICc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydGllcyAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIHdoZW4gcHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICcgaXMgcHJlc2VudFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG46ICcgKyAoJGRlcHMubGVuZ3RoKSArICcsIGRlcHM6IFxcJyc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJ1xcJywgcHJvcGVydHk6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSc7XG4gIH1cbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRzY2hlbWFEZXBzKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hRGVwc1skcHJvcGVydHldO1xuICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IHRydWU7IGlmICgnICsgKCRkYXRhKSArICdbXFwnJyArICgkcHJvcGVydHkpICsgJ1xcJ10gIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpO1xuICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICAgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2VudW0oaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydlbnVtJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2VudW0nLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGkgPSAnaScgKyAkbHZsO1xuICBvdXQgKz0gJ3ZhciBlbnVtU2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7Zm9yICh2YXIgJyArICgkaSkgKyAnPTA7ICcgKyAoJGkpICsgJzxlbnVtU2NoZW1hJyArICgkbHZsKSArICcubGVuZ3RoOyAnICsgKCRpKSArICcrKykgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJywgZW51bVNjaGVtYScgKyAoJGx2bCkgKyAnWycgKyAoJGkpICsgJ10pKSB7ICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyBicmVhazsgfSBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ2VudW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlIGVxdWFsIHRvIG9uZSBvZiB2YWx1ZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnZW51bScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgZXF1YWwgdG8gb25lIG9mIHZhbHVlc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZm9ybWF0KGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnZm9ybWF0J10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2Zvcm1hdCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkZm9ybWF0ID0gaXQuZm9ybWF0c1skc2NoZW1hXTtcbiAgaWYgKGl0Lm9wdHMuZm9ybWF0ICE9PSBmYWxzZSAmJiAkZm9ybWF0KSB7XG4gICAgb3V0ICs9ICcgaWYgKCEgICAnO1xuICAgIGlmICh0eXBlb2YgJGZvcm1hdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvdXQgKz0gJyBmb3JtYXRzJyArIChpdC51dGlsLmdldFByb3BlcnR5KCRzY2hlbWEpKSArICcgKCcgKyAoJGRhdGEpICsgJykgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgZm9ybWF0cycgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkc2NoZW1hKSkgKyAnIC50ZXN0KCcgKyAoJGRhdGEpICsgJykgJztcbiAgICB9XG4gICAgb3V0ICs9ICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdmb3JtYXQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBmb3JtYXQgJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdmb3JtYXQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBmb3JtYXQgJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2l0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnaXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnaXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQ7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoQXJyYXkuaXNBcnJheSgkc2NoZW1hKSkge1xuICAgIHZhciAkYWRkaXRpb25hbEl0ZW1zID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICBpZiAoJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoIDw9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJGkpICsgJykgeyAnO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRpLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkYWRkaXRpb25hbEl0ZW1zID09ICdvYmplY3QnICYmIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJGFkZGl0aW9uYWxJdGVtcywgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgJGl0LnNjaGVtYSA9ICRhZGRpdGlvbmFsSXRlbXM7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxJdGVtcyc7XG4gICAgICBvdXQgKz0gJyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJykgeyAgZm9yICh2YXIgaScgKyAoJGx2bCkgKyAnID0gJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnOyBpJyArICgkbHZsKSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyBpJyArICgkbHZsKSArICcrKykgeyAnO1xuICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAnaScgKyAkbHZsLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2knICsgJGx2bCArICddJztcbiAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9IH0gICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICBvdXQgKz0gJyAgZm9yICh2YXIgaScgKyAoJGx2bCkgKyAnID0gJyArICgwKSArICc7IGknICsgKCRsdmwpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7IGknICsgKCRsdmwpICsgJysrKSB7ICc7XG4gICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAnaScgKyAkbHZsLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1tpJyArICRsdmwgKyAnXSc7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4SXRlbXMoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydtYXhJdGVtcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhJdGVtcycsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWF4SXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBpdGVtc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ21heEl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBtb3JlIHRoYW4gJyArICgkc2NoZW1hKSArICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4TGVuZ3RoKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4TGVuZ3RoJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ21heExlbmd0aCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKCAnO1xuICBpZiAoaXQub3B0cy51bmljb2RlID09PSBmYWxzZSkge1xuICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJy5sZW5ndGggJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB1Y3MybGVuZ3RoKCcgKyAoJGRhdGEpICsgJykgJztcbiAgfVxuICBvdXQgKz0gJyA+ICcgKyAoJHNjaGVtYSkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhMZW5ndGgnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSBsb25nZXIgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBjaGFyYWN0ZXJzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWF4TGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgbG9uZ2VyIHRoYW4gJyArICgkc2NoZW1hKSArICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tYXhQcm9wZXJ0aWVzKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4UHJvcGVydGllcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhQcm9wZXJ0aWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggPiAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWF4UHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhQcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBtb3JlIHRoYW4gJyArICgkc2NoZW1hKSArICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tYXhpbXVtKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4aW11bSddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhpbXVtJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRleGNsdXNpdmUgPSBpdC5zY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSxcbiAgICAkb3AgPSAkZXhjbHVzaXZlID8gJzwnIDogJzw9JyxcbiAgICAkbm90T3AgPSAkZXhjbHVzaXZlID8gJz49JyA6ICc+JztcbiAgb3V0ICs9ICdpZiAoJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21heGltdW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICcgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGNvbmRpdGlvbjogXFwnJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyB9JztcbiAgICB9XG4gICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhpbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21pbkl0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluSXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWluSXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICgnICsgKCRkYXRhKSArICcubGVuZ3RoIDwgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pbkl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBsZXNzIHRoYW4gJyArICgkc2NoZW1hKSArICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5JdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21pbkxlbmd0aChpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21pbkxlbmd0aCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5MZW5ndGgnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdWNzMmxlbmd0aCgnICsgKCRkYXRhKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgPCAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWluTGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgc2hvcnRlciB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGNoYXJhY3RlcnNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5MZW5ndGgnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSBzaG9ydGVyIHRoYW4gJyArICgkc2NoZW1hKSArICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5Qcm9wZXJ0aWVzKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluUHJvcGVydGllcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggPCAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWluUHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5Qcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBsZXNzIHRoYW4gJyArICgkc2NoZW1hKSArICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5pbXVtKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluaW11bSddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5pbXVtJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRleGNsdXNpdmUgPSBpdC5zY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSxcbiAgICAkb3AgPSAkZXhjbHVzaXZlID8gJz4nIDogJz49JyxcbiAgICAkbm90T3AgPSAkZXhjbHVzaXZlID8gJzw9JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pbmltdW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICcgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGNvbmRpdGlvbjogXFwnJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyB9JztcbiAgICB9XG4gICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5pbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX211bHRpcGxlT2YoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydtdWx0aXBsZU9mJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ211bHRpcGxlT2YnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ3ZhciBkaXZpc2lvbicgKyAoJGx2bCkgKyAnID0gJyArICgkZGF0YSkgKyAnIC8gJyArICgkc2NoZW1hKSArICc7aWYgKCcgKyAoJGRhdGEpICsgJyAvICcgKyAoJHNjaGVtYSkgKyAnICE9PSBwYXJzZUludChkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSkgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbXVsdGlwbGVPZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgbXVsdGlwbGUgb2YgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtdWx0aXBsZU9mJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBtdWx0aXBsZSBvZiAnICsgKCRzY2hlbWEpICsgJ1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9ub3QoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydub3QnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbm90JyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7ICAnO1xuICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgIG91dCArPSAnICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICAnO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9IGVsc2UgeyBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIHZhbGlkXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKGZhbHNlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX29uZU9mKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnb25lT2YnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnb25lT2YnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciBwcmV2VmFsaWQnICsgKCRsdmwpICsgJyA9IGZhbHNlO3ZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICBpZiAoYXJyMSkge1xuICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgaWYgKGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICdbJyArICRpICsgJ10nO1xuICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IHRydWU7ICc7XG4gICAgICB9XG4gICAgICBpZiAoJGkpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyAmJiBwcmV2VmFsaWQnICsgKCRsdmwpICsgJykgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgJyArICgkdmFsaWQpICsgJyA9IHByZXZWYWxpZCcgKyAoJGx2bCkgKyAnID0gdHJ1ZTsnO1xuICAgIH1cbiAgfVxuICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICBvdXQgKz0gJycgKyAoJGNsb3NpbmdCcmFjZXMpICsgJ2lmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnb25lT2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdvbmVPZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gZWxzZSB7IGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0nO1xuICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICBvdXQgKz0gJyB9ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcGF0dGVybihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ3BhdHRlcm4nXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAncGF0dGVybicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG5ldyBSZWdFeHAoJHNjaGVtYSk7XG4gIG91dCArPSAnaWYgKCEgJyArIChpdC51c2VQYXR0ZXJuKCRzY2hlbWEpKSArICcudGVzdCgnICsgKCRkYXRhKSArICcpICkgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgncGF0dGVybicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggcGF0dGVybiBcIicgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncGF0dGVybicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggcGF0dGVybiBcIicgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnRpZXMoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydwcm9wZXJ0aWVzJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ3Byb3BlcnRpZXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQ7XG4gIHZhciAkc2NoZW1hS2V5cyA9IE9iamVjdC5rZXlzKCRzY2hlbWEgfHwge30pLFxuICAgICRwUHJvcGVydGllcyA9IGl0LnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyB8fCB7fSxcbiAgICAkcFByb3BlcnR5S2V5cyA9IE9iamVjdC5rZXlzKCRwUHJvcGVydGllcyksXG4gICAgJGFQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICRzb21lUHJvcGVydGllcyA9ICRzY2hlbWFLZXlzLmxlbmd0aCB8fCAkcFByb3BlcnR5S2V5cy5sZW5ndGgsXG4gICAgJG5vQWRkaXRpb25hbCA9ICRhUHJvcGVydGllcyA9PT0gZmFsc2UsXG4gICAgJGFkZGl0aW9uYWxJc1NjaGVtYSA9IHR5cGVvZiAkYVByb3BlcnRpZXMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJGFQcm9wZXJ0aWVzKS5sZW5ndGgsXG4gICAgJHJlbW92ZUFkZGl0aW9uYWwgPSBpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwsXG4gICAgJGNoZWNrQWRkaXRpb25hbCA9ICRub0FkZGl0aW9uYWwgfHwgJGFkZGl0aW9uYWxJc1NjaGVtYSB8fCAkcmVtb3ZlQWRkaXRpb25hbCxcbiAgICAkcmVxdWlyZWRQcm9wZXJ0aWVzID0gaXQudXRpbC50b0hhc2goaXQuc2NoZW1hLnJlcXVpcmVkIHx8IFtdKTtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyc7XG4gIGlmICgkY2hlY2tBZGRpdGlvbmFsKSB7XG4gICAgb3V0ICs9ICcgZm9yICh2YXIga2V5JyArICgkbHZsKSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgaWYgKCRzb21lUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgdmFyIGlzQWRkaXRpb25hbCcgKyAoJGx2bCkgKyAnID0gIShmYWxzZSAnO1xuICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoID4gNSkge1xuICAgICAgICAgIG91dCArPSAnIHx8IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJ1trZXknICsgKCRsdmwpICsgJ10gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyMSA9ICRzY2hlbWFLZXlzO1xuICAgICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMSA9IC0xLFxuICAgICAgICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjFbaTEgKz0gMV07XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8IGtleScgKyAoJGx2bCkgKyAnID09ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkcHJvcGVydHlLZXkpKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkcFByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycjIgPSAkcFByb3BlcnR5S2V5cztcbiAgICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgICB2YXIgJHBQcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcFByb3BlcnR5ID0gYXJyMlskaSArPSAxXTtcbiAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoaXQudXNlUGF0dGVybigkcFByb3BlcnR5KSkgKyAnLnRlc3Qoa2V5JyArICgkbHZsKSArICcpICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyApOyBpZiAoaXNBZGRpdGlvbmFsJyArICgkbHZsKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsID09ICdhbGwnKSB7XG4gICAgICBvdXQgKz0gJyBkZWxldGUgJyArICgkZGF0YSkgKyAnW2tleScgKyAoJGx2bCkgKyAnXTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoO1xuICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICdrZXknICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgaWYgKCRub0FkZGl0aW9uYWwpIHtcbiAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsKSB7XG4gICAgICAgICAgb3V0ICs9ICcgZGVsZXRlICcgKyAoJGRhdGEpICsgJ1trZXknICsgKCRsdmwpICsgJ107ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gZmFsc2U7ICAnO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbFByb3BlcnRpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXFwnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkYWRkaXRpb25hbElzU2NoZW1hKSB7XG4gICAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSAnZmFpbGluZycpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyAgJztcbiAgICAgICAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1trZXknICsgJGx2bCArICddJztcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodmFsaWRhdGUuZXJyb3JzICE9PSBudWxsKSB7IGlmIChlcnJvcnMpIHZhbGlkYXRlLmVycm9ycy5sZW5ndGggPSBlcnJvcnM7IGVsc2UgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgfSBkZWxldGUgJyArICgkZGF0YSkgKyAnW2tleScgKyAoJGx2bCkgKyAnXTsgfSAgJztcbiAgICAgICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkYVByb3BlcnRpZXM7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2tleScgKyAkbHZsICsgJ10nO1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gICAgfVxuICAgIGlmICgkc29tZVByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAnO1xuICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgIH1cbiAgfVxuICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGFycjMgPSAkc2NoZW1hS2V5cztcbiAgICBpZiAoYXJyMykge1xuICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSxcbiAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTMgPCBsMykge1xuICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5S2V5XTtcbiAgICAgICAgaWYgKGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgIHZhciAkcHJvcCA9IGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICRwYXNzRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICRwcm9wO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoaXQuZXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICAkY29kZSA9IGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpO1xuICAgICAgICAgICAgdmFyICR1c2VEYXRhID0gJHBhc3NEYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkbmV4dERhdGE7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkcmVxdWlyZWRQcm9wZXJ0aWVzWyRwcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCkgeyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSBmYWxzZTsgJztcbiAgICAgICAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aCxcbiAgICAgICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgICAgICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCkgeyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyB9IGVsc2UgeyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHVzZURhdGEpICsgJyAhPT0gdW5kZWZpbmVkKSB7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyB9ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBhcnI0ID0gJHBQcm9wZXJ0eUtleXM7XG4gIGlmIChhcnI0KSB7XG4gICAgdmFyICRwUHJvcGVydHksIGk0ID0gLTEsXG4gICAgICBsNCA9IGFycjQubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaTQgPCBsNCkge1xuICAgICAgJHBQcm9wZXJ0eSA9IGFycjRbaTQgKz0gMV07XG4gICAgICB2YXIgJHNjaCA9ICRwUHJvcGVydGllc1skcFByb3BlcnR5XTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcucGF0dGVyblByb3BlcnRpZXMnICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcFByb3BlcnR5KTtcbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIga2V5JyArICgkbHZsKSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7IGlmICgnICsgKGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkpICsgJy50ZXN0KGtleScgKyAoJGx2bCkgKyAnKSkgeyAnO1xuICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICdrZXknICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2tleScgKyAkbHZsICsgJ10nO1xuICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGVsc2UgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVmKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnJHJlZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICckcmVmJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgaWYgKCRzY2hlbWEgPT0gJyMnIHx8ICRzY2hlbWEgPT0gJyMvJykge1xuICAgIGlmIChpdC5pc1Jvb3QpIHtcbiAgICAgIG91dCArPSAnICBpZiAoISAnICsgKCd2YWxpZGF0ZScpICsgJygnICsgKCRkYXRhKSArICcsIChkYXRhUGF0aCB8fCBcXCdcXCcpJztcbiAgICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICAgIG91dCArPSAnICsgJyArIChpdC5lcnJvclBhdGgpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpICkgeyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9ICcgKyAoJ3ZhbGlkYXRlJykgKyAnLmVycm9yczsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoJyArICgndmFsaWRhdGUnKSArICcuZXJyb3JzKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7IH0gJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEgJyArICgncm9vdC5yZWZWYWxbMF0nKSArICcoJyArICgkZGF0YSkgKyAnLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSApIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCdyb290LnJlZlZhbFswXScpICsgJy5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJ3Jvb3QucmVmVmFsWzBdJykgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICRyZWZWYWwgPSBpdC5yZXNvbHZlUmVmKGl0LmJhc2VJZCwgJHNjaGVtYSwgaXQuaXNSb290KTtcbiAgICBpZiAoJHJlZlZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgJG1lc3NhZ2UgPSAnY2FuXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgJHNjaGVtYSArICcgZnJvbSBpZCAnICsgaXQuYmFzZUlkO1xuICAgICAgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gJ2ZhaWwnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCRtZXNzYWdlKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnJHJlZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdjYW5cXFxcXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSkpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGVzY2FwZWQ6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCckcmVmJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2NhblxcXFxcXCd0IHJlc29sdmUgcmVmZXJlbmNlICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmIChmYWxzZSkgeyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gJ2lnbm9yZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJG1lc3NhZ2UpO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkZXJyb3IgPSBuZXcgRXJyb3IoJG1lc3NhZ2UpO1xuICAgICAgICAkZXJyb3IubWlzc2luZ1JlZiA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgJHNjaGVtYSk7XG4gICAgICAgICRlcnJvci5taXNzaW5nU2NoZW1hID0gaXQucmVzb2x2ZS5ub3JtYWxpemVJZChpdC5yZXNvbHZlLmZ1bGxQYXRoKCRlcnJvci5taXNzaW5nUmVmKSk7XG4gICAgICAgIHRocm93ICRlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAkcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEgJyArICgkcmVmVmFsKSArICcoJyArICgkZGF0YSkgKyAnLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSApIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCRyZWZWYWwpICsgJy5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJHJlZlZhbCkgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICAgICAkaXQubGV2ZWwrKztcbiAgICAgICRpdC5zY2hlbWEgPSAkcmVmVmFsLnNjaGVtYTtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gJyc7XG4gICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgaWYgKC92YWxpZGF0ZVxcLnNjaGVtYS8udGVzdCgkY29kZSkpIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIHJvb3RTY2hlbWEnICsgKCRpdC5sZXZlbCkgKyAnID0gdmFsaWRhdGUuc2NoZW1hOyB2YWxpZGF0ZS5zY2hlbWEgPSAnICsgKCRyZWZWYWwuY29kZSkgKyAnOyAnICsgKCRjb2RlKSArICcgdmFsaWRhdGUuc2NoZW1hID0gcm9vdFNjaGVtYScgKyAoJGl0LmxldmVsKSArICc7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVxdWlyZWQoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydyZXF1aXJlZCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdyZXF1aXJlZCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIGlmIChpdC5zY2hlbWEucHJvcGVydGllcyAmJiBPYmplY3Qua2V5cyhpdC5zY2hlbWEucHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgdmFyICRyZXF1aXJlZCA9IFtdO1xuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRwcm9wZXJ0eSwgaTEgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgICAkcHJvcGVydHkgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgICB2YXIgJHByb3BlcnR5U2NoID0gaXQuc2NoZW1hLnByb3BlcnRpZXNbJHByb3BlcnR5XTtcbiAgICAgICAgaWYgKCEoJHByb3BlcnR5U2NoICYmIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHByb3BlcnR5U2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAgICRyZXF1aXJlZFskcmVxdWlyZWQubGVuZ3RoXSA9ICRwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJHJlcXVpcmVkID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoJHJlcXVpcmVkLmxlbmd0aCkge1xuICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFyIG1pc3NpbmcnICsgKCRsdmwpICsgJzsgJztcbiAgICAgIGlmICgkcmVxdWlyZWQubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgIG91dCArPSAnIGlmICggJztcbiAgICAgICAgdmFyIGFycjIgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSk7XG4gICAgICAgICAgICBvdXQgKz0gJyAoICcgKyAoJGRhdGEpICsgKCRwcm9wKSArICcgPT09IHVuZGVmaW5lZCAmJiAobWlzc2luZycgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKGl0Lm9wdHMuanNvblBvaW50ZXJzID8gJHByb3BlcnR5IDogJHByb3ApKSArICcpICkgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcpIHsgJztcbiAgICAgICAgdmFyICRwcm9wZXJ0eVBhdGggPSAnbWlzc2luZycgKyAkbHZsLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgJyArICRwcm9wZXJ0eVBhdGggKyAnICsgXFwnJztcbiAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQub3B0cy5qc29uUG9pbnRlcnMgPyBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCB0cnVlKSA6ICRjdXJyZW50RXJyb3JQYXRoICsgJyArICcgKyAkcHJvcGVydHlQYXRoO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIHZhciAkaSA9ICdpJyArICRsdmwsXG4gICAgICAgICAgJHByb3BlcnR5UGF0aCA9ICdzY2hlbWEnICsgJGx2bCArICdbJyArICRpICsgJ10nLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgXCJcXCdcIiArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFwiXFwnXCIgKyBcXCcnO1xuICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8IHNjaGVtYScgKyAoJGx2bCkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgdmFyICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICdbc2NoZW1hJyArICgkbHZsKSArICdbJyArICgkaSkgKyAnXV0gIT09IHVuZGVmaW5lZDsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSBicmVhazsgfSAgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAnO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRyZXF1aXJlZC5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgdmFyIGFycjMgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIzKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwzKSB7XG4gICAgICAgICAgICAkcHJvcGVydHkgPSBhcnIzWyRpICs9IDFdO1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpLFxuICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3ApO1xuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhKSArICgkcHJvcCkgKyAnID09PSB1bmRlZmluZWQpIHsgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHlcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIHZhciAkaSA9ICdpJyArICRsdmwsXG4gICAgICAgICAgJHByb3BlcnR5UGF0aCA9ICdzY2hlbWEnICsgJGx2bCArICdbJyArICRpICsgJ10nLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgXCJcXCdcIiArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFwiXFwnXCIgKyBcXCcnO1xuICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8IHNjaGVtYScgKyAoJGx2bCkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgaWYgKCcgKyAoJGRhdGEpICsgJ1tzY2hlbWEnICsgKCRsdmwpICsgJ1snICsgKCRpKSArICddXSA9PT0gdW5kZWZpbmVkKSB7ICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gfSAnO1xuICAgICAgfVxuICAgIH1cbiAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgfSBlbHNlIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgaWYgKHRydWUpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3VuaXF1ZUl0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsndW5pcXVlSXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAndW5pcXVlSXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBpZiAoJHNjaGVtYSAmJiBpdC5vcHRzLnVuaXF1ZUl0ZW1zICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAxKSB7IHZhciBpID0gJyArICgkZGF0YSkgKyAnLmxlbmd0aCwgajsgb3V0ZXI6IGZvciAoO2ktLTspIHsgZm9yIChqID0gaTsgai0tOykgeyBpZiAoZXF1YWwoJyArICgkZGF0YSkgKyAnW2ldLCAnICsgKCRkYXRhKSArICdbal0pKSB7ICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgYnJlYWsgb3V0ZXI7IH0gfSB9IH0gaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAnO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgndW5pcXVlSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjIFxcJyArIGogKyBcXCcgYW5kIFxcJyArIGkgKyBcXCcgYXJlIGlkZW50aWNhbClcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGk6IGksIGo6IGogfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCd1bmlxdWVJdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgXFwnICsgaiArIFxcJyBhbmQgXFwnICsgaSArIFxcJyBhcmUgaWRlbnRpY2FsKVxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgaTogaSwgajogaiB9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdmFsaWRhdGUoaXQpIHtcbiAgdmFyIG91dCA9ICcnO1xuICBpZiAoaXQuaXNUb3ApIHtcbiAgICB2YXIgJHRvcCA9IGl0LmlzVG9wLFxuICAgICAgJGx2bCA9IGl0LmxldmVsID0gMCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsID0gMCxcbiAgICAgICRkYXRhID0gJ2RhdGEnO1xuICAgIGl0LnJvb3RJZCA9IGl0LnJlc29sdmUuZnVsbFBhdGgoaXQucm9vdC5zY2hlbWEuaWQpO1xuICAgIGl0LmJhc2VJZCA9IGl0LmJhc2VJZCB8fCBpdC5yb290SWQ7XG4gICAgZGVsZXRlIGl0LmlzVG9wO1xuICAgIG91dCArPSAnIHZhbGlkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGRhdGFQYXRoKSB7IFxcJ3VzZSBzdHJpY3RcXCc7IHZhciB2RXJyb3JzID0gbnVsbDsgJztcbiAgICBvdXQgKz0gJyB2YXIgZXJyb3JzID0gMDsgICAgICc7XG4gIH0gZWxzZSB7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICAgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICAgIGlmIChpdC5zY2hlbWEuaWQpIGl0LmJhc2VJZCA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgaXQuc2NoZW1hLmlkKTtcbiAgICBvdXQgKz0gJyB2YXIgZXJyc18nICsgKCRsdmwpICsgJyA9IGVycm9yczsnO1xuICB9XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzLFxuICAgICRjbG9zaW5nQnJhY2VzMSA9ICcnLFxuICAgICRjbG9zaW5nQnJhY2VzMiA9ICcnO1xuICB2YXIgJHR5cGVTY2hlbWEgPSBpdC5zY2hlbWEudHlwZTtcbiAgdmFyIGFycjEgPSBpdC5SVUxFUztcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHJ1bGVzR3JvdXAsIGkxID0gLTEsXG4gICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgJHJ1bGVzR3JvdXAgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgaWYgKCRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkpIHtcbiAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsLmNoZWNrRGF0YVR5cGUoJHJ1bGVzR3JvdXAudHlwZSwgJGRhdGEpKSArICcpIHsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyMiA9ICRydWxlc0dyb3VwLnJ1bGVzO1xuICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgIHZhciAkcnVsZSwgaTIgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpMiA8IGwyKSB7XG4gICAgICAgICAgICAkcnVsZSA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgICAgICBpZiAoJHNob3VsZFVzZVJ1bGUoJHJ1bGUpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGUuY29kZShpdCkpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMSArPSAnfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMSkgKyAnICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMxID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgaWYgKCR0eXBlU2NoZW1hICYmICR0eXBlU2NoZW1hID09PSAkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgJHR5cGVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dCArPSAnIGVsc2UgeyAgJztcbiAgICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1tcXCcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCInLCdcIikpICsgJ1xcJ10nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IHR5cGU6IFxcJyc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyB9JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgndHlwZScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcnICsgKCR0eXBlU2NoZW1hKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKGVycm9ycyA9PT0gJztcbiAgICAgICAgICBpZiAoJHRvcCkge1xuICAgICAgICAgICAgb3V0ICs9ICcwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICdlcnJzXycgKyAoJGx2bCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMyICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJHR5cGVTY2hlbWEgJiYgISR0eXBlQ2hlY2tlZCkge1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnR5cGUnLFxuICAgICAgJGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCR0eXBlU2NoZW1hKSxcbiAgICAgICRtZXRob2QgPSAkaXNBcnJheSA/ICdjaGVja0RhdGFUeXBlcycgOiAnY2hlY2tEYXRhVHlwZSc7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoaXQudXRpbFskbWV0aG9kXSgkdHlwZVNjaGVtYSwgJGRhdGEsIHRydWUpKSArICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSc7XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMikgKyAnICc7XG4gIH1cbiAgaWYgKCR0b3ApIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyAnO1xuICAgIG91dCArPSAnIHJldHVybiBlcnJvcnMgPT09IDA7ICAgICAgICc7XG4gICAgb3V0ICs9ICcgfSc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSBlcnJvcnMgPT09IGVycnNfJyArICgkbHZsKSArICc7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIGlmICgkdG9wICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgPSBpdC51dGlsLmNsZWFuVXBWYXJFcnJvcnMob3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHJ1bGVzR3JvdXAucnVsZXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoJHNob3VsZFVzZVJ1bGUoJHJ1bGVzR3JvdXAucnVsZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VSdWxlKCRydWxlKSB7XG4gICAgcmV0dXJuIGl0LnNjaGVtYVskcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8ICgkcnVsZS5rZXl3b3JkID09ICdwcm9wZXJ0aWVzJyAmJiAoaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSB8fCB0eXBlb2YgaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09ICdvYmplY3QnIHx8IChpdC5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgJiYgT2JqZWN0LmtleXMoaXQuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKS5sZW5ndGgpKSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcImlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwiaXRlbXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvc2l0aXZlSW50ZWdlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIjogMFxuICAgICAgICB9LFxuICAgICAgICBcInBvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgICAgICAgIFwiYWxsT2ZcIjogWyB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyXCIgfSwgeyBcImRlZmF1bHRcIjogMCB9IF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzaW1wbGVUeXBlc1wiOiB7XG4gICAgICAgICAgICBcImVudW1cIjogWyBcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCIgXVxuICAgICAgICB9LFxuICAgICAgICBcInN0cmluZ0FycmF5XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImlkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgICAgICB9LFxuICAgICAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGl0bGVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlZmF1bHRcIjoge30sXG4gICAgICAgIFwibXVsdGlwbGVPZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJtaW5pbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhMZW5ndGhcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgIFwibWluTGVuZ3RoXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MFwiIH0sXG4gICAgICAgIFwicGF0dGVyblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgICAgICB9LFxuICAgICAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiI1wiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhJdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyXCIgfSxcbiAgICAgICAgXCJtaW5JdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIm1heFByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgIFwibWluUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInJlcXVpcmVkXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwiIH0sXG4gICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJlbnVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcImFsbE9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICAgIFwiYW55T2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgICAgXCJvbmVPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgICBcIm5vdFwiOiB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgfSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiBbIFwibWF4aW11bVwiIF0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiBbIFwibWluaW11bVwiIF1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB7fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3QgdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnVWludDY0QXJyYXksZT1TeW1ib2woKSxyPW5ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIse2ZhdGFsOiEwfSk7ZnVuY3Rpb24gbih0LGUpe2xldCBuPW5ldyBVaW50MzJBcnJheSh0KVtlKy00Pj4+Ml0+Pj4xO2NvbnN0IHM9bmV3IFVpbnQxNkFycmF5KHQsZSxuKTtpZihuPD0xOTIpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ucyk7dHJ5e3JldHVybiByLmRlY29kZShzKX1jYXRjaHtsZXQgdD1cIlwiLGU9MDtmb3IoO24tZT4xMDI0Oyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnMuc3ViYXJyYXkoZSxlKz0xMDI0KSk7cmV0dXJuIHQrU3RyaW5nLmZyb21DaGFyQ29kZSguLi5zLnN1YmFycmF5KGUpKX19ZnVuY3Rpb24gcyh0KXtjb25zdCBlPXt9O2Z1bmN0aW9uIHIodCxlKXtyZXR1cm4gdD9uKHQuYnVmZmVyLGUpOlwiPHlldCB1bmtub3duPlwifWNvbnN0IHM9dC5lbnY9dC5lbnZ8fHt9O3JldHVybiBzLmFib3J0PXMuYWJvcnR8fGZ1bmN0aW9uKHQsbixvLGkpe2NvbnN0IGE9ZS5tZW1vcnl8fHMubWVtb3J5O3Rocm93IEVycm9yKGBhYm9ydDogJHtyKGEsdCl9IGF0ICR7cihhLG4pfToke299OiR7aX1gKX0scy50cmFjZT1zLnRyYWNlfHxmdW5jdGlvbih0LG4sLi4ubyl7Y29uc3QgaT1lLm1lbW9yeXx8cy5tZW1vcnk7Y29uc29sZS5sb2coYHRyYWNlOiAke3IoaSx0KX0ke24/XCIgXCI6XCJcIn0ke28uc2xpY2UoMCxuKS5qb2luKFwiLCBcIil9YCl9LHMuc2VlZD1zLnNlZWR8fERhdGUubm93LHQuTWF0aD10Lk1hdGh8fE1hdGgsdC5EYXRlPXQuRGF0ZXx8RGF0ZSxlfWNvbnN0IG89ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcIk9wZXJhdGlvbiByZXF1aXJlcyBjb21waWxpbmcgd2l0aCAtLWV4cG9ydFJ1bnRpbWVcIil9O2Z1bmN0aW9uIGkoZSxyKXtjb25zdCBzPXIuZXhwb3J0cyxpPXMubWVtb3J5LGE9cy50YWJsZSxjPXMuX19uZXd8fG8sdT1zLl9fcGlufHxvLHk9cy5fX3VucGlufHxvLGw9cy5fX2NvbGxlY3R8fG8scD1zLl9fcnR0aV9iYXNlLGQ9cD9mdW5jdGlvbih0KXtyZXR1cm4gdFtwPj4+Ml19Om87ZnVuY3Rpb24gYih0KXtjb25zdCBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IFVpbnQzMkFycmF5KGkuYnVmZmVyKTtpZigodD4+Pj0wKT49ZChlKSl0aHJvdyBFcnJvcihgaW52YWxpZCBpZDogJHt0fWApO3JldHVybiBlWyhwKzQ+Pj4yKSsyKnRdfSh0KTtpZighKDcmZSkpdGhyb3cgRXJyb3IoYG5vdCBhbiBhcnJheTogJHt0fSwgZmxhZ3M9JHtlfWApO3JldHVybiBlfWZ1bmN0aW9uIGgodCl7Y29uc3QgZT1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpO2lmKCh0Pj4+PTApPj1kKGUpKXRocm93IEVycm9yKGBpbnZhbGlkIGlkOiAke3R9YCk7cmV0dXJuIGVbKHArND4+PjIpKzIqdCsxXX1mdW5jdGlvbiBtKHQpe3JldHVybiAzMS1NYXRoLmNsejMyKHQ+Pj42JjMxKX1mdW5jdGlvbiBnKHQsZSxyKXtjb25zdCBuPWkuYnVmZmVyO2lmKHIpc3dpdGNoKHQpe2Nhc2UgMjpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShuKTtjYXNlIDM6cmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobil9ZWxzZSBzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBuZXcoZT9JbnQ4QXJyYXk6VWludDhBcnJheSkobik7Y2FzZSAxOnJldHVybiBuZXcoZT9JbnQxNkFycmF5OlVpbnQxNkFycmF5KShuKTtjYXNlIDI6cmV0dXJuIG5ldyhlP0ludDMyQXJyYXk6VWludDMyQXJyYXkpKG4pO2Nhc2UgMzpyZXR1cm4gbmV3KGU/QmlnSW50NjRBcnJheTpCaWdVaW50NjRBcnJheSkobil9dGhyb3cgRXJyb3IoYHVuc3VwcG9ydGVkIGFsaWduOiAke3R9YCl9ZnVuY3Rpb24gQSh0KXtjb25zdCBlPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcikscj1iKGVbdCstOD4+PjJdKSxuPW0ocik7bGV0IHM9NCZyP3Q6ZVt0KzQ+Pj4yXTtjb25zdCBvPTImcj9lW3QrMTI+Pj4yXTplW3MrLTQ+Pj4yXT4+Pm47cmV0dXJuIGcobiwyMDQ4JnIsNDA5NiZyKS5zdWJhcnJheShzPj4+PW4scytvKX1mdW5jdGlvbiB3KHQsZSxyKXtyZXR1cm4gbmV3IHQoXyh0LGUscikpfWZ1bmN0aW9uIF8odCxlLHIpe2NvbnN0IG49aS5idWZmZXIscz1uZXcgVWludDMyQXJyYXkobiksbz1zW3IrND4+PjJdO3JldHVybiBuZXcgdChuLG8sc1tvKy00Pj4+Ml0+Pj5lKX1mdW5jdGlvbiBUKHQscixuKXtlW2BfX2dldCR7cn1gXT13LmJpbmQobnVsbCx0LG4pLGVbYF9fZ2V0JHtyfVZpZXdgXT1fLmJpbmQobnVsbCx0LG4pfXJldHVybiBlLl9fbmV3PWMsZS5fX3Bpbj11LGUuX191bnBpbj15LGUuX19jb2xsZWN0PWwsZS5fX25ld1N0cmluZz1mdW5jdGlvbih0KXtpZihudWxsPT10KXJldHVybiAwO2NvbnN0IGU9dC5sZW5ndGgscj1jKGU8PDEsMSksbj1uZXcgVWludDE2QXJyYXkoaS5idWZmZXIpO2Zvcih2YXIgcz0wLG89cj4+PjE7czxlOysrcyluW28rc109dC5jaGFyQ29kZUF0KHMpO3JldHVybiByfSxlLl9fbmV3QXJyYXlCdWZmZXI9ZnVuY3Rpb24odCl7aWYobnVsbD09dClyZXR1cm4gMDtjb25zdCBlPW5ldyBVaW50OEFycmF5KHQpLHI9YyhlLmxlbmd0aCwwKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIpLnNldChlLHIpLHJ9LGUuX19nZXRTdHJpbmc9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIG51bGw7Y29uc3QgZT1pLmJ1ZmZlcjtpZigxIT09bmV3IFVpbnQzMkFycmF5KGUpW3QrLTg+Pj4yXSl0aHJvdyBFcnJvcihgbm90IGEgc3RyaW5nOiAke3R9YCk7cmV0dXJuIG4oZSx0KX0sZS5fX25ld0FycmF5PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgcj1iKHQpLG49bShyKSxzPWUubGVuZ3RoLG89YyhzPDxuLDQmcj90OjApO2xldCBhO2lmKDQmcilhPW87ZWxzZXt1KG8pO2NvbnN0IGU9YygyJnI/MTY6MTIsdCk7eShvKTtjb25zdCBmPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcik7ZltlKzA+Pj4yXT1vLGZbZSs0Pj4+Ml09byxmW2UrOD4+PjJdPXM8PG4sMiZyJiYoZltlKzEyPj4+Ml09cyksYT1lfWNvbnN0IGY9ZyhuLDIwNDgmciw0MDk2JnIpO2lmKDE2Mzg0JnIpZm9yKGxldCB0PTA7dDxzOysrdCl7Y29uc3Qgcj1lW3RdO2ZbKG8+Pj5uKSt0XT1yfWVsc2UgZi5zZXQoZSxvPj4+bik7cmV0dXJuIGF9LGUuX19nZXRBcnJheVZpZXc9QSxlLl9fZ2V0QXJyYXk9ZnVuY3Rpb24odCl7Y29uc3QgZT1BKHQpLHI9ZS5sZW5ndGgsbj1uZXcgQXJyYXkocik7Zm9yKGxldCB0PTA7dDxyO3QrKyluW3RdPWVbdF07cmV0dXJuIG59LGUuX19nZXRBcnJheUJ1ZmZlcj1mdW5jdGlvbih0KXtjb25zdCBlPWkuYnVmZmVyLHI9bmV3IFVpbnQzMkFycmF5KGUpW3QrLTQ+Pj4yXTtyZXR1cm4gZS5zbGljZSh0LHQrcil9LFtJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV0uZm9yRWFjaCgodD0+e1QodCx0Lm5hbWUsMzEtTWF0aC5jbHozMih0LkJZVEVTX1BFUl9FTEVNRU5UKSl9KSksdCYmW0JpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXldLmZvckVhY2goKHQ9PntUKHQsdC5uYW1lLnNsaWNlKDMpLDMpfSkpLGUuX19pbnN0YW5jZW9mPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgcj1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpO2xldCBuPXJbdCstOD4+PjJdO2lmKG48PWQocikpZG97aWYobj09ZSlyZXR1cm4hMDtuPWgobil9d2hpbGUobik7cmV0dXJuITF9LGUubWVtb3J5PWUubWVtb3J5fHxpLGUudGFibGU9ZS50YWJsZXx8YSxmKHMsZSl9ZnVuY3Rpb24gYSh0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVzcG9uc2UmJnQgaW5zdGFuY2VvZiBSZXNwb25zZX1mdW5jdGlvbiBjKHQpe3JldHVybiB0IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlfWFzeW5jIGZ1bmN0aW9uIHUodCxlPXt9KXtpZihhKHQ9YXdhaXQgdCkpcmV0dXJuIHkodCxlKTtjb25zdCByPWModCk/dDphd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHQpLG49cyhlKSxvPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHIsZSk7cmV0dXJue21vZHVsZTpyLGluc3RhbmNlOm8sZXhwb3J0czppKG4sbyl9fWFzeW5jIGZ1bmN0aW9uIHkodCxlPXt9KXtpZighV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpcmV0dXJuIHUoYSh0PWF3YWl0IHQpP3QuYXJyYXlCdWZmZXIoKTp0LGUpO2NvbnN0IHI9cyhlKSxuPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQsZSksbz1pKHIsbi5pbnN0YW5jZSk7cmV0dXJuey4uLm4sZXhwb3J0czpvfX1mdW5jdGlvbiBmKHQscj17fSl7Y29uc3Qgbj10Ll9fYXJndW1lbnRzTGVuZ3RoP2U9Pnt0Ll9fYXJndW1lbnRzTGVuZ3RoLnZhbHVlPWV9OnQuX19zZXRBcmd1bWVudHNMZW5ndGh8fHQuX19zZXRhcmdjfHwoKCk9Pnt9KTtmb3IobGV0IHMgaW4gdCl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHMpKWNvbnRpbnVlO2NvbnN0IG89dFtzXTtsZXQgaT1zLnNwbGl0KFwiLlwiKSxhPXI7Zm9yKDtpLmxlbmd0aD4xOyl7bGV0IHQ9aS5zaGlmdCgpO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLHQpfHwoYVt0XT17fSksYT1hW3RdfWxldCBjPWlbMF0sdT1jLmluZGV4T2YoXCIjXCIpO2lmKHU+PTApe2NvbnN0IHI9Yy5zdWJzdHJpbmcoMCx1KSxpPWFbcl07aWYodm9pZCAwPT09aXx8IWkucHJvdG90eXBlKXtjb25zdCB0PWZ1bmN0aW9uKC4uLmUpe3JldHVybiB0LndyYXAodC5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwuLi5lKSl9O3QucHJvdG90eXBlPXt2YWx1ZU9mKCl7cmV0dXJuIHRoaXNbZV19fSx0LndyYXA9ZnVuY3Rpb24ocil7cmV0dXJuIE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse1tlXTp7dmFsdWU6cix3cml0YWJsZTohMX19KX0saSYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSkuZm9yRWFjaCgoZT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksZSkpKSksYVtyXT10fWlmKGM9Yy5zdWJzdHJpbmcodSsxKSxhPWFbcl0ucHJvdG90eXBlLC9eKGdldHxzZXQpOi8udGVzdChjKSl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGM9Yy5zdWJzdHJpbmcoNCkpKXtsZXQgcj10W3MucmVwbGFjZShcInNldDpcIixcImdldDpcIildLG49dFtzLnJlcGxhY2UoXCJnZXQ6XCIsXCJzZXQ6XCIpXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHtnZXQoKXtyZXR1cm4gcih0aGlzW2VdKX0sc2V0KHQpe24odGhpc1tlXSx0KX0sZW51bWVyYWJsZTohMH0pfX1lbHNlXCJjb25zdHJ1Y3RvclwiPT09Yz8oYVtjXT0oLi4udCk9PihuKHQubGVuZ3RoKSxvKC4uLnQpKSkub3JpZ2luYWw9bzooYVtjXT1mdW5jdGlvbiguLi50KXtyZXR1cm4gbih0Lmxlbmd0aCksbyh0aGlzW2VdLC4uLnQpfSkub3JpZ2luYWw9b31lbHNlL14oZ2V0fHNldCk6Ly50ZXN0KGMpP09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGM9Yy5zdWJzdHJpbmcoNCkpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHtnZXQ6dFtzLnJlcGxhY2UoXCJzZXQ6XCIsXCJnZXQ6XCIpXSxzZXQ6dFtzLnJlcGxhY2UoXCJnZXQ6XCIsXCJzZXQ6XCIpXSxlbnVtZXJhYmxlOiEwfSk6XCJmdW5jdGlvblwiPT10eXBlb2YgbyYmbyE9PW4/KGFbY109KC4uLnQpPT4obih0Lmxlbmd0aCksbyguLi50KSkpLm9yaWdpbmFsPW86YVtjXT1vfXJldHVybiByfXZhciBsPXtpbnN0YW50aWF0ZTp1LGluc3RhbnRpYXRlU3luYzpmdW5jdGlvbih0LGU9e30pe2NvbnN0IHI9Yyh0KT90Om5ldyBXZWJBc3NlbWJseS5Nb2R1bGUodCksbj1zKGUpLG89bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHIsZSk7cmV0dXJue21vZHVsZTpyLGluc3RhbmNlOm8sZXhwb3J0czppKG4sbyl9fSxpbnN0YW50aWF0ZVN0cmVhbWluZzp5LGRlbWFuZ2xlOmZ9O2Z1bmN0aW9uIHAodCxlLHIpe3JldHVybiBlfWZ1bmN0aW9uIGQodCxlLHIpe3JldHVybiB0LmV4cG9ydHNbYF9fZ2V0JHtmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGFydHNXaXRoKFwifmxpYi90eXBlZGFycmF5L1wiKT8oKHQ9dC5zbGljZShcIn5saWIvdHlwZWRhcnJheS9cIi5sZW5ndGgpKS5zdGFydHNXaXRoKFwiQmlnXCIpJiYodD10LnNsaWNlKDMpKSx0KTp0fShyKX1WaWV3YF0oZSl9ZnVuY3Rpb24gYih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX25ld0FycmF5KHQuZ2V0VHlwZUlkKHIpLGUpfWZ1bmN0aW9uIGgodCl7aWYoIXQuc3RhcnRzV2l0aChcIn5saWIvYXJyYXkvQXJyYXlcIikpdGhyb3cgRXJyb3IoYCR7SlNPTi5zdHJpbmdpZnkodCl9IGlzIG5vdCBhbiBhcnJheSB0eXBlYCk7cmV0dXJuIHQuc2xpY2UoXCJ+bGliL2FycmF5L0FycmF5PFwiLmxlbmd0aCwtMSl9Y29uc3QgbT1uZXcgTWFwKFtbXCJ2b2lkXCIse2FzY1RvSnM6cCxqc1RvQXNjOnB9XSxbL14oaXx1fGYpKDh8MTZ8MzJ8NjQpfFt1aV1zaXplfGJvb2x8ZXh0ZXJucmVmJC8se2FzY1RvSnM6cCxqc1RvQXNjOnB9XSxbXCJ+bGliL3N0cmluZy9TdHJpbmdcIix7YXNjVG9KczpmdW5jdGlvbih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX2dldFN0cmluZyhlKX0sanNUb0FzYzpmdW5jdGlvbih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX25ld1N0cmluZyhlKX19XSxbXCJ+bGliL3R5cGVkYXJyYXkvSW50OEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvSW50MTZBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0ludDMyQXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50OEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvVWludDE2QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50MzJBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0ludDY0QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50NjRBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L1VpbnQ4Q2xhbXBlZEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvRmxvYXQzMkFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvRmxvYXQ2NEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL2FycmF5YnVmZmVyL0FycmF5QnVmZmVyXCIse2FzY1RvSnM6ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LmV4cG9ydHMuX19nZXRBcnJheUJ1ZmZlcihlKX0sanNUb0FzYzpmdW5jdGlvbih0LGUscil7Y29uc3Qgbj10LmV4cG9ydHMuX19uZXcoZS5ieXRlTGVuZ3RoLHQuZ2V0VHlwZUlkKHIpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodC5leHBvcnRzLm1lbW9yeS5idWZmZXIsbixlLmJ5dGVMZW5ndGgpLnNldChuZXcgVWludDhBcnJheShlKSksbn19XSxbL15+bGliXFwvYXJyYXlcXC9BcnJheTwuKz4kLyx7YXNjVG9KczpmdW5jdGlvbih0LGUscil7Y29uc3Qgbj1oKHIpLHM9QShuKTtyZXR1cm4gdC5leHBvcnRzLl9fZ2V0QXJyYXkoZSkubWFwKChlPT5zLmFzY1RvSnModCxlLG4pKSl9LGpzVG9Bc2M6ZnVuY3Rpb24odCxlLHIpe2NvbnN0IG49aChyKSxzPUEobiksbz1lLm1hcCgoZT0+cy5qc1RvQXNjKHQsZSxuKSkpO3JldHVybiB0LmV4cG9ydHMuX19uZXdBcnJheSh0LmdldFR5cGVJZChyKSxvKX19XV0pLGc9bmV3IFNldDtmdW5jdGlvbiBBKHQpe2Zvcihjb25zdFtlLHJdb2YgbSlpZihcInN0cmluZ1wiIT10eXBlb2YgZSl7aWYoZS50ZXN0KHQpKXJldHVybiByfWVsc2UgaWYoZT09PXQpcmV0dXJuIHI7cmV0dXJuIGcuaGFzKHQpfHwoY29uc29sZS53YXJuKGBObyBjb252ZXJ0ZXIgZm9yICR7SlNPTi5zdHJpbmdpZnkodCl9LCB1c2luZyBwYXNzLXRocm91Z2hgKSxnLmFkZCh0KSkse2FzY1RvSnM6cCxqc1RvQXNjOnB9fWZ1bmN0aW9uIHcodCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT1BKHQpKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5hc2NUb0pzfWZ1bmN0aW9uIF8odCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT1BKHQpKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5qc1RvQXNjfWZ1bmN0aW9uIFQodCxlLHIpe2NvbnN0IG49ci5wYXJhbWV0ZXJzLm1hcCh3KSxzPV8oci5yZXR1cm5UeXBlKTtyZXR1cm4gZnVuY3Rpb24oLi4ubyl7aWYoby5sZW5ndGghPW4ubGVuZ3RoKXRocm93IEVycm9yKGBFeHBlY3RlZCAke24ubGVuZ3RofSBhcmd1bWVudHMsIGdvdCAke28ubGVuZ3RofWApO2NvbnN0IGk9by5tYXAoKChlLHMpPT5uW3NdKHQsZSxyLnBhcmFtZXRlcnNbc10pKSksYT1lKC4uLmkpO3JldHVybiBzKHQsYSxyLnJldHVyblR5cGUpfX1mdW5jdGlvbiBqKHQsZSxyKXtjb25zdCBuPXIucGFyYW1ldGVycy5tYXAoXykscz13KHIucmV0dXJuVHlwZSk7cmV0dXJuKC4uLm8pPT57aWYoby5sZW5ndGghPW4ubGVuZ3RoKXRocm93IEVycm9yKGBFeHBlY3RlZCAke24ubGVuZ3RofSBhcmd1bWVudHMsIGdvdCAke28ubGVuZ3RofWApO2NvbnN0IGk9W10sYT1vLm1hcCgoKGUscyk9Pntjb25zdCBvPW5bc10odCxlLHIucGFyYW1ldGVyc1tzXSk7cmV0dXJuIG8hPT1lJiYodC5leHBvcnRzLl9fcGluKG8pLGkucHVzaChvKSksb30pKSxjPWUoLi4uYSk7cmV0dXJuIGkuZm9yRWFjaCgoZT0+dC5leHBvcnRzLl9fdW5waW4oZSkpKSxzKHQsYyxyLnJldHVyblR5cGUpfX1mdW5jdGlvbiB4KHQse2RlcHRoOmU9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfT17fSl7cmV0dXJuIGU8PTB8fCF0fHxcIm9iamVjdFwiIT10eXBlb2YgdD90Ok9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0KS5tYXAoKChbdCxyXSk9Plt0LHgocix7ZGVwdGg6ZS0xfSldKSkpfWZ1bmN0aW9uIE8odCl7Y29uc3QgZT1XZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnModCxcImFzLWJpbmRfYmluZGluZ3NcIikscj1uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShuZXcgVWludDhBcnJheShlWzBdKSk7dHJ5e3JldHVybiBKU09OLnBhcnNlKHIpfWNhdGNoKHQpe3Rocm93IEVycm9yKGBDb3VsZG7igJl0IGRlY29kZSB0eXBlIGRlc2NyaXB0b3I6ICR7dC5tZXNzYWdlfWApfX1jbGFzcyBVe2NvbnN0cnVjdG9yKCl7dGhpcy51bmJvdW5kRXhwb3J0cz17fSx0aGlzLmV4cG9ydHM9e30sdGhpcy5pbXBvcnRPYmplY3Q9e319Z2V0VHlwZUlkKHQpe2lmKHQgaW4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzKXJldHVybiB0aGlzLnR5cGVEZXNjcmlwdG9yLnR5cGVJZHNbdF0uaWQ7dGhyb3cgRXJyb3IoYFVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KHQpfWApfWdldFR5cGVTaXplKHQpe2lmKHQgaW4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzKXJldHVybiB0aGlzLnR5cGVEZXNjcmlwdG9yLnR5cGVJZHNbdF0uYnl0ZVNpemU7dGhyb3cgRXJyb3IoYFVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KHQpfWApfV92YWxpZGF0ZSgpe2lmKCFXZWJBc3NlbWJseS5Nb2R1bGUuZXhwb3J0cyh0aGlzLm1vZHVsZSkuZmluZCgodD0+XCJfX25ld1wiPT09dC5uYW1lKSkpdGhyb3cgRXJyb3IoXCJUaGUgQXNzZW1ibHlTY3JpcHQgd2FzbSBtb2R1bGUgd2FzIG5vdCBidWlsdCB3aXRoIC0tZXhwb3J0UnVudGltZSwgd2hpY2ggaXMgcmVxdWlyZWQuXCIpO2lmKDEhPT1XZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnModGhpcy5tb2R1bGUsXCJhcy1iaW5kX2JpbmRpbmdzXCIpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQXNzZW1ibHlTY3JpcHQgd2FzbSBtb2R1bGUgd2FzIG5vdCBidWlsdCB3aXRoIHRoZSBhcy1iaW5kIHRyYW5zZm9ybS5cIil9YXN5bmMgX2luc3RhbnRpYXRlKHQsZSl7dGhpcy5tb2R1bGU9YXdhaXQgYXN5bmMgZnVuY3Rpb24odCl7aWYodD1hd2FpdCBQcm9taXNlLnJlc29sdmUodCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlc3BvbnNlJiZ0IGluc3RhbmNlb2YgUmVzcG9uc2Upe2lmKFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcpcmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcodCk7dD1hd2FpdCB0LmFycmF5QnVmZmVyKCl9cmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGUodCl9KHQpLHRoaXMuX3ZhbGlkYXRlKCksdGhpcy50eXBlRGVzY3JpcHRvcj1PKHRoaXMubW9kdWxlKSx0aGlzLl9pbnN0YW50aWF0ZUJpbmRJbXBvcnRGdW5jdGlvbnMoZSksdGhpcy5sb2FkZWRNb2R1bGU9YXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlKXtyZXR1cm4gbC5pbnN0YW50aWF0ZSh0LGUpfSh0aGlzLm1vZHVsZSx0aGlzLmltcG9ydE9iamVjdCksdGhpcy5faW5zdGFudGlhdGVCaW5kVW5ib3VuZEV4cG9ydHMoKX1faW5zdGFudGlhdGVTeW5jKHQsZSl7dGhpcy5tb2R1bGU9bmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh0KSx0aGlzLl92YWxpZGF0ZSgpLHRoaXMudHlwZURlc2NyaXB0b3I9Tyh0aGlzLm1vZHVsZSksdGhpcy5faW5zdGFudGlhdGVCaW5kSW1wb3J0RnVuY3Rpb25zKGUpLHRoaXMubG9hZGVkTW9kdWxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGwuaW5zdGFudGlhdGVTeW5jKHQsZSl9KHRoaXMubW9kdWxlLHRoaXMuaW1wb3J0T2JqZWN0KSx0aGlzLl9pbnN0YW50aWF0ZUJpbmRVbmJvdW5kRXhwb3J0cygpfV9pbnN0YW50aWF0ZUJpbmRJbXBvcnRGdW5jdGlvbnModCl7dGhpcy5pbXBvcnRPYmplY3Q9eCh0LHtkZXB0aDoyfSk7Zm9yKGNvbnN0W2Uscl1vZiBPYmplY3QuZW50cmllcyh0aGlzLnR5cGVEZXNjcmlwdG9yLmltcG9ydGVkRnVuY3Rpb25zKSlmb3IoY29uc3RbbixzXW9mIE9iamVjdC5lbnRyaWVzKHIpKXRoaXMuaW1wb3J0T2JqZWN0W2VdW2BfX2FzYmluZF91bmJvdW5kXyR7bn1gXT10W2VdW25dLHRoaXMuaW1wb3J0T2JqZWN0W2VdW25dPVQodGhpcyx0W2VdW25dLHMpfV9pbnN0YW50aWF0ZUJpbmRVbmJvdW5kRXhwb3J0cygpe2NvbnN0IHQ9dGhpcy5sb2FkZWRNb2R1bGUuZXhwb3J0czt0aGlzLmV4cG9ydHM9eCh0LHtkZXB0aDoxfSk7Zm9yKGNvbnN0W2Uscl1vZiBPYmplY3QuZW50cmllcyh0aGlzLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zKSl0aGlzLmV4cG9ydHNbZV09aih0aGlzLHRbZV0scil9fWV4cG9ydHMuY29udmVydGVycz1tLGV4cG9ydHMuaW5zdGFudGlhdGU9YXN5bmMgZnVuY3Rpb24odCxlKXtsZXQgcj1uZXcgVTtyZXR1cm4gYXdhaXQgci5faW5zdGFudGlhdGUodCxlKSxyfSxleHBvcnRzLmluc3RhbnRpYXRlU3luYz1mdW5jdGlvbih0LGUpe2xldCByPW5ldyBVO3JldHVybiByLl9pbnN0YW50aWF0ZVN5bmModCxlKSxyfSxleHBvcnRzLnZlcnNpb249XCIwLjguMVwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBtcXR0ID0gcmVxdWlyZShcIm1xdHRcIik7XHJcbnZhciBpbkFycmF5ID0gcmVxdWlyZShcImluLWFycmF5XCIpO1xyXG5cclxudmFyIFJlZ3VsYXJDbGllbnRQcm90b3R5cGUgPSBtcXR0Lk1xdHRDbGllbnQucHJvdG90eXBlO1xyXG5cclxudmFyIEFTWU5DX01FVEhPRFMgPSBbXCJwdWJsaXNoXCIsXHJcblx0XCJzdWJzY3JpYmVcIixcclxuXHRcInVuc3Vic2NyaWJlXCIsXHJcblx0XCJ1bnN1YnNjcmliZVwiLFxyXG5cdFwiZW5kXCJcclxuXTtcclxuXHJcbnZhciBTWU5DX01FVEhPRFMgPSBbXHJcblx0XCJlbWl0XCIsXHJcblx0XCJhZGRMaXN0ZW5lclwiLFxyXG5cdFwib25cIixcclxuXHRcIm9uY2VcIixcclxuXHRcInJlbW92ZUxpc3RlbmVyXCIsXHJcblx0XCJyZW1vdmVBbGxMaXN0ZW5lcnNcIixcclxuXHRcInNldE1heExpc3RlbmVyc1wiLFxyXG5cdFwiZ2V0TWF4TGlzdGVuZXJzXCIsXHJcblx0XCJsaXN0ZW5lcnNcIixcclxuXHRcImxpc3RlbmVyQ291bnRcIlxyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0Y29ubmVjdDogY29ubmVjdCxcclxuXHRBc3luY0NsaWVudDogQXN5bmNDbGllbnRcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbm5lY3QoYnJva2VyVVJMLCBvcHRzKSB7XHJcblx0dmFyIGNsaWVudCA9IG1xdHQuY29ubmVjdChicm9rZXJVUkwsIG9wdHMpO1xyXG5cclxuXHR2YXIgYXN5bmNDbGllbnQgPSBuZXcgQXN5bmNDbGllbnQoY2xpZW50KTtcclxuXHJcblx0cmV0dXJuIGFzeW5jQ2xpZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBBc3luY0NsaWVudChjbGllbnQpIHtcclxuXHR0aGlzLl9jbGllbnQgPSBjbGllbnQ7XHJcbn1cclxuXHJcbkFzeW5jQ2xpZW50LnByb3RvdHlwZSA9IHtcclxuXHRzZXQgaGFuZGxlTWVzc2FnZShuZXdIYW5kbGVyKSB7XHJcblx0XHR0aGlzLl9jbGllbnQuaGFuZGxlTWVzc2FnZSA9IG5ld0hhbmRsZXI7XHJcblx0fSxcclxuXHRnZXQgaGFuZGxlTWVzc2FnZSgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jbGllbnQuaGFuZGxlTWVzc2FnZTtcclxuXHR9XHJcbn07XHJcblxyXG5BU1lOQ19NRVRIT0RTLmZvckVhY2goZGVmaW5lQXN5bmMpO1xyXG5TWU5DX01FVEhPRFMuZm9yRWFjaChkZWZpbmVQYXNzdGhyb3VnaCk7XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVQYXNzdGhyb3VnaChuYW1lKSB7XHJcblx0QXN5bmNDbGllbnQucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG5cdFx0cmV0dXJuIGNsaWVudFtuYW1lXS5hcHBseShjbGllbnQsIGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lQXN5bmMobmFtZSkge1xyXG5cdEFzeW5jQ2xpZW50LnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGFzeW5jTWV0aG9kKCkge1xyXG5cdFx0dmFyIGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuXHRcdHZhciBhcmdzID0gW107XHJcblx0XHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdGZvciAoaTsgaSA8IGxlbmd0aDsgaSsrKVxyXG5cdFx0XHRhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHRcdGFyZ3MucHVzaChtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XHJcblx0XHRcdGNsaWVudFtuYW1lXS5hcHBseShjbGllbnQsIGFyZ3MpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdHJldHVybiBmdW5jdGlvbihlcnIsIGRhdGEpIHtcclxuXHRcdGlmIChlcnIpXHJcblx0XHRcdHJlamVjdChlcnIpO1xyXG5cdFx0ZWxzZSByZXNvbHZlKGRhdGEpO1xyXG5cdH07XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwidmFyIER1cGxleFN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgnKVxuICAsIHV0aWwgICAgICAgICA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIEJ1ZmZlciAgICAgICA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cblxuZnVuY3Rpb24gQnVmZmVyTGlzdCAoY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyTGlzdChjYWxsYmFjaylcblxuICB0aGlzLl9idWZzICA9IFtdXG4gIHRoaXMubGVuZ3RoID0gMFxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcblxuICAgIHZhciBwaXBlciA9IGZ1bmN0aW9uIHBpcGVyIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhlcnIpXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5vbigncGlwZScsIGZ1bmN0aW9uIG9uUGlwZSAoc3JjKSB7XG4gICAgICBzcmMub24oJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcbiAgICB0aGlzLm9uKCd1bnBpcGUnLCBmdW5jdGlvbiBvblVucGlwZSAoc3JjKSB7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGVuZChjYWxsYmFjaylcbiAgfVxuXG4gIER1cGxleFN0cmVhbS5jYWxsKHRoaXMpXG59XG5cblxudXRpbC5pbmhlcml0cyhCdWZmZXJMaXN0LCBEdXBsZXhTdHJlYW0pXG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX29mZnNldCA9IGZ1bmN0aW9uIF9vZmZzZXQgKG9mZnNldCkge1xuICB2YXIgdG90ID0gMCwgaSA9IDAsIF90XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiBbIDAsIDAgXVxuICBmb3IgKDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBfdCA9IHRvdCArIHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgaWYgKG9mZnNldCA8IF90IHx8IGkgPT0gdGhpcy5fYnVmcy5sZW5ndGggLSAxKVxuICAgICAgcmV0dXJuIFsgaSwgb2Zmc2V0IC0gdG90IF1cbiAgICB0b3QgPSBfdFxuICB9XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChidWYpIHtcbiAgdmFyIGkgPSAwXG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgdGhpcy5fYXBwZW5kQnVmZmVyKGJ1Zik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShidWYpKSB7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmFwcGVuZChidWZbaV0pXG4gIH0gZWxzZSBpZiAoYnVmIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkge1xuICAgIC8vIHVud3JhcCBhcmd1bWVudCBpbnRvIGluZGl2aWR1YWwgQnVmZmVyTGlzdHNcbiAgICBmb3IgKDsgaSA8IGJ1Zi5fYnVmcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYXBwZW5kKGJ1Zi5fYnVmc1tpXSlcbiAgfSBlbHNlIGlmIChidWYgIT0gbnVsbCkge1xuICAgIC8vIGNvZXJjZSBudW1iZXIgYXJndW1lbnRzIHRvIHN0cmluZ3MsIHNpbmNlIEJ1ZmZlcihudW1iZXIpIGRvZXNcbiAgICAvLyB1bmluaXRpYWxpemVkIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgaWYgKHR5cGVvZiBidWYgPT0gJ251bWJlcicpXG4gICAgICBidWYgPSBidWYudG9TdHJpbmcoKVxuXG4gICAgdGhpcy5fYXBwZW5kQnVmZmVyKEJ1ZmZlci5mcm9tKGJ1ZikpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fYXBwZW5kQnVmZmVyID0gZnVuY3Rpb24gYXBwZW5kQnVmZmVyIChidWYpIHtcbiAgdGhpcy5fYnVmcy5wdXNoKGJ1ZilcbiAgdGhpcy5sZW5ndGggKz0gYnVmLmxlbmd0aFxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoYnVmLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdGhpcy5fYXBwZW5kQnVmZmVyKGJ1ZilcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpXG4gICAgY2FsbGJhY2soKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQgKHNpemUpIHtcbiAgaWYgKCF0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpXG5cbiAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHRoaXMubGVuZ3RoKVxuICB0aGlzLnB1c2godGhpcy5zbGljZSgwLCBzaXplKSlcbiAgdGhpcy5jb25zdW1lKHNpemUpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kIChjaHVuaykge1xuICBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rKVxuXG4gIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrKG51bGwsIHRoaXMuc2xpY2UoKSlcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgfVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuc2xpY2UoaW5kZXgsIGluZGV4ICsgMSlbMF1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT0gJ251bWJlcicgJiYgc3RhcnQgPCAwKVxuICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoXG4gIGlmICh0eXBlb2YgZW5kID09ICdudW1iZXInICYmIGVuZCA8IDApXG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIHJldHVybiB0aGlzLmNvcHkobnVsbCwgMCwgc3RhcnQsIGVuZClcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZHN0LCBkc3RTdGFydCwgc3JjU3RhcnQsIHNyY0VuZCkge1xuICBpZiAodHlwZW9mIHNyY1N0YXJ0ICE9ICdudW1iZXInIHx8IHNyY1N0YXJ0IDwgMClcbiAgICBzcmNTdGFydCA9IDBcbiAgaWYgKHR5cGVvZiBzcmNFbmQgIT0gJ251bWJlcicgfHwgc3JjRW5kID4gdGhpcy5sZW5ndGgpXG4gICAgc3JjRW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHNyY1N0YXJ0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG4gIGlmIChzcmNFbmQgPD0gMClcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuXG4gIHZhciBjb3B5ICAgPSAhIWRzdFxuICAgICwgb2ZmICAgID0gdGhpcy5fb2Zmc2V0KHNyY1N0YXJ0KVxuICAgICwgbGVuICAgID0gc3JjRW5kIC0gc3JjU3RhcnRcbiAgICAsIGJ5dGVzICA9IGxlblxuICAgICwgYnVmb2ZmID0gKGNvcHkgJiYgZHN0U3RhcnQpIHx8IDBcbiAgICAsIHN0YXJ0ICA9IG9mZlsxXVxuICAgICwgbFxuICAgICwgaVxuXG4gIC8vIGNvcHkvc2xpY2UgZXZlcnl0aGluZ1xuICBpZiAoc3JjU3RhcnQgPT09IDAgJiYgc3JjRW5kID09IHRoaXMubGVuZ3RoKSB7XG4gICAgaWYgKCFjb3B5KSB7IC8vIHNsaWNlLCBidXQgZnVsbCBjb25jYXQgaWYgbXVsdGlwbGUgYnVmZmVyc1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZnMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5fYnVmc1swXVxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmcywgdGhpcy5sZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gY29weSwgbmVlZCB0byBjb3B5IGluZGl2aWR1YWwgYnVmZmVyc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYpXG4gICAgICBidWZvZmYgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0XG4gIH1cblxuICAvLyBlYXN5LCBjaGVhcCBjYXNlIHdoZXJlIGl0J3MgYSBzdWJzZXQgb2Ygb25lIG9mIHRoZSBidWZmZXJzXG4gIGlmIChieXRlcyA8PSB0aGlzLl9idWZzW29mZlswXV0ubGVuZ3RoIC0gc3RhcnQpIHtcbiAgICByZXR1cm4gY29weVxuICAgICAgPyB0aGlzLl9idWZzW29mZlswXV0uY29weShkc3QsIGRzdFN0YXJ0LCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIDogdGhpcy5fYnVmc1tvZmZbMF1dLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICB9XG5cbiAgaWYgKCFjb3B5KSAvLyBhIHNsaWNlLCB3ZSBuZWVkIHNvbWV0aGluZyB0byBjb3B5IGluIHRvXG4gICAgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcblxuICBmb3IgKGkgPSBvZmZbMF07IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgbCA9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoIC0gc3RhcnRcblxuICAgIGlmIChieXRlcyA+IGwpIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQpXG4gICAgICBidWZvZmYgKz0gbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgYnVmb2ZmICs9IGxcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgYnl0ZXMgLT0gbFxuXG4gICAgaWYgKHN0YXJ0KVxuICAgICAgc3RhcnQgPSAwXG4gIH1cblxuICAvLyBzYWZlZ3VhcmQgc28gdGhhdCB3ZSBkb24ndCByZXR1cm4gdW5pbml0aWFsaXplZCBtZW1vcnlcbiAgaWYgKGRzdC5sZW5ndGggPiBidWZvZmYpIHJldHVybiBkc3Quc2xpY2UoMCwgYnVmb2ZmKVxuXG4gIHJldHVybiBkc3Rcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hhbGxvd1NsaWNlID0gZnVuY3Rpb24gc2hhbGxvd1NsaWNlIChzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgdGhpcy5sZW5ndGhcblxuICBpZiAoc3RhcnQgPCAwKVxuICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuXG4gIHZhciBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldChzdGFydClcbiAgICAsIGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gICAgLCBidWZmZXJzID0gdGhpcy5fYnVmcy5zbGljZShzdGFydE9mZnNldFswXSwgZW5kT2Zmc2V0WzBdICsgMSlcblxuICBpZiAoZW5kT2Zmc2V0WzFdID09IDApXG4gICAgYnVmZmVycy5wb3AoKVxuICBlbHNlXG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXSA9IGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGgtMV0uc2xpY2UoMCwgZW5kT2Zmc2V0WzFdKVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPSAwKVxuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcylcbiAgLy8gZG8gbm90aGluZyBpZiBub3QgYSBwb3NpdGl2ZSBudW1iZXJcbiAgaWYgKE51bWJlci5pc05hTihieXRlcykgfHwgYnl0ZXMgPD0gMCkgcmV0dXJuIHRoaXNcblxuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPj0gdGhpcy5fYnVmc1swXS5sZW5ndGgpIHtcbiAgICAgIGJ5dGVzIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbMF0gPSB0aGlzLl9idWZzWzBdLnNsaWNlKGJ5dGVzKVxuICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXNcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gZHVwbGljYXRlICgpIHtcbiAgdmFyIGkgPSAwXG4gICAgLCBjb3B5ID0gbmV3IEJ1ZmZlckxpc3QoKVxuXG4gIGZvciAoOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKylcbiAgICBjb3B5LmFwcGVuZCh0aGlzLl9idWZzW2ldKVxuXG4gIHJldHVybiBjb3B5XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB0aGlzLl9idWZzLmxlbmd0aCA9IDBcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5cbjsoZnVuY3Rpb24gKCkge1xuICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICdyZWFkRG91YmxlQkUnIDogOFxuICAgICwgJ3JlYWREb3VibGVMRScgOiA4XG4gICAgLCAncmVhZEZsb2F0QkUnICA6IDRcbiAgICAsICdyZWFkRmxvYXRMRScgIDogNFxuICAgICwgJ3JlYWRJbnQzMkJFJyAgOiA0XG4gICAgLCAncmVhZEludDMyTEUnICA6IDRcbiAgICAsICdyZWFkVUludDMyQkUnIDogNFxuICAgICwgJ3JlYWRVSW50MzJMRScgOiA0XG4gICAgLCAncmVhZEludDE2QkUnICA6IDJcbiAgICAsICdyZWFkSW50MTZMRScgIDogMlxuICAgICwgJ3JlYWRVSW50MTZCRScgOiAyXG4gICAgLCAncmVhZFVJbnQxNkxFJyA6IDJcbiAgICAsICdyZWFkSW50OCcgICAgIDogMVxuICAgICwgJ3JlYWRVSW50OCcgICAgOiAxXG4gIH1cblxuICBmb3IgKHZhciBtIGluIG1ldGhvZHMpIHtcbiAgICAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIG1ldGhvZHNbbV0pW21dKDApXG4gICAgICB9XG4gICAgfShtKSlcbiAgfVxufSgpKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdFxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwidmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSkge1xuICB2YXIgZmlsdGVyO1xuICBpZiAodHlwZW9mIGNpcmN1bGFyID09PSAnb2JqZWN0Jykge1xuICAgIGRlcHRoID0gY2lyY3VsYXIuZGVwdGg7XG4gICAgcHJvdG90eXBlID0gY2lyY3VsYXIucHJvdG90eXBlO1xuICAgIGZpbHRlciA9IGNpcmN1bGFyLmZpbHRlcjtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyXG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgcmV0dXJuIHBhcmVudDtcblxuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgcHJvdG87XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgIT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgQnVmZmVyKHBhcmVudC5sZW5ndGgpO1xuICAgICAgcGFyZW50LmNvcHkoY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICBwcm90byA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFsbFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnQpIHtcbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMuc2V0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZFtpXSA9IF9jbG9uZShwYXJlbnRbaV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn07XG5jbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuZnVuY3Rpb24gX19pc0RhdGUobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5jbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuZnVuY3Rpb24gX19nZXRSZWdFeHBGbGFncyhyZSkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmUuaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn07XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgICAgICAgICAgICAgPSByZXF1aXJlKFwidHlwZS92YWx1ZS9pc1wiKVxuICAsIGVuc3VyZVZhbHVlICAgICAgICAgPSByZXF1aXJlKFwidHlwZS92YWx1ZS9lbnN1cmVcIilcbiAgLCBlbnN1cmVQbGFpbkZ1bmN0aW9uID0gcmVxdWlyZShcInR5cGUvcGxhaW4tZnVuY3Rpb24vZW5zdXJlXCIpXG4gICwgY29weSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9jb3B5XCIpXG4gICwgbm9ybWFsaXplT3B0aW9ucyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9uc1wiKVxuICAsIG1hcCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvbWFwXCIpO1xuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZWZpbmU7XG5cbmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjLCBvcHRpb25zKSB7XG5cdHZhciB2YWx1ZSA9IGVuc3VyZVZhbHVlKGRlc2MpICYmIGVuc3VyZVBsYWluRnVuY3Rpb24oZGVzYy52YWx1ZSksIGRncztcblx0ZGdzID0gY29weShkZXNjKTtcblx0ZGVsZXRlIGRncy53cml0YWJsZTtcblx0ZGVsZXRlIGRncy52YWx1ZTtcblx0ZGdzLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIW9wdGlvbnMub3ZlcndyaXRlRGVmaW5pdGlvbiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSByZXR1cm4gdmFsdWU7XG5cdFx0ZGVzYy52YWx1ZSA9IGJpbmQuY2FsbCh2YWx1ZSwgb3B0aW9ucy5yZXNvbHZlQ29udGV4dCA/IG9wdGlvbnMucmVzb2x2ZUNvbnRleHQodGhpcykgOiB0aGlzKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkZXNjKTtcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0fTtcblx0cmV0dXJuIGRncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3BzLyosIG9wdGlvbnMqLykge1xuXHR2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJndW1lbnRzWzFdKTtcblx0aWYgKGlzVmFsdWUob3B0aW9ucy5yZXNvbHZlQ29udGV4dCkpIGVuc3VyZVBsYWluRnVuY3Rpb24ob3B0aW9ucy5yZXNvbHZlQ29udGV4dCk7XG5cdHJldHVybiBtYXAocHJvcHMsIGZ1bmN0aW9uIChkZXNjLCBuYW1lKSB7IHJldHVybiBkZWZpbmUobmFtZSwgZGVzYywgb3B0aW9ucyk7IH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgICAgICAgID0gcmVxdWlyZShcInR5cGUvdmFsdWUvaXNcIilcbiAgLCBpc1BsYWluRnVuY3Rpb24gPSByZXF1aXJlKFwidHlwZS9wbGFpbi1mdW5jdGlvbi9pc1wiKVxuICAsIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9hc3NpZ25cIilcbiAgLCBub3JtYWxpemVPcHRzICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnNcIilcbiAgLCBjb250YWlucyAgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvIy9jb250YWluc1wiKTtcblxudmFyIGQgPSAobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHwgdHlwZW9mIGRzY3IgIT09IFwic3RyaW5nXCIpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGlzVmFsdWUoZHNjcikpIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCBcImNcIik7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJlXCIpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsIFwid1wiKTtcblx0fSBlbHNlIHtcblx0XHRjID0gdyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9XG5cblx0ZGVzYyA9IHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUsIHdyaXRhYmxlOiB3IH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59KTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gXCJzdHJpbmdcIikge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gZ2V0O1xuXHRcdGdldCA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcblx0fVxuXHRpZiAoIWlzVmFsdWUoZ2V0KSkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNQbGFpbkZ1bmN0aW9uKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNWYWx1ZShzZXQpKSB7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc1BsYWluRnVuY3Rpb24oc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChpc1ZhbHVlKGRzY3IpKSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJjXCIpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsIFwiZVwiKTtcblx0fSBlbHNlIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNoaWZ0ID0gcmVxdWlyZSgnc3RyZWFtLXNoaWZ0JylcblxudmFyIFNJR05BTF9GTFVTSCA9IChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKVxuICA/IEJ1ZmZlci5mcm9tKFswXSlcbiAgOiBuZXcgQnVmZmVyKFswXSlcblxudmFyIG9udW5jb3JrID0gZnVuY3Rpb24oc2VsZiwgZm4pIHtcbiAgaWYgKHNlbGYuX2NvcmtlZCkgc2VsZi5vbmNlKCd1bmNvcmsnLCBmbilcbiAgZWxzZSBmbigpXG59XG5cbnZhciBhdXRvRGVzdHJveSA9IGZ1bmN0aW9uIChzZWxmLCBlcnIpIHtcbiAgaWYgKHNlbGYuX2F1dG9EZXN0cm95KSBzZWxmLmRlc3Ryb3koZXJyKVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24oc2VsZiwgZW5kKSB7XG4gIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSBhdXRvRGVzdHJveShzZWxmLCBlcnIubWVzc2FnZSA9PT0gJ3ByZW1hdHVyZSBjbG9zZScgPyBudWxsIDogZXJyKVxuICAgIGVsc2UgaWYgKGVuZCAmJiAhc2VsZi5fZW5kZWQpIHNlbGYuZW5kKClcbiAgfVxufVxuXG52YXIgZW5kID0gZnVuY3Rpb24od3MsIGZuKSB7XG4gIGlmICghd3MpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSAmJiB3cy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgcmV0dXJuIGZuKClcbiAgaWYgKHdzLl93cml0YWJsZVN0YXRlKSByZXR1cm4gd3MuZW5kKGZuKVxuICB3cy5lbmQoKVxuICBmbigpXG59XG5cbnZhciB0b1N0cmVhbXMyID0gZnVuY3Rpb24ocnMpIHtcbiAgcmV0dXJuIG5ldyAoc3RyZWFtLlJlYWRhYmxlKSh7b2JqZWN0TW9kZTp0cnVlLCBoaWdoV2F0ZXJNYXJrOjE2fSkud3JhcChycylcbn1cblxudmFyIER1cGxleGlmeSA9IGZ1bmN0aW9uKHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4aWZ5KSkgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLl93cml0YWJsZSA9IG51bGxcbiAgdGhpcy5fcmVhZGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlMiA9IG51bGxcblxuICB0aGlzLl9hdXRvRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuYXV0b0Rlc3Ryb3kgIT09IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmREZXN0cm95ID0gIW9wdHMgfHwgb3B0cy5kZXN0cm95ICE9PSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkRW5kID0gIW9wdHMgfHwgb3B0cy5lbmQgIT09IGZhbHNlXG4gIHRoaXMuX2NvcmtlZCA9IDEgLy8gc3RhcnQgY29ya2VkXG4gIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gIHRoaXMuX2RyYWluZWQgPSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkaW5nID0gZmFsc2VcbiAgdGhpcy5fdW53cml0ZSA9IG51bGxcbiAgdGhpcy5fdW5yZWFkID0gbnVsbFxuICB0aGlzLl9lbmRlZCA9IGZhbHNlXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIGlmICh3cml0YWJsZSkgdGhpcy5zZXRXcml0YWJsZSh3cml0YWJsZSlcbiAgaWYgKHJlYWRhYmxlKSB0aGlzLnNldFJlYWRhYmxlKHJlYWRhYmxlKVxufVxuXG5pbmhlcml0cyhEdXBsZXhpZnksIHN0cmVhbS5EdXBsZXgpXG5cbkR1cGxleGlmeS5vYmogPSBmdW5jdGlvbih3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5vYmplY3RNb2RlID0gdHJ1ZVxuICBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxNlxuICByZXR1cm4gbmV3IER1cGxleGlmeSh3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoKyt0aGlzLl9jb3JrZWQgPT09IDEpIHRoaXMuZW1pdCgnY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jb3JrZWQgJiYgLS10aGlzLl9jb3JrZWQgPT09IDApIHRoaXMuZW1pdCgndW5jb3JrJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5zZXRXcml0YWJsZSA9IGZ1bmN0aW9uKHdyaXRhYmxlKSB7XG4gIGlmICh0aGlzLl91bndyaXRlKSB0aGlzLl91bndyaXRlKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAod3JpdGFibGUgJiYgd3JpdGFibGUuZGVzdHJveSkgd3JpdGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAod3JpdGFibGUgPT09IG51bGwgfHwgd3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5lbmQoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyh3cml0YWJsZSwge3dyaXRhYmxlOnRydWUsIHJlYWRhYmxlOmZhbHNlfSwgZGVzdHJveWVyKHRoaXMsIHRoaXMuX2ZvcndhcmRFbmQpKVxuXG4gIHZhciBvbmRyYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uZHJhaW4gPSBzZWxmLl9vbmRyYWluXG4gICAgc2VsZi5fb25kcmFpbiA9IG51bGxcbiAgICBpZiAob25kcmFpbikgb25kcmFpbigpXG4gIH1cblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl93cml0YWJsZS5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKVxuICAgIHVuZW5kKClcbiAgfVxuXG4gIGlmICh0aGlzLl91bndyaXRlKSBwcm9jZXNzLm5leHRUaWNrKG9uZHJhaW4pIC8vIGZvcmNlIGEgZHJhaW4gb24gc3RyZWFtIHJlc2V0IHRvIGF2b2lkIGxpdmVsb2Nrc1xuXG4gIHRoaXMuX3dyaXRhYmxlID0gd3JpdGFibGVcbiAgdGhpcy5fd3JpdGFibGUub24oJ2RyYWluJywgb25kcmFpbilcbiAgdGhpcy5fdW53cml0ZSA9IGNsZWFyXG5cbiAgdGhpcy51bmNvcmsoKSAvLyBhbHdheXMgdW5jb3JrIHNldFdyaXRhYmxlXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0UmVhZGFibGUgPSBmdW5jdGlvbihyZWFkYWJsZSkge1xuICBpZiAodGhpcy5fdW5yZWFkKSB0aGlzLl91bnJlYWQoKVxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIGlmIChyZWFkYWJsZSAmJiByZWFkYWJsZS5kZXN0cm95KSByZWFkYWJsZS5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChyZWFkYWJsZSA9PT0gbnVsbCB8fCByZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgICB0aGlzLnJlc3VtZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHVuZW5kID0gZW9zKHJlYWRhYmxlLCB7d3JpdGFibGU6ZmFsc2UsIHJlYWRhYmxlOnRydWV9LCBkZXN0cm95ZXIodGhpcykpXG5cbiAgdmFyIG9ucmVhZGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9mb3J3YXJkKClcbiAgfVxuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYucHVzaChudWxsKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fcmVhZGFibGUyLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gICAgc2VsZi5fcmVhZGFibGUyLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICB1bmVuZCgpXG4gIH1cblxuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9yZWFkYWJsZSA9IHJlYWRhYmxlXG4gIHRoaXMuX3JlYWRhYmxlMiA9IHJlYWRhYmxlLl9yZWFkYWJsZVN0YXRlID8gcmVhZGFibGUgOiB0b1N0cmVhbXMyKHJlYWRhYmxlKVxuICB0aGlzLl9yZWFkYWJsZTIub24oJ3JlYWRhYmxlJywgb25yZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdlbmQnLCBvbmVuZClcbiAgdGhpcy5fdW5yZWFkID0gY2xlYXJcblxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZm9yd2FyZGluZyB8fCAhdGhpcy5fcmVhZGFibGUyIHx8ICF0aGlzLl9kcmFpbmVkKSByZXR1cm5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IHRydWVcblxuICB2YXIgZGF0YVxuXG4gIHdoaWxlICh0aGlzLl9kcmFpbmVkICYmIChkYXRhID0gc2hpZnQodGhpcy5fcmVhZGFibGUyKSkgIT09IG51bGwpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIGNvbnRpbnVlXG4gICAgdGhpcy5fZHJhaW5lZCA9IHRoaXMucHVzaChkYXRhKVxuICB9XG5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9kZXN0cm95KGVycilcbiAgfSlcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAoZXJyKSB7XG4gICAgdmFyIG9uZHJhaW4gPSB0aGlzLl9vbmRyYWluXG4gICAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgICBpZiAob25kcmFpbikgb25kcmFpbihlcnIpXG4gICAgZWxzZSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZvcndhcmREZXN0cm95KSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlICYmIHRoaXMuX3JlYWRhYmxlLmRlc3Ryb3kpIHRoaXMuX3JlYWRhYmxlLmRlc3Ryb3koKVxuICAgIGlmICh0aGlzLl93cml0YWJsZSAmJiB0aGlzLl93cml0YWJsZS5kZXN0cm95KSB0aGlzLl93cml0YWJsZS5kZXN0cm95KClcbiAgfVxuXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IoKVxuICBpZiAodGhpcy5fY29ya2VkKSByZXR1cm4gb251bmNvcmsodGhpcywgdGhpcy5fd3JpdGUuYmluZCh0aGlzLCBkYXRhLCBlbmMsIGNiKSlcbiAgaWYgKGRhdGEgPT09IFNJR05BTF9GTFVTSCkgcmV0dXJuIHRoaXMuX2ZpbmlzaChjYilcbiAgaWYgKCF0aGlzLl93cml0YWJsZSkgcmV0dXJuIGNiKClcblxuICBpZiAodGhpcy5fd3JpdGFibGUud3JpdGUoZGF0YSkgPT09IGZhbHNlKSB0aGlzLl9vbmRyYWluID0gY2JcbiAgZWxzZSBjYigpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLmVtaXQoJ3ByZWVuZCcpXG4gIG9udW5jb3JrKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGVuZChzZWxmLl9mb3J3YXJkRW5kICYmIHNlbGYuX3dyaXRhYmxlLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGhheHggdG8gbm90IGVtaXQgcHJlZmluaXNoIHR3aWNlXG4gICAgICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9PT0gZmFsc2UpIHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzZWxmLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICBvbnVuY29yayhzZWxmLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQobnVsbCwgbnVsbCwgZGF0YSlcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChkYXRhLCBudWxsLCBlbmMpXG4gIHRoaXMuX2VuZGVkID0gdHJ1ZVxuICBpZiAoZGF0YSkgdGhpcy53cml0ZShkYXRhKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nKSB0aGlzLndyaXRlKFNJR05BTF9GTFVTSClcbiAgcmV0dXJuIHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2IpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4aWZ5XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDaGlsZFByb2Nlc3MgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gM1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblx0dmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlYWRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpO1xuXHR9O1xuXG5cdHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VuZXh0dGljayk7XG5cdH07XG5cblx0dmFyIG9uY2xvc2VuZXh0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChjYW5jZWxsZWQpIHJldHVybjtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiAocnMuZW5kZWQgJiYgIXJzLmRlc3Ryb3llZCkpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHRcdGlmICh3cml0YWJsZSAmJiAhKHdzICYmICh3cy5lbmRlZCAmJiAhd3MuZGVzdHJveWVkKSkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdH07XG5cblx0dmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0fTtcblxuXHRpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcblx0XHRzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7XG5cdFx0ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHR9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtc1xuXHRcdHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdH1cblxuXHRpZiAoaXNDaGlsZFByb2Nlc3Moc3RyZWFtKSkgc3RyZWFtLm9uKCdleGl0Jywgb25leGl0KTtcblxuXHRzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcblx0c3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGNhbmNlbGxlZCA9IHRydWU7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLy8gSW5zcGlyZWQgYnkgR29vZ2xlIENsb3N1cmU6XG4vLyBodHRwOi8vY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL3N2bi9kb2NzL1xuLy8gY2xvc3VyZV9nb29nX2FycmF5X2FycmF5LmpzLmh0bWwjZ29vZy5hcnJheS5jbGVhclxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHZhbHVlID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhbHVlKHRoaXMpLmxlbmd0aCA9IDA7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbnVtYmVySXNOYU4gICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL2lzLW5hblwiKVxuICAsIHRvUG9zSW50ICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiKVxuICAsIHZhbHVlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGluZGV4T2YgICAgICAgICAgID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcbiAgLCBvYmpIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBhYnMgICAgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgICAgICAgICAgICAgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCovKSB7XG5cdHZhciBpLCBsZW5ndGgsIGZyb21JbmRleCwgdmFsO1xuXHRpZiAoIW51bWJlcklzTmFOKHNlYXJjaEVsZW1lbnQpKSByZXR1cm4gaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdGxlbmd0aCA9IHRvUG9zSW50KHZhbHVlKHRoaXMpLmxlbmd0aCk7XG5cdGZyb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGlzTmFOKGZyb21JbmRleCkpIGZyb21JbmRleCA9IDA7XG5cdGVsc2UgaWYgKGZyb21JbmRleCA+PSAwKSBmcm9tSW5kZXggPSBmbG9vcihmcm9tSW5kZXgpO1xuXHRlbHNlIGZyb21JbmRleCA9IHRvUG9zSW50KHRoaXMubGVuZ3RoKSAtIGZsb29yKGFicyhmcm9tSW5kZXgpKTtcblxuXHRmb3IgKGkgPSBmcm9tSW5kZXg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdGlmIChvYmpIYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpKSB7XG5cdFx0XHR2YWwgPSB0aGlzW2ldO1xuXHRcdFx0aWYgKG51bWJlcklzTmFOKHZhbCkpIHJldHVybiBpOyAvLyBKc2xpbnQ6IGlnbm9yZVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IEFycmF5LmZyb20gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZnJvbSA9IEFycmF5LmZyb20sIGFyciwgcmVzdWx0O1xuXHRpZiAodHlwZW9mIGZyb20gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRhcnIgPSBbXCJyYXpcIiwgXCJkd2FcIl07XG5cdHJlc3VsdCA9IGZyb20oYXJyKTtcblx0cmV0dXJuIEJvb2xlYW4ocmVzdWx0ICYmIHJlc3VsdCAhPT0gYXJyICYmIHJlc3VsdFsxXSA9PT0gXCJkd2FcIik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yXG4gICwgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKFwiLi4vLi4vZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgaXNGdW5jdGlvbiAgICAgPSByZXF1aXJlKFwiLi4vLi4vZnVuY3Rpb24vaXMtZnVuY3Rpb25cIilcbiAgLCB0b1Bvc0ludCAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9udW1iZXIvdG8tcG9zLWludGVnZXJcIilcbiAgLCBjYWxsYWJsZSAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWxpZFZhbHVlICAgICA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIilcbiAgLCBpc1ZhbHVlICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvaXMtdmFsdWVcIilcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9zdHJpbmcvaXMtc3RyaW5nXCIpXG4gICwgaXNBcnJheSAgICAgICAgPSBBcnJheS5pc0FycmF5XG4gICwgY2FsbCAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGRlc2MgICAgICAgICAgID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbnVsbCB9XG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnJheUxpa2UvKiwgbWFwRm4sIHRoaXNBcmcqLykge1xuXHR2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV1cblx0ICAsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl1cblx0ICAsIENvbnRleHRcblx0ICAsIGlcblx0ICAsIGpcblx0ICAsIGFyclxuXHQgICwgbGVuZ3RoXG5cdCAgLCBjb2RlXG5cdCAgLCBpdGVyYXRvclxuXHQgICwgcmVzdWx0XG5cdCAgLCBnZXRJdGVyYXRvclxuXHQgICwgdmFsdWU7XG5cblx0YXJyYXlMaWtlID0gT2JqZWN0KHZhbGlkVmFsdWUoYXJyYXlMaWtlKSk7XG5cblx0aWYgKGlzVmFsdWUobWFwRm4pKSBjYWxsYWJsZShtYXBGbik7XG5cdGlmICghdGhpcyB8fCB0aGlzID09PSBBcnJheSB8fCAhaXNGdW5jdGlvbih0aGlzKSkge1xuXHRcdC8vIFJlc3VsdDogUGxhaW4gYXJyYXlcblx0XHRpZiAoIW1hcEZuKSB7XG5cdFx0XHRpZiAoaXNBcmd1bWVudHMoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFyZ3VtZW50c1xuXHRcdFx0XHRsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoICE9PSAxKSByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgYXJyYXlMaWtlKTtcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KDEpO1xuXHRcdFx0XHRhcnJbMF0gPSBhcnJheUxpa2VbMF07XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0XHRcdC8vIFNvdXJjZTogQXJyYXlcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KChsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoKSk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuXHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhcnIgPSBbXTtcblx0fSBlbHNlIHtcblx0XHQvLyBSZXN1bHQ6IE5vbiBwbGFpbiBhcnJheVxuXHRcdENvbnRleHQgPSB0aGlzO1xuXHR9XG5cblx0aWYgKCFpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRpZiAoKGdldEl0ZXJhdG9yID0gYXJyYXlMaWtlW2l0ZXJhdG9yU3ltYm9sXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gU291cmNlOiBJdGVyYXRvclxuXHRcdFx0aXRlcmF0b3IgPSBjYWxsYWJsZShnZXRJdGVyYXRvcikuY2FsbChhcnJheUxpa2UpO1xuXHRcdFx0aWYgKENvbnRleHQpIGFyciA9IG5ldyBDb250ZXh0KCk7XG5cdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRpID0gMDtcblx0XHRcdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBpKSA6IHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0aWYgKENvbnRleHQpIHtcblx0XHRcdFx0XHRkZXNjLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcnJbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRcdCsraTtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGk7XG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcnJheUxpa2UpKSB7XG5cdFx0XHQvLyBTb3VyY2U6IFN0cmluZ1xuXHRcdFx0bGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0aWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuXHRcdFx0XHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgdmFsdWUgKz0gYXJyYXlMaWtlWysraV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgdmFsdWUsIGopIDogdmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaiwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2pdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytqO1xuXHRcdFx0fVxuXHRcdFx0bGVuZ3RoID0gajtcblx0XHR9XG5cdH1cblx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gU291cmNlOiBhcnJheSBvciBhcnJheS1saWtlXG5cdFx0bGVuZ3RoID0gdG9Qb3NJbnQoYXJyYXlMaWtlLmxlbmd0aCk7XG5cdFx0aWYgKENvbnRleHQpIGFyciA9IG5ldyBDb250ZXh0KGxlbmd0aCk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCBhcnJheUxpa2VbaV0sIGkpIDogYXJyYXlMaWtlW2ldO1xuXHRcdFx0aWYgKENvbnRleHQpIHtcblx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGksIGRlc2MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChDb250ZXh0KSB7XG5cdFx0ZGVzYy52YWx1ZSA9IG51bGw7XG5cdFx0YXJyLmxlbmd0aCA9IGxlbmd0aDtcblx0fVxuXHRyZXR1cm4gYXJyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICwgaWQgPSBvYmpUb1N0cmluZy5jYWxsKChmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0pKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGlkOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgLCBpc0Z1bmN0aW9uU3RyaW5nVGFnID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL15bb2JqZWN0IFtBLVphLXowLTldKkZ1bmN0aW9uXSQvKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIGlzRnVuY3Rpb25TdHJpbmdUYWcob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge307XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gTWF0aC5zaWduIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNpZ24gPSBNYXRoLnNpZ247XG5cdGlmICh0eXBlb2Ygc2lnbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBzaWduKDEwKSA9PT0gMSAmJiBzaWduKC0yMCkgPT09IC0xO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IDApIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlID4gMCA/IDEgOiAtMTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOO1xuXHRpZiAodHlwZW9mIG51bWJlcklzTmFOICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICFudW1iZXJJc05hTih7fSkgJiYgbnVtYmVySXNOYU4oTmFOKSAmJiAhbnVtYmVySXNOYU4oMzQpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzaWduICA9IHJlcXVpcmUoXCIuLi9tYXRoL3NpZ25cIilcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAodmFsdWUgPT09IDAgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gc2lnbih2YWx1ZSkgKiBmbG9vcihhYnModmFsdWUpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoXCIuL3RvLWludGVnZXJcIilcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG1heCgwLCB0b0ludGVnZXIodmFsdWUpKTsgfTtcbiIsIi8vIEludGVybmFsIG1ldGhvZCwgdXNlZCBieSBpdGVyYXRpb24gZnVuY3Rpb25zLlxuLy8gQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBmb3VuZCBpbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgdGFrZXMgY29tcGFyZUZuIHRvIGl0ZXJhdGUgb2JqZWN0IGluIHNwZWNpZmljIG9yZGVyXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIilcbiAgLCBiaW5kICAgICAgICAgICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICwgY2FsbCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGtleXMgICAgICAgICAgICAgICAgICAgID0gT2JqZWN0LmtleXNcbiAgLCBvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgZGVmVmFsKSB7XG5cdHJldHVybiBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnLCBjb21wYXJlRm4qLykge1xuXHRcdHZhciBsaXN0LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCBjb21wYXJlRm4gPSBhcmd1bWVudHNbM107XG5cdFx0b2JqID0gT2JqZWN0KHZhbHVlKG9iaikpO1xuXHRcdGNhbGxhYmxlKGNiKTtcblxuXHRcdGxpc3QgPSBrZXlzKG9iaik7XG5cdFx0aWYgKGNvbXBhcmVGbikge1xuXHRcdFx0bGlzdC5zb3J0KHR5cGVvZiBjb21wYXJlRm4gPT09IFwiZnVuY3Rpb25cIiA/IGJpbmQuY2FsbChjb21wYXJlRm4sIG9iaikgOiB1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSBtZXRob2QgPSBsaXN0W21ldGhvZF07XG5cdFx0cmV0dXJuIGNhbGwuY2FsbChtZXRob2QsIGxpc3QsIGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG5cdFx0XHRpZiAoIW9ialByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpKSByZXR1cm4gZGVmVmFsO1xuXHRcdFx0cmV0dXJuIGNhbGwuY2FsbChjYiwgdGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqLCBpbmRleCk7XG5cdFx0fSk7XG5cdH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE9iamVjdC5hc3NpZ24gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgb2JqO1xuXHRpZiAodHlwZW9mIGFzc2lnbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiBcInJhelwiIH07XG5cdGFzc2lnbihvYmosIHsgYmFyOiBcImR3YVwiIH0sIHsgdHJ6eTogXCJ0cnp5XCIgfSk7XG5cdHJldHVybiBvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5ID09PSBcInJhemR3YXRyenlcIjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtleXMgID0gcmVxdWlyZShcIi4uL2tleXNcIilcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG1heCAgID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYy8qLCDigKZzcmNuKi8pIHtcblx0dmFyIGVycm9yLCBpLCBsZW5ndGggPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkge1xuXHRcdFx0ZGVzdFtrZXldID0gc3JjW2tleV07XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0c3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdGtleXMoc3JjKS5mb3JFYWNoKGFzc2lnbik7XG5cdH1cblx0aWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGVycm9yO1xuXHRyZXR1cm4gZGVzdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFGcm9tICA9IHJlcXVpcmUoXCIuLi9hcnJheS9mcm9tXCIpXG4gICwgYXNzaWduID0gcmVxdWlyZShcIi4vYXNzaWduXCIpXG4gICwgdmFsdWUgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iai8qLCBwcm9wZXJ0eU5hbWVzLCBvcHRpb25zKi8pIHtcblx0dmFyIGNvcHkgPSBPYmplY3QodmFsdWUob2JqKSksIHByb3BlcnR5TmFtZXMgPSBhcmd1bWVudHNbMV0sIG9wdGlvbnMgPSBPYmplY3QoYXJndW1lbnRzWzJdKTtcblx0aWYgKGNvcHkgIT09IG9iaiAmJiAhcHJvcGVydHlOYW1lcykgcmV0dXJuIGNvcHk7XG5cdHZhciByZXN1bHQgPSB7fTtcblx0aWYgKHByb3BlcnR5TmFtZXMpIHtcblx0XHRhRnJvbShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5lbnN1cmUgfHwgcHJvcGVydHlOYW1lIGluIG9iaikgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBvYmpbcHJvcGVydHlOYW1lXTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRhc3NpZ24ocmVzdWx0LCBvYmopO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gV29ya2Fyb3VuZCBmb3IgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjgwNFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIHNoaW07XG5cbmlmICghcmVxdWlyZShcIi4vc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZFwiKSgpKSB7XG5cdHNoaW0gPSByZXF1aXJlKFwiLi9zZXQtcHJvdG90eXBlLW9mL3NoaW1cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bGxPYmplY3QsIHBvbHlQcm9wcywgZGVzYztcblx0aWYgKCFzaGltKSByZXR1cm4gY3JlYXRlO1xuXHRpZiAoc2hpbS5sZXZlbCAhPT0gMSkgcmV0dXJuIGNyZWF0ZTtcblxuXHRudWxsT2JqZWN0ID0ge307XG5cdHBvbHlQcm9wcyA9IHt9O1xuXHRkZXNjID0geyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcblx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG5cdFx0XHRwb2x5UHJvcHNbbmFtZV0gPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwb2x5UHJvcHNbbmFtZV0gPSBkZXNjO1xuXHR9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobnVsbE9iamVjdCwgcG9seVByb3BzKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc2hpbSwgXCJudWxsUG9seWZpbGxcIiwge1xuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiBudWxsT2JqZWN0XG5cdH0pO1xuXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wcykge1xuXHRcdHJldHVybiBjcmVhdGUocHJvdG90eXBlID09PSBudWxsID8gbnVsbE9iamVjdCA6IHByb3RvdHlwZSwgcHJvcHMpO1xuXHR9O1xufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL19pdGVyYXRlXCIpKFwiZm9yRWFjaFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG52YXIgbWFwID0geyBmdW5jdGlvbjogdHJ1ZSwgb2JqZWN0OiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoaXNWYWx1ZSh2YWx1ZSkgJiYgbWFwW3R5cGVvZiB2YWx1ZV0pIHx8IGZhbHNlOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdW5kZWZpbmVkID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uL25vb3BcIikoKTsgLy8gU3VwcG9ydCBFUzMgZW5naW5lc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCAhPT0gX3VuZGVmaW5lZCAmJiB2YWwgIT09IG51bGw7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gT2JqZWN0LmtleXMgOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKFwicHJpbWl0aXZlXCIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4uL2lzLXZhbHVlXCIpO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIGtleXMoaXNWYWx1ZShvYmplY3QpID8gT2JqZWN0KG9iamVjdCkgOiBvYmplY3QpOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYWxsYWJsZSA9IHJlcXVpcmUoXCIuL3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgZm9yRWFjaCAgPSByZXF1aXJlKFwiLi9mb3ItZWFjaFwiKVxuICAsIGNhbGwgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2IvKiwgdGhpc0FyZyovKSB7XG5cdHZhciByZXN1bHQgPSB7fSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcblx0Y2FsbGFibGUoY2IpO1xuXHRmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIHRhcmdldE9iaiwgaW5kZXgpIHtcblx0XHRyZXN1bHRba2V5XSA9IGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGtleSwgdGFyZ2V0T2JqLCBpbmRleCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMxLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmICghaXNWYWx1ZShvcHRpb25zKSkgcmV0dXJuO1xuXHRcdHByb2Nlc3MoT2JqZWN0KG9wdGlvbnMpLCByZXN1bHQpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmcvKiwg4oCmYXJncyovKSB7XG5cdHZhciBzZXQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChuYW1lKSB7IHNldFtuYW1lXSA9IHRydWU7IH0pO1xuXHRyZXR1cm4gc2V0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YgOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgcGxhaW5PYmplY3QgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyogQ3VzdG9tQ3JlYXRlKi8pIHtcblx0dmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBjdXN0b21DcmVhdGUgPSBhcmd1bWVudHNbMF0gfHwgY3JlYXRlO1xuXHRpZiAodHlwZW9mIHNldFByb3RvdHlwZU9mICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGdldFByb3RvdHlwZU9mKHNldFByb3RvdHlwZU9mKGN1c3RvbUNyZWF0ZShudWxsKSwgcGxhaW5PYmplY3QpKSA9PT0gcGxhaW5PYmplY3Q7XG59O1xuIiwiLyogZXNsaW50IG5vLXByb3RvOiBcIm9mZlwiICovXG5cbi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ICAgICAgICAgPSByZXF1aXJlKFwiLi4vaXMtb2JqZWN0XCIpXG4gICwgdmFsdWUgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG9iaklzUHJvdG90eXBlT2YgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2ZcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgbnVsbERlc2MgICAgICAgICA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfVxuICAsIHZhbGlkYXRlO1xuXG52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHR2YWx1ZShvYmopO1xuXHRpZiAocHJvdG90eXBlID09PSBudWxsIHx8IGlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiBvYmo7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm90b3R5cGUgbXVzdCBiZSBudWxsIG9yIGFuIG9iamVjdFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0dmFyIGZuLCBzZXQ7XG5cdGlmICghc3RhdHVzKSByZXR1cm4gbnVsbDtcblx0aWYgKHN0YXR1cy5sZXZlbCA9PT0gMikge1xuXHRcdGlmIChzdGF0dXMuc2V0KSB7XG5cdFx0XHRzZXQgPSBzdGF0dXMuc2V0O1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0c2V0LmNhbGwodmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLCBwcm90b3R5cGUpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gc2VsZihvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gb2JqSXNQcm90b3R5cGVPZi5jYWxsKHNlbGYubnVsbFBvbHlmaWxsLCBvYmopO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlbGV0ZSBzZWxmLm51bGxQb2x5ZmlsbC5fX3Byb3RvX187XG5cdFx0XHRpZiAocHJvdG90eXBlID09PSBudWxsKSBwcm90b3R5cGUgPSBzZWxmLm51bGxQb2x5ZmlsbDtcblx0XHRcdG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVmaW5lUHJvcGVydHkoc2VsZi5udWxsUG9seWZpbGwsIFwiX19wcm90b19fXCIsIG51bGxEZXNjKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcImxldmVsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogc3RhdHVzLmxldmVsXG5cdH0pO1xufSkoXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRtcE9iajEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0ICAsIHRtcE9iajIgPSB7fVxuXHRcdCAgLCBzZXRcblx0XHQgICwgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgXCJfX3Byb3RvX19cIik7XG5cblx0XHRpZiAoZGVzYykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2V0ID0gZGVzYy5zZXQ7IC8vIE9wZXJhIGNyYXNoZXMgYXQgdGhpcyBwb2ludFxuXHRcdFx0XHRzZXQuY2FsbCh0bXBPYmoxLCB0bXBPYmoyKTtcblx0XHRcdH0gY2F0Y2ggKGlnbm9yZSkge31cblx0XHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IHNldDogc2V0LCBsZXZlbDogMiB9O1xuXHRcdH1cblxuXHRcdHRtcE9iajEuX19wcm90b19fID0gdG1wT2JqMjtcblx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBsZXZlbDogMiB9O1xuXG5cdFx0dG1wT2JqMSA9IHt9O1xuXHRcdHRtcE9iajEuX19wcm90b19fID0gdG1wT2JqMjtcblx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBsZXZlbDogMSB9O1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KSgpXG4pO1xuXG5yZXF1aXJlKFwiLi4vY3JlYXRlXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRyZXR1cm4gZm47XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnMgOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHIgPSBcInJhemR3YXRyenlcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHN0ci5jb250YWlucyhcImR3YVwiKSA9PT0gdHJ1ZSAmJiBzdHIuY29udGFpbnMoXCJmb29cIikgPT09IGZhbHNlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLyosIHBvc2l0aW9uKi8pIHtcblx0cmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCBzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSkgPiAtMTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgaWQgPSBvYmpUb1N0cmluZy5jYWxsKFwiXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fFxuXHRcdCh2YWx1ZSAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG5cdFx0XHQodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGlkKSkgfHxcblx0XHRmYWxzZVxuXHQpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVxuICAsIGNvbnRhaW5zICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nLyMvY29udGFpbnNcIilcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZShcIi4vXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgJ25ldydcIik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgYXJyKTtcblx0aWYgKCFraW5kKSBraW5kID0gXCJ2YWx1ZVwiO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsIFwia2V5K3ZhbHVlXCIpKSBraW5kID0gXCJrZXkrdmFsdWVcIjtcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCBcImtleVwiKSkga2luZCA9IFwia2V5XCI7XG5cdGVsc2Uga2luZCA9IFwidmFsdWVcIjtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2tpbmRfX1wiLCBkKFwiXCIsIGtpbmQpKTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuLy8gSW50ZXJuYWwgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5BcnJheUl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwidmFsdWVcIikgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwia2V5K3ZhbHVlXCIpIHJldHVybiBbaSwgdGhpcy5fX2xpc3RfX1tpXV07XG5cdFx0cmV0dXJuIGk7XG5cdH0pXG59KTtcbmRlZmluZVByb3BlcnR5KEFycmF5SXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiQXJyYXkgSXRlcmF0b3JcIikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGNhbGxhYmxlICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCIpXG4gICwgZ2V0ICAgICAgICAgPSByZXF1aXJlKFwiLi9nZXRcIik7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLCBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjYiAvKiwgdGhpc0FyZyovKSB7XG5cdHZhciBtb2RlLCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCByZXN1bHQsIGRvQnJlYWssIGJyb2tlbiwgaSwgbGVuZ3RoLCBjaGFyLCBjb2RlO1xuXHRpZiAoaXNBcnJheShpdGVyYWJsZSkgfHwgaXNBcmd1bWVudHMoaXRlcmFibGUpKSBtb2RlID0gXCJhcnJheVwiO1xuXHRlbHNlIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIG1vZGUgPSBcInN0cmluZ1wiO1xuXHRlbHNlIGl0ZXJhYmxlID0gZ2V0KGl0ZXJhYmxlKTtcblxuXHRjYWxsYWJsZShjYik7XG5cdGRvQnJlYWsgPSBmdW5jdGlvbiAoKSB7XG5cdFx0YnJva2VuID0gdHJ1ZTtcblx0fTtcblx0aWYgKG1vZGUgPT09IFwiYXJyYXlcIikge1xuXHRcdHNvbWUuY2FsbChpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBkb0JyZWFrKTtcblx0XHRcdHJldHVybiBicm9rZW47XG5cdFx0fSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtb2RlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0bGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0Y2hhciA9IGl0ZXJhYmxlW2ldO1xuXHRcdFx0aWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgY2hhciArPSBpdGVyYWJsZVsrK2ldO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBjaGFyLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXG5cdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgZG9CcmVhayk7XG5cdFx0aWYgKGJyb2tlbikgcmV0dXJuO1xuXHRcdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBBcnJheUl0ZXJhdG9yICA9IHJlcXVpcmUoXCIuL2FycmF5XCIpXG4gICwgU3RyaW5nSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9zdHJpbmdcIilcbiAgLCBpdGVyYWJsZSAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLWl0ZXJhYmxlXCIpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmICh0eXBlb2YgaXRlcmFibGUob2JqKVtpdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9ialtpdGVyYXRvclN5bWJvbF0oKTtcblx0aWYgKGlzQXJndW1lbnRzKG9iaikpIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuXHRpZiAoaXNTdHJpbmcob2JqKSkgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihvYmopO1xuXHRyZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNsZWFyICAgID0gcmVxdWlyZShcImVzNS1leHQvYXJyYXkvIy9jbGVhclwiKVxuICAsIGFzc2lnbiAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiKVxuICAsIGNhbGxhYmxlID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWVcIilcbiAgLCBkICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgYXV0b0JpbmQgPSByZXF1aXJlKFwiZC9hdXRvLWJpbmRcIilcbiAgLCBTeW1ib2wgICA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgSXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0b3IgPSBmdW5jdGlvbiAobGlzdCwgY29udGV4dCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgSXRlcmF0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgJ25ldydcIik7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fbGlzdF9fOiBkKFwid1wiLCB2YWx1ZShsaXN0KSksXG5cdFx0X19jb250ZXh0X186IGQoXCJ3XCIsIGNvbnRleHQpLFxuXHRcdF9fbmV4dEluZGV4X186IGQoXCJ3XCIsIDApXG5cdH0pO1xuXHRpZiAoIWNvbnRleHQpIHJldHVybjtcblx0Y2FsbGFibGUoY29udGV4dC5vbik7XG5cdGNvbnRleHQub24oXCJfYWRkXCIsIHRoaXMuX29uQWRkKTtcblx0Y29udGV4dC5vbihcIl9kZWxldGVcIiwgdGhpcy5fb25EZWxldGUpO1xuXHRjb250ZXh0Lm9uKFwiX2NsZWFyXCIsIHRoaXMuX29uQ2xlYXIpO1xufTtcblxuLy8gSW50ZXJuYWwgJUl0ZXJhdG9yUHJvdG90eXBlJSBkb2Vzbid0IGV4cG9zZSBpdHMgY29uc3RydWN0b3JcbmRlbGV0ZSBJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbmRlZmluZVByb3BlcnRpZXMoXG5cdEl0ZXJhdG9yLnByb3RvdHlwZSxcblx0YXNzaWduKFxuXHRcdHtcblx0XHRcdF9uZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWRvX18pIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmIChpICE9PSB1bmRlZmluZWQpIHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGlzdF9fLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdFx0XHR0aGlzLl91bkJpbmQoKTtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH0pLFxuXHRcdFx0bmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jcmVhdGVSZXN1bHQodGhpcy5fbmV4dCgpKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZVJlc3VsdDogZChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0XHRcdHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy5fcmVzb2x2ZShpKSB9O1xuXHRcdFx0fSksXG5cdFx0XHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRcdH0pLFxuXHRcdFx0X3VuQmluZDogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX19saXN0X18gPSBudWxsO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fX3JlZG9fXztcblx0XHRcdFx0aWYgKCF0aGlzLl9fY29udGV4dF9fKSByZXR1cm47XG5cdFx0XHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKFwiX2FkZFwiLCB0aGlzLl9vbkFkZCk7XG5cdFx0XHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKFwiX2RlbGV0ZVwiLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdFx0XHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKFwiX2NsZWFyXCIsIHRoaXMuX29uQ2xlYXIpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fID0gbnVsbDtcblx0XHRcdH0pLFxuXHRcdFx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gXCJbb2JqZWN0IFwiICsgKHRoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBcIk9iamVjdFwiKSArIFwiXVwiO1xuXHRcdFx0fSlcblx0XHR9LFxuXHRcdGF1dG9CaW5kKHtcblx0XHRcdF9vbkFkZDogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdFx0XHQrK3RoaXMuX19uZXh0SW5kZXhfXztcblx0XHRcdFx0aWYgKCF0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX3JlZG9fX1wiLCBkKFwiY1wiLCBbaW5kZXhdKSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX19yZWRvX18uZm9yRWFjaChmdW5jdGlvbiAocmVkbywgaSkge1xuXHRcdFx0XHRcdGlmIChyZWRvID49IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gKytyZWRvO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5wdXNoKGluZGV4KTtcblx0XHRcdH0pLFxuXHRcdFx0X29uRGVsZXRlOiBkKGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdFx0XHQtLXRoaXMuX19uZXh0SW5kZXhfXztcblx0XHRcdFx0aWYgKCF0aGlzLl9fcmVkb19fKSByZXR1cm47XG5cdFx0XHRcdGkgPSB0aGlzLl9fcmVkb19fLmluZGV4T2YoaW5kZXgpO1xuXHRcdFx0XHRpZiAoaSAhPT0gLTEpIHRoaXMuX19yZWRvX18uc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGopIHtcblx0XHRcdFx0XHRpZiAocmVkbyA+IGluZGV4KSB0aGlzLl9fcmVkb19fW2pdID0gLS1yZWRvO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH0pLFxuXHRcdFx0X29uQ2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlZG9fXykgY2xlYXIuY2FsbCh0aGlzLl9fcmVkb19fKTtcblx0XHRcdFx0dGhpcy5fX25leHRJbmRleF9fID0gMDtcblx0XHRcdH0pXG5cdFx0fSlcblx0KVxuKTtcblxuZGVmaW5lUHJvcGVydHkoXG5cdEl0ZXJhdG9yLnByb3RvdHlwZSxcblx0U3ltYm9sLml0ZXJhdG9yLFxuXHRkKGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSlcbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgaXNWYWx1ZSAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvaXMtdmFsdWVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIik7XG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yXG4gICwgaXNBcnJheSAgICAgICAgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNBcmd1bWVudHModmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZVtpdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbn07XG4iLCIvLyBUaGFua3MgQG1hdGhpYXNieW5lbnNcbi8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSNpdGVyYXRpbmctb3Zlci1zeW1ib2xzXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKFwiLi9cIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgU3RyaW5nSXRlcmF0b3I7XG5cblN0cmluZ0l0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdJdGVyYXRvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmV3J1wiKTtcblx0c3RyID0gU3RyaW5nKHN0cik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgc3RyKTtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2xlbmd0aF9fXCIsIGQoXCJcIiwgc3RyLmxlbmd0aCkpO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoU3RyaW5nSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuLy8gSW50ZXJuYWwgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0dGhpcy5fdW5CaW5kKCk7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fSksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0dmFyIGNoYXIgPSB0aGlzLl9fbGlzdF9fW2ldLCBjb2RlO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPT09IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIGNoYXI7XG5cdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHJldHVybiBjaGFyICsgdGhpcy5fX2xpc3RfX1t0aGlzLl9fbmV4dEluZGV4X18rK107XG5cdFx0cmV0dXJuIGNoYXI7XG5cdH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKFwiY1wiLCBcIlN0cmluZyBJdGVyYXRvclwiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKFwiLi9pcy1pdGVyYWJsZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBpdGVyYWJsZVwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKSA/IE1hcCA6IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0Ly8gV2ViS2l0IGRvZXNuJ3Qgc3VwcG9ydCBhcmd1bWVudHMgYW5kIGNyYXNoZXNcblx0XHRtYXAgPSBuZXcgTWFwKFtbJ3JheicsICdvbmUnXSwgWydkd2EnLCAndHdvJ10sIFsndHJ6eScsICd0aHJlZSddXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKFN0cmluZyhtYXApICE9PSAnW29iamVjdCBNYXBdJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAobWFwLnNpemUgIT09IDMpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuY2xlYXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZGVsZXRlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmVudHJpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5nZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuaGFzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmtleXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuc2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdGl0ZXJhdG9yID0gbWFwLmVudHJpZXMoKTtcblx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRpZiAocmVzdWx0LmRvbmUgIT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdGlmICghcmVzdWx0LnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMF0gIT09ICdyYXonKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMV0gIT09ICdvbmUnKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRXhwb3J0cyB0cnVlIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIG5hdGl2ZSBgTWFwYCBpbXBsZW1lbnRhdGlvbixcbi8vIHdoYXRldmVyIHRoYXQgaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpKSA9PT0gJ1tvYmplY3QgTWFwXScpO1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9wcmltaXRpdmUtc2V0JykoJ2tleScsXG5cdCd2YWx1ZScsICdrZXkrdmFsdWUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvcicpXG4gICwgdG9TdHJpbmdUYWdTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykudG9TdHJpbmdUYWdcbiAgLCBraW5kcyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vaXRlcmF0b3Ita2luZHMnKVxuXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgdW5CaW5kID0gSXRlcmF0b3IucHJvdG90eXBlLl91bkJpbmRcbiAgLCBNYXBJdGVyYXRvcjtcblxuTWFwSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXAsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcEl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcihtYXAsIGtpbmQpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIG1hcC5fX21hcEtleXNEYXRhX18sIG1hcCk7XG5cdGlmICgha2luZCB8fCAha2luZHNba2luZF0pIGtpbmQgPSAna2V5K3ZhbHVlJztcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19raW5kX186IGQoJycsIGtpbmQpLFxuXHRcdF9fdmFsdWVzX186IGQoJ3cnLCBtYXAuX19tYXBWYWx1ZXNEYXRhX18pXG5cdH0pO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoTWFwSXRlcmF0b3IpLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAndmFsdWUnKSByZXR1cm4gdGhpcy5fX3ZhbHVlc19fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5JykgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0cmV0dXJuIFt0aGlzLl9fbGlzdF9fW2ldLCB0aGlzLl9fdmFsdWVzX19baV1dO1xuXHR9KSxcblx0X3VuQmluZDogZChmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fX3ZhbHVlc19fID0gbnVsbDtcblx0XHR1bkJpbmQuY2FsbCh0aGlzKTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nOyB9KVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwSXRlcmF0b3IucHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCxcblx0ZCgnYycsICdNYXAgSXRlcmF0b3InKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGVhciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9jbGVhcicpXG4gICwgZUluZGV4T2YgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvZS1pbmRleC1vZicpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjYWxsYWJsZSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWxpZFZhbHVlICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGVlICAgICAgICAgICAgID0gcmVxdWlyZSgnZXZlbnQtZW1pdHRlcicpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKCdlczYtc3ltYm9sJylcbiAgLCBpdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZScpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvZm9yLW9mJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdG9yJylcbiAgLCBpc05hdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vaXMtbmF0aXZlLWltcGxlbWVudGVkJylcblxuICAsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCBNYXBQb2x5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcFBvbHkgPSBmdW5jdGlvbiAoLyppdGVyYWJsZSovKSB7XG5cdHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXSwga2V5cywgdmFsdWVzLCBzZWxmO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwUG9seSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIHJlcXVpcmVzIFxcJ25ld1xcJycpO1xuXHRpZiAoaXNOYXRpdmUgJiYgc2V0UHJvdG90eXBlT2YgJiYgKE1hcCAhPT0gTWFwUG9seSkpIHtcblx0XHRzZWxmID0gc2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLCBnZXRQcm90b3R5cGVPZih0aGlzKSk7XG5cdH0gZWxzZSB7XG5cdFx0c2VsZiA9IHRoaXM7XG5cdH1cblx0aWYgKGl0ZXJhYmxlICE9IG51bGwpIGl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ZGVmaW5lUHJvcGVydGllcyhzZWxmLCB7XG5cdFx0X19tYXBLZXlzRGF0YV9fOiBkKCdjJywga2V5cyA9IFtdKSxcblx0XHRfX21hcFZhbHVlc0RhdGFfXzogZCgnYycsIHZhbHVlcyA9IFtdKVxuXHR9KTtcblx0aWYgKCFpdGVyYWJsZSkgcmV0dXJuIHNlbGY7XG5cdGZvck9mKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIga2V5ID0gdmFsaWRWYWx1ZSh2YWx1ZSlbMF07XG5cdFx0dmFsdWUgPSB2YWx1ZVsxXTtcblx0XHRpZiAoZUluZGV4T2YuY2FsbChrZXlzLCBrZXkpICE9PSAtMSkgcmV0dXJuO1xuXHRcdGtleXMucHVzaChrZXkpO1xuXHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0fSwgc2VsZik7XG5cdHJldHVybiBzZWxmO1xufTtcblxuaWYgKGlzTmF0aXZlKSB7XG5cdGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwUG9seSwgTWFwKTtcblx0TWFwUG9seS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1hcC5wcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogZChNYXBQb2x5KVxuXHR9KTtcbn1cblxuZWUoZGVmaW5lUHJvcGVydGllcyhNYXBQb2x5LnByb3RvdHlwZSwge1xuXHRjbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbWFwS2V5c0RhdGFfXy5sZW5ndGgpIHJldHVybjtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fKTtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBWYWx1ZXNEYXRhX18pO1xuXHRcdHRoaXMuZW1pdCgnX2NsZWFyJyk7XG5cdH0pLFxuXHRkZWxldGU6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfXy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuZW1pdCgnX2RlbGV0ZScsIGluZGV4LCBrZXkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9KSxcblx0ZW50cmllczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpOyB9KSxcblx0Zm9yRWFjaDogZChmdW5jdGlvbiAoY2IvKiwgdGhpc0FyZyovKSB7XG5cdFx0dmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV0sIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXHRcdGl0ZXJhdG9yID0gdGhpcy5lbnRyaWVzKCk7XG5cdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR3aGlsZSAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tyZXN1bHRdLFxuXHRcdFx0XHR0aGlzLl9fbWFwS2V5c0RhdGFfX1tyZXN1bHRdLCB0aGlzKTtcblx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0fVxuXHR9KSxcblx0Z2V0OiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcblx0XHRyZXR1cm4gdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF07XG5cdH0pLFxuXHRoYXM6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiAoZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSAhPT0gLTEpO1xuXHR9KSxcblx0a2V5czogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleScpOyB9KSxcblx0c2V0OiBkKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSwgZW1pdDtcblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX19tYXBLZXlzRGF0YV9fLnB1c2goa2V5KSAtIDE7XG5cdFx0XHRlbWl0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF0gPSB2YWx1ZTtcblx0XHRpZiAoZW1pdCkgdGhpcy5lbWl0KCdfYWRkJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pLFxuXHRzaXplOiBkLmdzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aDsgfSksXG5cdHZhbHVlczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7IH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBNYXBdJzsgfSlcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBQb2x5LnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCBkKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJ2MnLCAnTWFwJykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIikuU3ltYm9sXG5cdDogcmVxdWlyZShcIi4vcG9seWZpbGxcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpXG4gICwgdmFsaWRUeXBlcyA9IHsgb2JqZWN0OiB0cnVlLCBzeW1ib2w6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHN5bWJvbCA9IFN5bWJvbChcInRlc3Qgc3ltYm9sXCIpO1xuXHR0cnkgeyBTdHJpbmcoc3ltYm9sKTsgfVxuXHRjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBSZXR1cm4gJ3RydWUnIGFsc28gZm9yIHBvbHlmaWxsc1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9QcmltaXRpdmVdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnXSkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCIpIHJldHVybiB0cnVlO1xuXHRpZiAoIXZhbHVlLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cdGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSBcIlN5bWJvbFwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiB2YWx1ZVt2YWx1ZS5jb25zdHJ1Y3Rvci50b1N0cmluZ1RhZ10gPT09IFwiU3ltYm9sXCI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkID0gcmVxdWlyZShcImRcIik7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgb2JqUHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxudmFyIGNyZWF0ZWQgPSBjcmVhdGUobnVsbCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXNjKSB7XG5cdHZhciBwb3N0Zml4ID0gMCwgbmFtZSwgaWUxMUJ1Z1dvcmthcm91bmQ7XG5cdHdoaWxlIChjcmVhdGVkW2Rlc2MgKyAocG9zdGZpeCB8fCBcIlwiKV0pICsrcG9zdGZpeDtcblx0ZGVzYyArPSBwb3N0Zml4IHx8IFwiXCI7XG5cdGNyZWF0ZWRbZGVzY10gPSB0cnVlO1xuXHRuYW1lID0gXCJAQFwiICsgZGVzYztcblx0ZGVmaW5lUHJvcGVydHkoXG5cdFx0b2JqUHJvdG90eXBlLFxuXHRcdG5hbWUsXG5cdFx0ZC5ncyhudWxsLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdC8vIEZvciBJRTExIGlzc3VlIHNlZTpcblx0XHRcdC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrZGV0YWlsL3ZpZXcvMTkyODUwOC9cblx0XHRcdC8vICAgIGllMTEtYnJva2VuLWdldHRlcnMtb24tZG9tLW9iamVjdHNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEyXG5cdFx0XHRpZiAoaWUxMUJ1Z1dvcmthcm91bmQpIHJldHVybjtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gdHJ1ZTtcblx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGQodmFsdWUpKTtcblx0XHRcdGllMTFCdWdXb3JrYXJvdW5kID0gZmFsc2U7XG5cdFx0fSlcblx0KTtcblx0cmV0dXJuIG5hbWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIE5hdGl2ZVN5bWJvbCA9IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIikuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTeW1ib2xQb2x5ZmlsbCkge1xuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwsIHtcblx0XHQvLyBUbyBlbnN1cmUgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciBuYXRpdmUgZnVuY3Rpb25zIChlLmcuIEFycmF5LmZyb20pXG5cdFx0Ly8gZmFsbGJhY2sgdG8gZXZlbnR1YWwgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdpdmVuIHN5bWJvbFxuXHRcdGhhc0luc3RhbmNlOiBkKFxuXHRcdFx0XCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaGFzSW5zdGFuY2UpIHx8IFN5bWJvbFBvbHlmaWxsKFwiaGFzSW5zdGFuY2VcIilcblx0XHQpLFxuXHRcdGlzQ29uY2F0U3ByZWFkYWJsZTogZChcblx0XHRcdFwiXCIsXG5cdFx0XHQoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUpIHx8XG5cdFx0XHRcdFN5bWJvbFBvbHlmaWxsKFwiaXNDb25jYXRTcHJlYWRhYmxlXCIpXG5cdFx0KSxcblx0XHRpdGVyYXRvcjogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pdGVyYXRvcikgfHwgU3ltYm9sUG9seWZpbGwoXCJpdGVyYXRvclwiKSksXG5cdFx0bWF0Y2g6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wubWF0Y2gpIHx8IFN5bWJvbFBvbHlmaWxsKFwibWF0Y2hcIikpLFxuXHRcdHJlcGxhY2U6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucmVwbGFjZSkgfHwgU3ltYm9sUG9seWZpbGwoXCJyZXBsYWNlXCIpKSxcblx0XHRzZWFyY2g6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc2VhcmNoKSB8fCBTeW1ib2xQb2x5ZmlsbChcInNlYXJjaFwiKSksXG5cdFx0c3BlY2llczogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGVjaWVzKSB8fCBTeW1ib2xQb2x5ZmlsbChcInNwZWNpZXNcIikpLFxuXHRcdHNwbGl0OiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwbGl0KSB8fCBTeW1ib2xQb2x5ZmlsbChcInNwbGl0XCIpKSxcblx0XHR0b1ByaW1pdGl2ZTogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBTeW1ib2xQb2x5ZmlsbChcInRvUHJpbWl0aXZlXCIpXG5cdFx0KSxcblx0XHR0b1N0cmluZ1RhZzogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvU3RyaW5nVGFnKSB8fCBTeW1ib2xQb2x5ZmlsbChcInRvU3RyaW5nVGFnXCIpXG5cdFx0KSxcblx0XHR1bnNjb3BhYmxlczogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnVuc2NvcGFibGVzKSB8fCBTeW1ib2xQb2x5ZmlsbChcInVuc2NvcGFibGVzXCIpXG5cdFx0KVxuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGQgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCB2YWxpZGF0ZVN5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi92YWxpZGF0ZS1zeW1ib2xcIik7XG5cbnZhciByZWdpc3RyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFN5bWJvbFBvbHlmaWxsKSB7XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbCwge1xuXHRcdGZvcjogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAocmVnaXN0cnlba2V5XSkgcmV0dXJuIHJlZ2lzdHJ5W2tleV07XG5cdFx0XHRyZXR1cm4gKHJlZ2lzdHJ5W2tleV0gPSBTeW1ib2xQb2x5ZmlsbChTdHJpbmcoa2V5KSkpO1xuXHRcdH0pLFxuXHRcdGtleUZvcjogZChmdW5jdGlvbiAoc3ltYm9sKSB7XG5cdFx0XHR2YXIga2V5O1xuXHRcdFx0dmFsaWRhdGVTeW1ib2woc3ltYm9sKTtcblx0XHRcdGZvciAoa2V5IGluIHJlZ2lzdHJ5KSB7XG5cdFx0XHRcdGlmIChyZWdpc3RyeVtrZXldID09PSBzeW1ib2wpIHJldHVybiBrZXk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0pXG5cdH0pO1xufTtcbiIsIi8vIEVTMjAxNSBTeW1ib2wgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCAob3IgcGFydGlhbGx5KSBzdXBwb3J0IGl0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZCAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIHZhbGlkYXRlU3ltYm9sICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWRhdGUtc3ltYm9sXCIpXG4gICwgTmF0aXZlU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpLlN5bWJvbFxuICAsIGdlbmVyYXRlTmFtZSAgICAgICAgID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvZ2VuZXJhdGUtbmFtZVwiKVxuICAsIHNldHVwU3RhbmRhcmRTeW1ib2xzID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvc2V0dXAvc3RhbmRhcmQtc3ltYm9sc1wiKVxuICAsIHNldHVwU3ltYm9sUmVnaXN0cnkgID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvc2V0dXAvc3ltYm9sLXJlZ2lzdHJ5XCIpO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgU3ltYm9sUG9seWZpbGwsIEhpZGRlblN5bWJvbCwgaXNOYXRpdmVTYWZlO1xuXG5pZiAodHlwZW9mIE5hdGl2ZVN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdHRyeSB7XG5cdFx0U3RyaW5nKE5hdGl2ZVN5bWJvbCgpKTtcblx0XHRpc05hdGl2ZVNhZmUgPSB0cnVlO1xuXHR9IGNhdGNoIChpZ25vcmUpIHt9XG59IGVsc2Uge1xuXHROYXRpdmVTeW1ib2wgPSBudWxsO1xufVxuXG4vLyBJbnRlcm5hbCBjb25zdHJ1Y3RvciAobm90IG9uZSBleHBvc2VkKSBmb3IgY3JlYXRpbmcgU3ltYm9sIGluc3RhbmNlcy5cbi8vIFRoaXMgb25lIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYHNvbWVTeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2xgIGFsd2F5cyByZXR1cm4gZmFsc2VcbkhpZGRlblN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIEhpZGRlblN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTtcblx0cmV0dXJuIFN5bWJvbFBvbHlmaWxsKGRlc2NyaXB0aW9uKTtcbn07XG5cbi8vIEV4cG9zZWQgYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIChyZXR1cm5zIGluc3RhbmNlcyBvZiBIaWRkZW5TeW1ib2wpXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFBvbHlmaWxsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpO1xuXHRpZiAoaXNOYXRpdmVTYWZlKSByZXR1cm4gTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcblx0c3ltYm9sID0gY3JlYXRlKEhpZGRlblN5bWJvbC5wcm90b3R5cGUpO1xuXHRkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogU3RyaW5nKGRlc2NyaXB0aW9uKTtcblx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXMoc3ltYm9sLCB7XG5cdFx0X19kZXNjcmlwdGlvbl9fOiBkKFwiXCIsIGRlc2NyaXB0aW9uKSxcblx0XHRfX25hbWVfXzogZChcIlwiLCBnZW5lcmF0ZU5hbWUoZGVzY3JpcHRpb24pKVxuXHR9KTtcbn07XG5cbnNldHVwU3RhbmRhcmRTeW1ib2xzKFN5bWJvbFBvbHlmaWxsKTtcbnNldHVwU3ltYm9sUmVnaXN0cnkoU3ltYm9sUG9seWZpbGwpO1xuXG4vLyBJbnRlcm5hbCB0d2Vha3MgZm9yIHJlYWwgc3ltYm9sIHByb2R1Y2VyXG5kZWZpbmVQcm9wZXJ0aWVzKEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3ltYm9sUG9seWZpbGwpLFxuXHR0b1N0cmluZzogZChcIlwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbmFtZV9fOyB9KVxufSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGV4cG9zZWQgb24gU3ltYm9sLnByb3RvdHlwZVxuLy8gVGhleSB3b24ndCBiZSBhY2Nlc3NpYmxlIG9uIHByb2R1Y2VkIHN5bWJvbCBpbnN0YW5jZXMgYXMgdGhleSBkZXJpdmUgZnJvbSBIaWRkZW5TeW1ib2wucHJvdG90eXBlXG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwge1xuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiBcIlN5bWJvbCAoXCIgKyB2YWxpZGF0ZVN5bWJvbCh0aGlzKS5fX2Rlc2NyaXB0aW9uX18gKyBcIilcIjsgfSksXG5cdHZhbHVlT2Y6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVTeW1ib2wodGhpcyk7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFxuXHRTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsXG5cdFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLFxuXHRkKFwiXCIsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3ltYm9sID0gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdFx0aWYgKHR5cGVvZiBzeW1ib2wgPT09IFwic3ltYm9sXCIpIHJldHVybiBzeW1ib2w7XG5cdFx0cmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xuXHR9KVxuKTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiU3ltYm9sXCIpKTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0b24gb2YgdG9QcmltaXRpdmUgYW5kIHRvU3RyaW5nVGFnIGZvciByZXR1cm5lZCBzeW1ib2wgaW5zdGFuY2VzXG5kZWZpbmVQcm9wZXJ0eShcblx0SGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsXG5cdGQoXCJjXCIsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZ10pXG4pO1xuXG4vLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0byBkZWZpbmUgYHRvUHJpbWl0aXZlYCBhcyBsYXN0IG9uZSwgYXMgc29tZSBpbXBsZW1lbnRhdGlvbnNcbi8vIGltcGxlbWVudCBgdG9QcmltaXRpdmVgIG5hdGl2ZWx5IHdpdGhvdXQgaW1wbGVtZW50aW5nIGB0b1N0cmluZ1RhZ2AgKG9yIG90aGVyIHNwZWNpZmllZCBzeW1ib2xzKVxuLy8gQW5kIHRoYXQgbWF5IGludm9rZSBlcnJvciBpbiBkZWZpbml0aW9uIGZsb3c6XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNjQxNDYxNDlcbmRlZmluZVByb3BlcnR5KFxuXHRIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSxcblx0ZChcImNcIiwgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlXSlcbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzU3ltYm9sID0gcmVxdWlyZShcIi4vaXMtc3ltYm9sXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzU3ltYm9sKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsInZhciBuYWl2ZUZhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZikgcmV0dXJuIHNlbGY7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdykgcmV0dXJuIHdpbmRvdztcblx0dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMpIHJldHVybiB0aGlzO1xuXG5cdC8vIFVuZXhwZWN0ZWQgc3RyaWN0IG1vZGUgKG1heSBoYXBwZW4gaWYgZS5nLiBidW5kbGVkIGludG8gRVNNIG1vZHVsZSlcblxuXHQvLyBUaGFua3MgQG1hdGhpYXNieW5lbnMgLT4gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcblx0Ly8gSW4gYWxsIEVTNSsgZW5naW5lcyBnbG9iYWwgb2JqZWN0IGluaGVyaXRzIGZyb20gT2JqZWN0LnByb3RvdHlwZVxuXHQvLyAoaWYgeW91IGFwcHJvYWNoZWQgb25lIHRoYXQgZG9lc24ndCBwbGVhc2UgcmVwb3J0KVxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcIl9fZ2xvYmFsX19cIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gVW5mb3J0dW5hdGUgY2FzZSBvZiBPYmplY3QucHJvdG90eXBlIGJlaW5nIHNlYWxlZCAodmlhIHByZXZlbnRFeHRlbnNpb25zLCBzZWFsIG9yIGZyZWV6ZSlcblx0XHRyZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHR9XG5cdHRyeSB7XG5cdFx0Ly8gU2FmYXJpIGNhc2UgKHdpbmRvdy5fX2dsb2JhbF9fIGlzIHJlc29sdmVkIHdpdGggZ2xvYmFsIGNvbnRleHQsIGJ1dCBfX2dsb2JhbF9fIGRvZXMgbm90KVxuXHRcdGlmICghX19nbG9iYWxfXykgcmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0XHRyZXR1cm4gX19nbG9iYWxfXztcblx0fSBmaW5hbGx5IHtcblx0XHRkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX2dsb2JhbF9fO1xuXHR9XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IGdsb2JhbFRoaXMgOiByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvblwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG5cdGlmICghZ2xvYmFsVGhpcykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gZ2xvYmFsVGhpcy5BcnJheSA9PT0gQXJyYXk7XG59O1xuIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHNcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XVxufVxuXG5odHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgcGFyYW1zID0gdmFsaWRhdGVQYXJhbXMocGFyYW1zKVxuICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYilcbn1cblxuaHR0cHMuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgcGFyYW1zID0gdmFsaWRhdGVQYXJhbXMocGFyYW1zKVxuICByZXR1cm4gaHR0cC5nZXQuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhcmFtcyAocGFyYW1zKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIHBhcmFtcyA9IHVybC5wYXJzZShwYXJhbXMpXG4gIH1cbiAgaWYgKCFwYXJhbXMucHJvdG9jb2wpIHtcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6J1xuICB9XG4gIGlmIChwYXJhbXMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm90b2NvbCBcIicgKyBwYXJhbXMucHJvdG9jb2wgKyAnXCIgbm90IHN1cHBvcnRlZC4gRXhwZWN0ZWQgXCJodHRwczpcIicpXG4gIH1cbiAgcmV0dXJuIHBhcmFtc1xufVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qIVxuICogaW4tYXJyYXkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2luLWFycmF5PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluQXJyYXkgKGFyciwgdmFsKSB7XG4gIGFyciA9IGFyciB8fCBbXTtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJbaV0gPT09IHZhbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDE0LCAyMDE1IFNpbW9uIEx5ZGVsbFxuLy8gWDExICjigJxNSVTigJ0pIExpY2Vuc2VkLiAoU2VlIExJQ0VOU0UuKVxuXG4vLyBUaGlzIHJlZ2V4IGNvbWVzIGZyb20gcmVnZXguY29mZmVlLCBhbmQgaXMgaW5zZXJ0ZWQgaGVyZSBieSBnZW5lcmF0ZS1pbmRleC5qc1xuLy8gKHJ1biBgbnBtIHJ1biBidWlsZGApLlxubW9kdWxlLmV4cG9ydHMgPSAvKChbJ1wiXSkoPzooPyFcXDJ8XFxcXCkufFxcXFwoPzpcXHJcXG58W1xcc1xcU10pKSooXFwyKT98YCg/OlteYFxcXFwkXXxcXFxcW1xcc1xcU118XFwkKD8hXFx7KXxcXCRcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfT8pKlxcfT8pKihgKT8pfChcXC9cXC8uKil8KFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqKFxcKlxcLyk/KXwoXFwvKD8hXFwqKSg/OlxcWyg/Oig/IVtcXF1cXFxcXSkufFxcXFwuKSpcXF18KD8hW1xcL1xcXVxcXFxdKS58XFxcXC4pK1xcLyg/Oig/IVxccyooPzpcXGJ8W1xcdTAwODAtXFx1RkZGRiRcXFxcJ1wifih7XXxbK1xcLSFdKD8hPSl8XFwuP1xcZCkpfFtnbWl5dV17MSw1fVxcYig/IVtcXHUwMDgwLVxcdUZGRkYkXFxcXF18XFxzKig/OlsrXFwtKiUmfF48PiE9Pyh7XXxcXC8oPyFbXFwvKl0pKSkpKXwoKD86MFt4WF1bXFxkYS1mQS1GXSt8MFtvT11bMC03XSt8MFtiQl1bMDFdK3woPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8pKXwoKD8hXFxkKSg/Oig/IVxccylbJFxcd1xcdTAwODAtXFx1RkZGRl18XFxcXHVbXFxkYS1mQS1GXXs0fXxcXFxcdVxce1tcXGRhLWZBLUZdezEsNn1cXH0pKyl8KC0tfFxcK1xcK3wmJnxcXHxcXHx8PT58XFwuezN9fCg/OlsrXFwtKlxcLyUmfF5dfDx7MSwyfXw+ezEsM318IT0/fD17MSwyfSk9P3xbPzp+XXxbOywuW1xcXSgpe31dKXwoXFxzKyl8KF4kfFtcXHNcXFNdKS9nXG5cbm1vZHVsZS5leHBvcnRzLm1hdGNoVG9Ub2tlbiA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHZhciB0b2tlbiA9IHt0eXBlOiBcImludmFsaWRcIiwgdmFsdWU6IG1hdGNoWzBdfVxuICAgICAgIGlmIChtYXRjaFsgMV0pIHRva2VuLnR5cGUgPSBcInN0cmluZ1wiICwgdG9rZW4uY2xvc2VkID0gISEobWF0Y2hbM10gfHwgbWF0Y2hbNF0pXG4gIGVsc2UgaWYgKG1hdGNoWyA1XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiXG4gIGVsc2UgaWYgKG1hdGNoWyA2XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiLCB0b2tlbi5jbG9zZWQgPSAhIW1hdGNoWzddXG4gIGVsc2UgaWYgKG1hdGNoWyA4XSkgdG9rZW4udHlwZSA9IFwicmVnZXhcIlxuICBlbHNlIGlmIChtYXRjaFsgOV0pIHRva2VuLnR5cGUgPSBcIm51bWJlclwiXG4gIGVsc2UgaWYgKG1hdGNoWzEwXSkgdG9rZW4udHlwZSA9IFwibmFtZVwiXG4gIGVsc2UgaWYgKG1hdGNoWzExXSkgdG9rZW4udHlwZSA9IFwicHVuY3R1YXRvclwiXG4gIGVsc2UgaWYgKG1hdGNoWzEyXSkgdG9rZW4udHlwZSA9IFwid2hpdGVzcGFjZVwiXG4gIHJldHVybiB0b2tlblxufVxuIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuIiwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAgJy8nLFxuICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgZjogICAgJ1xcZicsXG4gICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgdDogICAgJ1xcdCdcbiAgICB9LFxuICAgIHRleHQsXG5cbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBtLFxuICAgICAgICAgICAgYXQ6ICAgICAgYXQsXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBcbiAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIkV4cGVjdGVkICdcIiArIGMgKyBcIicgaW5zdGVhZCBvZiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICBhdCArPSAxO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgIFxuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgc3RyaW5nXCIpO1xuICAgIH0sXG5cbiAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxuXG4gICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgdmFsdWUsICAvLyBQbGFjZSBob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cblxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICB9LFxuXG4gICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgIH07XG5cbnZhbHVlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcbi8vIG9yIGEgd29yZC5cblxuICAgIHdoaXRlKCk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgJ3snOlxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgIGNhc2UgJy0nOlxuICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICB9XG59O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgXG4gICAgdGV4dCA9IHNvdXJjZTtcbiAgICBhdCA9IDA7XG4gICAgY2ggPSAnICc7XG4gICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICB3aGl0ZSgpO1xuICAgIGlmIChjaCkge1xuICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4gICAgLy8gcmVzdWx0LlxuXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG59O1xuIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8qIFByb3RvY29sIC0gcHJvdG9jb2wgY29uc3RhbnRzICovXG52YXIgcHJvdG9jb2wgPSBtb2R1bGUuZXhwb3J0c1xuXG4vKiBDb21tYW5kIGNvZGUgPT4gbW5lbW9uaWMgKi9cbnByb3RvY29sLnR5cGVzID0ge1xuICAwOiAncmVzZXJ2ZWQnLFxuICAxOiAnY29ubmVjdCcsXG4gIDI6ICdjb25uYWNrJyxcbiAgMzogJ3B1Ymxpc2gnLFxuICA0OiAncHViYWNrJyxcbiAgNTogJ3B1YnJlYycsXG4gIDY6ICdwdWJyZWwnLFxuICA3OiAncHViY29tcCcsXG4gIDg6ICdzdWJzY3JpYmUnLFxuICA5OiAnc3ViYWNrJyxcbiAgMTA6ICd1bnN1YnNjcmliZScsXG4gIDExOiAndW5zdWJhY2snLFxuICAxMjogJ3BpbmdyZXEnLFxuICAxMzogJ3BpbmdyZXNwJyxcbiAgMTQ6ICdkaXNjb25uZWN0JyxcbiAgMTU6ICdyZXNlcnZlZCdcbn1cblxuLyogTW5lbW9uaWMgPT4gQ29tbWFuZCBjb2RlICovXG5wcm90b2NvbC5jb2RlcyA9IHt9XG5mb3IgKHZhciBrIGluIHByb3RvY29sLnR5cGVzKSB7XG4gIHZhciB2ID0gcHJvdG9jb2wudHlwZXNba11cbiAgcHJvdG9jb2wuY29kZXNbdl0gPSBrXG59XG5cbi8qIEhlYWRlciAqL1xucHJvdG9jb2wuQ01EX1NISUZUID0gNFxucHJvdG9jb2wuQ01EX01BU0sgPSAweEYwXG5wcm90b2NvbC5EVVBfTUFTSyA9IDB4MDhcbnByb3RvY29sLlFPU19NQVNLID0gMHgwM1xucHJvdG9jb2wuUU9TX1NISUZUID0gMVxucHJvdG9jb2wuUkVUQUlOX01BU0sgPSAweDAxXG5cbi8qIExlbmd0aCAqL1xucHJvdG9jb2wuTEVOR1RIX01BU0sgPSAweDdGXG5wcm90b2NvbC5MRU5HVEhfRklOX01BU0sgPSAweDgwXG5cbi8qIENvbm5hY2sgKi9cbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX01BU0sgPSAweDAxXG5wcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTS10pXG5wcm90b2NvbC5DT05OQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snY29ubmFjayddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIENvbm5lY3QgKi9cbnByb3RvY29sLlVTRVJOQU1FX01BU0sgPSAweDgwXG5wcm90b2NvbC5QQVNTV09SRF9NQVNLID0gMHg0MFxucHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA9IDB4MjBcbnByb3RvY29sLldJTExfUU9TX01BU0sgPSAweDE4XG5wcm90b2NvbC5XSUxMX1FPU19TSElGVCA9IDNcbnByb3RvY29sLldJTExfRkxBR19NQVNLID0gMHgwNFxucHJvdG9jb2wuQ0xFQU5fU0VTU0lPTl9NQVNLID0gMHgwMlxucHJvdG9jb2wuQ09OTkVDVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Nvbm5lY3QnXSA8PCBwcm90b2NvbC5DTURfU0hJRlRdKVxuXG5mdW5jdGlvbiBnZW5IZWFkZXIgKHR5cGUpIHtcbiAgcmV0dXJuIFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKHFvcykge1xuICAgIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChkdXApIHtcbiAgICAgIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChyZXRhaW4pIHtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMSlcbiAgICAgICAgYnVmLndyaXRlVUludDgoXG4gICAgICAgICAgcHJvdG9jb2wuY29kZXNbdHlwZV0gPDwgcHJvdG9jb2wuQ01EX1NISUZUIHxcbiAgICAgICAgICAoZHVwID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwKSB8XG4gICAgICAgICAgcW9zIDw8IHByb3RvY29sLlFPU19TSElGVCB8IHJldGFpbiwgMCwgdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGJ1ZlxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vKiBQdWJsaXNoICovXG5wcm90b2NvbC5QVUJMSVNIX0hFQURFUiA9IGdlbkhlYWRlcigncHVibGlzaCcpXG5cbi8qIFN1YnNjcmliZSAqL1xucHJvdG9jb2wuU1VCU0NSSUJFX0hFQURFUiA9IGdlbkhlYWRlcignc3Vic2NyaWJlJylcblxuLyogVW5zdWJzY3JpYmUgKi9cbnByb3RvY29sLlVOU1VCU0NSSUJFX0hFQURFUiA9IGdlbkhlYWRlcigndW5zdWJzY3JpYmUnKVxuXG4vKiBDb25maXJtYXRpb25zICovXG5wcm90b2NvbC5BQ0tTID0ge1xuICB1bnN1YmFjazogZ2VuSGVhZGVyKCd1bnN1YmFjaycpLFxuICBwdWJhY2s6IGdlbkhlYWRlcigncHViYWNrJyksXG4gIHB1YmNvbXA6IGdlbkhlYWRlcigncHViY29tcCcpLFxuICBwdWJyZWw6IGdlbkhlYWRlcigncHVicmVsJyksXG4gIHB1YnJlYzogZ2VuSGVhZGVyKCdwdWJyZWMnKVxufVxuXG5wcm90b2NvbC5TVUJBQ0tfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydzdWJhY2snXSA8PCBwcm90b2NvbC5DTURfU0hJRlRdKVxuXG4vKiBQcm90b2NvbCB2ZXJzaW9ucyAqL1xucHJvdG9jb2wuVkVSU0lPTjMgPSBCdWZmZXIuZnJvbShbM10pXG5wcm90b2NvbC5WRVJTSU9ONCA9IEJ1ZmZlci5mcm9tKFs0XSlcblxuLyogUW9TICovXG5wcm90b2NvbC5RT1MgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtxb3NdKVxufSlcblxuLyogRW1wdHkgcGFja2V0cyAqL1xucHJvdG9jb2wuRU1QVFkgPSB7XG4gIHBpbmdyZXE6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3JlcSddIDw8IDQsIDBdKSxcbiAgcGluZ3Jlc3A6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3Jlc3AnXSA8PCA0LCAwXSksXG4gIGRpc2Nvbm5lY3Q6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snZGlzY29ubmVjdCddIDw8IDQsIDBdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIHdyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChwYWNrZXQpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBBY2N1bXVsYXRvcigpXG4gIHdyaXRlVG9TdHJlYW0ocGFja2V0LCBzdHJlYW0pXG4gIHJldHVybiBzdHJlYW0uY29uY2F0KClcbn1cblxuZnVuY3Rpb24gQWNjdW11bGF0b3IgKCkge1xuICB0aGlzLl9hcnJheSA9IG5ldyBBcnJheSgyMClcbiAgdGhpcy5faSA9IDBcbn1cblxuaW5oZXJpdHMoQWNjdW11bGF0b3IsIEVFKVxuXG5BY2N1bXVsYXRvci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5fYXJyYXlbdGhpcy5faSsrXSA9IGNodW5rXG4gIHJldHVybiB0cnVlXG59XG5cbkFjY3VtdWxhdG9yLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSAwXG4gIHZhciBsZW5ndGhzID0gbmV3IEFycmF5KHRoaXMuX2FycmF5Lmxlbmd0aClcbiAgdmFyIGxpc3QgPSB0aGlzLl9hcnJheVxuICB2YXIgcG9zID0gMFxuICB2YXIgaVxuICB2YXIgcmVzdWx0XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0W2ldICE9PSAnc3RyaW5nJykgbGVuZ3Roc1tpXSA9IGxpc3RbaV0ubGVuZ3RoXG4gICAgZWxzZSBsZW5ndGhzW2ldID0gQnVmZmVyLmJ5dGVMZW5ndGgobGlzdFtpXSlcblxuICAgIGxlbmd0aCArPSBsZW5ndGhzW2ldXG4gIH1cblxuICByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxpc3RbaV0uY29weShyZXN1bHQsIHBvcylcbiAgICAgIHBvcyArPSBsZW5ndGhzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC53cml0ZShsaXN0W2ldLCBwb3MpXG4gICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKVxuZXhwb3J0cy5nZW5lcmF0ZSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKVxuZXhwb3J0cy53cml0ZVRvU3RyZWFtID0gcmVxdWlyZSgnLi93cml0ZVRvU3RyZWFtJylcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBtYXggPSA2NTUzNlxudmFyIGNhY2hlID0ge31cblxuZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXIgKGkpIHtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICBidWZmZXIud3JpdGVVSW50OChpID4+IDgsIDApXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGkgJiAweDAwRkYsIDAgKyAxKVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDYWNoZSAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBjYWNoZVtpXSA9IGdlbmVyYXRlQnVmZmVyKGkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhY2hlOiBjYWNoZSxcbiAgZ2VuZXJhdGVDYWNoZTogZ2VuZXJhdGVDYWNoZSxcbiAgZ2VuZXJhdGVOdW1iZXI6IGdlbmVyYXRlQnVmZmVyXG59XG4iLCJcbmZ1bmN0aW9uIFBhY2tldCAoKSB7XG4gIHRoaXMuY21kID0gbnVsbFxuICB0aGlzLnJldGFpbiA9IGZhbHNlXG4gIHRoaXMucW9zID0gMFxuICB0aGlzLmR1cCA9IGZhbHNlXG4gIHRoaXMubGVuZ3RoID0gLTFcbiAgdGhpcy50b3BpYyA9IG51bGxcbiAgdGhpcy5wYXlsb2FkID0gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tldFxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibCA9IHJlcXVpcmUoJ2JsJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIFBhY2tldCA9IHJlcXVpcmUoJy4vcGFja2V0JylcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZXIpKSByZXR1cm4gbmV3IFBhcnNlcigpXG5cbiAgdGhpcy5fc3RhdGVzID0gW1xuICAgICdfcGFyc2VIZWFkZXInLFxuICAgICdfcGFyc2VMZW5ndGgnLFxuICAgICdfcGFyc2VQYXlsb2FkJyxcbiAgICAnX25ld1BhY2tldCdcbiAgXVxuXG4gIHRoaXMuX3Jlc2V0U3RhdGUoKVxufVxuXG5pbmhlcml0cyhQYXJzZXIsIEVFKVxuXG5QYXJzZXIucHJvdG90eXBlLl9yZXNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhY2tldCA9IG5ldyBQYWNrZXQoKVxuICB0aGlzLmVycm9yID0gbnVsbFxuICB0aGlzLl9saXN0ID0gYmwoKVxuICB0aGlzLl9zdGF0ZUNvdW50ZXIgPSAwXG59XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmVycm9yKSB0aGlzLl9yZXNldFN0YXRlKClcblxuICB0aGlzLl9saXN0LmFwcGVuZChidWYpXG5cbiAgd2hpbGUgKCh0aGlzLnBhY2tldC5sZW5ndGggIT09IC0xIHx8IHRoaXMuX2xpc3QubGVuZ3RoID4gMCkgJiZcbiAgICAgICAgIHRoaXNbdGhpcy5fc3RhdGVzW3RoaXMuX3N0YXRlQ291bnRlcl1dKCkgJiZcbiAgICAgICAgICF0aGlzLmVycm9yKSB7XG4gICAgdGhpcy5fc3RhdGVDb3VudGVyKytcblxuICAgIGlmICh0aGlzLl9zdGF0ZUNvdW50ZXIgPj0gdGhpcy5fc3RhdGVzLmxlbmd0aCkgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgYnVmZmVyXG4gIHZhciB6ZXJvID0gdGhpcy5fbGlzdC5yZWFkVUludDgoMClcbiAgdGhpcy5wYWNrZXQuY21kID0gY29uc3RhbnRzLnR5cGVzW3plcm8gPj4gY29uc3RhbnRzLkNNRF9TSElGVF1cbiAgdGhpcy5wYWNrZXQucmV0YWluID0gKHplcm8gJiBjb25zdGFudHMuUkVUQUlOX01BU0spICE9PSAwXG4gIHRoaXMucGFja2V0LnFvcyA9ICh6ZXJvID4+IGNvbnN0YW50cy5RT1NfU0hJRlQpICYgY29uc3RhbnRzLlFPU19NQVNLXG4gIHRoaXMucGFja2V0LmR1cCA9ICh6ZXJvICYgY29uc3RhbnRzLkRVUF9NQVNLKSAhPT0gMFxuXG4gIHRoaXMuX2xpc3QuY29uc3VtZSgxKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgbGlzdFxuICB2YXIgYnl0ZXMgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBsZW5ndGggPSAwXG4gIHZhciByZXN1bHQgPSB0cnVlXG4gIHZhciBjdXJyZW50XG5cbiAgd2hpbGUgKGJ5dGVzIDwgNSkge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9saXN0LnJlYWRVSW50OChieXRlcysrKVxuICAgIGxlbmd0aCArPSBtdWwgKiAoY3VycmVudCAmIGNvbnN0YW50cy5MRU5HVEhfTUFTSylcbiAgICBtdWwgKj0gMHg4MFxuXG4gICAgaWYgKChjdXJyZW50ICYgY29uc3RhbnRzLkxFTkdUSF9GSU5fTUFTSykgPT09IDApIGJyZWFrXG4gICAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIDw9IGJ5dGVzKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0KSB7XG4gICAgdGhpcy5wYWNrZXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5fbGlzdC5jb25zdW1lKGJ5dGVzKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBmYWxzZVxuXG4gIC8vIERvIHdlIGhhdmUgYSBwYXlsb2FkPyBEbyB3ZSBoYXZlIGVub3VnaCBkYXRhIHRvIGNvbXBsZXRlIHRoZSBwYXlsb2FkP1xuICAvLyBQSU5HcyBoYXZlIG5vIHBheWxvYWRcbiAgaWYgKHRoaXMucGFja2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9saXN0Lmxlbmd0aCA+PSB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLl9wb3MgPSAwXG5cbiAgICBzd2l0Y2ggKHRoaXMucGFja2V0LmNtZCkge1xuICAgICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29ubmVjdCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgICAgdGhpcy5fcGFyc2VDb25uYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgICB0aGlzLl9wYXJzZVB1Ymxpc2goKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHViYWNrJzpcbiAgICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgY2FzZSAncHViY29tcCc6XG4gICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUlkKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N1YnNjcmliZSc6XG4gICAgICAgIHRoaXMuX3BhcnNlU3Vic2NyaWJlKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlU3ViYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzpcbiAgICAgICAgdGhpcy5fcGFyc2VVbnN1YnNjcmliZSgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlVW5zdWJhY2soKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGluZ3JlcSc6XG4gICAgICBjYXNlICdwaW5ncmVzcCc6XG4gICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgLy8gVGhlc2UgYXJlIGVtcHR5LCBub3RoaW5nIHRvIGRvXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm90b2NvbElkIC8vIFByb3RvY29sIElEXG4gIHZhciBjbGllbnRJZCAvLyBDbGllbnQgSURcbiAgdmFyIHRvcGljIC8vIFdpbGwgdG9waWNcbiAgdmFyIHBheWxvYWQgLy8gV2lsbCBwYXlsb2FkXG4gIHZhciBwYXNzd29yZCAvLyBQYXNzd29yZFxuICB2YXIgdXNlcm5hbWUgLy8gVXNlcm5hbWVcbiAgdmFyIGZsYWdzID0ge31cbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgLy8gUGFyc2UgcHJvdG9jb2xJZFxuICBwcm90b2NvbElkID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwcm90b2NvbElkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHByb3RvY29sSWQnKSlcbiAgaWYgKHByb3RvY29sSWQgIT09ICdNUVRUJyAmJiBwcm90b2NvbElkICE9PSAnTVFJc2RwJykge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sSWQnKSlcbiAgfVxuXG4gIHBhY2tldC5wcm90b2NvbElkID0gcHJvdG9jb2xJZFxuXG4gIC8vIFBhcnNlIGNvbnN0YW50cyB2ZXJzaW9uIG51bWJlclxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuXG4gIHBhY2tldC5wcm90b2NvbFZlcnNpb24gPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG5cbiAgaWYgKHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDMgJiYgcGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gNCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKSlcbiAgfVxuXG4gIHRoaXMuX3BvcysrXG5cbiAgaWYgKHRoaXMuX3BvcyA+PSB0aGlzLl9saXN0Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG4gIH1cblxuICAvLyBQYXJzZSBjb25uZWN0IGZsYWdzXG4gIGZsYWdzLnVzZXJuYW1lID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuVVNFUk5BTUVfTUFTSylcbiAgZmxhZ3MucGFzc3dvcmQgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5QQVNTV09SRF9NQVNLKVxuICBmbGFncy53aWxsID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuV0lMTF9GTEFHX01BU0spXG5cbiAgaWYgKGZsYWdzLndpbGwpIHtcbiAgICBwYWNrZXQud2lsbCA9IHt9XG4gICAgcGFja2V0LndpbGwucmV0YWluID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuV0lMTF9SRVRBSU5fTUFTSykgIT09IDBcbiAgICBwYWNrZXQud2lsbC5xb3MgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5XSUxMX1FPU19NQVNLKSA+PiBjb25zdGFudHMuV0lMTF9RT1NfU0hJRlRcbiAgfVxuXG4gIHBhY2tldC5jbGVhbiA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLkNMRUFOX1NFU1NJT05fTUFTSykgIT09IDBcbiAgdGhpcy5fcG9zKytcblxuICAvLyBQYXJzZSBrZWVwYWxpdmVcbiAgcGFja2V0LmtlZXBhbGl2ZSA9IHRoaXMuX3BhcnNlTnVtKClcbiAgaWYgKHBhY2tldC5rZWVwYWxpdmUgPT09IC0xKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuXG4gIC8vIFBhcnNlIGNsaWVudElkXG4gIGNsaWVudElkID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICBpZiAoY2xpZW50SWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG4gIHBhY2tldC5jbGllbnRJZCA9IGNsaWVudElkXG5cbiAgaWYgKGZsYWdzLndpbGwpIHtcbiAgICAvLyBQYXJzZSB3aWxsIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHdpbGwgdG9waWMnKSlcbiAgICBwYWNrZXQud2lsbC50b3BpYyA9IHRvcGljXG5cbiAgICAvLyBQYXJzZSB3aWxsIHBheWxvYWRcbiAgICBwYXlsb2FkID0gdGhpcy5fcGFyc2VCdWZmZXIoKVxuICAgIGlmIChwYXlsb2FkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHdpbGwgcGF5bG9hZCcpKVxuICAgIHBhY2tldC53aWxsLnBheWxvYWQgPSBwYXlsb2FkXG4gIH1cblxuICAvLyBQYXJzZSB1c2VybmFtZVxuICBpZiAoZmxhZ3MudXNlcm5hbWUpIHtcbiAgICB1c2VybmFtZSA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodXNlcm5hbWUgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdXNlcm5hbWUnKSlcbiAgICBwYWNrZXQudXNlcm5hbWUgPSB1c2VybmFtZVxuICB9XG5cbiAgLy8gUGFyc2UgcGFzc3dvcmRcbiAgaWYgKGZsYWdzLnBhc3N3b3JkKSB7XG4gICAgcGFzc3dvcmQgPSB0aGlzLl9wYXJzZUJ1ZmZlcigpXG4gICAgaWYgKHBhc3N3b3JkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHBhc3N3b3JkJykpXG4gICAgcGFja2V0LnBhc3N3b3JkID0gcGFzc3dvcmRcbiAgfVxuXG4gIHJldHVybiBwYWNrZXRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VDb25uYWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPCAyKSByZXR1cm4gbnVsbFxuXG4gIHBhY2tldC5zZXNzaW9uUHJlc2VudCA9ICEhKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKSAmIGNvbnN0YW50cy5TRVNTSU9OUFJFU0VOVF9NQVNLKVxuICBwYWNrZXQucmV0dXJuQ29kZSA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcylcblxuICBpZiAocGFja2V0LnJldHVybkNvZGUgPT09IC0xKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHJldHVybiBjb2RlJykpXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlUHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG4gIHBhY2tldC50b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcblxuICBpZiAocGFja2V0LnRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgLy8gUGFyc2UgbWVzc2FnZUlkXG4gIGlmIChwYWNrZXQucW9zID4gMCkgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgcGFja2V0LnBheWxvYWQgPSB0aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcywgcGFja2V0Lmxlbmd0aClcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICB2YXIgdG9waWNcbiAgdmFyIHFvc1xuXG4gIGlmIChwYWNrZXQucW9zICE9PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1dyb25nIHN1YnNjcmliZSBoZWFkZXInKSlcbiAgfVxuXG4gIHBhY2tldC5zdWJzY3JpcHRpb25zID0gW11cblxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICB3aGlsZSAodGhpcy5fcG9zIDwgcGFja2V0Lmxlbmd0aCkge1xuICAgIC8vIFBhcnNlIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgICBpZiAodGhpcy5fcG9zID49IHBhY2tldC5sZW5ndGgpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdNYWxmb3JtZWQgU3Vic2NyaWJlIFBheWxvYWQnKSlcbiAgICBxb3MgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKylcblxuICAgIC8vIFB1c2ggcGFpciB0byBzdWJzY3JpcHRpb25zXG4gICAgcGFja2V0LnN1YnNjcmlwdGlvbnMucHVzaCh7IHRvcGljOiB0b3BpYywgcW9zOiBxb3MgfSlcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN1YmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYWNrZXQuZ3JhbnRlZCA9IFtdXG5cbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgLy8gUGFyc2UgZ3JhbnRlZCBRb1Nlc1xuICB3aGlsZSAodGhpcy5fcG9zIDwgdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5wYWNrZXQuZ3JhbnRlZC5wdXNoKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKSlcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gW11cblxuICAvLyBQYXJzZSBtZXNzYWdlSWRcbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICB2YXIgdG9waWNcblxuICAgIC8vIFBhcnNlIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgICAvLyBQdXNoIHRvcGljIHRvIHVuc3Vic2NyaXB0aW9uc1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMucHVzaCh0b3BpYylcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVVuc3ViYWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgbWVzc2FnZUlkJykpXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICBwYWNrZXQubWVzc2FnZUlkID0gdGhpcy5fcGFyc2VOdW0oKVxuXG4gIGlmIChwYWNrZXQubWVzc2FnZUlkID09PSBudWxsKSB7XG4gICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTdHJpbmcgPSBmdW5jdGlvbiAobWF5YmVCdWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMuX3BhcnNlTnVtKClcbiAgdmFyIHJlc3VsdFxuICB2YXIgZW5kID0gbGVuZ3RoICsgdGhpcy5fcG9zXG5cbiAgaWYgKGxlbmd0aCA9PT0gLTEgfHwgZW5kID4gdGhpcy5fbGlzdC5sZW5ndGggfHwgZW5kID4gdGhpcy5wYWNrZXQubGVuZ3RoKSByZXR1cm4gbnVsbFxuXG4gIHJlc3VsdCA9IHRoaXMuX2xpc3QudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLl9wb3MsIGVuZClcbiAgdGhpcy5fcG9zICs9IGxlbmd0aFxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYXJzZU51bSgpXG4gIHZhciByZXN1bHRcbiAgdmFyIGVuZCA9IGxlbmd0aCArIHRoaXMuX3Bvc1xuXG4gIGlmIChsZW5ndGggPT09IC0xIHx8IGVuZCA+IHRoaXMuX2xpc3QubGVuZ3RoIHx8IGVuZCA+IHRoaXMucGFja2V0Lmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICByZXN1bHQgPSB0aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcywgZW5kKVxuXG4gIHRoaXMuX3BvcyArPSBsZW5ndGhcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTnVtID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fbGlzdC5sZW5ndGggLSB0aGlzLl9wb3MgPCAyKSByZXR1cm4gLTFcblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fbGlzdC5yZWFkVUludDE2QkUodGhpcy5fcG9zKVxuICB0aGlzLl9wb3MgKz0gMlxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fbmV3UGFja2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXQpIHtcbiAgICB0aGlzLl9saXN0LmNvbnN1bWUodGhpcy5wYWNrZXQubGVuZ3RoKVxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgdGhpcy5wYWNrZXQpXG4gIH1cblxuICB0aGlzLnBhY2tldCA9IG5ldyBQYWNrZXQoKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX2VtaXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lcnJvciA9IGVyclxuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwcm90b2NvbCA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGVtcHR5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG52YXIgemVyb0J1ZiA9IEJ1ZmZlci5mcm9tKFswXSlcbnZhciBudW1iZXJzID0gcmVxdWlyZSgnLi9udW1iZXJzJylcbnZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJykubmV4dFRpY2tcblxudmFyIG51bUNhY2hlID0gbnVtYmVycy5jYWNoZVxudmFyIGdlbmVyYXRlTnVtYmVyID0gbnVtYmVycy5nZW5lcmF0ZU51bWJlclxudmFyIGdlbmVyYXRlQ2FjaGUgPSBudW1iZXJzLmdlbmVyYXRlQ2FjaGVcbnZhciB3cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyQ2FjaGVkXG52YXIgdG9HZW5lcmF0ZSA9IHRydWVcblxuZnVuY3Rpb24gZ2VuZXJhdGUgKHBhY2tldCwgc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uY29yaykge1xuICAgIHN0cmVhbS5jb3JrKClcbiAgICBuZXh0VGljayh1bmNvcmssIHN0cmVhbSlcbiAgfVxuXG4gIGlmICh0b0dlbmVyYXRlKSB7XG4gICAgdG9HZW5lcmF0ZSA9IGZhbHNlXG4gICAgZ2VuZXJhdGVDYWNoZSgpXG4gIH1cblxuICBzd2l0Y2ggKHBhY2tldC5jbWQpIHtcbiAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgIHJldHVybiBjb25uZWN0KHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ2Nvbm5hY2snOlxuICAgICAgcmV0dXJuIGNvbm5hY2socGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAncHVibGlzaCc6XG4gICAgICByZXR1cm4gcHVibGlzaChwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdwdWJhY2snOlxuICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgY2FzZSAncHVicmVsJzpcbiAgICBjYXNlICdwdWJjb21wJzpcbiAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICByZXR1cm4gY29uZmlybWF0aW9uKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3N1YnNjcmliZSc6XG4gICAgICByZXR1cm4gc3Vic2NyaWJlKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgICByZXR1cm4gc3ViYWNrKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzpcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdwaW5ncmVxJzpcbiAgICBjYXNlICdwaW5ncmVzcCc6XG4gICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICByZXR1cm4gZW1wdHlQYWNrZXQocGFja2V0LCBzdHJlYW0pXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVW5rbm93biBjb21tYW5kJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuLyoqXG4gKiBDb250cm9scyBudW1iZXJzIGNhY2hlLlxuICogU2V0IHRvIFwiZmFsc2VcIiB0byBhbGxvY2F0ZSBidWZmZXJzIG9uLXRoZS1mbGlnaHQgaW5zdGVhZCBvZiBwcmUtZ2VuZXJhdGVkIGNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZW5lcmF0ZSwgJ2NhY2hlTnVtYmVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyaXRlTnVtYmVyID09PSB3cml0ZU51bWJlckNhY2hlZFxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFudW1DYWNoZSB8fCBPYmplY3Qua2V5cyhudW1DYWNoZSkubGVuZ3RoID09PSAwKSB0b0dlbmVyYXRlID0gdHJ1ZVxuICAgICAgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckNhY2hlZFxuICAgIH0gZWxzZSB7XG4gICAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICAgIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJHZW5lcmF0ZWRcbiAgICB9XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHVuY29yayAoc3RyZWFtKSB7XG4gIHN0cmVhbS51bmNvcmsoKVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgcHJvdG9jb2xJZCA9IHNldHRpbmdzLnByb3RvY29sSWQgfHwgJ01RVFQnXG4gIHZhciBwcm90b2NvbFZlcnNpb24gPSBzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gfHwgNFxuICB2YXIgd2lsbCA9IHNldHRpbmdzLndpbGxcbiAgdmFyIGNsZWFuID0gc2V0dGluZ3MuY2xlYW5cbiAgdmFyIGtlZXBhbGl2ZSA9IHNldHRpbmdzLmtlZXBhbGl2ZSB8fCAwXG4gIHZhciBjbGllbnRJZCA9IHNldHRpbmdzLmNsaWVudElkIHx8ICcnXG4gIHZhciB1c2VybmFtZSA9IHNldHRpbmdzLnVzZXJuYW1lXG4gIHZhciBwYXNzd29yZCA9IHNldHRpbmdzLnBhc3N3b3JkXG5cbiAgaWYgKGNsZWFuID09PSB1bmRlZmluZWQpIGNsZWFuID0gdHJ1ZVxuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gTXVzdCBiZSBhIHN0cmluZyBhbmQgbm9uLWZhbHN5XG4gIGlmICghcHJvdG9jb2xJZCB8fFxuICAgICAodHlwZW9mIHByb3RvY29sSWQgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIocHJvdG9jb2xJZCkpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSBwcm90b2NvbElkLmxlbmd0aCArIDJcblxuICAvLyBNdXN0IGJlIDMgb3IgNFxuICBpZiAocHJvdG9jb2xWZXJzaW9uICE9PSAzICYmIHByb3RvY29sVmVyc2lvbiAhPT0gNCkge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbCB2ZXJzaW9uJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMVxuXG4gIC8vIENsaWVudElkIG1pZ2h0IGJlIG9taXR0ZWQgaW4gMy4xLjEsIGJ1dCBvbmx5IGlmIGNsZWFuU2Vzc2lvbiBpcyBzZXQgdG8gMVxuICBpZiAoKHR5cGVvZiBjbGllbnRJZCA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKGNsaWVudElkKSkgJiZcbiAgICAgKGNsaWVudElkIHx8IHByb3RvY29sVmVyc2lvbiA9PT0gNCkgJiYgKGNsaWVudElkIHx8IGNsZWFuKSkge1xuICAgIGxlbmd0aCArPSBjbGllbnRJZC5sZW5ndGggKyAyXG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb3RvY29sVmVyc2lvbiA8IDQpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignY2xpZW50SWQgbXVzdCBiZSBzdXBwbGllZCBiZWZvcmUgMy4xLjEnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoKGNsZWFuICogMSkgPT09IDApIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignY2xpZW50SWQgbXVzdCBiZSBnaXZlbiBpZiBjbGVhblNlc3Npb24gc2V0IHRvIDAnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIE11c3QgYmUgYSB0d28gYnl0ZSBudW1iZXJcbiAgaWYgKHR5cGVvZiBrZWVwYWxpdmUgIT09ICdudW1iZXInIHx8XG4gICAgICBrZWVwYWxpdmUgPCAwIHx8XG4gICAgICBrZWVwYWxpdmUgPiA2NTUzNSB8fFxuICAgICAga2VlcGFsaXZlICUgMSAhPT0gMCkge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBrZWVwYWxpdmUnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gQ29ubmVjdCBmbGFnc1xuICBsZW5ndGggKz0gMVxuXG4gIC8vIElmIHdpbGwgZXhpc3RzLi4uXG4gIGlmICh3aWxsKSB7XG4gICAgLy8gSXQgbXVzdCBiZSBhbiBvYmplY3RcbiAgICBpZiAodHlwZW9mIHdpbGwgIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIEl0IG11c3QgaGF2ZSB0b3BpYyB0eXBlb2Ygc3RyaW5nXG4gICAgaWYgKCF3aWxsLnRvcGljIHx8IHR5cGVvZiB3aWxsLnRvcGljICE9PSAnc3RyaW5nJykge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwgdG9waWMnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgod2lsbC50b3BpYykgKyAyXG4gICAgfVxuXG4gICAgLy8gUGF5bG9hZFxuICAgIGlmICh3aWxsLnBheWxvYWQgJiYgd2lsbC5wYXlsb2FkKSB7XG4gICAgICBpZiAod2lsbC5wYXlsb2FkLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbC5wYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh3aWxsLnBheWxvYWQpICsgMlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCArPSB3aWxsLnBheWxvYWQubGVuZ3RoICsgMlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCBwYXlsb2FkJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXJuYW1lXG4gIHZhciBwcm92aWRlZFVzZXJuYW1lID0gZmFsc2VcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICBpZiAoaXNTdHJpbmdPckJ1ZmZlcih1c2VybmFtZSkpIHtcbiAgICAgIHByb3ZpZGVkVXNlcm5hbWUgPSB0cnVlXG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcm5hbWUpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhc3N3b3JkXG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgaWYgKCFwcm92aWRlZFVzZXJuYW1lKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1VzZXJuYW1lIGlzIHJlcXVpcmVkIHRvIHVzZSBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgICBsZW5ndGggKz0gYnl0ZUxlbmd0aChwYXNzd29yZCkgKyAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5DT05ORUNUX0hFQURFUilcblxuICAvLyBHZW5lcmF0ZSBsZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gR2VuZXJhdGUgcHJvdG9jb2wgSURcbiAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHByb3RvY29sSWQpXG4gIHN0cmVhbS53cml0ZShcbiAgICBwcm90b2NvbFZlcnNpb24gPT09IDQgPyBwcm90b2NvbC5WRVJTSU9ONCA6IHByb3RvY29sLlZFUlNJT04zXG4gIClcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIHZhciBmbGFncyA9IDBcbiAgZmxhZ3MgfD0gKHVzZXJuYW1lICE9IG51bGwpID8gcHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHBhc3N3b3JkICE9IG51bGwpID8gcHJvdG9jb2wuUEFTU1dPUkRfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5yZXRhaW4pID8gcHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5xb3MpID8gd2lsbC5xb3MgPDwgcHJvdG9jb2wuV0lMTF9RT1NfU0hJRlQgOiAwXG4gIGZsYWdzIHw9IHdpbGwgPyBwcm90b2NvbC5XSUxMX0ZMQUdfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gY2xlYW4gPyBwcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgOiAwXG5cbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtmbGFnc10pKVxuXG4gIC8vIEtlZXBhbGl2ZVxuICB3cml0ZU51bWJlcihzdHJlYW0sIGtlZXBhbGl2ZSlcblxuICAvLyBDbGllbnQgSURcbiAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIGNsaWVudElkKVxuXG4gIC8vIFdpbGxcbiAgaWYgKHdpbGwpIHtcbiAgICB3cml0ZVN0cmluZyhzdHJlYW0sIHdpbGwudG9waWMpXG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHdpbGwucGF5bG9hZClcbiAgfVxuXG4gIC8vIFVzZXJuYW1lIGFuZCBwYXNzd29yZFxuICBpZiAodXNlcm5hbWUgIT0gbnVsbCkge1xuICAgIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCB1c2VybmFtZSlcbiAgfVxuICBpZiAocGFzc3dvcmQgIT0gbnVsbCkge1xuICAgIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCBwYXNzd29yZClcbiAgfVxuICAvLyBUaGlzIGlzIGEgc21hbGwgcGFja2V0IHRoYXQgaGFwcGVucyBvbmx5IG9uY2Ugb24gYSBzdHJlYW1cbiAgLy8gV2UgYXNzdW1lIHRoZSBzdHJlYW0gaXMgYWx3YXlzIGZyZWUgdG8gcmVjZWl2ZSBtb3JlIGRhdGEgYWZ0ZXIgdGhpc1xuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb25uYWNrIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgcmMgPSBzZXR0aW5ncy5yZXR1cm5Db2RlXG5cbiAgLy8gQ2hlY2sgcmV0dXJuIGNvZGVcbiAgaWYgKHR5cGVvZiByYyAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcmV0dXJuIGNvZGUnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5DT05OQUNLX0hFQURFUilcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCAyKVxuICBzdHJlYW0ud3JpdGUob3B0cy5zZXNzaW9uUHJlc2VudCA/IHByb3RvY29sLlNFU1NJT05QUkVTRU5UX0hFQURFUiA6IHplcm9CdWYpXG5cbiAgcmV0dXJuIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmNdKSlcbn1cblxuZnVuY3Rpb24gcHVibGlzaCAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIHFvcyA9IHNldHRpbmdzLnFvcyB8fCAwXG4gIHZhciByZXRhaW4gPSBzZXR0aW5ncy5yZXRhaW4gPyBwcm90b2NvbC5SRVRBSU5fTUFTSyA6IDBcbiAgdmFyIHRvcGljID0gc2V0dGluZ3MudG9waWNcbiAgdmFyIHBheWxvYWQgPSBzZXR0aW5ncy5wYXlsb2FkIHx8IGVtcHR5XG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gVG9waWMgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgQnVmZmVyXG4gIGlmICh0eXBlb2YgdG9waWMgPT09ICdzdHJpbmcnKSBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodG9waWMpICsgMlxuICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodG9waWMpKSBsZW5ndGggKz0gdG9waWMubGVuZ3RoICsgMlxuICBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdldCB0aGUgcGF5bG9hZCBsZW5ndGhcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXlsb2FkKVxuICBlbHNlIGxlbmd0aCArPSBwYXlsb2FkLmxlbmd0aFxuXG4gIC8vIE1lc3NhZ2UgSUQgbXVzdCBhIG51bWJlciBpZiBxb3MgPiAwXG4gIGlmIChxb3MgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChxb3MpIGxlbmd0aCArPSAyXG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5QVUJMSVNIX0hFQURFUltxb3NdW29wdHMuZHVwID8gMSA6IDBdW3JldGFpbiA/IDEgOiAwXSlcblxuICAvLyBSZW1haW5pbmcgbGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIFRvcGljXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgYnl0ZUxlbmd0aCh0b3BpYykpXG4gIHN0cmVhbS53cml0ZSh0b3BpYylcblxuICAvLyBNZXNzYWdlIElEXG4gIGlmIChxb3MgPiAwKSB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIFBheWxvYWRcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShwYXlsb2FkKVxufVxuXG4vKiBQdWJhY2ssIHB1YnJlYywgcHVicmVsIGFuZCBwdWJjb21wICovXG5mdW5jdGlvbiBjb25maXJtYXRpb24gKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciB0eXBlID0gc2V0dGluZ3MuY21kIHx8ICdwdWJhY2snXG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgZHVwID0gKHNldHRpbmdzLmR1cCAmJiB0eXBlID09PSAncHVicmVsJykgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIHFvcyA9IDBcblxuICBpZiAodHlwZSA9PT0gJ3B1YnJlbCcpIHFvcyA9IDFcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5BQ0tTW3R5cGVdW3Fvc11bZHVwXVswXSlcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCAyKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgcmV0dXJuIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZSAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIHN1YnMgPSBzZXR0aW5ncy5zdWJzY3JpcHRpb25zXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDaGVjayBzdWJzY3JpcHRpb25zXG4gIGlmICh0eXBlb2Ygc3VicyA9PT0gJ29iamVjdCcgJiYgc3Vicy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBpdG9waWMgPSBzdWJzW2ldLnRvcGljXG4gICAgICB2YXIgaXFvcyA9IHN1YnNbaV0ucW9zXG5cbiAgICAgIGlmICh0eXBlb2YgaXRvcGljICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgdG9waWMnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGlxb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBxb3MnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChpdG9waWMpICsgMiArIDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIEdlbmVyYXRlIG1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuXG4gIC8vIEdlbmVyYXRlIHN1YnNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHN1YiA9IHN1YnNbal1cbiAgICB2YXIganRvcGljID0gc3ViLnRvcGljXG4gICAgdmFyIGpxb3MgPSBzdWIucW9zXG5cbiAgICAvLyBXcml0ZSB0b3BpYyBzdHJpbmdcbiAgICB3cml0ZVN0cmluZyhzdHJlYW0sIGp0b3BpYylcblxuICAgIC8vIFdyaXRlIHFvc1xuICAgIHJlc3VsdCA9IHN0cmVhbS53cml0ZShwcm90b2NvbC5RT1NbanFvc10pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHN1YmFjayAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBncmFudGVkID0gc2V0dGluZ3MuZ3JhbnRlZFxuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gQ2hlY2sgZ3JhbnRlZCBxb3MgdmVjdG9yXG4gIGlmICh0eXBlb2YgZ3JhbnRlZCA9PT0gJ29iamVjdCcgJiYgZ3JhbnRlZC5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYW50ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgZ3JhbnRlZFtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBsZW5ndGggKz0gMVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5TVUJBQ0tfSEVBREVSKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgcmV0dXJuIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShncmFudGVkKSlcbn1cblxuZnVuY3Rpb24gdW5zdWJzY3JpYmUgKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgZHVwID0gc2V0dGluZ3MuZHVwID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciB1bnN1YnMgPSBzZXR0aW5ncy51bnN1YnNjcmlwdGlvbnNcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoICs9IDJcbiAgfVxuICAvLyBDaGVjayB1bnN1YnNcbiAgaWYgKHR5cGVvZiB1bnN1YnMgPT09ICdvYmplY3QnICYmIHVuc3Vicy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuc3Vicy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB1bnN1YnNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB1bnN1YnNjcmlwdGlvbnMnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodW5zdWJzW2ldKSArIDJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVuc3Vic2NyaXB0aW9ucycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5VTlNVQlNDUklCRV9IRUFERVJbMV1bZHVwID8gMSA6IDBdWzBdKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gVW5zdWJzXG4gIHZhciByZXN1bHQgPSB0cnVlXG4gIGZvciAodmFyIGogPSAwOyBqIDwgdW5zdWJzLmxlbmd0aDsgaisrKSB7XG4gICAgcmVzdWx0ID0gd3JpdGVTdHJpbmcoc3RyZWFtLCB1bnN1YnNbal0pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGVtcHR5UGFja2V0IChvcHRzLCBzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShwcm90b2NvbC5FTVBUWVtvcHRzLmNtZF0pXG59XG5cbi8qKlxuICogY2FsY0xlbmd0aExlbmd0aCAtIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSByZW1haW5pbmdcbiAqIGxlbmd0aCBmaWVsZFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxjTGVuZ3RoTGVuZ3RoIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IDEyOCkgcmV0dXJuIDFcbiAgZWxzZSBpZiAobGVuZ3RoID49IDEyOCAmJiBsZW5ndGggPCAxNjM4NCkgcmV0dXJuIDJcbiAgZWxzZSBpZiAobGVuZ3RoID49IDE2Mzg0ICYmIGxlbmd0aCA8IDIwOTcxNTIpIHJldHVybiAzXG4gIGVsc2UgaWYgKGxlbmd0aCA+PSAyMDk3MTUyICYmIGxlbmd0aCA8IDI2ODQzNTQ1NikgcmV0dXJuIDRcbiAgZWxzZSByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBnZW5CdWZMZW5ndGggKGxlbmd0aCkge1xuICB2YXIgZGlnaXQgPSAwXG4gIHZhciBwb3MgPSAwXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoY2FsY0xlbmd0aExlbmd0aChsZW5ndGgpKVxuXG4gIGRvIHtcbiAgICBkaWdpdCA9IGxlbmd0aCAlIDEyOCB8IDBcbiAgICBsZW5ndGggPSBsZW5ndGggLyAxMjggfCAwXG4gICAgaWYgKGxlbmd0aCA+IDApIGRpZ2l0ID0gZGlnaXQgfCAweDgwXG5cbiAgICBidWZmZXIud3JpdGVVSW50OChkaWdpdCwgcG9zKyspXG4gIH0gd2hpbGUgKGxlbmd0aCA+IDApXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG4vKipcbiAqIHdyaXRlTGVuZ3RoIC0gd3JpdGUgYW4gTVFUVCBzdHlsZSBsZW5ndGggZmllbGQgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxOdW1iZXI+IGxlbmd0aCAtIGxlbmd0aCAoPjApXG4gKiBAcmV0dXJucyA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBsZW5ndGhDYWNoZSA9IHt9XG5mdW5jdGlvbiB3cml0ZUxlbmd0aCAoc3RyZWFtLCBsZW5ndGgpIHtcbiAgdmFyIGJ1ZmZlciA9IGxlbmd0aENhY2hlW2xlbmd0aF1cblxuICBpZiAoIWJ1ZmZlcikge1xuICAgIGJ1ZmZlciA9IGdlbkJ1Zkxlbmd0aChsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA8IDE2Mzg0KSBsZW5ndGhDYWNoZVtsZW5ndGhdID0gYnVmZmVyXG4gIH1cblxuICBzdHJlYW0ud3JpdGUoYnVmZmVyKVxufVxuXG4vKipcbiAqIHdyaXRlU3RyaW5nIC0gd3JpdGUgYSB1dGY4IHN0cmluZyB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gc3RyaW5nIC0gc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmcgKHN0cmVhbSwgc3RyaW5nKSB7XG4gIHZhciBzdHJsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHJpbmcpXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgc3RybGVuKVxuXG4gIHN0cmVhbS53cml0ZShzdHJpbmcsICd1dGY4Jylcbn1cblxuLyoqXG4gKiB3cml0ZU51bWJlciAtIHdyaXRlIGEgdHdvIGJ5dGUgbnVtYmVyIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiBudW1iZXIgLSBudW1iZXIgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JpdGVOdW1iZXJDYWNoZWQgKHN0cmVhbSwgbnVtYmVyKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUobnVtQ2FjaGVbbnVtYmVyXSlcbn1cbmZ1bmN0aW9uIHdyaXRlTnVtYmVyR2VuZXJhdGVkIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKGdlbmVyYXRlTnVtYmVyKG51bWJlcikpXG59XG5cbi8qKlxuICogd3JpdGVTdHJpbmdPckJ1ZmZlciAtIHdyaXRlIGEgU3RyaW5nIG9yIEJ1ZmZlciB3aXRoIHRoZSBpdHMgbGVuZ3RoIHByZWZpeFxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IHRvV3JpdGUgLSBTdHJpbmcgb3IgQnVmZmVyXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nT3JCdWZmZXIgKHN0cmVhbSwgdG9Xcml0ZSkge1xuICBpZiAodHlwZW9mIHRvV3JpdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB0b1dyaXRlKVxuICB9IGVsc2UgaWYgKHRvV3JpdGUpIHtcbiAgICB3cml0ZU51bWJlcihzdHJlYW0sIHRvV3JpdGUubGVuZ3RoKVxuICAgIHN0cmVhbS53cml0ZSh0b1dyaXRlKVxuICB9IGVsc2Ugd3JpdGVOdW1iZXIoc3RyZWFtLCAwKVxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChidWZPclN0cmluZykge1xuICBpZiAoIWJ1Zk9yU3RyaW5nKSByZXR1cm4gMFxuICBlbHNlIGlmIChidWZPclN0cmluZyBpbnN0YW5jZW9mIEJ1ZmZlcikgcmV0dXJuIGJ1Zk9yU3RyaW5nLmxlbmd0aFxuICBlbHNlIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChidWZPclN0cmluZylcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdPckJ1ZmZlciAoZmllbGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycgfHwgZmllbGQgaW5zdGFuY2VvZiBCdWZmZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xyXG4gKi9cclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXHJcbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKVxyXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXHJcbnZhciBtcXR0UGFja2V0ID0gcmVxdWlyZSgnbXF0dC1wYWNrZXQnKVxyXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5Xcml0YWJsZVxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbnZhciByZUludGVydmFsID0gcmVxdWlyZSgncmVpbnRlcnZhbCcpXHJcbnZhciB2YWxpZGF0aW9ucyA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbnMnKVxyXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXHJcbnZhciBzZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gIC8vIHdvcmtzIGluIG5vZGUgdjAuOFxyXG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXHJcbn1cclxudmFyIGRlZmF1bHRDb25uZWN0T3B0aW9ucyA9IHtcclxuICBrZWVwYWxpdmU6IDYwLFxyXG4gIHJlc2NoZWR1bGVQaW5nczogdHJ1ZSxcclxuICBwcm90b2NvbElkOiAnTVFUVCcsXHJcbiAgcHJvdG9jb2xWZXJzaW9uOiA0LFxyXG4gIHJlY29ubmVjdFBlcmlvZDogMTAwMCxcclxuICBjb25uZWN0VGltZW91dDogMzAgKiAxMDAwLFxyXG4gIGNsZWFuOiB0cnVlLFxyXG4gIHJlc3Vic2NyaWJlOiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRJZCAoKSB7XHJcbiAgcmV0dXJuICdtcXR0anNfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cigyLCA4KVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZW5kUGFja2V0IChjbGllbnQsIHBhY2tldCwgY2IpIHtcclxuICBjbGllbnQuZW1pdCgncGFja2V0c2VuZCcsIHBhY2tldClcclxuXHJcbiAgdmFyIHJlc3VsdCA9IG1xdHRQYWNrZXQud3JpdGVUb1N0cmVhbShwYWNrZXQsIGNsaWVudC5zdHJlYW0pXHJcblxyXG4gIGlmICghcmVzdWx0ICYmIGNiKSB7XHJcbiAgICBjbGllbnQuc3RyZWFtLm9uY2UoJ2RyYWluJywgY2IpXHJcbiAgfSBlbHNlIGlmIChjYikge1xyXG4gICAgY2IoKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmx1c2ggKHF1ZXVlKSB7XHJcbiAgaWYgKHF1ZXVlKSB7XHJcbiAgICBPYmplY3Qua2V5cyhxdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUlkKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcXVldWVbbWVzc2FnZUlkXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHF1ZXVlW21lc3NhZ2VJZF0obmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKVxyXG4gICAgICAgIGRlbGV0ZSBxdWV1ZVttZXNzYWdlSWRdXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdG9yZUFuZFNlbmQgKGNsaWVudCwgcGFja2V0LCBjYikge1xyXG4gIGNsaWVudC5vdXRnb2luZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uIHN0b3JlZFBhY2tldCAoZXJyKSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXHJcbiAgICB9XHJcbiAgICBzZW5kUGFja2V0KGNsaWVudCwgcGFja2V0LCBjYilcclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBub3AgKCkge31cclxuXHJcbi8qKlxyXG4gKiBNcXR0Q2xpZW50IGNvbnN0cnVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gLSBzdHJlYW1cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiAoc2VlIENvbm5lY3Rpb24jY29ubmVjdClcclxuICovXHJcbmZ1bmN0aW9uIE1xdHRDbGllbnQgKHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpIHtcclxuICB2YXIga1xyXG4gIHZhciB0aGF0ID0gdGhpc1xyXG5cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTXF0dENsaWVudCkpIHtcclxuICAgIHJldHVybiBuZXcgTXF0dENsaWVudChzdHJlYW1CdWlsZGVyLCBvcHRpb25zKVxyXG4gIH1cclxuXHJcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxyXG5cclxuICAvLyBEZWZhdWx0c1xyXG4gIGZvciAoayBpbiBkZWZhdWx0Q29ubmVjdE9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zW2tdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aGlzLm9wdGlvbnNba10gPSBkZWZhdWx0Q29ubmVjdE9wdGlvbnNba11cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub3B0aW9uc1trXSA9IG9wdGlvbnNba11cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMub3B0aW9ucy5jbGllbnRJZCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmNsaWVudElkID09PSAnc3RyaW5nJykgPyB0aGlzLm9wdGlvbnMuY2xpZW50SWQgOiBkZWZhdWx0SWQoKVxyXG5cclxuICB0aGlzLnN0cmVhbUJ1aWxkZXIgPSBzdHJlYW1CdWlsZGVyXHJcblxyXG4gIC8vIEluZmxpZ2h0IG1lc3NhZ2Ugc3RvcmFnZXNcclxuICB0aGlzLm91dGdvaW5nU3RvcmUgPSB0aGlzLm9wdGlvbnMub3V0Z29pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxyXG4gIHRoaXMuaW5jb21pbmdTdG9yZSA9IHRoaXMub3B0aW9ucy5pbmNvbWluZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXHJcblxyXG4gIC8vIFNob3VsZCBRb1MgemVybyBtZXNzYWdlcyBiZSBxdWV1ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBicm9rZW4/XHJcbiAgdGhpcy5xdWV1ZVFvU1plcm8gPSB0aGlzLm9wdGlvbnMucXVldWVRb1NaZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogdGhpcy5vcHRpb25zLnF1ZXVlUW9TWmVyb1xyXG5cclxuICAvLyBtYXAgb2Ygc3Vic2NyaWJlZCB0b3BpY3MgdG8gc3VwcG9ydCByZWNvbm5lY3Rpb25cclxuICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcyA9IHt9XHJcblxyXG4gIC8vIG1hcCBvZiBhIHN1YnNjcmliZSBtZXNzYWdlSWQgYW5kIGEgdG9waWNcclxuICB0aGlzLm1lc3NhZ2VJZFRvVG9waWMgPSB7fVxyXG5cclxuICAvLyBQaW5nIHRpbWVyLCBzZXR1cCBpbiBfc2V0dXBQaW5nVGltZXJcclxuICB0aGlzLnBpbmdUaW1lciA9IG51bGxcclxuICAvLyBJcyB0aGUgY2xpZW50IGNvbm5lY3RlZD9cclxuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXHJcbiAgLy8gQXJlIHdlIGRpc2Nvbm5lY3Rpbmc/XHJcbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcclxuICAvLyBQYWNrZXQgcXVldWVcclxuICB0aGlzLnF1ZXVlID0gW11cclxuICAvLyBjb25uYWNrIHRpbWVyXHJcbiAgdGhpcy5jb25uYWNrVGltZXIgPSBudWxsXHJcbiAgLy8gUmVjb25uZWN0IHRpbWVyXHJcbiAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGxcclxuICAvKipcclxuICAgKiBNZXNzYWdlSURzIHN0YXJ0aW5nIHdpdGggMVxyXG4gICAqIGVuc3VyZSB0aGF0IG5leHRJZCBpcyBtaW4uIDEsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXF0dGpzL01RVFQuanMvaXNzdWVzLzgxMFxyXG4gICAqL1xyXG4gIHRoaXMubmV4dElkID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjU1MzUpKVxyXG5cclxuICAvLyBJbmZsaWdodCBjYWxsYmFja3NcclxuICB0aGlzLm91dGdvaW5nID0ge31cclxuXHJcbiAgLy8gTWFyayBjb25uZWN0ZWQgb24gY29ubmVjdFxyXG4gIHRoaXMub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlXHJcbiAgICB2YXIgb3V0U3RvcmUgPSB0aGlzLm91dGdvaW5nU3RvcmUuY3JlYXRlU3RyZWFtKClcclxuXHJcbiAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgcmVtb3ZlKVxyXG4gICAgb3V0U3RvcmUub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCByZW1vdmUpXHJcbiAgICB9KVxyXG4gICAgb3V0U3RvcmUub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcclxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcclxuICAgIH0pXHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcclxuICAgICAgb3V0U3RvcmUuZGVzdHJveSgpXHJcbiAgICAgIG91dFN0b3JlID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3JlRGVsaXZlciAoKSB7XHJcbiAgICAgIC8vIGVkZ2UgY2FzZSwgd2Ugd3JhcHBlZCB0aGlzIHR3aWNlXHJcbiAgICAgIGlmICghb3V0U3RvcmUpIHtcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBhY2tldCA9IG91dFN0b3JlLnJlYWQoMSlcclxuICAgICAgdmFyIGNiXHJcblxyXG4gICAgICBpZiAoIXBhY2tldCkge1xyXG4gICAgICAgIC8vIHJlYWQgd2hlbiBkYXRhIGlzIGF2YWlsYWJsZSBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgb3V0U3RvcmUub25jZSgncmVhZGFibGUnLCBzdG9yZURlbGl2ZXIpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IHN0cmVhbSByZWFkIG9wZXJhdGlvbnMgd2hlbiBkaXNjb25uZWN0ZWRcclxuICAgICAgaWYgKCF0aGF0LmRpc2Nvbm5lY3RpbmcgJiYgIXRoYXQucmVjb25uZWN0VGltZXIpIHtcclxuICAgICAgICBjYiA9IHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF1cclxuICAgICAgICB0aGF0Lm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gZnVuY3Rpb24gKGVyciwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgcGFzc2VkIGluIHRvIHB1Ymxpc2ggZ2V0cyBpbnZva2VkXHJcbiAgICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgY2IoZXJyLCBzdGF0dXMpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RvcmVEZWxpdmVyKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldChwYWNrZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAob3V0U3RvcmUuZGVzdHJveSkge1xyXG4gICAgICAgIG91dFN0b3JlLmRlc3Ryb3koKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RhcnQgZmxvd2luZ1xyXG4gICAgc3RvcmVEZWxpdmVyKClcclxuICB9KVxyXG5cclxuICAvLyBNYXJrIGRpc2Nvbm5lY3RlZCBvbiBzdHJlYW0gY2xvc2VcclxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2VcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcclxuICB9KVxyXG5cclxuICAvLyBTZXR1cCBwaW5nIHRpbWVyXHJcbiAgdGhpcy5vbignY29ubmVjdCcsIHRoaXMuX3NldHVwUGluZ1RpbWVyKVxyXG5cclxuICAvLyBTZW5kIHF1ZXVlZCBwYWNrZXRzXHJcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVcclxuXHJcbiAgICBmdW5jdGlvbiBkZWxpdmVyICgpIHtcclxuICAgICAgdmFyIGVudHJ5ID0gcXVldWUuc2hpZnQoKVxyXG4gICAgICB2YXIgcGFja2V0ID0gbnVsbFxyXG5cclxuICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWNrZXQgPSBlbnRyeS5wYWNrZXRcclxuXHJcbiAgICAgIHRoYXQuX3NlbmRQYWNrZXQoXHJcbiAgICAgICAgcGFja2V0LFxyXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgIGlmIChlbnRyeS5jYikge1xyXG4gICAgICAgICAgICBlbnRyeS5jYihlcnIpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZWxpdmVyKClcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICBkZWxpdmVyKClcclxuICB9KVxyXG5cclxuICB2YXIgZmlyc3RDb25uZWN0aW9uID0gdHJ1ZVxyXG4gIC8vIHJlc3Vic2NyaWJlXHJcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghZmlyc3RDb25uZWN0aW9uICYmXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmNsZWFuICYmXHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MpLmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xyXG4gICAgICAgIHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzLnJlc3Vic2NyaWJlID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzID0ge31cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpcnN0Q29ubmVjdGlvbiA9IGZhbHNlXHJcbiAgfSlcclxuXHJcbiAgLy8gQ2xlYXIgcGluZyB0aW1lclxyXG4gIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoYXQucGluZ1RpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgIHRoYXQucGluZ1RpbWVyLmNsZWFyKClcclxuICAgICAgdGhhdC5waW5nVGltZXIgPSBudWxsXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gU2V0dXAgcmVjb25uZWN0IHRpbWVyIG9uIGRpc2Nvbm5lY3RcclxuICB0aGlzLm9uKCdjbG9zZScsIHRoaXMuX3NldHVwUmVjb25uZWN0KVxyXG5cclxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcclxuXHJcbiAgdGhpcy5fc2V0dXBTdHJlYW0oKVxyXG59XHJcbmluaGVyaXRzKE1xdHRDbGllbnQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXHJcblxyXG4vKipcclxuICogc2V0dXAgdGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoZSBpbm5lciBzdHJlYW0uXHJcbiAqXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwU3RyZWFtID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjb25uZWN0UGFja2V0XHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcbiAgdmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlKClcclxuICB2YXIgcGFyc2VyID0gbXF0dFBhY2tldC5wYXJzZXIodGhpcy5vcHRpb25zKVxyXG4gIHZhciBjb21wbGV0ZVBhcnNlID0gbnVsbFxyXG4gIHZhciBwYWNrZXRzID0gW11cclxuXHJcbiAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxyXG5cclxuICB0aGlzLnN0cmVhbSA9IHRoaXMuc3RyZWFtQnVpbGRlcih0aGlzKVxyXG5cclxuICBwYXJzZXIub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcclxuICAgIHBhY2tldHMucHVzaChwYWNrZXQpXHJcbiAgfSlcclxuXHJcbiAgZnVuY3Rpb24gbmV4dFRpY2tXb3JrICgpIHtcclxuICAgIHByb2Nlc3MubmV4dFRpY2sod29yaylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdvcmsgKCkge1xyXG4gICAgdmFyIHBhY2tldCA9IHBhY2tldHMuc2hpZnQoKVxyXG4gICAgdmFyIGRvbmUgPSBjb21wbGV0ZVBhcnNlXHJcblxyXG4gICAgaWYgKHBhY2tldCkge1xyXG4gICAgICB0aGF0Ll9oYW5kbGVQYWNrZXQocGFja2V0LCBuZXh0VGlja1dvcmspXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb21wbGV0ZVBhcnNlID0gbnVsbFxyXG4gICAgICBkb25lKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyaXRhYmxlLl93cml0ZSA9IGZ1bmN0aW9uIChidWYsIGVuYywgZG9uZSkge1xyXG4gICAgY29tcGxldGVQYXJzZSA9IGRvbmVcclxuICAgIHBhcnNlci5wYXJzZShidWYpXHJcbiAgICB3b3JrKClcclxuICB9XHJcblxyXG4gIHRoaXMuc3RyZWFtLnBpcGUod3JpdGFibGUpXHJcblxyXG4gIC8vIFN1cHByZXNzIGNvbm5lY3Rpb24gZXJyb3JzXHJcbiAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9wKVxyXG5cclxuICAvLyBFY2hvIHN0cmVhbSBjbG9zZVxyXG4gIGVvcyh0aGlzLnN0cmVhbSwgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nsb3NlJykpXHJcblxyXG4gIC8vIFNlbmQgYSBjb25uZWN0IHBhY2tldFxyXG4gIGNvbm5lY3RQYWNrZXQgPSBPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucylcclxuICBjb25uZWN0UGFja2V0LmNtZCA9ICdjb25uZWN0J1xyXG4gIC8vIGF2b2lkIG1lc3NhZ2UgcXVldWVcclxuICBzZW5kUGFja2V0KHRoaXMsIGNvbm5lY3RQYWNrZXQpXHJcblxyXG4gIC8vIEVjaG8gY29ubmVjdGlvbiBlcnJvcnNcclxuICBwYXJzZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpXHJcblxyXG4gIC8vIG1hbnkgZHJhaW4gbGlzdGVuZXJzIGFyZSBuZWVkZWQgZm9yIHFvcyAxIGNhbGxiYWNrcyBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbnRlcm1pdHRlbnRcclxuICB0aGlzLnN0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoMTAwMClcclxuXHJcbiAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxyXG4gIHRoaXMuY29ubmFja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGF0Ll9jbGVhblVwKHRydWUpXHJcbiAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3RUaW1lb3V0KVxyXG59XHJcblxyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xyXG4gIHRoaXMuZW1pdCgncGFja2V0cmVjZWl2ZScsIHBhY2tldClcclxuXHJcbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XHJcbiAgICBjYXNlICdwdWJsaXNoJzpcclxuICAgICAgdGhpcy5faGFuZGxlUHVibGlzaChwYWNrZXQsIGRvbmUpXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdwdWJhY2snOlxyXG4gICAgY2FzZSAncHVicmVjJzpcclxuICAgIGNhc2UgJ3B1YmNvbXAnOlxyXG4gICAgY2FzZSAnc3ViYWNrJzpcclxuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcclxuICAgICAgdGhpcy5faGFuZGxlQWNrKHBhY2tldClcclxuICAgICAgZG9uZSgpXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdwdWJyZWwnOlxyXG4gICAgICB0aGlzLl9oYW5kbGVQdWJyZWwocGFja2V0LCBkb25lKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnY29ubmFjayc6XHJcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5hY2socGFja2V0KVxyXG4gICAgICBkb25lKClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ3BpbmdyZXNwJzpcclxuICAgICAgdGhpcy5faGFuZGxlUGluZ3Jlc3AocGFja2V0KVxyXG4gICAgICBkb25lKClcclxuICAgICAgYnJlYWtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIGRvIGFuIGVycm9yIGhhbmRsaW5nXHJcbiAgICAgIC8vIG9yIGp1c3QgbG9nIGl0XHJcbiAgICAgIGJyZWFrXHJcbiAgfVxyXG59XHJcblxyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2hlY2tEaXNjb25uZWN0aW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignY2xpZW50IGRpc2Nvbm5lY3RpbmcnKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudCBkaXNjb25uZWN0aW5nJykpXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLmRpc2Nvbm5lY3RpbmdcclxufVxyXG5cclxuLyoqXHJcbiAqIHB1Ymxpc2ggLSBwdWJsaXNoIDxtZXNzYWdlPiB0byA8dG9waWM+XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIHRvcGljIHRvIHB1Ymxpc2ggdG9cclxuICogQHBhcmFtIHtTdHJpbmcsIEJ1ZmZlcn0gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gcHVibGlzaFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gcHVibGlzaCBvcHRpb25zLCBpbmNsdWRlczpcclxuICogICAge051bWJlcn0gcW9zIC0gcW9zIGxldmVsIHRvIHB1Ymxpc2ggb25cclxuICogICAge0Jvb2xlYW59IHJldGFpbiAtIHdoZXRoZXIgb3Igbm90IHRvIHJldGFpbiB0aGUgbWVzc2FnZVxyXG4gKiAgICB7Qm9vbGVhbn0gZHVwIC0gd2hldGhlciBvciBub3QgbWFyayBhIG1lc3NhZ2UgYXMgZHVwbGljYXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIpe31cclxuICogICAgY2FsbGVkIHdoZW4gcHVibGlzaCBzdWNjZWVkcyBvciBmYWlsc1xyXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKlxyXG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScpO1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnLCB7cW9zOiAxLCByZXRhaW46IHRydWUsIGR1cDogdHJ1ZX0pO1xyXG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScsIGNvbnNvbGUubG9nKTtcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWMsIG1lc3NhZ2UsIG9wdHMsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIHBhY2tldFxyXG5cclxuICAvLyAucHVibGlzaCh0b3BpYywgcGF5bG9hZCwgY2IpO1xyXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY2FsbGJhY2sgPSBvcHRzXHJcbiAgICBvcHRzID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgLy8gZGVmYXVsdCBvcHRzXHJcbiAgdmFyIGRlZmF1bHRPcHRzID0ge3FvczogMCwgcmV0YWluOiBmYWxzZSwgZHVwOiBmYWxzZX1cclxuICBvcHRzID0geHRlbmQoZGVmYXVsdE9wdHMsIG9wdHMpXHJcblxyXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcGFja2V0ID0ge1xyXG4gICAgY21kOiAncHVibGlzaCcsXHJcbiAgICB0b3BpYzogdG9waWMsXHJcbiAgICBwYXlsb2FkOiBtZXNzYWdlLFxyXG4gICAgcW9zOiBvcHRzLnFvcyxcclxuICAgIHJldGFpbjogb3B0cy5yZXRhaW4sXHJcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpLFxyXG4gICAgZHVwOiBvcHRzLmR1cFxyXG4gIH1cclxuXHJcbiAgc3dpdGNoIChvcHRzLnFvcykge1xyXG4gICAgY2FzZSAxOlxyXG4gICAgY2FzZSAyOlxyXG5cclxuICAgICAgLy8gQWRkIHRvIGNhbGxiYWNrc1xyXG4gICAgICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gY2FsbGJhY2sgfHwgbm9wXHJcbiAgICAgIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxyXG4gICAgICBicmVha1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKVxyXG4gICAgICBicmVha1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLyoqXHJcbiAqIHN1YnNjcmliZSAtIHN1YnNjcmliZSB0byA8dG9waWM+XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheSwgT2JqZWN0fSB0b3BpYyAtIHRvcGljKHMpIHRvIHN1YnNjcmliZSB0bywgc3VwcG9ydHMgb2JqZWN0cyBpbiB0aGUgZm9ybSB7J3RvcGljJzogcW9zfVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9uYWwgc3Vic2NyaXB0aW9uIG9wdGlvbnMsIGluY2x1ZGVzOlxyXG4gKiAgICB7TnVtYmVyfSBxb3MgLSBzdWJzY3JpYmUgcW9zIGxldmVsXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIsIGdyYW50ZWQpe30gd2hlcmU6XHJcbiAqICAgIHtFcnJvcn0gZXJyIC0gc3Vic2NyaXB0aW9uIGVycm9yIChub25lIGF0IHRoZSBtb21lbnQhKVxyXG4gKiAgICB7QXJyYXl9IGdyYW50ZWQgLSBhcnJheSBvZiB7dG9waWM6ICd0JywgcW9zOiAwfVxyXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycpO1xyXG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIHtxb3M6IDF9KTtcclxuICogQGV4YW1wbGUgY2xpZW50LnN1YnNjcmliZSh7J3RvcGljJzogMCwgJ3RvcGljMic6IDF9LCBjb25zb2xlLmxvZyk7XHJcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoJ3RvcGljJywgY29uc29sZS5sb2cpO1xyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwYWNrZXRcclxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICB2YXIgc3VicyA9IFtdXHJcbiAgdmFyIG9iaiA9IGFyZ3Muc2hpZnQoKVxyXG4gIHZhciByZXN1YnNjcmliZSA9IG9iai5yZXN1YnNjcmliZVxyXG4gIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCkgfHwgbm9wXHJcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXHJcbiAgdmFyIGludmFsaWRUb3BpY1xyXG4gIHZhciB0aGF0ID0gdGhpc1xyXG5cclxuICBkZWxldGUgb2JqLnJlc3Vic2NyaWJlXHJcblxyXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgb2JqID0gW29ial1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIG9wdHMgPSBjYWxsYmFja1xyXG4gICAgY2FsbGJhY2sgPSBub3BcclxuICB9XHJcblxyXG4gIGludmFsaWRUb3BpYyA9IHZhbGlkYXRpb25zLnZhbGlkYXRlVG9waWNzKG9iailcclxuICBpZiAoaW52YWxpZFRvcGljICE9PSBudWxsKSB7XHJcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIG5ldyBFcnJvcignSW52YWxpZCB0b3BpYyAnICsgaW52YWxpZFRvcGljKSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGNhbGxiYWNrKSkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHZhciBkZWZhdWx0T3B0cyA9IHsgcW9zOiAwIH1cclxuICBvcHRzID0geHRlbmQoZGVmYXVsdE9wdHMsIG9wdHMpXHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xyXG4gICAgICBpZiAodGhhdC5fcmVzdWJzY3JpYmVUb3BpY3NbdG9waWNdIDwgb3B0cy5xb3MgfHxcclxuICAgICAgICAgICF0aGF0Ll9yZXN1YnNjcmliZVRvcGljcy5oYXNPd25Qcm9wZXJ0eSh0b3BpYykgfHxcclxuICAgICAgICAgIHJlc3Vic2NyaWJlKSB7XHJcbiAgICAgICAgc3Vicy5wdXNoKHtcclxuICAgICAgICAgIHRvcGljOiB0b3BpYyxcclxuICAgICAgICAgIHFvczogb3B0cy5xb3NcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH0gZWxzZSB7XHJcbiAgICBPYmplY3RcclxuICAgICAgLmtleXMob2JqKVxyXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaykge1xyXG4gICAgICAgIGlmICh0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1trXSA8IG9ialtrXSB8fFxyXG4gICAgICAgICAgICAhdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3MuaGFzT3duUHJvcGVydHkoaykgfHxcclxuICAgICAgICAgICAgcmVzdWJzY3JpYmUpIHtcclxuICAgICAgICAgIHN1YnMucHVzaCh7XHJcbiAgICAgICAgICAgIHRvcGljOiBrLFxyXG4gICAgICAgICAgICBxb3M6IG9ialtrXVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgfVxyXG5cclxuICBwYWNrZXQgPSB7XHJcbiAgICBjbWQ6ICdzdWJzY3JpYmUnLFxyXG4gICAgc3Vic2NyaXB0aW9uczogc3VicyxcclxuICAgIHFvczogMSxcclxuICAgIHJldGFpbjogZmFsc2UsXHJcbiAgICBkdXA6IGZhbHNlLFxyXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxyXG4gIH1cclxuXHJcbiAgaWYgKCFzdWJzLmxlbmd0aCkge1xyXG4gICAgY2FsbGJhY2sobnVsbCwgW10pXHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIC8vIHN1YnNjcmlwdGlvbnMgdG8gcmVzdWJzY3JpYmUgdG8gaW4gY2FzZSBvZiBkaXNjb25uZWN0XHJcbiAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xyXG4gICAgdmFyIHRvcGljcyA9IFtdXHJcbiAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICBpZiAodGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCA+IDApIHtcclxuICAgICAgICB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1tzdWIudG9waWNdID0gc3ViLnFvc1xyXG4gICAgICAgIHRvcGljcy5wdXNoKHN1Yi50b3BpYylcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHRoYXQubWVzc2FnZUlkVG9Ub3BpY1twYWNrZXQubWVzc2FnZUlkXSA9IHRvcGljc1xyXG4gIH1cclxuXHJcbiAgdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IGZ1bmN0aW9uIChlcnIsIHBhY2tldCkge1xyXG4gICAgaWYgKCFlcnIpIHtcclxuICAgICAgdmFyIGdyYW50ZWQgPSBwYWNrZXQuZ3JhbnRlZFxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYW50ZWQubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBzdWJzW2ldLnFvcyA9IGdyYW50ZWRbaV1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrKGVyciwgc3VicylcclxuICB9XHJcblxyXG4gIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogdW5zdWJzY3JpYmUgLSB1bnN1YnNjcmliZSBmcm9tIHRvcGljKHMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheX0gdG9waWMgLSB0b3BpY3MgdG8gdW5zdWJzY3JpYmUgZnJvbVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGJhY2sgZmlyZWQgb24gdW5zdWJhY2tcclxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcclxuICogQGFwaSBwdWJsaWNcclxuICogQGV4YW1wbGUgY2xpZW50LnVuc3Vic2NyaWJlKCd0b3BpYycpO1xyXG4gKiBAZXhhbXBsZSBjbGllbnQudW5zdWJzY3JpYmUoJ3RvcGljJywgY29uc29sZS5sb2cpO1xyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodG9waWMsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIHBhY2tldCA9IHtcclxuICAgIGNtZDogJ3Vuc3Vic2NyaWJlJyxcclxuICAgIHFvczogMSxcclxuICAgIG1lc3NhZ2VJZDogdGhpcy5fbmV4dElkKClcclxuICB9XHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcblxyXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9wXHJcblxyXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSBbdG9waWNdXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9waWMgPT09ICdvYmplY3QnICYmIHRvcGljLmxlbmd0aCkge1xyXG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IHRvcGljXHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XHJcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY11cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gY2FsbGJhY2tcclxuXHJcbiAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQpXHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBlbmQgLSBjbG9zZSBjb25uZWN0aW9uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgLSBkbyBub3Qgd2FpdCBmb3IgYWxsIGluLWZsaWdodCBtZXNzYWdlcyB0byBiZSBhY2tlZFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxlZCB3aGVuIHRoZSBjbGllbnQgaGFzIGJlZW4gY2xvc2VkXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZm9yY2UsIGNiKSB7XHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcblxyXG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNiID0gZm9yY2VcclxuICAgIGZvcmNlID0gZmFsc2VcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsb3NlU3RvcmVzICgpIHtcclxuICAgIHRoYXQuZGlzY29ubmVjdGVkID0gdHJ1ZVxyXG4gICAgdGhhdC5pbmNvbWluZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhhdC5vdXRnb2luZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5lbWl0KCdlbmQnKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICAgIGlmICh0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCkge1xyXG4gICAgICB0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5pc2ggKCkge1xyXG4gICAgLy8gZGVmZXIgY2xvc2VzU3RvcmVzIG9mIGFuIEkvTyBjeWNsZSxcclxuICAgIC8vIGp1c3QgdG8gbWFrZSBzdXJlIHRoaW5ncyBhcmVcclxuICAgIC8vIG9rIGZvciB3ZWJzb2NrZXRzXHJcbiAgICB0aGF0Ll9jbGVhblVwKGZvcmNlLCBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBjbG9zZVN0b3JlcykpXHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxyXG5cclxuICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSB0cnVlXHJcblxyXG4gIGlmICghZm9yY2UgJiYgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID4gMCkge1xyXG4gICAgLy8gd2FpdCAxMG1zLCBqdXN0IHRvIGJlIHN1cmUgd2UgcmVjZWl2ZWQgYWxsIG9mIGl0XHJcbiAgICB0aGlzLm9uY2UoJ291dGdvaW5nRW1wdHknLCBzZXRUaW1lb3V0LmJpbmQobnVsbCwgZmluaXNoLCAxMCkpXHJcbiAgfSBlbHNlIHtcclxuICAgIGZpbmlzaCgpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogcmVtb3ZlT3V0Z29pbmdNZXNzYWdlIC0gcmVtb3ZlIGEgbWVzc2FnZSBpbiBvdXRnb2luZyBzdG9yZVxyXG4gKiB0aGUgb3V0Z29pbmcgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aGUgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpIGlmIHRoZSBtZXNzYWdlIGlzIHJlbW92ZWRcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pZCAtIG1lc3NhZ2VJZCB0byByZW1vdmUgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKlxyXG4gKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlT3V0Z29pbmdNZXNzYWdlKGNsaWVudC5nZXRMYXN0TWVzc2FnZUlkKCkpO1xyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUucmVtb3ZlT3V0Z29pbmdNZXNzYWdlID0gZnVuY3Rpb24gKG1pZCkge1xyXG4gIHZhciBjYiA9IHRoaXMub3V0Z29pbmdbbWlkXVxyXG4gIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cclxuICB0aGlzLm91dGdvaW5nU3RvcmUuZGVsKHttZXNzYWdlSWQ6IG1pZH0sIGZ1bmN0aW9uICgpIHtcclxuICAgIGNiKG5ldyBFcnJvcignTWVzc2FnZSByZW1vdmVkJykpXHJcbiAgfSlcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogcmVjb25uZWN0IC0gY29ubmVjdCBhZ2FpbiB1c2luZyB0aGUgc2FtZSBvcHRpb25zIGFzIGNvbm5lY3QoKVxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9uYWwgcmVjb25uZWN0IG9wdGlvbnMsIGluY2x1ZGVzOlxyXG4gKiAgICB7U3RvcmV9IGluY29taW5nU3RvcmUgLSBhIHN0b3JlIGZvciB0aGUgaW5jb21pbmcgcGFja2V0c1xyXG4gKiAgICB7U3RvcmV9IG91dGdvaW5nU3RvcmUgLSBhIHN0b3JlIGZvciB0aGUgb3V0Z29pbmcgcGFja2V0c1xyXG4gKiAgICBpZiBvcHRzIGlzIG5vdCBnaXZlbiwgY3VycmVudCBzdG9yZXMgYXJlIHVzZWRcclxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAob3B0cykge1xyXG4gICAgICB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSA9IG9wdHMuaW5jb21pbmdTdG9yZVxyXG4gICAgICB0aGF0Lm9wdGlvbnMub3V0Z29pbmdTdG9yZSA9IG9wdHMub3V0Z29pbmdTdG9yZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgPSBudWxsXHJcbiAgICAgIHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlID0gbnVsbFxyXG4gICAgfVxyXG4gICAgdGhhdC5pbmNvbWluZ1N0b3JlID0gdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcclxuICAgIHRoYXQub3V0Z29pbmdTdG9yZSA9IHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXHJcbiAgICB0aGF0LmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxyXG4gICAgdGhhdC5kaXNjb25uZWN0ZWQgPSBmYWxzZVxyXG4gICAgdGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QgPSBudWxsXHJcbiAgICB0aGF0Ll9yZWNvbm5lY3QoKVxyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZyAmJiAhdGhpcy5kaXNjb25uZWN0ZWQpIHtcclxuICAgIHRoaXMuX2RlZmVycmVkUmVjb25uZWN0ID0gZlxyXG4gIH0gZWxzZSB7XHJcbiAgICBmKClcclxuICB9XHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLyoqXHJcbiAqIF9yZWNvbm5lY3QgLSBpbXBsZW1lbnQgcmVjb25uZWN0aW9uXHJcbiAqIEBhcGkgcHJpdmF0ZWlzaFxyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUuX3JlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmVtaXQoJ3JlY29ubmVjdCcpXHJcbiAgdGhpcy5fc2V0dXBTdHJlYW0oKVxyXG59XHJcblxyXG4vKipcclxuICogX3NldHVwUmVjb25uZWN0IC0gc2V0dXAgcmVjb25uZWN0IHRpbWVyXHJcbiAqL1xyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2V0dXBSZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcblxyXG4gIGlmICghdGhhdC5kaXNjb25uZWN0aW5nICYmICF0aGF0LnJlY29ubmVjdFRpbWVyICYmICh0aGF0Lm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID4gMCkpIHtcclxuICAgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcpIHtcclxuICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJylcclxuICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlXHJcbiAgICB9XHJcbiAgICB0aGF0LnJlY29ubmVjdFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGF0Ll9yZWNvbm5lY3QoKVxyXG4gICAgfSwgdGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBfY2xlYXJSZWNvbm5lY3QgLSBjbGVhciB0aGUgcmVjb25uZWN0IHRpbWVyXHJcbiAqL1xyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2xlYXJSZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RUaW1lcilcclxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogX2NsZWFuVXAgLSBjbGVhbiB1cCBvbiBjb25uZWN0aW9uIGVuZFxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9jbGVhblVwID0gZnVuY3Rpb24gKGZvcmNlZCwgZG9uZSkge1xyXG4gIGlmIChkb25lKSB7XHJcbiAgICB0aGlzLnN0cmVhbS5vbignY2xvc2UnLCBkb25lKVxyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlZCkge1xyXG4gICAgaWYgKCh0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2xlYW4pIHtcclxuICAgICAgZmx1c2godGhpcy5vdXRnb2luZylcclxuICAgIH1cclxuICAgIHRoaXMuc3RyZWFtLmRlc3Ryb3koKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9zZW5kUGFja2V0KFxyXG4gICAgICB7IGNtZDogJ2Rpc2Nvbm5lY3QnIH0sXHJcbiAgICAgIHNldEltbWVkaWF0ZS5iaW5kKFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgdGhpcy5zdHJlYW0uZW5kLmJpbmQodGhpcy5zdHJlYW0pXHJcbiAgICAgIClcclxuICAgIClcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy5kaXNjb25uZWN0aW5nKSB7XHJcbiAgICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXHJcbiAgICB0aGlzLl9zZXR1cFJlY29ubmVjdCgpXHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5waW5nVGltZXIgIT09IG51bGwpIHtcclxuICAgIHRoaXMucGluZ1RpbWVyLmNsZWFyKClcclxuICAgIHRoaXMucGluZ1RpbWVyID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgaWYgKGRvbmUgJiYgIXRoaXMuY29ubmVjdGVkKSB7XHJcbiAgICB0aGlzLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBkb25lKVxyXG4gICAgZG9uZSgpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogX3NlbmRQYWNrZXQgLSBzZW5kIG9yIHF1ZXVlIGEgcGFja2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGUgKHNlZSBgcHJvdG9jb2xgKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9wdGlvbnNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayB3aGVuIHRoZSBwYWNrZXQgaXMgc2VudFxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2IpIHtcclxuICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XHJcbiAgICBpZiAoKChwYWNrZXQucW9zIHx8IDApID09PSAwICYmIHRoaXMucXVldWVRb1NaZXJvKSB8fCBwYWNrZXQuY21kICE9PSAncHVibGlzaCcpIHtcclxuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgcGFja2V0OiBwYWNrZXQsIGNiOiBjYiB9KVxyXG4gICAgfSBlbHNlIGlmIChwYWNrZXQucW9zID4gMCkge1xyXG4gICAgICBjYiA9IHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF1cclxuICAgICAgdGhpcy5vdXRnb2luZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoZXJyKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH0gZWxzZSBpZiAoY2IpIHtcclxuICAgICAgY2IobmV3IEVycm9yKCdObyBjb25uZWN0aW9uIHRvIGJyb2tlcicpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gV2hlbiBzZW5kaW5nIGEgcGFja2V0LCByZXNjaGVkdWxlIHRoZSBwaW5nIHRpbWVyXHJcbiAgdGhpcy5fc2hpZnRQaW5nSW50ZXJ2YWwoKVxyXG5cclxuICBzd2l0Y2ggKHBhY2tldC5jbWQpIHtcclxuICAgIGNhc2UgJ3B1Ymxpc2gnOlxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAncHVicmVsJzpcclxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IpXHJcbiAgICAgIHJldHVyblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBwYWNrZXQsIGNiKVxyXG4gICAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIHN3aXRjaCAocGFja2V0LnFvcykge1xyXG4gICAgY2FzZSAyOlxyXG4gICAgY2FzZSAxOlxyXG4gICAgICBzdG9yZUFuZFNlbmQodGhpcywgcGFja2V0LCBjYilcclxuICAgICAgYnJlYWtcclxuICAgIC8qKlxyXG4gICAgICogbm8gbmVlZCBvZiBjYXNlIGhlcmUgc2luY2UgaXQgd2lsbCBiZSBjYXVnaHQgYnkgZGVmYXVsdFxyXG4gICAgICogYW5kIGpzaGludCBjb21wbHkgdGhhdCBiZWZvcmUgZGVmYXVsdCBpdCBtdXN0IGJlIGEgYnJlYWtcclxuICAgICAqIGFueXdheSBpdCB3aWxsIHJlc3VsdCBpbiAtMSBldmFsdWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGNhc2UgMDpcclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBwYWNrZXQsIGNiKVxyXG4gICAgICBicmVha1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIF9zZXR1cFBpbmdUaW1lciAtIHNldHVwIHRoZSBwaW5nIHRpbWVyXHJcbiAqXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwUGluZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB0aGF0ID0gdGhpc1xyXG5cclxuICBpZiAoIXRoaXMucGluZ1RpbWVyICYmIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUpIHtcclxuICAgIHRoaXMucGluZ1Jlc3AgPSB0cnVlXHJcbiAgICB0aGlzLnBpbmdUaW1lciA9IHJlSW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGF0Ll9jaGVja1BpbmcoKVxyXG4gICAgfSwgdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSAqIDEwMDApXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogX3NoaWZ0UGluZ0ludGVydmFsIC0gcmVzY2hlZHVsZSB0aGUgcGluZyBpbnRlcnZhbFxyXG4gKlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9zaGlmdFBpbmdJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy5waW5nVGltZXIgJiYgdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSAmJiB0aGlzLm9wdGlvbnMucmVzY2hlZHVsZVBpbmdzKSB7XHJcbiAgICB0aGlzLnBpbmdUaW1lci5yZXNjaGVkdWxlKHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxyXG4gIH1cclxufVxyXG4vKipcclxuICogX2NoZWNrUGluZyAtIGNoZWNrIGlmIGEgcGluZ3Jlc3AgaGFzIGNvbWUgYmFjaywgYW5kIHBpbmcgdGhlIHNlcnZlciBhZ2FpblxyXG4gKlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9jaGVja1BpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMucGluZ1Jlc3ApIHtcclxuICAgIHRoaXMucGluZ1Jlc3AgPSBmYWxzZVxyXG4gICAgdGhpcy5fc2VuZFBhY2tldCh7IGNtZDogJ3BpbmdyZXEnIH0pXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGRvIGEgZm9yY2VkIGNsZWFudXAgc2luY2Ugc29ja2V0IHdpbGwgYmUgaW4gYmFkIHNoYXBlXHJcbiAgICB0aGlzLl9jbGVhblVwKHRydWUpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogX2hhbmRsZVBpbmdyZXNwIC0gaGFuZGxlIGEgcGluZ3Jlc3BcclxuICpcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGluZ3Jlc3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5waW5nUmVzcCA9IHRydWVcclxufVxyXG5cclxuLyoqXHJcbiAqIF9oYW5kbGVDb25uYWNrXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZUNvbm5hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XHJcbiAgdmFyIHJjID0gcGFja2V0LnJldHVybkNvZGVcclxuICB2YXIgZXJyb3JzID0gW1xyXG4gICAgJycsXHJcbiAgICAnVW5hY2NlcHRhYmxlIHByb3RvY29sIHZlcnNpb24nLFxyXG4gICAgJ0lkZW50aWZpZXIgcmVqZWN0ZWQnLFxyXG4gICAgJ1NlcnZlciB1bmF2YWlsYWJsZScsXHJcbiAgICAnQmFkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJyxcclxuICAgICdOb3QgYXV0aG9yaXplZCdcclxuICBdXHJcblxyXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcclxuXHJcbiAgaWYgKHJjID09PSAwKSB7XHJcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlXHJcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBwYWNrZXQpXHJcbiAgfSBlbHNlIGlmIChyYyA+IDApIHtcclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gcmVmdXNlZDogJyArIGVycm9yc1tyY10pXHJcbiAgICBlcnIuY29kZSA9IHJjXHJcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIF9oYW5kbGVQdWJsaXNoXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG4vKlxyXG50aG9zZSBsYXRlIDIgY2FzZSBzaG91bGQgYmUgcmV3cml0ZSB0byBjb21wbHkgd2l0aCBjb2Rpbmcgc3R5bGU6XHJcblxyXG5jYXNlIDE6XHJcbmNhc2UgMDpcclxuICAvLyBkbyBub3Qgd2FpdCBzZW5kaW5nIGEgcHViYWNrXHJcbiAgLy8gbm8gY2FsbGJhY2sgcGFzc2VkXHJcbiAgaWYgKDEgPT09IHFvcykge1xyXG4gICAgdGhpcy5fc2VuZFBhY2tldCh7XHJcbiAgICAgIGNtZDogJ3B1YmFjaycsXHJcbiAgICAgIG1lc3NhZ2VJZDogbWlkXHJcbiAgICB9KTtcclxuICB9XHJcbiAgLy8gZW1pdCB0aGUgbWVzc2FnZSBldmVudCBmb3IgYm90aCBxb3MgMSBhbmQgMFxyXG4gIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpO1xyXG4gIHRoaXMuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGRvbmUpO1xyXG4gIGJyZWFrO1xyXG5kZWZhdWx0OlxyXG4gIC8vIGRvIG5vdGhpbmcgYnV0IGV2ZXJ5IHN3aXRjaCBtdXMgaGF2ZSBhIGRlZmF1bHRcclxuICAvLyBsb2cgb3IgdGhyb3cgYW4gZXJyb3IgYWJvdXQgdW5rbm93biBxb3NcclxuICBicmVhaztcclxuXHJcbmZvciBub3cgaSBqdXN0IHN1cHByZXNzZWQgdGhlIHdhcm5pbmdzXHJcbiovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQdWJsaXNoID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xyXG4gIGRvbmUgPSB0eXBlb2YgZG9uZSAhPT0gJ3VuZGVmaW5lZCcgPyBkb25lIDogbm9wXHJcbiAgdmFyIHRvcGljID0gcGFja2V0LnRvcGljLnRvU3RyaW5nKClcclxuICB2YXIgbWVzc2FnZSA9IHBhY2tldC5wYXlsb2FkXHJcbiAgdmFyIHFvcyA9IHBhY2tldC5xb3NcclxuICB2YXIgbWlkID0gcGFja2V0Lm1lc3NhZ2VJZFxyXG4gIHZhciB0aGF0ID0gdGhpc1xyXG5cclxuICBzd2l0Y2ggKHFvcykge1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICB0aGlzLmluY29taW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgIHJldHVybiBkb25lKGVycilcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldCh7Y21kOiAncHVicmVjJywgbWVzc2FnZUlkOiBtaWR9LCBkb25lKVxyXG4gICAgICB9KVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XHJcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpXHJcbiAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlbmQgJ3B1YmFjaycgaWYgdGhlIGFib3ZlICdoYW5kbGVNZXNzYWdlJyBtZXRob2QgZXhlY3V0ZWRcclxuICAgICAgICAvLyBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldCh7Y21kOiAncHViYWNrJywgbWVzc2FnZUlkOiBtaWR9LCBkb25lKVxyXG4gICAgICB9KVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XHJcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpXHJcbiAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGRvbmUpXHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xyXG4gICAgICBicmVha1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBtZXNzYWdlcyB3aXRoIGJhY2twcmVzc3VyZSBzdXBwb3J0LCBvbmUgYXQgYSB0aW1lLlxyXG4gKiBPdmVycmlkZSBhdCB3aWxsLlxyXG4gKlxyXG4gKiBAcGFyYW0gUGFja2V0IHBhY2tldCB0aGUgcGFja2V0XHJcbiAqIEBwYXJhbSBGdW5jdGlvbiBjYWxsYmFjayBjYWxsIHdoZW4gZmluaXNoZWRcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAocGFja2V0LCBjYWxsYmFjaykge1xyXG4gIGNhbGxiYWNrKClcclxufVxyXG5cclxuLyoqXHJcbiAqIF9oYW5kbGVBY2tcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xyXG4gIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xyXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXHJcbiAgdmFyIHR5cGUgPSBwYWNrZXQuY21kXHJcbiAgdmFyIHJlc3BvbnNlID0gbnVsbFxyXG4gIHZhciBjYiA9IHRoaXMub3V0Z29pbmdbbWlkXVxyXG4gIHZhciB0aGF0ID0gdGhpc1xyXG5cclxuICBpZiAoIWNiKSB7XHJcbiAgICAvLyBTZXJ2ZXIgc2VudCBhbiBhY2sgaW4gZXJyb3IsIGlnbm9yZSBpdC5cclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgLy8gUHJvY2Vzc1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSAncHViY29tcCc6XHJcbiAgICAgIC8vIHNhbWUgdGhpbmcgYXMgcHViYWNrIGZvciBRb1MgMlxyXG4gICAgY2FzZSAncHViYWNrJzpcclxuICAgICAgLy8gQ2FsbGJhY2sgLSB3ZSdyZSBkb25lXHJcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cclxuICAgICAgdGhpcy5vdXRnb2luZ1N0b3JlLmRlbChwYWNrZXQsIGNiKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAncHVicmVjJzpcclxuICAgICAgcmVzcG9uc2UgPSB7XHJcbiAgICAgICAgY21kOiAncHVicmVsJyxcclxuICAgICAgICBxb3M6IDIsXHJcbiAgICAgICAgbWVzc2FnZUlkOiBtaWRcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fc2VuZFBhY2tldChyZXNwb25zZSlcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ3N1YmFjayc6XHJcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cclxuICAgICAgaWYgKHBhY2tldC5ncmFudGVkLmxlbmd0aCA9PT0gMSAmJiAocGFja2V0LmdyYW50ZWRbMF0gJiAweDgwKSAhPT0gMCkge1xyXG4gICAgICAgIC8vIHN1YmFjayB3aXRoIEZhaWx1cmUgc3RhdHVzXHJcbiAgICAgICAgdmFyIHRvcGljcyA9IHRoaXMubWVzc2FnZUlkVG9Ub3BpY1ttaWRdXHJcbiAgICAgICAgaWYgKHRvcGljcykge1xyXG4gICAgICAgICAgdG9waWNzLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY11cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNiKG51bGwsIHBhY2tldClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcclxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxyXG4gICAgICBjYihudWxsKVxyXG4gICAgICBicmVha1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHBhY2tldCB0eXBlJykpXHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nICYmXHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3V0Z29pbmcpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgdGhpcy5lbWl0KCdvdXRnb2luZ0VtcHR5JylcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBfaGFuZGxlUHVicmVsXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUHVicmVsID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcclxuICBjYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IG5vcFxyXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXHJcbiAgdmFyIHRoYXQgPSB0aGlzXHJcblxyXG4gIHZhciBjb21wID0ge2NtZDogJ3B1YmNvbXAnLCBtZXNzYWdlSWQ6IG1pZH1cclxuXHJcbiAgdGhhdC5pbmNvbWluZ1N0b3JlLmdldChwYWNrZXQsIGZ1bmN0aW9uIChlcnIsIHB1Yikge1xyXG4gICAgaWYgKCFlcnIgJiYgcHViLmNtZCAhPT0gJ3B1YnJlbCcpIHtcclxuICAgICAgdGhhdC5lbWl0KCdtZXNzYWdlJywgcHViLnRvcGljLCBwdWIucGF5bG9hZCwgcHViKVxyXG4gICAgICB0aGF0LmluY29taW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQuaGFuZGxlTWVzc2FnZShwdWIsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIF9uZXh0SWRcclxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLl9uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gaWQgYmVjb21lcyBjdXJyZW50IHN0YXRlIG9mIHRoaXMubmV4dElkIGFuZCBpbmNyZW1lbnRzIGFmdGVyd2FyZHNcclxuICB2YXIgaWQgPSB0aGlzLm5leHRJZCsrXHJcbiAgLy8gRW5zdXJlIDE2IGJpdCB1bnNpZ25lZCBpbnQgKG1heCA2NTUzNSwgbmV4dElkIGdvdCBvbmUgaGlnaGVyKVxyXG4gIGlmICh0aGlzLm5leHRJZCA9PT0gNjU1MzYpIHtcclxuICAgIHRoaXMubmV4dElkID0gMVxyXG4gIH1cclxuICByZXR1cm4gaWRcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldExhc3RNZXNzYWdlSWRcclxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcclxuICovXHJcbk1xdHRDbGllbnQucHJvdG90eXBlLmdldExhc3RNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICh0aGlzLm5leHRJZCA9PT0gMSkgPyA2NTUzNSA6ICh0aGlzLm5leHRJZCAtIDEpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXF0dENsaWVudFxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbnZhciBNcXR0Q2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50JylcclxudmFyIFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmUnKVxyXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcclxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxyXG52YXIgcHJvdG9jb2xzID0ge31cclxuXHJcbmlmIChwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3NlcicpIHtcclxuICBwcm90b2NvbHMubXF0dCA9IHJlcXVpcmUoJy4vdGNwJylcclxuICBwcm90b2NvbHMudGNwID0gcmVxdWlyZSgnLi90Y3AnKVxyXG4gIHByb3RvY29scy5zc2wgPSByZXF1aXJlKCcuL3RscycpXHJcbiAgcHJvdG9jb2xzLnRscyA9IHJlcXVpcmUoJy4vdGxzJylcclxuICBwcm90b2NvbHMubXF0dHMgPSByZXF1aXJlKCcuL3RscycpXHJcbn0gZWxzZSB7XHJcbiAgcHJvdG9jb2xzLnd4ID0gcmVxdWlyZSgnLi93eCcpXHJcbiAgcHJvdG9jb2xzLnd4cyA9IHJlcXVpcmUoJy4vd3gnKVxyXG59XHJcblxyXG5wcm90b2NvbHMud3MgPSByZXF1aXJlKCcuL3dzJylcclxucHJvdG9jb2xzLndzcyA9IHJlcXVpcmUoJy4vd3MnKVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBhdXRoIGF0dHJpYnV0ZSBhbmQgbWVyZ2UgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGluIHRoZSBvcHRpb25zIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb24gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUF1dGhPcHRpb25zIChvcHRzKSB7XHJcbiAgdmFyIG1hdGNoZXNcclxuICBpZiAob3B0cy5hdXRoKSB7XHJcbiAgICBtYXRjaGVzID0gb3B0cy5hdXRoLm1hdGNoKC9eKC4rKTooLispJC8pXHJcbiAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICBvcHRzLnVzZXJuYW1lID0gbWF0Y2hlc1sxXVxyXG4gICAgICBvcHRzLnBhc3N3b3JkID0gbWF0Y2hlc1syXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0cy51c2VybmFtZSA9IG9wdHMuYXV0aFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGNvbm5lY3QgLSBjb25uZWN0IHRvIGFuIE1RVFQgYnJva2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Jyb2tlclVybF0gLSB1cmwgb2YgdGhlIGJyb2tlciwgb3B0aW9uYWxcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBzZWUgTXF0dENsaWVudCNjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gY29ubmVjdCAoYnJva2VyVXJsLCBvcHRzKSB7XHJcbiAgaWYgKCh0eXBlb2YgYnJva2VyVXJsID09PSAnb2JqZWN0JykgJiYgIW9wdHMpIHtcclxuICAgIG9wdHMgPSBicm9rZXJVcmxcclxuICAgIGJyb2tlclVybCA9IG51bGxcclxuICB9XHJcblxyXG4gIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gIGlmIChicm9rZXJVcmwpIHtcclxuICAgIHZhciBwYXJzZWQgPSB1cmwucGFyc2UoYnJva2VyVXJsLCB0cnVlKVxyXG4gICAgaWYgKHBhcnNlZC5wb3J0ICE9IG51bGwpIHtcclxuICAgICAgcGFyc2VkLnBvcnQgPSBOdW1iZXIocGFyc2VkLnBvcnQpXHJcbiAgICB9XHJcblxyXG4gICAgb3B0cyA9IHh0ZW5kKHBhcnNlZCwgb3B0cylcclxuXHJcbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvdG9jb2wnKVxyXG4gICAgfVxyXG4gICAgb3B0cy5wcm90b2NvbCA9IG9wdHMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJylcclxuICB9XHJcblxyXG4gIC8vIG1lcmdlIGluIHRoZSBhdXRoIG9wdGlvbnMgaWYgc3VwcGxpZWRcclxuICBwYXJzZUF1dGhPcHRpb25zKG9wdHMpXHJcblxyXG4gIC8vIHN1cHBvcnQgY2xpZW50SWQgcGFzc2VkIGluIHRoZSBxdWVyeSBzdHJpbmcgb2YgdGhlIHVybFxyXG4gIGlmIChvcHRzLnF1ZXJ5ICYmIHR5cGVvZiBvcHRzLnF1ZXJ5LmNsaWVudElkID09PSAnc3RyaW5nJykge1xyXG4gICAgb3B0cy5jbGllbnRJZCA9IG9wdHMucXVlcnkuY2xpZW50SWRcclxuICB9XHJcblxyXG4gIGlmIChvcHRzLmNlcnQgJiYgb3B0cy5rZXkpIHtcclxuICAgIGlmIChvcHRzLnByb3RvY29sKSB7XHJcbiAgICAgIGlmIChbJ21xdHRzJywgJ3dzcycsICd3eHMnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpID09PSAtMSkge1xyXG4gICAgICAgIHN3aXRjaCAob3B0cy5wcm90b2NvbCkge1xyXG4gICAgICAgICAgY2FzZSAnbXF0dCc6XHJcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnbXF0dHMnXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICd3cyc6XHJcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3NzJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnd3gnOlxyXG4gICAgICAgICAgICBvcHRzLnByb3RvY29sID0gJ3d4cydcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBmb3Igc2VjdXJlIGNvbm5lY3Rpb246IFwiJyArIG9wdHMucHJvdG9jb2wgKyAnXCIhJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGRvbid0IGtub3cgd2hhdCBwcm90b2NvbCBoZSB3YW50IHRvIHVzZSwgbXF0dHMgb3Igd3NzXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzZWN1cmUgcHJvdG9jb2wga2V5JylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghcHJvdG9jb2xzW29wdHMucHJvdG9jb2xdKSB7XHJcbiAgICB2YXIgaXNTZWN1cmUgPSBbJ21xdHRzJywgJ3dzcyddLmluZGV4T2Yob3B0cy5wcm90b2NvbCkgIT09IC0xXHJcbiAgICBvcHRzLnByb3RvY29sID0gW1xyXG4gICAgICAnbXF0dCcsXHJcbiAgICAgICdtcXR0cycsXHJcbiAgICAgICd3cycsXHJcbiAgICAgICd3c3MnLFxyXG4gICAgICAnd3gnLFxyXG4gICAgICAnd3hzJ1xyXG4gICAgXS5maWx0ZXIoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcclxuICAgICAgaWYgKGlzU2VjdXJlICYmIGluZGV4ICUgMiA9PT0gMCkge1xyXG4gICAgICAgIC8vIFNraXAgaW5zZWN1cmUgcHJvdG9jb2xzIHdoZW4gcmVxdWVzdGluZyBhIHNlY3VyZSBvbmUuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICh0eXBlb2YgcHJvdG9jb2xzW2tleV0gPT09ICdmdW5jdGlvbicpXHJcbiAgICB9KVswXVxyXG4gIH1cclxuXHJcbiAgaWYgKG9wdHMuY2xlYW4gPT09IGZhbHNlICYmICFvcHRzLmNsaWVudElkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2xpZW50SWQgZm9yIHVuY2xlYW4gY2xpZW50cycpXHJcbiAgfVxyXG5cclxuICBpZiAob3B0cy5wcm90b2NvbCkge1xyXG4gICAgb3B0cy5kZWZhdWx0UHJvdG9jb2wgPSBvcHRzLnByb3RvY29sXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cmFwcGVyIChjbGllbnQpIHtcclxuICAgIGlmIChvcHRzLnNlcnZlcnMpIHtcclxuICAgICAgaWYgKCFjbGllbnQuX3JlY29ubmVjdENvdW50IHx8IGNsaWVudC5fcmVjb25uZWN0Q291bnQgPT09IG9wdHMuc2VydmVycy5sZW5ndGgpIHtcclxuICAgICAgICBjbGllbnQuX3JlY29ubmVjdENvdW50ID0gMFxyXG4gICAgICB9XHJcblxyXG4gICAgICBvcHRzLmhvc3QgPSBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0uaG9zdFxyXG4gICAgICBvcHRzLnBvcnQgPSBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucG9ydFxyXG4gICAgICBvcHRzLnByb3RvY29sID0gKCFvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucHJvdG9jb2wgPyBvcHRzLmRlZmF1bHRQcm90b2NvbCA6IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wcm90b2NvbClcclxuICAgICAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdFxyXG5cclxuICAgICAgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCsrXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb3RvY29sc1tvcHRzLnByb3RvY29sXShjbGllbnQsIG9wdHMpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IE1xdHRDbGllbnQod3JhcHBlciwgb3B0cylcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XHJcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0XHJcbm1vZHVsZS5leHBvcnRzLk1xdHRDbGllbnQgPSBNcXR0Q2xpZW50XHJcbm1vZHVsZS5leHBvcnRzLlN0b3JlID0gU3RvcmVcclxuIiwiJ3VzZSBzdHJpY3QnXHJcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKVxyXG5cclxuLypcclxuICB2YXJpYWJsZXMgcG9ydCBhbmQgaG9zdCBjYW4gYmUgcmVtb3ZlZCBzaW5jZVxyXG4gIHlvdSBoYXZlIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBpbiBvcHRzIG9iamVjdFxyXG4qL1xyXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKGNsaWVudCwgb3B0cykge1xyXG4gIHZhciBwb3J0LCBob3N0XHJcbiAgb3B0cy5wb3J0ID0gb3B0cy5wb3J0IHx8IDE4ODNcclxuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcclxuXHJcbiAgcG9ydCA9IG9wdHMucG9ydFxyXG4gIGhvc3QgPSBvcHRzLmhvc3RuYW1lXHJcblxyXG4gIHJldHVybiBuZXQuY3JlYXRlQ29ubmVjdGlvbihwb3J0LCBob3N0KVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxyXG4iLCIndXNlIHN0cmljdCdcclxudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpXHJcblxyXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKG1xdHRDbGllbnQsIG9wdHMpIHtcclxuICB2YXIgY29ubmVjdGlvblxyXG4gIG9wdHMucG9ydCA9IG9wdHMucG9ydCB8fCA4ODgzXHJcbiAgb3B0cy5ob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcclxuXHJcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gZmFsc2VcclxuXHJcbiAgZGVsZXRlIG9wdHMucGF0aFxyXG5cclxuICBjb25uZWN0aW9uID0gdGxzLmNvbm5lY3Qob3B0cylcclxuICAvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFsyLCBcIm5vZnVuY1wiXSAqL1xyXG4gIGNvbm5lY3Rpb24ub24oJ3NlY3VyZUNvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAob3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgJiYgIWNvbm5lY3Rpb24uYXV0aG9yaXplZCkge1xyXG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdUTFMgbm90IGF1dGhvcml6ZWQnKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVExTZXJyb3JzKVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZVRMU2Vycm9ycyAoZXJyKSB7XHJcbiAgICAvLyBIb3cgY2FuIEkgZ2V0IHZlcmlmeSB0aGlzIGVycm9yIGlzIGEgdGxzIGVycm9yP1xyXG4gICAgaWYgKG9wdHMucmVqZWN0VW5hdXRob3JpemVkKSB7XHJcbiAgICAgIG1xdHRDbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2xvc2UgdGhpcyBjb25uZWN0aW9uIHRvIG1hdGNoIHRoZSBiZWhhdmlvdXIgb2YgbmV0XHJcbiAgICAvLyBvdGhlcndpc2UgYWxsIHdlIGdldCBpcyBhbiBlcnJvciBmcm9tIHRoZSBjb25uZWN0aW9uXHJcbiAgICAvLyBhbmQgY2xvc2UgZXZlbnQgZG9lc24ndCBmaXJlLiBUaGlzIGlzIGEgd29yayBhcm91bmRcclxuICAgIC8vIHRvIGVuYWJsZSB0aGUgcmVjb25uZWN0IGNvZGUgdG8gd29yayB0aGUgc2FtZSBhcyB3aXRoXHJcbiAgICAvLyBuZXQuY3JlYXRlQ29ubmVjdGlvblxyXG4gICAgY29ubmVjdGlvbi5lbmQoKVxyXG4gIH1cclxuXHJcbiAgY29ubmVjdGlvbi5vbignZXJyb3InLCBoYW5kbGVUTFNlcnJvcnMpXHJcbiAgcmV0dXJuIGNvbm5lY3Rpb25cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcclxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0LXN0cmVhbScpXHJcbnZhciB1cmxNb2R1bGUgPSByZXF1aXJlKCd1cmwnKVxyXG52YXIgV1NTX09QVElPTlMgPSBbXHJcbiAgJ3JlamVjdFVuYXV0aG9yaXplZCcsXHJcbiAgJ2NhJyxcclxuICAnY2VydCcsXHJcbiAgJ2tleScsXHJcbiAgJ3BmeCcsXHJcbiAgJ3Bhc3NwaHJhc2UnXHJcbl1cclxudmFyIElTX0JST1dTRVIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcclxuICB2YXIgdXJsID0gb3B0cy5wcm90b2NvbCArICc6Ly8nICsgb3B0cy5ob3N0bmFtZSArICc6JyArIG9wdHMucG9ydCArIG9wdHMucGF0aFxyXG4gIGlmICh0eXBlb2YgKG9wdHMudHJhbnNmb3JtV3NVcmwpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxyXG4gIH1cclxuICByZXR1cm4gdXJsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XHJcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XHJcbiAgICBvcHRzLmhvc3RuYW1lID0gJ2xvY2FsaG9zdCdcclxuICB9XHJcbiAgaWYgKCFvcHRzLnBvcnQpIHtcclxuICAgIGlmIChvcHRzLnByb3RvY29sID09PSAnd3NzJykge1xyXG4gICAgICBvcHRzLnBvcnQgPSA0NDNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdHMucG9ydCA9IDgwXHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghb3B0cy5wYXRoKSB7XHJcbiAgICBvcHRzLnBhdGggPSAnLydcclxuICB9XHJcblxyXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcclxuICAgIG9wdHMud3NPcHRpb25zID0ge31cclxuICB9XHJcbiAgaWYgKCFJU19CUk9XU0VSICYmIG9wdHMucHJvdG9jb2wgPT09ICd3c3MnKSB7XHJcbiAgICAvLyBBZGQgY2VydC9rZXkvY2EgZXRjIG9wdGlvbnNcclxuICAgIFdTU19PUFRJT05TLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgIW9wdHMud3NPcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgb3B0cy53c09wdGlvbnNbcHJvcF0gPSBvcHRzW3Byb3BdXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXQgKGNsaWVudCwgb3B0cykge1xyXG4gIHZhciB3ZWJzb2NrZXRTdWJQcm90b2NvbCA9XHJcbiAgICAob3B0cy5wcm90b2NvbElkID09PSAnTVFJc2RwJykgJiYgKG9wdHMucHJvdG9jb2xWZXJzaW9uID09PSAzKVxyXG4gICAgICA/ICdtcXR0djMuMSdcclxuICAgICAgOiAnbXF0dCdcclxuXHJcbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcclxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxyXG4gIHJldHVybiB3ZWJzb2NrZXQodXJsLCBbd2Vic29ja2V0U3ViUHJvdG9jb2xdLCBvcHRzLndzT3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcclxuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyQnJvd3NlciAoY2xpZW50LCBvcHRzKSB7XHJcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XHJcbiAgICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0XHJcbiAgfVxyXG5cclxuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcclxuICAgIC8vIFRocm93aW5nIGFuIGVycm9yIGluIGEgV2ViIFdvcmtlciBpZiBubyBgaG9zdG5hbWVgIGlzIGdpdmVuLCBiZWNhdXNlIHdlXHJcbiAgICAvLyBjYW4gbm90IGRldGVybWluZSB0aGUgYGhvc3RuYW1lYCBhdXRvbWF0aWNhbGx5LiAgSWYgY29ubmVjdGluZyB0b1xyXG4gICAgLy8gbG9jYWxob3N0LCBwbGVhc2Ugc3VwcGx5IHRoZSBgaG9zdG5hbWVgIGFzIGFuIGFyZ3VtZW50LlxyXG4gICAgaWYgKHR5cGVvZiAoZG9jdW1lbnQpID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VkID0gdXJsTW9kdWxlLnBhcnNlKGRvY3VtZW50LlVSTClcclxuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWVcclxuXHJcbiAgICBpZiAoIW9wdHMucG9ydCkge1xyXG4gICAgICBvcHRzLnBvcnQgPSBwYXJzZWQucG9ydFxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcclxufVxyXG5cclxuaWYgKElTX0JST1dTRVIpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlckJyb3dzZXJcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxyXG59XHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuLyogZ2xvYmFsIHd4ICovXHJcbnZhciBzb2NrZXRPcGVuID0gZmFsc2VcclxudmFyIHNvY2tldE1zZ1F1ZXVlID0gW11cclxuXHJcbmZ1bmN0aW9uIHNlbmRTb2NrZXRNZXNzYWdlIChtc2cpIHtcclxuICBpZiAoc29ja2V0T3Blbikge1xyXG4gICAgd3guc2VuZFNvY2tldE1lc3NhZ2Uoe1xyXG4gICAgICBkYXRhOiBtc2cuYnVmZmVyIHx8IG1zZ1xyXG4gICAgfSlcclxuICB9IGVsc2Uge1xyXG4gICAgc29ja2V0TXNnUXVldWUucHVzaChtc2cpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBXZWJTb2NrZXQgKHVybCwgcHJvdG9jb2xzKSB7XHJcbiAgdmFyIHdzID0ge1xyXG4gICAgT1BFTjogMSxcclxuICAgIENMT1NJTkc6IDIsXHJcbiAgICBDTE9TRUQ6IDMsXHJcbiAgICByZWFkeVN0YXRlOiBzb2NrZXRPcGVuID8gMSA6IDAsXHJcbiAgICBzZW5kOiBzZW5kU29ja2V0TWVzc2FnZSxcclxuICAgIGNsb3NlOiB3eC5jbG9zZVNvY2tldCxcclxuICAgIG9ub3BlbjogbnVsbCxcclxuICAgIG9ubWVzc2FnZTogbnVsbCxcclxuICAgIG9uY2xvc2U6IG51bGwsXHJcbiAgICBvbmVycm9yOiBudWxsXHJcbiAgfVxyXG5cclxuICB3eC5jb25uZWN0U29ja2V0KHtcclxuICAgIHVybDogdXJsLFxyXG4gICAgcHJvdG9jb2xzOiBwcm90b2NvbHNcclxuICB9KVxyXG4gIHd4Lm9uU29ja2V0T3BlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICB3cy5yZWFkeVN0YXRlID0gd3MuT1BFTlxyXG4gICAgc29ja2V0T3BlbiA9IHRydWVcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ja2V0TXNnUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2VuZFNvY2tldE1lc3NhZ2Uoc29ja2V0TXNnUXVldWVbaV0pXHJcbiAgICB9XHJcbiAgICBzb2NrZXRNc2dRdWV1ZSA9IFtdXHJcblxyXG4gICAgd3Mub25vcGVuICYmIHdzLm9ub3Blbi5hcHBseSh3cywgYXJndW1lbnRzKVxyXG4gIH0pXHJcbiAgd3gub25Tb2NrZXRNZXNzYWdlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgIHdzLm9ubWVzc2FnZSAmJiB3cy5vbm1lc3NhZ2UuYXBwbHkod3MsIGFyZ3VtZW50cylcclxuICB9KVxyXG4gIHd4Lm9uU29ja2V0Q2xvc2UoZnVuY3Rpb24gKCkge1xyXG4gICAgd3Mub25jbG9zZSAmJiB3cy5vbmNsb3NlLmFwcGx5KHdzLCBhcmd1bWVudHMpXHJcbiAgICB3cy5yZWFkeVN0YXRlID0gd3MuQ0xPU0VEXHJcbiAgICBzb2NrZXRPcGVuID0gZmFsc2VcclxuICB9KVxyXG4gIHd4Lm9uU29ja2V0RXJyb3IoZnVuY3Rpb24gKCkge1xyXG4gICAgd3Mub25lcnJvciAmJiB3cy5vbmVycm9yLmFwcGx5KHdzLCBhcmd1bWVudHMpXHJcbiAgICB3cy5yZWFkeVN0YXRlID0gd3MuQ0xPU0VEXHJcbiAgICBzb2NrZXRPcGVuID0gZmFsc2VcclxuICB9KVxyXG5cclxuICByZXR1cm4gd3NcclxufVxyXG5cclxudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJ3dlYnNvY2tldC1zdHJlYW0nKVxyXG5cclxuZnVuY3Rpb24gYnVpbGRVcmwgKG9wdHMsIGNsaWVudCkge1xyXG4gIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgPT09ICd3eHMnID8gJ3dzcycgOiAnd3MnXHJcbiAgdmFyIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgb3B0cy5wYXRoXHJcbiAgaWYgKG9wdHMucG9ydCAmJiBvcHRzLnBvcnQgIT09IDgwICYmIG9wdHMucG9ydCAhPT0gNDQzKSB7XHJcbiAgICB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgb3B0cy5ob3N0bmFtZSArICc6JyArIG9wdHMucG9ydCArIG9wdHMucGF0aFxyXG4gIH1cclxuICBpZiAodHlwZW9mIChvcHRzLnRyYW5zZm9ybVdzVXJsKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdXJsID0gb3B0cy50cmFuc2Zvcm1Xc1VybCh1cmwsIG9wdHMsIGNsaWVudClcclxuICB9XHJcbiAgcmV0dXJuIHVybFxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXREZWZhdWx0T3B0cyAob3B0cykge1xyXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xyXG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXHJcbiAgfVxyXG4gIGlmICghb3B0cy5wYXRoKSB7XHJcbiAgICBvcHRzLnBhdGggPSAnLydcclxuICB9XHJcblxyXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcclxuICAgIG9wdHMud3NPcHRpb25zID0ge31cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldCAoY2xpZW50LCBvcHRzKSB7XHJcbiAgdmFyIHdlYnNvY2tldFN1YlByb3RvY29sID1cclxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXHJcbiAgICAgID8gJ21xdHR2My4xJ1xyXG4gICAgICA6ICdtcXR0J1xyXG5cclxuICBzZXREZWZhdWx0T3B0cyhvcHRzKVxyXG4gIHZhciB1cmwgPSBidWlsZFVybChvcHRzLCBjbGllbnQpXHJcbiAgcmV0dXJuIHdlYnNvY2tldChXZWJTb2NrZXQodXJsLCBbd2Vic29ja2V0U3ViUHJvdG9jb2xdKSlcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcclxuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3RcclxuXHJcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcclxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xyXG4gKi9cclxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxyXG5cclxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcclxudmFyIHN0cmVhbXNPcHRzID0geyBvYmplY3RNb2RlOiB0cnVlIH1cclxudmFyIGRlZmF1bHRTdG9yZU9wdGlvbnMgPSB7XHJcbiAgY2xlYW46IHRydWVcclxufVxyXG5cclxuLyoqXHJcbiAqIGVzNi1tYXAgY2FuIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBldmVuIGlmIEVTIHZlcnNpb24gaXMgb2xkZXIuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNEZXNjcmlwdGlvblxyXG4gKiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBhIE1hcCB3aGljaCBpcyBhIG1hcCBvZiBhbiBvYmplY3QsIGVzcGVjaWFsbHlcclxuICogYSBkaWN0aW9uYXJ5IG9mIGRpY3Rpb25hcmllcywgd2lsbCBvbmx5IG1hcCB0byB0aGUgb2JqZWN0J3MgaW5zZXJ0aW9uXHJcbiAqIG9yZGVyLiBJbiBFUzIwMTUgdGhpcyBpcyBvcmRlcmVkIGZvciBvYmplY3RzIGJ1dCBmb3Igb2xkZXIgdmVyc2lvbnMgb2ZcclxuICogRVMsIHRoaXMgbWF5IGJlIHJhbmRvbSBhbmQgbm90IG9yZGVyZWQuXHJcbiAqXHJcbiAqL1xyXG52YXIgTWFwID0gcmVxdWlyZSgnZXM2LW1hcCcpXHJcblxyXG4vKipcclxuICogSW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIHRoZSBtZXNzYWdlIHN0b3JlXHJcbiAqIFRoaXMgY2FuIGFjdHVhbGx5IGJlIHNhdmVkIGludG8gZmlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBzdG9yZSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdG9yZSkpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmUob3B0aW9ucylcclxuICB9XHJcblxyXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cclxuXHJcbiAgLy8gRGVmYXVsdHNcclxuICB0aGlzLm9wdGlvbnMgPSB4dGVuZChkZWZhdWx0U3RvcmVPcHRpb25zLCBvcHRpb25zKVxyXG5cclxuICB0aGlzLl9pbmZsaWdodHMgPSBuZXcgTWFwKClcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBwYWNrZXQgdG8gdGhlIHN0b3JlLCBhIHBhY2tldCBpc1xyXG4gKiBhbnl0aGluZyB0aGF0IGhhcyBhIG1lc3NhZ2VJZCBwcm9wZXJ0eS5cclxuICpcclxuICovXHJcblN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xyXG4gIHRoaXMuX2luZmxpZ2h0cy5zZXQocGFja2V0Lm1lc3NhZ2VJZCwgcGFja2V0KVxyXG5cclxuICBpZiAoY2IpIHtcclxuICAgIGNiKClcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RyZWFtIHdpdGggYWxsIHRoZSBwYWNrZXRzIGluIHRoZSBzdG9yZVxyXG4gKlxyXG4gKi9cclxuU3RvcmUucHJvdG90eXBlLmNyZWF0ZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlKHN0cmVhbXNPcHRzKVxyXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZVxyXG4gIHZhciB2YWx1ZXMgPSBbXVxyXG4gIHZhciBpID0gMFxyXG5cclxuICB0aGlzLl9pbmZsaWdodHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgdmFsdWVzLnB1c2godmFsdWUpXHJcbiAgfSlcclxuXHJcbiAgc3RyZWFtLl9yZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFkZXN0cm95ZWQgJiYgaSA8IHZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5wdXNoKHZhbHVlc1tpKytdKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wdXNoKG51bGwpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChkZXN0cm95ZWQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzXHJcblxyXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxyXG5cclxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyZWFtXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkZWxldGVzIGEgcGFja2V0IGZyb20gdGhlIHN0b3JlLlxyXG4gKi9cclxuU3RvcmUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XHJcbiAgcGFja2V0ID0gdGhpcy5faW5mbGlnaHRzLmdldChwYWNrZXQubWVzc2FnZUlkKVxyXG4gIGlmIChwYWNrZXQpIHtcclxuICAgIHRoaXMuX2luZmxpZ2h0cy5kZWxldGUocGFja2V0Lm1lc3NhZ2VJZClcclxuICAgIGNiKG51bGwsIHBhY2tldClcclxuICB9IGVsc2UgaWYgKGNiKSB7XHJcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgcGFja2V0IGZyb20gdGhlIHN0b3JlLlxyXG4gKi9cclxuU3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XHJcbiAgcGFja2V0ID0gdGhpcy5faW5mbGlnaHRzLmdldChwYWNrZXQubWVzc2FnZUlkKVxyXG4gIGlmIChwYWNrZXQpIHtcclxuICAgIGNiKG51bGwsIHBhY2tldClcclxuICB9IGVsc2UgaWYgKGNiKSB7XHJcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogQ2xvc2UgdGhlIHN0b3JlXHJcbiAqL1xyXG5TdG9yZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcclxuICBpZiAodGhpcy5vcHRpb25zLmNsZWFuKSB7XHJcbiAgICB0aGlzLl9pbmZsaWdodHMgPSBudWxsXHJcbiAgfVxyXG4gIGlmIChjYikge1xyXG4gICAgY2IoKVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIHRvcGljIHRvIHNlZSBpZiBpdCdzIHZhbGlkIG9yIG5vdC5cclxuICogQSB0b3BpYyBpcyB2YWxpZCBpZiBpdCBmb2xsb3cgYmVsb3cgcnVsZXM6XHJcbiAqIC0gUnVsZSAjMTogSWYgYW55IHBhcnQgb2YgdGhlIHRvcGljIGlzIG5vdCBgK2Agb3IgYCNgLCB0aGVuIGl0IG11c3Qgbm90IGNvbnRhaW4gYCtgIGFuZCAnIydcclxuICogLSBSdWxlICMyOiBQYXJ0IGAjYCBtdXN0IGJlIGxvY2F0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgbWFpbGJveFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSBBIHRvcGljXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdG9waWMgaXMgdmFsaWQsIHJldHVybnMgdHJ1ZS4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVUb3BpYyAodG9waWMpIHtcclxuICB2YXIgcGFydHMgPSB0b3BpYy5zcGxpdCgnLycpXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChwYXJ0c1tpXSA9PT0gJysnKSB7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcnRzW2ldID09PSAnIycpIHtcclxuICAgICAgLy8gZm9yIFJ1bGUgIzJcclxuICAgICAgcmV0dXJuIGkgPT09IHBhcnRzLmxlbmd0aCAtIDFcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFydHNbaV0uaW5kZXhPZignKycpICE9PSAtMSB8fCBwYXJ0c1tpXS5pbmRleE9mKCcjJykgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGFuIGFycmF5IG9mIHRvcGljcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gaXMgdmFsaWQgb3Igbm90XHJcbiAgKiBAcGFyYW0ge0FycmF5fSB0b3BpY3MgLSBBcnJheSBvZiB0b3BpY3NcclxuICogQHJldHVybnMge1N0cmluZ30gSWYgdGhlIHRvcGljcyBpcyB2YWxpZCwgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHJldHVybnMgdGhlIGludmFsaWQgb25lXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVRvcGljcyAodG9waWNzKSB7XHJcbiAgaWYgKHRvcGljcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAnZW1wdHlfdG9waWNfbGlzdCdcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3BpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghdmFsaWRhdGVUb3BpYyh0b3BpY3NbaV0pKSB7XHJcbiAgICAgIHJldHVybiB0b3BpY3NbaV1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgdmFsaWRhdGVUb3BpY3M6IHZhbGlkYXRlVG9waWNzXHJcbn1cclxuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG5cbmV4cG9ydHMuaG9tZWRpciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICcvJ1xufTtcbiIsIi8vICdwYXRoJyBtb2R1bGUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xIChvbmx5IHRoZSBwb3NpeCBwYXJ0KVxuLy8gdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbFxuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KHBhdGgpKTtcbiAgfVxufVxuXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgdmFyIGxhc3RTbGFzaCA9IC0xO1xuICB2YXIgZG90cyA9IDA7XG4gIHZhciBjb2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSBpZiAoY29kZSA9PT0gNDcgLyovKi8pXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBjb2RlID0gNDcgLyovKi87XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IC8qLiovIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYgLyouKi8pIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmVzICs9ICcvLi4nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmVzICs9ICcvJyArIHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgLyouKi8gJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICB2YXIgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAocGF0aE9iamVjdC5uYW1lIHx8ICcnKSArIChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7XG4gIGlmICghZGlyKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIGRpciArIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGRpciArIHNlcCArIGJhc2U7XG59XG5cbnZhciBwb3NpeCA9IHtcbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJztcbiAgICB2YXIgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgIHZhciBjd2Q7XG5cbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBpZiAoaSA+PSAwKVxuICAgICAgICBwYXRoID0gYXJndW1lbnRzW2ldO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBwYXRoID0gY3dkO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUpO1xuXG4gICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy4nO1xuICAgIH1cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcblxuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcgLyovKi87XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgIWlzQWJzb2x1dGUpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSBwYXRoID0gJy4nO1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpIHBhdGggKz0gJy8nO1xuXG4gICAgaWYgKGlzQWJzb2x1dGUpIHJldHVybiAnLycgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHZhciBqb2luZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGpvaW5lZCArPSAnLycgKyBhcmc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnLic7XG4gICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIGFzc2VydFBhdGgoZnJvbSk7XG4gICAgYXNzZXJ0UGF0aCh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgZnJvbVN0YXJ0ID0gMTtcbiAgICBmb3IgKDsgZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGg7ICsrZnJvbVN0YXJ0KSB7XG4gICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICB2YXIgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIHRvU3RhcnQgPSAxO1xuICAgIGZvciAoOyB0b1N0YXJ0IDwgdG8ubGVuZ3RoOyArK3RvU3RhcnQpIHtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICB2YXIgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XG5cbiAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8PSBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28nOyB0bz0nLydcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgIHZhciB0b0NvZGUgPSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKTtcbiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG9Db2RlKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSA0NyAvKi8qLylcbiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXG4gICAgLy8gYW5kIGBmcm9tYFxuICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBvdXQgKz0gJy4uJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dCArPSAnLy4uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxuICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgIGlmIChvdXQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvdXQgKyB0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCk7XG4gICAgZWxzZSB7XG4gICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gNDcgLyovKi8pXG4gICAgICAgICsrdG9TdGFydDtcbiAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0KTtcbiAgICB9XG4gIH0sXG5cbiAgX21ha2VMb25nOiBmdW5jdGlvbiBfbWFrZUxvbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHJldHVybiAnLy8nO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG5cbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXh0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoLmxlbmd0aCAmJiBleHQgPT09IHBhdGgpIHJldHVybiAnJztcbiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtlbHNlIGlmIChlbmQgPT09IC0xKSBlbmQgPSBwYXRoLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBhdGhPYmplY3QpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcGF0aE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0KCcvJywgcGF0aE9iamVjdCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBzdGFydDtcbiAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuXG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcblxuICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHN0YXJ0RG90ID0gaTtlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtlbHNlIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UGFydCA+IDApIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO2Vsc2UgaWYgKGlzQWJzb2x1dGUpIHJldC5kaXIgPSAnLyc7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgd2luMzI6IG51bGwsXG4gIHBvc2l4OiBudWxsXG59O1xuXG5wb3NpeC5wb3NpeCA9IHBvc2l4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBSZUludGVydmFsIChjYWxsYmFjaywgaW50ZXJ2YWwsIGFyZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX2FyZ3MgPSBhcmdzO1xuXG4gIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIGludGVydmFsLCB0aGlzLl9hcmdzKTtcblxuICB0aGlzLnJlc2NoZWR1bGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAvLyBpZiBubyBpbnRlcnZhbCBlbnRlcmVkLCB1c2UgdGhlIGludGVydmFsIHBhc3NlZCBpbiBvbiBjcmVhdGlvblxuICAgIGlmICghaW50ZXJ2YWwpXG4gICAgICBpbnRlcnZhbCA9IHNlbGYuX2ludGVydmFsO1xuXG4gICAgaWYgKHNlbGYuX2ludGVydmFsKVxuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChzZWxmLl9jYWxsYmFjaywgaW50ZXJ2YWwsIHNlbGYuX2FyZ3MpO1xuICB9O1xuXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICAgIHNlbGYuX2ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzZWxmLl9jYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9hcmdzID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZUludGVydmFsICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBuZWVkZWQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJ2YWwgbmVlZGVkJyk7XG5cbiAgdmFyIGFyZ3M7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVJbnRlcnZhbChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVJbnRlcnZhbDtcbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJ2YXIgQ2xpZW50UmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKVxudmFyIHJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvcmVzcG9uc2UnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBzdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2J1aWx0aW4tc3RhdHVzLWNvZGVzJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG52YXIgaHR0cCA9IGV4cG9ydHNcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG5cdFx0b3B0cyA9IHVybC5wYXJzZShvcHRzKVxuXHRlbHNlXG5cdFx0b3B0cyA9IGV4dGVuZChvcHRzKVxuXG5cdC8vIE5vcm1hbGx5LCB0aGUgcGFnZSBpcyBsb2FkZWQgZnJvbSBodHRwIG9yIGh0dHBzLCBzbyBub3Qgc3BlY2lmeWluZyBhIHByb3RvY29sXG5cdC8vIHdpbGwgcmVzdWx0IGluIGEgKHZhbGlkKSBwcm90b2NvbC1yZWxhdGl2ZSB1cmwuIEhvd2V2ZXIsIHRoaXMgd29uJ3Qgd29yayBpZlxuXHQvLyB0aGUgcHJvdG9jb2wgaXMgc29tZXRoaW5nIGVsc2UsIGxpa2UgJ2ZpbGU6J1xuXHR2YXIgZGVmYXVsdFByb3RvY29sID0gZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sLnNlYXJjaCgvXmh0dHBzPzokLykgPT09IC0xID8gJ2h0dHA6JyA6ICcnXG5cblx0dmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCB8fCBkZWZhdWx0UHJvdG9jb2xcblx0dmFyIGhvc3QgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXHR2YXIgcG9ydCA9IG9wdHMucG9ydFxuXHR2YXIgcGF0aCA9IG9wdHMucGF0aCB8fCAnLydcblxuXHQvLyBOZWNlc3NhcnkgZm9yIElQdjYgYWRkcmVzc2VzXG5cdGlmIChob3N0ICYmIGhvc3QuaW5kZXhPZignOicpICE9PSAtMSlcblx0XHRob3N0ID0gJ1snICsgaG9zdCArICddJ1xuXG5cdC8vIFRoaXMgbWF5IGJlIGEgcmVsYXRpdmUgdXJsLiBUaGUgYnJvd3NlciBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cblx0b3B0cy51cmwgPSAoaG9zdCA/IChwcm90b2NvbCArICcvLycgKyBob3N0KSA6ICcnKSArIChwb3J0ID8gJzonICsgcG9ydCA6ICcnKSArIHBhdGhcblx0b3B0cy5tZXRob2QgPSAob3B0cy5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcblx0b3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cblx0Ly8gQWxzbyB2YWxpZCBvcHRzLmF1dGgsIG9wdHMubW9kZVxuXG5cdHZhciByZXEgPSBuZXcgQ2xpZW50UmVxdWVzdChvcHRzKVxuXHRpZiAoY2IpXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGNiKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvcHRzLCBjYikge1xuXHR2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KG9wdHMsIGNiKVxuXHRyZXEuZW5kKClcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLkNsaWVudFJlcXVlc3QgPSBDbGllbnRSZXF1ZXN0XG5odHRwLkluY29taW5nTWVzc2FnZSA9IHJlc3BvbnNlLkluY29taW5nTWVzc2FnZVxuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge31cbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0XG5cbmh0dHAuZ2xvYmFsQWdlbnQgPSBuZXcgaHR0cC5BZ2VudCgpXG5cbmh0dHAuU1RBVFVTX0NPREVTID0gc3RhdHVzQ29kZXNcblxuaHR0cC5NRVRIT0RTID0gW1xuXHQnQ0hFQ0tPVVQnLFxuXHQnQ09OTkVDVCcsXG5cdCdDT1BZJyxcblx0J0RFTEVURScsXG5cdCdHRVQnLFxuXHQnSEVBRCcsXG5cdCdMT0NLJyxcblx0J00tU0VBUkNIJyxcblx0J01FUkdFJyxcblx0J01LQUNUSVZJVFknLFxuXHQnTUtDT0wnLFxuXHQnTU9WRScsXG5cdCdOT1RJRlknLFxuXHQnT1BUSU9OUycsXG5cdCdQQVRDSCcsXG5cdCdQT1NUJyxcblx0J1BST1BGSU5EJyxcblx0J1BST1BQQVRDSCcsXG5cdCdQVVJHRScsXG5cdCdQVVQnLFxuXHQnUkVQT1JUJyxcblx0J1NFQVJDSCcsXG5cdCdTVUJTQ1JJQkUnLFxuXHQnVFJBQ0UnLFxuXHQnVU5MT0NLJyxcblx0J1VOU1VCU0NSSUJFJ1xuXSIsImV4cG9ydHMuZmV0Y2ggPSBpc0Z1bmN0aW9uKGdsb2JhbC5mZXRjaCkgJiYgaXNGdW5jdGlvbihnbG9iYWwuUmVhZGFibGVTdHJlYW0pXG5cbmV4cG9ydHMud3JpdGFibGVTdHJlYW0gPSBpc0Z1bmN0aW9uKGdsb2JhbC5Xcml0YWJsZVN0cmVhbSlcblxuZXhwb3J0cy5hYm9ydENvbnRyb2xsZXIgPSBpc0Z1bmN0aW9uKGdsb2JhbC5BYm9ydENvbnRyb2xsZXIpXG5cbi8vIFRoZSB4aHIgcmVxdWVzdCB0byBleGFtcGxlLmNvbSBtYXkgdmlvbGF0ZSBzb21lIHJlc3RyaWN0aXZlIENTUCBjb25maWd1cmF0aW9ucyxcbi8vIHNvIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgYGZldGNoYCwgYXZvaWQgY2FsbGluZyBnZXRYSFIoKVxuLy8gYW5kIGFzc3VtZSBzdXBwb3J0IGZvciBjZXJ0YWluIGZlYXR1cmVzIGJlbG93LlxudmFyIHhoclxuZnVuY3Rpb24gZ2V0WEhSICgpIHtcblx0Ly8gQ2FjaGUgdGhlIHhociB2YWx1ZVxuXHRpZiAoeGhyICE9PSB1bmRlZmluZWQpIHJldHVybiB4aHJcblxuXHRpZiAoZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0eGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0Ly8gSWYgWERvbWFpblJlcXVlc3QgaXMgYXZhaWxhYmxlIChpZSBvbmx5LCB3aGVyZSB4aHIgbWlnaHQgbm90IHdvcmtcblx0XHQvLyBjcm9zcyBkb21haW4pLCB1c2UgdGhlIHBhZ2UgbG9jYXRpb24uIE90aGVyd2lzZSB1c2UgZXhhbXBsZS5jb21cblx0XHQvLyBOb3RlOiB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgbWFrZSBhbiBodHRwIHJlcXVlc3QuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKCdHRVQnLCBnbG9iYWwuWERvbWFpblJlcXVlc3QgPyAnLycgOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScpXG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHR4aHIgPSBudWxsXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcnZpY2Ugd29ya2VycyBkb24ndCBoYXZlIFhIUlxuXHRcdHhociA9IG51bGxcblx0fVxuXHRyZXR1cm4geGhyXG59XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZVN1cHBvcnQgKHR5cGUpIHtcblx0dmFyIHhociA9IGdldFhIUigpXG5cdGlmICgheGhyKSByZXR1cm4gZmFsc2Vcblx0dHJ5IHtcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gdHlwZVxuXHRcdHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSB0eXBlXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZVxufVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gYXJyYXlidWZmZXIgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGNoZWNrVHlwZVN1cHBvcnQoKSwgc2luY2UgdGhhdCBjYWxscyBnZXRYSFIoKS5cbmV4cG9ydHMuYXJyYXlidWZmZXIgPSBleHBvcnRzLmZldGNoIHx8IGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJylcblxuLy8gVGhlc2UgbmV4dCB0d28gdGVzdHMgdW5hdm9pZGFibHkgc2hvdyB3YXJuaW5ncyBpbiBDaHJvbWUuIFNpbmNlIGZldGNoIHdpbGwgYWx3YXlzXG4vLyBiZSB1c2VkIGlmIGl0J3MgYXZhaWxhYmxlLCBqdXN0IHJldHVybiBmYWxzZSBmb3IgdGhlc2UgdG8gYXZvaWQgdGhlIHdhcm5pbmdzLlxuZXhwb3J0cy5tc3N0cmVhbSA9ICFleHBvcnRzLmZldGNoICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21zLXN0cmVhbScpXG5leHBvcnRzLm1vemNodW5rZWRhcnJheWJ1ZmZlciA9ICFleHBvcnRzLmZldGNoICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIG92ZXJyaWRlTWltZVR5cGUgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGdldFhIUigpLlxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gZXhwb3J0cy5mZXRjaCB8fCAoZ2V0WEhSKCkgPyBpc0Z1bmN0aW9uKGdldFhIUigpLm92ZXJyaWRlTWltZVR5cGUpIDogZmFsc2UpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG52YXIgclN0YXRlcyA9IHJlc3BvbnNlLnJlYWR5U3RhdGVzXG5cbmZ1bmN0aW9uIGRlY2lkZU1vZGUgKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2ggJiYgdXNlRmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAndGV4dCdcblx0fVxufVxuXG52YXIgQ2xpZW50UmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fb3B0cyA9IG9wdHNcblx0c2VsZi5fYm9keSA9IFtdXG5cdHNlbGYuX2hlYWRlcnMgPSB7fVxuXHRpZiAob3B0cy5hdXRoKVxuXHRcdHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0T2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0dmFyIHVzZUZldGNoID0gdHJ1ZVxuXHRpZiAob3B0cy5tb2RlID09PSAnZGlzYWJsZS1mZXRjaCcgfHwgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cyAmJiAhY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpKSB7XG5cdFx0Ly8gSWYgdGhlIHVzZSBvZiBYSFIgc2hvdWxkIGJlIHByZWZlcnJlZC4gTm90IHR5cGljYWxseSBuZWVkZWQuXG5cdFx0dXNlRmV0Y2ggPSBmYWxzZVxuXHRcdHByZWZlckJpbmFyeSA9IHRydWVcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdwcmVmZXItc3RyZWFtaW5nJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBhIGhpZ2ggcHJpb3JpdHkgYnV0IGJpbmFyeSBjb21wYXRpYmlsaXR5IGFuZFxuXHRcdC8vIHRoZSBhY2N1cmFjeSBvZiB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyIGFyZW4ndFxuXHRcdHByZWZlckJpbmFyeSA9IGZhbHNlXG5cdH0gZWxzZSBpZiAob3B0cy5tb2RlID09PSAnYWxsb3ctd3JvbmctY29udGVudC10eXBlJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIHByZXNlcnZpbmcgdGhlICdjb250ZW50LXR5cGUnIGhlYWRlclxuXHRcdHByZWZlckJpbmFyeSA9ICFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGVcblx0fSBlbHNlIGlmICghb3B0cy5tb2RlIHx8IG9wdHMubW9kZSA9PT0gJ2RlZmF1bHQnIHx8IG9wdHMubW9kZSA9PT0gJ3ByZWZlci1mYXN0Jykge1xuXHRcdC8vIFVzZSBiaW5hcnkgaWYgdGV4dCBzdHJlYW1pbmcgbWF5IGNvcnJ1cHQgZGF0YSBvciB0aGUgY29udGVudC10eXBlIGhlYWRlciwgb3IgZm9yIHNwZWVkXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0cy5tb2RlJylcblx0fVxuXHRzZWxmLl9tb2RlID0gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnksIHVzZUZldGNoKVxuXHRzZWxmLl9mZXRjaFRpbWVyID0gbnVsbFxuXHRzZWxmLl9zb2NrZXRUaW1lb3V0ID0gbnVsbFxuXHRzZWxmLl9zb2NrZXRUaW1lciA9IG51bGxcblxuXHRzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fb25GaW5pc2goKVxuXHR9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBzdHJlYW0uV3JpdGFibGUpXG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0dmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXHQvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlXG5cdC8vIGhlYWRlcnMuIFRvIGJlIGhvbmVzdCBJJ20gbm90IGVudGlyZWx5IHN1cmUgaGlkaW5nIHRoZXNlIHdhcm5pbmdzIGlzIGEgZ29vZCB0aGluZywgYnV0XG5cdC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG5cdGlmICh1bnNhZmVIZWFkZXJzLmluZGV4T2YobG93ZXJOYW1lKSAhPT0gLTEpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0ge1xuXHRcdG5hbWU6IG5hbWUsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIGhlYWRlciA9IHRoaXMuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXVxuXHRpZiAoaGVhZGVyKVxuXHRcdHJldHVybiBoZWFkZXIudmFsdWVcblx0cmV0dXJuIG51bGxcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGRlbGV0ZSBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXHR2YXIgb3B0cyA9IHNlbGYuX29wdHNcblxuXHRpZiAoJ3RpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy50aW1lb3V0ICE9PSAwKSB7XG5cdFx0c2VsZi5zZXRUaW1lb3V0KG9wdHMudGltZW91dClcblx0fVxuXG5cdHZhciBoZWFkZXJzT2JqID0gc2VsZi5faGVhZGVyc1xuXHR2YXIgYm9keSA9IG51bGxcblx0aWYgKG9wdHMubWV0aG9kICE9PSAnR0VUJyAmJiBvcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgQmxvYihzZWxmLl9ib2R5LCB7XG4gICAgICAgICAgICB0eXBlOiAoaGVhZGVyc09ialsnY29udGVudC10eXBlJ10gfHwge30pLnZhbHVlIHx8ICcnXG4gICAgICAgIH0pO1xuICAgIH1cblxuXHQvLyBjcmVhdGUgZmxhdHRlbmVkIGxpc3Qgb2YgaGVhZGVyc1xuXHR2YXIgaGVhZGVyc0xpc3QgPSBbXVxuXHRPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlOYW1lKSB7XG5cdFx0dmFyIG5hbWUgPSBoZWFkZXJzT2JqW2tleU5hbWVdLm5hbWVcblx0XHR2YXIgdmFsdWUgPSBoZWFkZXJzT2JqW2tleU5hbWVdLnZhbHVlXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHZdKVxuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdmFsdWVdKVxuXHRcdH1cblx0fSlcblxuXHRpZiAoc2VsZi5fbW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHZhciBzaWduYWwgPSBudWxsXG5cdFx0aWYgKGNhcGFiaWxpdHkuYWJvcnRDb250cm9sbGVyKSB7XG5cdFx0XHR2YXIgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXHRcdFx0c2lnbmFsID0gY29udHJvbGxlci5zaWduYWxcblx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyID0gY29udHJvbGxlclxuXG5cdFx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmIG9wdHMucmVxdWVzdFRpbWVvdXQgIT09IDApIHtcblx0XHRcdFx0c2VsZi5fZmV0Y2hUaW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdFx0XHRpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0XHRcdFx0XHRzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlci5hYm9ydCgpXG5cdFx0XHRcdH0sIG9wdHMucmVxdWVzdFRpbWVvdXQpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2xvYmFsLmZldGNoKHNlbGYuX29wdHMudXJsLCB7XG5cdFx0XHRtZXRob2Q6IHNlbGYuX29wdHMubWV0aG9kLFxuXHRcdFx0aGVhZGVyczogaGVhZGVyc0xpc3QsXG5cdFx0XHRib2R5OiBib2R5IHx8IHVuZGVmaW5lZCxcblx0XHRcdG1vZGU6ICdjb3JzJyxcblx0XHRcdGNyZWRlbnRpYWxzOiBvcHRzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbicsXG5cdFx0XHRzaWduYWw6IHNpZ25hbFxuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxuXHRcdFx0c2VsZi5fY29ubmVjdCgpXG5cdFx0fSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0c2VsZi5fcmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgcmVhc29uKVxuXHRcdH0pXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBDYW4ndCBzZXQgcmVzcG9uc2VUeXBlIG9uIHJlYWxseSBvbGQgYnJvd3NlcnNcblx0XHRpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHNlbGYuX21vZGVcblxuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuXG5cdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cykge1xuXHRcdFx0eGhyLnRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0XG5cdFx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWFkZXJzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLl9yZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWEhSIGVycm9yJykpXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKGJvZHkpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgeGhyLnN0YXR1cyBpcyByZWFkYWJsZSBhbmQgbm9uLXplcm8sIGluZGljYXRpbmcgbm8gZXJyb3IuXG4gKiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhdmFpbGFibGUgaW4gcmVhZHlTdGF0ZSAzLFxuICogYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkICh4aHIpIHtcblx0dHJ5IHtcblx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1c1xuXHRcdHJldHVybiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gMClcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9yZXNldFRpbWVycyhmYWxzZSlcblxuXHRpZiAoIXN0YXR1c1ZhbGlkKHNlbGYuX3hocikgfHwgc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdGlmICghc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fY29ubmVjdCgpXG5cblx0c2VsZi5fcmVzcG9uc2UuX29uWEhSUHJvZ3Jlc3Moc2VsZi5fcmVzZXRUaW1lcnMuYmluZChzZWxmKSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSwgc2VsZi5fcmVzZXRUaW1lcnMuYmluZChzZWxmKSlcblx0c2VsZi5fcmVzcG9uc2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0fSlcblxuXHRzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX2JvZHkucHVzaChjaHVuaylcblx0Y2IoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fcmVzZXRUaW1lcnMgPSBmdW5jdGlvbiAoZG9uZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX3NvY2tldFRpbWVyKVxuXHRzZWxmLl9zb2NrZXRUaW1lciA9IG51bGxcblxuXHRpZiAoZG9uZSkge1xuXHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fZmV0Y2hUaW1lcilcblx0XHRzZWxmLl9mZXRjaFRpbWVyID0gbnVsbFxuXHR9IGVsc2UgaWYgKHNlbGYuX3NvY2tldFRpbWVvdXQpIHtcblx0XHRzZWxmLl9zb2NrZXRUaW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgndGltZW91dCcpXG5cdFx0fSwgc2VsZi5fc29ja2V0VGltZW91dClcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IENsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9kZXN0cm95ZWQgPSB0cnVlXG5cdHNlbGYuX3Jlc2V0VGltZXJzKHRydWUpXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdGVsc2UgaWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblxuXHRpZiAoZXJyKVxuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChjYilcblx0XHRzZWxmLm9uY2UoJ3RpbWVvdXQnLCBjYilcblxuXHRzZWxmLl9zb2NrZXRUaW1lb3V0ID0gdGltZW91dFxuXHRzZWxmLl9yZXNldFRpbWVycyhmYWxzZSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZmx1c2hIZWFkZXJzID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIHJTdGF0ZXMgPSBleHBvcnRzLnJlYWR5U3RhdGVzID0ge1xuXHRVTlNFTlQ6IDAsXG5cdE9QRU5FRDogMSxcblx0SEVBREVSU19SRUNFSVZFRDogMixcblx0TE9BRElORzogMyxcblx0RE9ORTogNFxufVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gZXhwb3J0cy5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbiAoeGhyLCByZXNwb25zZSwgbW9kZSwgcmVzZXRUaW1lcnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5SZWFkYWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fbW9kZSA9IG1vZGVcblx0c2VsZi5oZWFkZXJzID0ge31cblx0c2VsZi5yYXdIZWFkZXJzID0gW11cblx0c2VsZi50cmFpbGVycyA9IHt9XG5cdHNlbGYucmF3VHJhaWxlcnMgPSBbXVxuXG5cdC8vIEZha2UgdGhlICdjbG9zZScgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgJ2VuZCcgZmlyZXNcblx0c2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZSBuZXh0VGljayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB0aGUgJ3JlcXVlc3QnIG1vZHVsZSBmcm9tIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcFxuXHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCdjbG9zZScpXG5cdFx0fSlcblx0fSlcblxuXHRpZiAobW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXG5cdFx0c2VsZi51cmwgPSByZXNwb25zZS51cmxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0XG5cdFx0XG5cdFx0cmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIsIGtleSl7XG5cdFx0XHRzZWxmLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gaGVhZGVyXG5cdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChrZXksIGhlYWRlcilcblx0XHR9KVxuXG5cdFx0aWYgKGNhcGFiaWxpdHkud3JpdGFibGVTdHJlYW0pIHtcblx0XHRcdHZhciB3cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyhmYWxzZSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKHNlbGYucHVzaChCdWZmZXIuZnJvbShjaHVuaykpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSByZXNvbHZlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkucGlwZVRvKHdyaXRhYmxlKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBjYXRjaCAoZSkge30gLy8gcGlwZVRvIG1ldGhvZCBpc24ndCBkZWZpbmVkLiBDYW4ndCBmaW5kIGEgYmV0dGVyIHdheSB0byBmZWF0dXJlIHRlc3QgdGhpc1xuXHRcdH1cblx0XHQvLyBmYWxsYmFjayBmb3Igd2hlbiB3cml0YWJsZVN0cmVhbSBvciBwaXBlVG8gYXJlbid0IGF2YWlsYWJsZVxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRyZXNldFRpbWVycyhyZXN1bHQuZG9uZSlcblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cdH0gZWxzZSB7XG5cdFx0c2VsZi5feGhyID0geGhyXG5cdFx0c2VsZi5fcG9zID0gMFxuXG5cdFx0c2VsZi51cmwgPSB4aHIucmVzcG9uc2VVUkxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0aGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHR2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRcdGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuXHRcdGlmICghY2FwYWJpbGl0eS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHR2YXIgbWltZVR5cGUgPSBzZWxmLnJhd0hlYWRlcnNbJ21pbWUtdHlwZSddXG5cdFx0XHRpZiAobWltZVR5cGUpIHtcblx0XHRcdFx0dmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9KFteO10pKDt8JCkvKVxuXHRcdFx0XHRpZiAoY2hhcnNldE1hdGNoKSB7XG5cdFx0XHRcdFx0c2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghc2VsZi5fY2hhcnNldClcblx0XHRcdFx0c2VsZi5fY2hhcnNldCA9ICd1dGYtOCcgLy8gYmVzdCBndWVzc1xuXHRcdH1cblx0fVxufVxuXG5pbmhlcml0cyhJbmNvbWluZ01lc3NhZ2UsIHN0cmVhbS5SZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHJlc29sdmUgPSBzZWxmLl9yZXN1bWVGZXRjaFxuXHRpZiAocmVzb2x2ZSkge1xuXHRcdHNlbGYuX3Jlc3VtZUZldGNoID0gbnVsbFxuXHRcdHJlc29sdmUoKVxuXHR9XG59XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAocmVzZXRUaW1lcnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0dmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKVxuXHRcdFx0XHRpZiAoc2VsZi5fY2hhcnNldCA9PT0gJ3gtdXNlci1kZWZpbmVkJykge1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSkpXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgJ21zLXN0cmVhbSc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IGdsb2JhbC5NU1N0cmVhbVJlYWRlcigpXG5cdFx0XHRyZWFkZXIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRzZWxmLnB1c2gobnVsbClcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzaGlmdFxuXG5mdW5jdGlvbiBzaGlmdCAoc3RyZWFtKSB7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJzKSByZXR1cm4gbnVsbFxuICByZXR1cm4gKHJzLm9iamVjdE1vZGUgfHwgdHlwZW9mIHN0cmVhbS5fZHVwbGV4U3RhdGUgPT09ICdudW1iZXInKSA/IHN0cmVhbS5yZWFkKCkgOiBzdHJlYW0ucmVhZChnZXRTdGF0ZUxlbmd0aChycykpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlTGVuZ3RoIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgIC8vIFNpbmNlIG5vZGUgNi4zLjAgc3RhdGUuYnVmZmVyIGlzIGEgQnVmZmVyTGlzdCBub3QgYW4gYXJyYXlcbiAgICBpZiAoc3RhdGUuYnVmZmVyLmhlYWQpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoXG59XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGF1ZGlvLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTYuIGF1ZGlvXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gcGFyc2VBdWRpb1R5cGUoc3RyLCBpbnB1dCwgb3V0cHV0KSB7XG4gIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHN0ci5pbmRleE9mKCdpbnB1dCcpID49IDApIHsgcmVzdWx0ID0gJ01pY3JvcGhvbmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignZGlzcGxheSBhdWRpbycpID49IDApIHsgcmVzdWx0ID0gJ1NwZWFrZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignc3BlYWsnKSA+PSAwKSB7IHJlc3VsdCA9ICdTcGVha2VyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2xhdXQnKSA+PSAwKSB7IHJlc3VsdCA9ICdTcGVha2VyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2xvdWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdTcGVha2VyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2hlYWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdIZWFkc2V0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21pYycpID49IDApIHsgcmVzdWx0ID0gJ01pY3JvcGhvbmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbWlrcicpID49IDApIHsgcmVzdWx0ID0gJ01pY3JvcGhvbmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZigncGhvbmUnKSA+PSAwKSB7IHJlc3VsdCA9ICdQaG9uZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdjb250cm9sbCcpID49IDApIHsgcmVzdWx0ID0gJ0NvbnRyb2xsZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbGluZSBvJykgPj0gMCkgeyByZXN1bHQgPSAnTGluZSBPdXQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignZGlnaXRhbCBvJykgPj0gMCkgeyByZXN1bHQgPSAnRGlnaXRhbCBPdXQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignc21hcnQgc291bmQgdGVjaG5vbG9neScpID49IDApIHsgcmVzdWx0ID0gJ0RpZ2l0YWwgU2lnbmFsIFByb2Nlc3Nvcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoaWdoIGRlZmluaXRpb24gYXVkaW8nKSA+PSAwKSB7IHJlc3VsdCA9ICdTb3VuZCBEcml2ZXInOyB9XG5cbiAgaWYgKCFyZXN1bHQgJiYgb3V0cHV0KSB7XG4gICAgcmVzdWx0ID0gJ1NwZWFrZXInO1xuICB9IGVsc2UgaWYgKCFyZXN1bHQgJiYgaW5wdXQpIHtcbiAgICByZXN1bHQgPSAnTWljcm9waG9uZSc7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBnZXRMaW51eEF1ZGlvUGNpKCkge1xuICBsZXQgY21kID0gJ2xzcGNpIC12IDI+L2Rldi9udWxsJztcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnRzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBwYXJ0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgbGluZXMgPSBlbGVtZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgIGlmIChsaW5lcyAmJiBsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhdWRpbycpID49IDApIHtcbiAgICAgICAgY29uc3QgYXVkaW8gPSB7fTtcbiAgICAgICAgYXVkaW8uc2xvdElkID0gbGluZXNbMF0uc3BsaXQoJyAnKVswXTtcbiAgICAgICAgYXVkaW8uZHJpdmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0tlcm5lbCBkcml2ZXIgaW4gdXNlJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnS2VybmVsIG1vZHVsZXMnLCAnOicsIHRydWUpO1xuICAgICAgICByZXN1bHQucHVzaChhdWRpbyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eEF1ZGlvUGNpTU0obGluZXMsIGF1ZGlvUENJKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBzbG90SWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2xvdCcpO1xuXG4gIGNvbnN0IHBjaU1hdGNoID0gYXVkaW9QQ0kuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnNsb3RJZCA9PT0gc2xvdElkOyB9KTtcblxuICByZXN1bHQuaWQgPSBzbG90SWQ7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NEZXZpY2UnKTtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTVmVuZG9yJyk7XG4gIHJlc3VsdC5yZXZpc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSZXYnKTtcbiAgcmVzdWx0LmRyaXZlciA9IHBjaU1hdGNoICYmIHBjaU1hdGNoLmxlbmd0aCA9PT0gMSAmJiBwY2lNYXRjaFswXS5kcml2ZXIgPyBwY2lNYXRjaFswXS5kcml2ZXIgOiAnJztcbiAgcmVzdWx0LmRlZmF1bHQgPSBudWxsO1xuICByZXN1bHQuY2hhbm5lbCA9ICdQQ0llJztcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUF1ZGlvVHlwZShyZXN1bHQubmFtZSwgbnVsbCwgbnVsbCk7XG4gIHJlc3VsdC5pbiA9IG51bGw7XG4gIHJlc3VsdC5vdXQgPSBudWxsO1xuICByZXN1bHQuc3RhdHVzID0gJ29ubGluZSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXJ3aW5DaGFubmVsKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHN0ci5pbmRleE9mKCdidWlsdGluJykgPj0gMCkgeyByZXN1bHQgPSAnQnVpbHQtSW4nOyB9XG4gIGlmIChzdHIuaW5kZXhPZignZXh0ZXJuJykgPj0gMCkgeyByZXN1bHQgPSAnQXVkaW8tSmFjayc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoZG1pJykgPj0gMCkgeyByZXN1bHQgPSAnSERNSSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdkaXNwbGF5cG9ydCcpID49IDApIHsgcmVzdWx0ID0gJ0Rpc3BsYXktUG9ydCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCd1c2InKSA+PSAwKSB7IHJlc3VsdCA9ICdVU0InOyB9XG4gIGlmIChzdHIuaW5kZXhPZigncGNpJykgPj0gMCkgeyByZXN1bHQgPSAnUENJZSc7IH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhcndpbkF1ZGlvKGF1ZGlvT2JqZWN0LCBpZCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgY2hhbm5lbFN0ciA9ICgoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV90cmFuc3BvcnQgfHwgJycpICsgJyAnICsgKGF1ZGlvT2JqZWN0Ll9uYW1lIHx8ICcnKSkudG9Mb3dlckNhc2UoKTtcblxuICByZXN1bHQuaWQgPSBpZDtcbiAgcmVzdWx0Lm5hbWUgPSBhdWRpb09iamVjdC5fbmFtZTtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2VfbWFudWZhY3R1cmVyO1xuICByZXN1bHQucmV2aXNpb24gPSBudWxsO1xuICByZXN1bHQuZHJpdmVyID0gbnVsbDtcbiAgcmVzdWx0LmRlZmF1bHQgPSAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGVmYXVsdF9hdWRpb19pbnB1dF9kZXZpY2UgfHwgJycpIHx8ICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZWZhdWx0X2F1ZGlvX291dHB1dF9kZXZpY2UgfHwgJycpO1xuICByZXN1bHQuY2hhbm5lbCA9IHBhcnNlRGFyd2luQ2hhbm5lbChjaGFubmVsU3RyKTtcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUF1ZGlvVHlwZShyZXN1bHQubmFtZSwgISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV9pbnB1dCB8fCAnJyksICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2Vfb3V0cHV0IHx8ICcnKSk7XG4gIHJlc3VsdC5pbiA9ICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2VfaW5wdXQgfHwgJycpO1xuICByZXN1bHQub3V0ID0gISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV9vdXRwdXQgfHwgJycpO1xuICByZXN1bHQuc3RhdHVzID0gJ29ubGluZSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzQXVkaW8obGluZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHN0YXR1cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGF0dXNJbmZvJywgJzonKTtcblxuICByZXN1bHQuaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGV2aWNlSUQnLCAnOicpOyAvLyBQTlBEZXZpY2VJRD8/XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gIHJlc3VsdC5yZXZpc2lvbiA9IG51bGw7XG4gIHJlc3VsdC5kcml2ZXIgPSBudWxsO1xuICByZXN1bHQuZGVmYXVsdCA9IG51bGw7XG4gIHJlc3VsdC5jaGFubmVsID0gbnVsbDtcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUF1ZGlvVHlwZShyZXN1bHQubmFtZSwgbnVsbCwgbnVsbCk7XG4gIHJlc3VsdC5pbiA9IG51bGw7XG4gIHJlc3VsdC5vdXQgPSBudWxsO1xuICByZXN1bHQuc3RhdHVzID0gc3RhdHVzO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGF1ZGlvKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgbGV0IGNtZCA9ICdsc3BjaSAtdm1tIDI+L2Rldi9udWxsJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgLy8gUENJXG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9QQ0kgPSBnZXRMaW51eEF1ZGlvUGNpKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG5cXG4nKTtcbiAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZWxlbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2xhc3MnLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYXVkaW8nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBwYXJzZUxpbnV4QXVkaW9QY2lNTShsaW5lcywgYXVkaW9QQ0kpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF1ZGlvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIFNQQXVkaW9EYXRhVHlwZSAtanNvbic7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dE9iaiA9IEpTT04ucGFyc2Uoc3Rkb3V0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQQXVkaW9EYXRhVHlwZSAmJiBvdXRPYmouU1BBdWRpb0RhdGFUeXBlLmxlbmd0aCAmJiBvdXRPYmouU1BBdWRpb0RhdGFUeXBlWzBdICYmIG91dE9iai5TUEF1ZGlvRGF0YVR5cGVbMF1bJ19pdGVtcyddICYmIG91dE9iai5TUEF1ZGlvRGF0YVR5cGVbMF1bJ19pdGVtcyddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0T2JqLlNQQXVkaW9EYXRhVHlwZVswXVsnX2l0ZW1zJ10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gcGFyc2VEYXJ3aW5BdWRpbyhvdXRPYmouU1BBdWRpb0RhdGFUeXBlWzBdWydfaXRlbXMnXVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhdWRpbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfU291bmREZXZpY2UgfCBzZWxlY3QgRGV2aWNlSUQsU3RhdHVzSW5mbyxOYW1lLE1hbnVmYWN0dXJlciB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZWxlbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6JykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZVdpbmRvd3NBdWRpbyhsaW5lcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5hdWRpbyA9IGF1ZGlvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gYmF0dGVyeS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDYuIEJhdHRlcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gcGFyc2VXaW5CYXR0ZXJ5UGFydChsaW5lcywgZGVzaWduZWRDYXBhY2l0eSwgZnVsbENoYXJnZUNhcGFjaXR5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBsZXQgc3RhdHVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JhdHRlcnlTdGF0dXMnLCAnOicpLnRyaW0oKTtcbiAgLy8gMSA9IFwiRGlzY2hhcmdpbmdcIlxuICAvLyAyID0gXCJPbiBBL0NcIlxuICAvLyAzID0gXCJGdWxseSBDaGFyZ2VkXCJcbiAgLy8gNCA9IFwiTG93XCJcbiAgLy8gNSA9IFwiQ3JpdGljYWxcIlxuICAvLyA2ID0gXCJDaGFyZ2luZ1wiXG4gIC8vIDcgPSBcIkNoYXJnaW5nIEhpZ2hcIlxuICAvLyA4ID0gXCJDaGFyZ2luZyBMb3dcIlxuICAvLyA5ID0gXCJDaGFyZ2luZyBDcml0aWNhbFwiXG4gIC8vIDEwID0gXCJVbmRlZmluZWRcIlxuICAvLyAxMSA9IFwiUGFydGlhbGx5IENoYXJnZWRcIlxuICBpZiAoc3RhdHVzID49IDApIHtcbiAgICBjb25zdCBzdGF0dXNWYWx1ZSA9IHN0YXR1cyA/IHBhcnNlSW50KHN0YXR1cykgOiAwO1xuICAgIHJlc3VsdC5zdGF0dXMgPSBzdGF0dXNWYWx1ZTtcbiAgICByZXN1bHQuaGFzQmF0dGVyeSA9IHRydWU7XG4gICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gZnVsbENoYXJnZUNhcGFjaXR5IHx8IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXNpZ25DYXBhY2l0eScsICc6JykgfHwgMCk7XG4gICAgcmVzdWx0LmRlc2lnbmVkQ2FwYWNpdHkgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVzaWduQ2FwYWNpdHknLCAnOicpIHx8IGRlc2lnbmVkQ2FwYWNpdHkpO1xuICAgIHJlc3VsdC52b2x0YWdlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Rlc2lnblZvbHRhZ2UnLCAnOicpIHx8IDApIC8gMTAwMC4wO1xuICAgIHJlc3VsdC5jYXBhY2l0eVVuaXQgPSAnbVdoJztcbiAgICByZXN1bHQucGVyY2VudCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdFc3RpbWF0ZWRDaGFyZ2VSZW1haW5pbmcnLCAnOicpIHx8IDApO1xuICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBwYXJzZUludChyZXN1bHQubWF4Q2FwYWNpdHkgKiByZXN1bHQucGVyY2VudCAvIDEwMCk7XG4gICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSAoc3RhdHVzVmFsdWUgPj0gNiAmJiBzdGF0dXNWYWx1ZSA8PSA5KSB8fCBzdGF0dXNWYWx1ZSA9PT0gMTEgfHwgKChzdGF0dXNWYWx1ZSAhPT0gMykgJiYgKHN0YXR1c1ZhbHVlICE9PSAxKSAmJiByZXN1bHQucGVyY2VudCA8IDEwMCk7XG4gICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gcmVzdWx0LmlzQ2hhcmdpbmcgfHwgc3RhdHVzVmFsdWUgPT09IDI7XG4gICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RldmljZUlEJywgJzonKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQuc3RhdHVzID0gLTE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaGFzQmF0dGVyeTogZmFsc2UsXG4gICAgICAgIGN5Y2xlQ291bnQ6IDAsXG4gICAgICAgIGlzQ2hhcmdpbmc6IGZhbHNlLFxuICAgICAgICBkZXNpZ25lZENhcGFjaXR5OiAwLFxuICAgICAgICBtYXhDYXBhY2l0eTogMCxcbiAgICAgICAgY3VycmVudENhcGFjaXR5OiAwLFxuICAgICAgICB2b2x0YWdlOiAwLFxuICAgICAgICBjYXBhY2l0eVVuaXQ6ICcnLFxuICAgICAgICBwZXJjZW50OiAwLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBudWxsLFxuICAgICAgICBhY0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgc2VyaWFsOiAnJ1xuICAgICAgfTtcblxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBsZXQgYmF0dGVyeV9wYXRoID0gJyc7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKCcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9CQVQxL3VldmVudCcpKSB7XG4gICAgICAgICAgYmF0dGVyeV9wYXRoID0gJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0JBVDEvJztcbiAgICAgICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKCcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9CQVQwL3VldmVudCcpKSB7XG4gICAgICAgICAgYmF0dGVyeV9wYXRoID0gJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0JBVDAvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhY0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYWNQYXRoID0gJyc7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKCcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9BQy9vbmxpbmUnKSkge1xuICAgICAgICAgIGFjUGF0aCA9ICcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9BQy9vbmxpbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMoJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0FDMC9vbmxpbmUnKSkge1xuICAgICAgICAgIGFjUGF0aCA9ICcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9BQzAvb25saW5lJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY1BhdGgpIHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gZnMucmVhZEZpbGVTeW5jKGFjUGF0aCk7XG4gICAgICAgICAgYWNDb25uZWN0ZWQgPSBmaWxlLnRvU3RyaW5nKCkudHJpbSgpID09PSAnMSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmF0dGVyeV9wYXRoKSB7XG4gICAgICAgICAgZnMucmVhZEZpbGUoYmF0dGVyeV9wYXRoICsgJ3VldmVudCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICByZXN1bHQuaXNDaGFyZ2luZyA9ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1NUQVRVUycsICc9JykudG9Mb3dlckNhc2UoKSA9PT0gJ2NoYXJnaW5nJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IGFjQ29ubmVjdGVkIHx8IHJlc3VsdC5pc0NoYXJnaW5nO1xuICAgICAgICAgICAgICByZXN1bHQudm9sdGFnZSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfVk9MVEFHRV9OT1cnLCAnPScpLCAxMCkgLyAxMDAwMDAwLjA7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYXBhY2l0eVVuaXQgPSByZXN1bHQudm9sdGFnZSA/ICdtV2gnIDogJ21BaCc7XG4gICAgICAgICAgICAgIHJlc3VsdC5jeWNsZUNvdW50ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DWUNMRV9DT1VOVCcsICc9JyksIDEwKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NIQVJHRV9GVUxMJywgJz0nLCB0cnVlLCB0cnVlKSwgMTApIC8gMTAwMC4wICogKHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgICAgY29uc3QgZGVzaW5nZWRNaW5Wb2x0YWdlID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9WT0xUQUdFX01JTl9ERVNJR04nLCAnPScpLCAxMCkgLyAxMDAwMDAwLjA7XG4gICAgICAgICAgICAgIHJlc3VsdC5kZXNpZ25lZENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NIQVJHRV9GVUxMX0RFU0lHTicsICc9JywgdHJ1ZSwgdHJ1ZSksIDEwKSAvIDEwMDAuMCAqIChkZXNpbmdlZE1pblZvbHRhZ2UgfHwgcmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NIQVJHRV9OT1cnLCAnPScpLCAxMCkgLyAxMDAwLjAgKiAocmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5tYXhDYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfRU5FUkdZX0ZVTEwnLCAnPScsIHRydWUsIHRydWUpLCAxMCkgLyAxMDAwLjA7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRlc2lnbmVkQ2FwYWNpdHkgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0VORVJHWV9GVUxMX0RFU0lHTicsICc9JywgdHJ1ZSwgdHJ1ZSksIDEwKSAvIDEwMDAuMCB8IHJlc3VsdC5tYXhDYXBhY2l0eTtcbiAgICAgICAgICAgICAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9FTkVSR1lfTk9XJywgJz0nKSwgMTApIC8gMTAwMC4wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NBUEFDSVRZJywgJz0nKTtcbiAgICAgICAgICAgICAgY29uc3QgZW5lcmd5ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9FTkVSR1lfTk9XJywgJz0nKSwgMTApO1xuICAgICAgICAgICAgICBjb25zdCBwb3dlciA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfUE9XRVJfTk9XJywgJz0nKSwgMTApO1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DVVJSRU5UX05PVycsICc9JyksIDEwKTtcblxuICAgICAgICAgICAgICByZXN1bHQucGVyY2VudCA9IHBhcnNlSW50KCcwJyArIHBlcmNlbnQsIDEwKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXhDYXBhY2l0eSAmJiByZXN1bHQuY3VycmVudENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnQgPSAxMDAuMCAqIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgLyByZXN1bHQubWF4Q2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNDaGFyZ2luZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW5lcmd5ICYmIHBvd2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRpbWVSZW1haW5pbmcgPSBNYXRoLmZsb29yKGVuZXJneSAvIHBvd2VyICogNjApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgJiYgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aW1lUmVtYWluaW5nID0gTWF0aC5mbG9vcihyZXN1bHQuY3VycmVudENhcGFjaXR5IC8gY3VycmVudCAqIDYwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQudHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfVEVDSE5PTE9HWScsICc9Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfTU9ERUxfTkFNRScsICc9Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX01BTlVGQUNUVVJFUicsICc9Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1NFUklBTF9OVU1CRVInLCAnPScpO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ3N5c2N0bCAtaSBody5hY3BpLmJhdHRlcnkgaHcuYWNwaS5hY2xpbmUnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBjb25zdCBiYXR0ZXJpZXMgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuYWNwaS5iYXR0ZXJ5LnVuaXRzJyksIDEwKTtcbiAgICAgICAgICBjb25zdCBwZXJjZW50ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmFjcGkuYmF0dGVyeS5saWZlJyksIDEwKTtcbiAgICAgICAgICByZXN1bHQuaGFzQmF0dGVyeSA9IChiYXR0ZXJpZXMgPiAwKTtcbiAgICAgICAgICByZXN1bHQuY3ljbGVDb3VudCA9IG51bGw7XG4gICAgICAgICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuYWNwaS5hY2xpbmUnKSAhPT0gJzEnO1xuICAgICAgICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IHJlc3VsdC5pc0NoYXJnaW5nO1xuICAgICAgICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IG51bGw7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IG51bGw7XG4gICAgICAgICAgcmVzdWx0LmNhcGFjaXR5VW5pdCA9ICd1bmtub3duJztcbiAgICAgICAgICByZXN1bHQucGVyY2VudCA9IGJhdHRlcmllcyA/IHBlcmNlbnQgOiBudWxsO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnaW9yZWcgLW4gQXBwbGVTbWFydEJhdHRlcnkgLXIgfCBlZ3JlcCBcIkN5Y2xlQ291bnR8SXNDaGFyZ2luZ3xEZXNpZ25DYXBhY2l0eXxNYXhDYXBhY2l0eXxDdXJyZW50Q2FwYWNpdHl8QmF0dGVyeVNlcmlhbE51bWJlcnxUaW1lUmVtYWluaW5nfFZvbHRhZ2VcIjsgcG1zZXQgLWcgYmF0dCB8IGdyZXAgJScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkucmVwbGFjZSgvICsvZywgJycpLnJlcGxhY2UoL1wiKy9nLCAnJykucmVwbGFjZSgvLS9nLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0LmN5Y2xlQ291bnQgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY3ljbGVjb3VudCcsICc9JyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC52b2x0YWdlID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHRhZ2UnLCAnPScpLCAxMCkgLyAxMDAwLjA7XG4gICAgICAgICAgICByZXN1bHQuY2FwYWNpdHlVbml0ID0gcmVzdWx0LnZvbHRhZ2UgPyAnbVdoJyA6ICdtQWgnO1xuICAgICAgICAgICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYXBwbGVyYXdtYXhjYXBhY2l0eScsICc9JyksIDEwKSAqIChyZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYXBwbGVyYXdjdXJyZW50Y2FwYWNpdHknLCAnPScpLCAxMCkgKiAocmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgcmVzdWx0LmRlc2lnbmVkQ2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXNpZ25DYXBhY2l0eScsICc9JyksIDEwKSAqIChyZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gJ0FwcGxlJztcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQmF0dGVyeVNlcmlhbE51bWJlcicsICc9Jyk7XG4gICAgICAgICAgICBsZXQgcGVyY2VudCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ludGVybmFsJywgJ0JhdHRlcnknKTtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0c1swXSkge1xuICAgICAgICAgICAgICBsZXQgcGFydHMyID0gcGFydHNbMF0uc3BsaXQoJ1xcdCcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMyICYmIHBhcnRzMlsxXSkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBwYXJzZUZsb2F0KHBhcnRzMlsxXS50cmltKCkucmVwbGFjZSgvJS9nLCAnJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHNbMV0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSAocGFydHNbMV0udHJpbSgpID09PSAnY2hhcmdpbmcnKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gKHBhcnRzWzFdLnRyaW0oKSAhPT0gJ2Rpc2NoYXJnaW5nJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQuaXNDaGFyZ2luZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpc2NoYXJnaW5nJywgJz0nKS50b0xvd2VyQ2FzZSgpID09PSAneWVzJztcbiAgICAgICAgICAgICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gcmVzdWx0LmlzQ2hhcmdpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm1heENhcGFjaXR5ICYmIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSB0cnVlO1xuICAgICAgICAgICAgICByZXN1bHQudHlwZSA9ICdMaS1pb24nO1xuICAgICAgICAgICAgICByZXN1bHQucGVyY2VudCA9IHBlcmNlbnQgIT09IG51bGwgPyBwZXJjZW50IDogTWF0aC5yb3VuZCgxMDAuMCAqIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgLyByZXN1bHQubWF4Q2FwYWNpdHkpO1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5pc0NoYXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRpbWVSZW1haW5pbmcgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVGltZVJlbWFpbmluZycsICc9JyksIDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9CYXR0ZXJ5IHwgc2VsZWN0IEJhdHRlcnlTdGF0dXMsIERlc2lnbkNhcGFjaXR5LCBEZXNpZ25Wb2x0YWdlLCBFc3RpbWF0ZWRDaGFyZ2VSZW1haW5pbmcsIERldmljZUlEIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJyhHZXQtQ2ltSW5zdGFuY2UgLUNsYXNzIEJhdHRlcnlTdGF0aWNEYXRhIC1OYW1lc3BhY2UgUk9PVC9XTUkpLkRlc2lnbmVkQ2FwYWNpdHknKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJyhHZXQtQ2ltSW5zdGFuY2UgLUNsYXNzIEJhdHRlcnlGdWxsQ2hhcmdlZENhcGFjaXR5IC1OYW1lc3BhY2UgUk9PVC9XTUkpLkZ1bGxDaGFyZ2VkQ2FwYWNpdHknKSk7XG4gICAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGRhdGEucmVzdWx0c1swXS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICBsZXQgYmF0dGVyaWVzID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdmFsdWUgPT4gL1xcUy8udGVzdCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUocGFydHNbaV0pICYmICghYmF0dGVyaWVzLmxlbmd0aCB8fCAhaGFzVmFsdWUocGFydHNbaSAtIDFdKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJhdHRlcmllcy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgYmF0dGVyaWVzW2JhdHRlcmllcy5sZW5ndGggLSAxXS5wdXNoKHBhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGRlc2lnbkNhcGFjaXRpZXMgPSBkYXRhLnJlc3VsdHNbMV0uc3BsaXQoJ1xcclxcbicpLmZpbHRlcihlID0+IGUpO1xuICAgICAgICAgICAgICBsZXQgZnVsbENoYXJnZUNhcGFjaXRpZXMgPSBkYXRhLnJlc3VsdHNbMl0uc3BsaXQoJ1xcclxcbicpLmZpbHRlcihlID0+IGUpO1xuICAgICAgICAgICAgICBpZiAoYmF0dGVyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBhZGRpdGlvbmFsQmF0dGVyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXR0ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGJhdHRlcmllc1tpXVswXS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkZXNpZ25lZENhcGFjaXR5ID0gZGVzaWduQ2FwYWNpdGllcyAmJiBkZXNpZ25DYXBhY2l0aWVzLmxlbmd0aCA+PSAoaSArIDEpICYmIGRlc2lnbkNhcGFjaXRpZXNbaV0gPyB1dGlsLnRvSW50KGRlc2lnbkNhcGFjaXRpZXNbaV0pIDogMDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxDaGFyZ2VDYXBhY2l0eSA9IGZ1bGxDaGFyZ2VDYXBhY2l0aWVzICYmIGZ1bGxDaGFyZ2VDYXBhY2l0aWVzLmxlbmd0aCA+PSAoaSArIDEpICYmIGZ1bGxDaGFyZ2VDYXBhY2l0aWVzW2ldID8gdXRpbC50b0ludChmdWxsQ2hhcmdlQ2FwYWNpdGllc1tpXSkgOiAwO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VXaW5CYXR0ZXJ5UGFydChsaW5lcywgZGVzaWduZWRDYXBhY2l0eSwgZnVsbENoYXJnZUNhcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QgJiYgcGFyc2VkLnN0YXR1cyA+IDAgJiYgcGFyc2VkLnN0YXR1cyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSBwYXJzZWQuaGFzQmF0dGVyeTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gcGFyc2VkLm1heENhcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGVzaWduZWRDYXBhY2l0eSA9IHBhcnNlZC5kZXNpZ25lZENhcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudm9sdGFnZSA9IHBhcnNlZC52b2x0YWdlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2FwYWNpdHlVbml0ID0gcGFyc2VkLmNhcGFjaXR5VW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnQgPSBwYXJzZWQucGVyY2VudDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IHBhcnNlZC5jdXJyZW50Q2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gcGFyc2VkLmlzQ2hhcmdpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IHBhcnNlZC5hY0Nvbm5lY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gcGFyc2VkLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZC5zdGF0dXMgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxCYXR0ZXJpZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCYXR0ZXJ5OiBwYXJzZWQuaGFzQmF0dGVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENhcGFjaXR5OiBwYXJzZWQubWF4Q2FwYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNpZ25lZENhcGFjaXR5OiBwYXJzZWQuZGVzaWduZWRDYXBhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHRhZ2U6IHBhcnNlZC52b2x0YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHlVbml0OiBwYXJzZWQuY2FwYWNpdHlVbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogcGFyc2VkLnBlcmNlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2FwYWNpdHk6IHBhcnNlZC5jdXJyZW50Q2FwYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYXJnaW5nOiBwYXJzZWQuaXNDaGFyZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVSZW1haW5pbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY0Nvbm5lY3RlZDogcGFyc2VkLmFjQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHBhcnNlZC5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbDogJydcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlyc3QgJiYgYWRkaXRpb25hbEJhdHRlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFkZGl0aW9uYWxCYXR0ZXJpZXNbMF07XG4gICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQmF0dGVyaWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQmF0dGVyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZGl0aW9uYWxCYXR0ZXJpZXMgPSBhZGRpdGlvbmFsQmF0dGVyaWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gYXVkaW8uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxNy4gYmx1ZXRvb3RoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIHBhcnNlQmx1ZXRvb3RoVHlwZShzdHIpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gIGlmIChzdHIuaW5kZXhPZigna2V5Ym9hcmQnKSA+PSAwKSB7IHJlc3VsdCA9ICdLZXlib2FyZCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtb3VzZScpID49IDApIHsgcmVzdWx0ID0gJ01vdXNlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3NwZWFrZXInKSA+PSAwKSB7IHJlc3VsdCA9ICdTcGVha2VyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2hlYWRzZXQnKSA+PSAwKSB7IHJlc3VsdCA9ICdIZWFkc2V0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3Bob25lJykgPj0gMCkgeyByZXN1bHQgPSAnUGhvbmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbWFjYm9vaycpID49IDApIHsgcmVzdWx0ID0gJ0NvbXB1dGVyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2ltYWMnKSA+PSAwKSB7IHJlc3VsdCA9ICdDb21wdXRlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdpcGFkJykgPj0gMCkgeyByZXN1bHQgPSAnVGFibGV0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3dhdGNoJykgPj0gMCkgeyByZXN1bHQgPSAnV2F0Y2gnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaGVhZHBob25lJykgPj0gMCkgeyByZXN1bHQgPSAnSGVhZHNldCc7IH1cbiAgLy8gdG8gYmUgY29udGludWVkIC4uLlxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmx1ZXRvb3RoTWFudWZhY3R1cmVyKHN0cikge1xuICBsZXQgcmVzdWx0ID0gc3RyLnNwbGl0KCcgJylbMF07XG4gIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoc3RyLmluZGV4T2YoJ2FwcGxlJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaXBhZCcpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2ltYWMnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdpcGhvbmUnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtYWdpYyBtb3VzZScpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21hY2Jvb2snKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgLy8gdG8gYmUgY29udGludWVkIC4uLlxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhCbHVldG9vdGhJbmZvKGxpbmVzLCBtYWNBZGRyMSwgbWFjQWRkcjIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgcmVzdWx0LmRldmljZSA9IG51bGw7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnPScpO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gbnVsbDtcbiAgcmVzdWx0Lm1hY0RldmljZSA9IG1hY0FkZHIxO1xuICByZXN1bHQubWFjSG9zdCA9IG1hY0FkZHIyO1xuICByZXN1bHQuYmF0dGVyeVBlcmNlbnQgPSBudWxsO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQmx1ZXRvb3RoVHlwZShyZXN1bHQubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgcmVzdWx0LmNvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGFyd2luQmx1ZXRvb3RoRGV2aWNlcyhibHVldG9vdGhPYmplY3QsIG1hY0FkZHIyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCB0eXBlU3RyID0gKChibHVldG9vdGhPYmplY3QuZGV2aWNlX21pbm9yQ2xhc3NPZkRldmljZV9zdHJpbmcgfHwgYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9tYWpvckNsYXNzT2ZEZXZpY2Vfc3RyaW5nIHx8IGJsdWV0b290aE9iamVjdC5kZXZpY2VfbWlub3JUeXBlIHx8ICcnKSArIChibHVldG9vdGhPYmplY3QuZGV2aWNlX25hbWUgfHwgJycpKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJlc3VsdC5kZXZpY2UgPSBibHVldG9vdGhPYmplY3QuZGV2aWNlX3NlcnZpY2VzIHx8ICcnO1xuICByZXN1bHQubmFtZSA9IGJsdWV0b290aE9iamVjdC5kZXZpY2VfbmFtZSB8fCAnJztcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IGJsdWV0b290aE9iamVjdC5kZXZpY2VfbWFudWZhY3R1cmVyIHx8IHBhcnNlQmx1ZXRvb3RoTWFudWZhY3R1cmVyKGJsdWV0b290aE9iamVjdC5kZXZpY2VfbmFtZSB8fCAnJykgfHwgJyc7XG4gIHJlc3VsdC5tYWNEZXZpY2UgPSAoYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9hZGRyIHx8IGJsdWV0b290aE9iamVjdC5kZXZpY2VfYWRkcmVzcyB8fCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICc6Jyk7XG4gIHJlc3VsdC5tYWNIb3N0ID0gbWFjQWRkcjI7XG4gIHJlc3VsdC5iYXR0ZXJ5UGVyY2VudCA9IGJsdWV0b290aE9iamVjdC5kZXZpY2VfYmF0dGVyeVBlcmNlbnQgfHwgbnVsbDtcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUJsdWV0b290aFR5cGUodHlwZVN0cik7XG4gIHJlc3VsdC5jb25uZWN0ZWQgPSBibHVldG9vdGhPYmplY3QuZGV2aWNlX2lzY29ubmVjdGVkID09PSAnYXR0cmliX1llcycgfHwgZmFsc2U7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzQmx1ZXRvb3RoKGxpbmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIHJlc3VsdC5kZXZpY2UgPSBudWxsO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKTtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICByZXN1bHQubWFjRGV2aWNlID0gbnVsbDtcbiAgcmVzdWx0Lm1hY0hvc3QgPSBudWxsO1xuICByZXN1bHQuYmF0dGVyeVBlcmNlbnQgPSBudWxsO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQmx1ZXRvb3RoVHlwZShyZXN1bHQubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgcmVzdWx0LmNvbm5lY3RlZCA9IG51bGw7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYmx1ZXRvb3RoRGV2aWNlcyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAvLyBnZXQgZmlsZXMgaW4gL3Zhci9saWIvYmx1ZXRvb3RoLyByZWN1cnNpdmVcbiAgICAgICAgY29uc3QgYnRGaWxlcyA9IHV0aWwuZ2V0RmlsZXNJblBhdGgoJy92YXIvbGliL2JsdWV0b290aC8nKTtcbiAgICAgICAgYnRGaWxlcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGVsZW1lbnQpO1xuICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IGVsZW1lbnQuc3BsaXQoJy8nKTtcbiAgICAgICAgICBjb25zdCBtYWNBZGRyMSA9IHBhdGhQYXJ0cy5sZW5ndGggPj0gNiA/IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgICAgICAgIGNvbnN0IG1hY0FkZHIyID0gcGF0aFBhcnRzLmxlbmd0aCA+PSA3ID8gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAzXSA6IG51bGw7XG4gICAgICAgICAgaWYgKGZpbGVuYW1lID09PSAnaW5mbycpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm9GaWxlID0gZnMucmVhZEZpbGVTeW5jKGVsZW1lbnQsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUxpbnV4Qmx1ZXRvb3RoSW5mbyhpbmZvRmlsZSwgbWFjQWRkcjEsIG1hY0FkZHIyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIFwiY29ubmVjdGVkXCIgd2l0aCBoY2l0b29sIGNvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhkaWNvbiA9IGV4ZWNTeW5jKCdoY2l0b29sIGNvbicpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5tYWNEZXZpY2UgJiYgcmVzdWx0W2ldLm1hY0RldmljZS5sZW5ndGggPiAxMCAmJiBoZGljb24uaW5kZXhPZihyZXN1bHRbaV0ubWFjRGV2aWNlLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0W2ldLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIFNQQmx1ZXRvb3RoRGF0YVR5cGUgLWpzb24nO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvdXRPYmogPSBKU09OLnBhcnNlKHN0ZG91dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgaWYgKG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlLmxlbmd0aCAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX3RpdGxlJ10gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV90aXRsZSddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIG1pc3Npbmc6IGhvc3QgQlQgQWRhcHRlciBtYWNBZGRyICgpXG4gICAgICAgICAgICAgICAgbGV0IG1hY0FkZHIyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2xvY2FsX2RldmljZV90aXRsZSddICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmxvY2FsX2RldmljZV90aXRsZS5nZW5lcmFsX2FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIG1hY0FkZHIyID0gb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0ubG9jYWxfZGV2aWNlX3RpdGxlLmdlbmVyYWxfYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJzonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV90aXRsZSddLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmpLZXkgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgICAgICAgaWYgKG9iaktleSAmJiBvYmpLZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyT2JqZWN0ID0gb2JqW29iaktleVswXV07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqZWN0LmRldmljZV9uYW1lID0gb2JqS2V5WzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibHVldG9vdGhEZXZpY2UgPSBwYXJzZURhcndpbkJsdWV0b290aERldmljZXMoaW5uZXJPYmplY3QsIG1hY0FkZHIyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmx1ZXRvb3RoRGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUgJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUubGVuZ3RoICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfY29ubmVjdGVkJ10gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9jb25uZWN0ZWQnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWNBZGRyMiA9IG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcyAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMuY29udHJvbGxlcl9hZGRyZXNzID8gb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzLmNvbnRyb2xsZXJfYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJzonKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9jb25uZWN0ZWQnXS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqS2V5ID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmpLZXkgJiYgb2JqS2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lck9iamVjdCA9IG9ialtvYmpLZXlbMF1dO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iamVjdC5kZXZpY2VfbmFtZSA9IG9iaktleVswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmplY3QuZGV2aWNlX2lzY29ubmVjdGVkID0gJ2F0dHJpYl9ZZXMnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibHVldG9vdGhEZXZpY2UgPSBwYXJzZURhcndpbkJsdWV0b290aERldmljZXMoaW5uZXJPYmplY3QsIG1hY0FkZHIyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmx1ZXRvb3RoRGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUgJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUubGVuZ3RoICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2Vfbm90X2Nvbm5lY3RlZCddICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2Vfbm90X2Nvbm5lY3RlZCddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hY0FkZHIyID0gb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcy5jb250cm9sbGVyX2FkZHJlc3MgPyBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMuY29udHJvbGxlcl9hZGRyZXNzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnOicpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX25vdF9jb25uZWN0ZWQnXS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqS2V5ID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmpLZXkgJiYgb2JqS2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lck9iamVjdCA9IG9ialtvYmpLZXlbMF1dO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iamVjdC5kZXZpY2VfbmFtZSA9IG9iaktleVswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmplY3QuZGV2aWNlX2lzY29ubmVjdGVkID0gJ2F0dHJpYl9Obyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsdWV0b290aERldmljZSA9IHBhcnNlRGFyd2luQmx1ZXRvb3RoRGV2aWNlcyhpbm5lck9iamVjdCwgbWFjQWRkcjIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChibHVldG9vdGhEZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUE5QRW50aXR5IHwgc2VsZWN0IFBOUENsYXNzLCBOYW1lLCBNYW51ZmFjdHVyZXIgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmdldFZhbHVlKHBhcnQuc3BsaXQoJ1xcbicpLCAnUE5QQ2xhc3MnLCAnOicpID09PSAnQmx1ZXRvb3RoJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlV2luZG93c0JsdWV0b290aChwYXJ0LnNwbGl0KCdcXG4nKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9uZXRic2QgfHwgX29wZW5ic2QgfHwgX3N1bm9zKSB7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmJsdWV0b290aERldmljZXMgPSBibHVldG9vdGhEZXZpY2VzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBjcHUuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA0LiBDUFVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5sZXQgX2NwdV9zcGVlZCA9IDA7XG5sZXQgX2N1cnJlbnRfY3B1ID0ge1xuICB1c2VyOiAwLFxuICBuaWNlOiAwLFxuICBzeXN0ZW06IDAsXG4gIGlkbGU6IDAsXG4gIGlycTogMCxcbiAgbG9hZDogMCxcbiAgdGljazogMCxcbiAgbXM6IDAsXG4gIGN1cnJlbnRMb2FkOiAwLFxuICBjdXJyZW50TG9hZFVzZXI6IDAsXG4gIGN1cnJlbnRMb2FkU3lzdGVtOiAwLFxuICBjdXJyZW50TG9hZE5pY2U6IDAsXG4gIGN1cnJlbnRMb2FkSWRsZTogMCxcbiAgY3VycmVudExvYWRJcnE6IDAsXG4gIHJhd0N1cnJlbnRMb2FkOiAwLFxuICByYXdDdXJyZW50TG9hZFVzZXI6IDAsXG4gIHJhd0N1cnJlbnRMb2FkU3lzdGVtOiAwLFxuICByYXdDdXJyZW50TG9hZE5pY2U6IDAsXG4gIHJhd0N1cnJlbnRMb2FkSWRsZTogMCxcbiAgcmF3Q3VycmVudExvYWRJcnE6IDBcbn07XG5sZXQgX2NwdXMgPSBbXTtcbmxldCBfY29yZWNvdW50ID0gMDtcblxuY29uc3QgQU1EQmFzZUZyZXF1ZW5jaWVzID0ge1xuICAnODM0Nic6ICcxLjgnLFxuICAnODM0Nyc6ICcxLjknLFxuICAnODM1MCc6ICcyLjAnLFxuICAnODM1NCc6ICcyLjInLFxuICAnODM1NnxTRSc6ICcyLjQnLFxuICAnODM1Nic6ICcyLjMnLFxuICAnODM2MCc6ICcyLjUnLFxuICAnMjM3Mic6ICcyLjEnLFxuICAnMjM3Myc6ICcyLjEnLFxuICAnMjM3NCc6ICcyLjInLFxuICAnMjM3Nic6ICcyLjMnLFxuICAnMjM3Nyc6ICcyLjMnLFxuICAnMjM3OCc6ICcyLjQnLFxuICAnMjM3OSc6ICcyLjQnLFxuICAnMjM4MCc6ICcyLjUnLFxuICAnMjM4MSc6ICcyLjUnLFxuICAnMjM4Mic6ICcyLjYnLFxuICAnMjM4NCc6ICcyLjcnLFxuICAnMjM4Nic6ICcyLjgnLFxuICAnMjM4Nyc6ICcyLjgnLFxuICAnMjM4OSc6ICcyLjknLFxuICAnMjM5Myc6ICczLjEnLFxuICAnODM3NCc6ICcyLjInLFxuICAnODM3Nic6ICcyLjMnLFxuICAnODM3OCc6ICcyLjQnLFxuICAnODM3OSc6ICcyLjQnLFxuICAnODM4MCc6ICcyLjUnLFxuICAnODM4MSc6ICcyLjUnLFxuICAnODM4Mic6ICcyLjYnLFxuICAnODM4NCc6ICcyLjcnLFxuICAnODM4Nic6ICcyLjgnLFxuICAnODM4Nyc6ICcyLjgnLFxuICAnODM4OSc6ICcyLjknLFxuICAnODM5Myc6ICczLjEnLFxuICAnMjQxOUVFJzogJzEuOCcsXG4gICcyNDIzSEUnOiAnMi4wJyxcbiAgJzI0MjVIRSc6ICcyLjEnLFxuICAnMjQyNyc6ICcyLjInLFxuICAnMjQzMSc6ICcyLjQnLFxuICAnMjQzNSc6ICcyLjYnLFxuICAnMjQzOVNFJzogJzIuOCcsXG4gICc4NDI1SEUnOiAnMi4xJyxcbiAgJzg0MzEnOiAnMi40JyxcbiAgJzg0MzUnOiAnMi42JyxcbiAgJzg0MzlTRSc6ICcyLjgnLFxuICAnNDEyMic6ICcyLjInLFxuICAnNDEzMCc6ICcyLjYnLFxuICAnNDE2MkVFJzogJzEuNycsXG4gICc0MTY0RUUnOiAnMS44JyxcbiAgJzQxNzBIRSc6ICcyLjEnLFxuICAnNDE3NEhFJzogJzIuMycsXG4gICc0MTc2SEUnOiAnMi40JyxcbiAgJzQxODAnOiAnMi42JyxcbiAgJzQxODQnOiAnMi44JyxcbiAgJzYxMjRIRSc6ICcxLjgnLFxuICAnNjEyOEhFJzogJzIuMCcsXG4gICc2MTMySEUnOiAnMi4yJyxcbiAgJzYxMjgnOiAnMi4wJyxcbiAgJzYxMzQnOiAnMi4zJyxcbiAgJzYxMzYnOiAnMi40JyxcbiAgJzYxNDAnOiAnMi42JyxcbiAgJzYxNjRIRSc6ICcxLjcnLFxuICAnNjE2NkhFJzogJzEuOCcsXG4gICc2MTY4JzogJzEuOScsXG4gICc2MTcyJzogJzIuMScsXG4gICc2MTc0JzogJzIuMicsXG4gICc2MTc2JzogJzIuMycsXG4gICc2MTc2U0UnOiAnMi4zJyxcbiAgJzYxODBTRSc6ICcyLjUnLFxuICAnMzI1MCc6ICcyLjUnLFxuICAnMzI2MCc6ICcyLjcnLFxuICAnMzI4MCc6ICcyLjQnLFxuICAnNDIyNic6ICcyLjcnLFxuICAnNDIyOCc6ICcyLjgnLFxuICAnNDIzMCc6ICcyLjknLFxuICAnNDIzNCc6ICczLjEnLFxuICAnNDIzOCc6ICczLjMnLFxuICAnNDI0MCc6ICczLjQnLFxuICAnNDI1Nic6ICcxLjYnLFxuICAnNDI3NCc6ICcyLjUnLFxuICAnNDI3Nic6ICcyLjYnLFxuICAnNDI4MCc6ICcyLjgnLFxuICAnNDI4NCc6ICczLjAnLFxuICAnNjIwNCc6ICczLjMnLFxuICAnNjIxMic6ICcyLjYnLFxuICAnNjIyMCc6ICczLjAnLFxuICAnNjIzNCc6ICcyLjQnLFxuICAnNjIzOCc6ICcyLjYnLFxuICAnNjI2MkhFJzogJzEuNicsXG4gICc2MjcyJzogJzIuMScsXG4gICc2Mjc0JzogJzIuMicsXG4gICc2Mjc2JzogJzIuMycsXG4gICc2Mjc4JzogJzIuNCcsXG4gICc2MjgyU0UnOiAnMi42JyxcbiAgJzYyODRTRSc6ICcyLjcnLFxuICAnNjMwOCc6ICczLjUnLFxuICAnNjMyMCc6ICcyLjgnLFxuICAnNjMyOCc6ICczLjInLFxuICAnNjMzOFAnOiAnMi4zJyxcbiAgJzYzNDQnOiAnMi42JyxcbiAgJzYzNDgnOiAnMi44JyxcbiAgJzYzNjYnOiAnMS44JyxcbiAgJzYzNzBQJzogJzIuMCcsXG4gICc2Mzc2JzogJzIuMycsXG4gICc2Mzc4JzogJzIuNCcsXG4gICc2MzgwJzogJzIuNScsXG4gICc2Mzg2JzogJzIuOCcsXG4gICdGWHw0MTAwJzogJzMuNicsXG4gICdGWHw0MTIwJzogJzMuOScsXG4gICdGWHw0MTMwJzogJzMuOCcsXG4gICdGWHw0MTUwJzogJzMuOCcsXG4gICdGWHw0MTcwJzogJzQuMicsXG4gICdGWHw2MTAwJzogJzMuMycsXG4gICdGWHw2MTIwJzogJzMuNicsXG4gICdGWHw2MTMwJzogJzMuNicsXG4gICdGWHw2MjAwJzogJzMuOCcsXG4gICdGWHw4MTAwJzogJzIuOCcsXG4gICdGWHw4MTIwJzogJzMuMScsXG4gICdGWHw4MTQwJzogJzMuMicsXG4gICdGWHw4MTUwJzogJzMuNicsXG4gICdGWHw4MTcwJzogJzMuOScsXG4gICdGWHw0MzAwJzogJzMuOCcsXG4gICdGWHw0MzIwJzogJzQuMCcsXG4gICdGWHw0MzUwJzogJzQuMicsXG4gICdGWHw2MzAwJzogJzMuNScsXG4gICdGWHw2MzUwJzogJzMuOScsXG4gICdGWHw4MzAwJzogJzMuMycsXG4gICdGWHw4MzEwJzogJzMuNCcsXG4gICdGWHw4MzIwJzogJzMuNScsXG4gICdGWHw4MzUwJzogJzQuMCcsXG4gICdGWHw4MzcwJzogJzQuMCcsXG4gICdGWHw5MzcwJzogJzQuNCcsXG4gICdGWHw5NTkwJzogJzQuNycsXG4gICdGWHw4MzIwRSc6ICczLjInLFxuICAnRlh8ODM3MEUnOiAnMy4zJyxcblxuICAvLyBaRU4gRGVza3RvcCBDUFVzXG4gICcxMjAwJzogJzMuMScsXG4gICdQcm8gMTIwMCc6ICczLjEnLFxuICAnMTMwMFgnOiAnMy41JyxcbiAgJ1BybyAxMzAwJzogJzMuNScsXG4gICcxNDAwJzogJzMuMicsXG4gICcxNTAwWCc6ICczLjUnLFxuICAnUHJvIDE1MDAnOiAnMy41JyxcbiAgJzE2MDAnOiAnMy4yJyxcbiAgJzE2MDBYJzogJzMuNicsXG4gICdQcm8gMTYwMCc6ICczLjInLFxuICAnMTcwMCc6ICczLjAnLFxuICAnUHJvIDE3MDAnOiAnMy4wJyxcbiAgJzE3MDBYJzogJzMuNCcsXG4gICdQcm8gMTcwMFgnOiAnMy40JyxcbiAgJzE4MDBYJzogJzMuNicsXG4gICcxOTAwWCc6ICczLjgnLFxuICAnMTkyMCc6ICczLjInLFxuICAnMTkyMFgnOiAnMy41JyxcbiAgJzE5NTBYJzogJzMuNCcsXG5cbiAgLy8gWkVOIERlc2t0b3AgQVBVc1xuICAnMjAwR0UnOiAnMy4yJyxcbiAgJ1BybyAyMDBHRSc6ICczLjInLFxuICAnMjIwR0UnOiAnMy40JyxcbiAgJzI0MEdFJzogJzMuNScsXG4gICczMDAwRyc6ICczLjUnLFxuICAnMzAwR0UnOiAnMy40JyxcbiAgJzMwNTBHRSc6ICczLjQnLFxuICAnMjIwMEcnOiAnMy41JyxcbiAgJ1BybyAyMjAwRyc6ICczLjUnLFxuICAnMjIwMEdFJzogJzMuMicsXG4gICdQcm8gMjIwMEdFJzogJzMuMicsXG4gICcyNDAwRyc6ICczLjYnLFxuICAnUHJvIDI0MDBHJzogJzMuNicsXG4gICcyNDAwR0UnOiAnMy4yJyxcbiAgJ1BybyAyNDAwR0UnOiAnMy4yJyxcblxuICAvLyBaRU4gTW9iaWxlIEFQVXNcbiAgJ1BybyAyMDBVJzogJzIuMycsXG4gICczMDBVJzogJzIuNCcsXG4gICcyMjAwVSc6ICcyLjUnLFxuICAnMzIwMFUnOiAnMi42JyxcbiAgJzIzMDBVJzogJzIuMCcsXG4gICdQcm8gMjMwMFUnOiAnMi4wJyxcbiAgJzI1MDBVJzogJzIuMCcsXG4gICdQcm8gMjUwMFUnOiAnMi4yJyxcbiAgJzI2MDBIJzogJzMuMicsXG4gICcyNzAwVSc6ICcyLjAnLFxuICAnUHJvIDI3MDBVJzogJzIuMicsXG4gICcyODAwSCc6ICczLjMnLFxuXG4gIC8vIFpFTiBTZXJ2ZXIgUHJvY2Vzc29yc1xuICAnNzM1MSc6ICcyLjQnLFxuICAnNzM1MVAnOiAnMi40JyxcbiAgJzc0MDEnOiAnMi4wJyxcbiAgJzc0MDFQJzogJzIuMCcsXG4gICc3NTUxUCc6ICcyLjAnLFxuICAnNzU1MSc6ICcyLjAnLFxuICAnNzI1MSc6ICcyLjEnLFxuICAnNzI2MSc6ICcyLjUnLFxuICAnNzI4MSc6ICcyLjEnLFxuICAnNzMwMSc6ICcyLjInLFxuICAnNzM3MSc6ICczLjEnLFxuICAnNzQ1MSc6ICcyLjMnLFxuICAnNzUwMSc6ICcyLjAnLFxuICAnNzU3MSc6ICcyLjInLFxuICAnNzYwMSc6ICcyLjInLFxuXG4gIC8vIFpFTiBFbWJlZGRlZCBQcm9jZXNzb3JzXG4gICdWMTUwMEInOiAnMi4yJyxcbiAgJ1YxNzgwQic6ICczLjM1JyxcbiAgJ1YxMjAyQic6ICcyLjMnLFxuICAnVjE0MDRJJzogJzIuMCcsXG4gICdWMTYwNUInOiAnMi4wJyxcbiAgJ1YxNzU2Qic6ICczLjI1JyxcbiAgJ1YxODA3Qic6ICczLjM1JyxcblxuICAnMzEwMSc6ICcyLjEnLFxuICAnMzE1MSc6ICcyLjcnLFxuICAnMzIwMSc6ICcxLjUnLFxuICAnMzI1MSc6ICcyLjUnLFxuICAnMzI1NSc6ICcyLjUnLFxuICAnMzMwMSc6ICcyLjAnLFxuICAnMzM1MSc6ICcxLjknLFxuICAnMzQwMSc6ICcxLjg1JyxcbiAgJzM0NTEnOiAnMi4xNScsXG5cbiAgLy8gWkVOKyBEZXNrdG9wXG4gICcxMjAwfEFGJzogJzMuMScsXG4gICcyMzAwWCc6ICczLjUnLFxuICAnMjUwMFgnOiAnMy42JyxcbiAgJzI2MDAnOiAnMy40JyxcbiAgJzI2MDBFJzogJzMuMScsXG4gICcxNjAwfEFGJzogJzMuMicsXG4gICcyNjAwWCc6ICczLjYnLFxuICAnMjcwMCc6ICczLjInLFxuICAnMjcwMEUnOiAnMi44JyxcbiAgJ1BybyAyNzAwJzogJzMuMicsXG4gICcyNzAwWCc6ICczLjcnLFxuICAnUHJvIDI3MDBYJzogJzMuNicsXG4gICcyOTIwWCc6ICczLjUnLFxuICAnMjk1MFgnOiAnMy41JyxcbiAgJzI5NzBXWCc6ICczLjAnLFxuICAnMjk5MFdYJzogJzMuMCcsXG5cbiAgLy8gWkVOKyBEZXNrdG9wIEFQVVxuICAnUHJvIDMwMEdFJzogJzMuNCcsXG4gICdQcm8gMzEyNUdFJzogJzMuNCcsXG4gICczMTUwRyc6ICczLjUnLFxuICAnUHJvIDMxNTBHJzogJzMuNScsXG4gICczMTUwR0UnOiAnMy4zJyxcbiAgJ1BybyAzMTUwR0UnOiAnMy4zJyxcbiAgJzMyMDBHJzogJzMuNicsXG4gICdQcm8gMzIwMEcnOiAnMy42JyxcbiAgJzMyMDBHRSc6ICczLjMnLFxuICAnUHJvIDMyMDBHRSc6ICczLjMnLFxuICAnMzM1MEcnOiAnMy42JyxcbiAgJ1BybyAzMzUwRyc6ICczLjYnLFxuICAnMzM1MEdFJzogJzMuMycsXG4gICdQcm8gMzM1MEdFJzogJzMuMycsXG4gICczNDAwRyc6ICczLjcnLFxuICAnUHJvIDM0MDBHJzogJzMuNycsXG4gICczNDAwR0UnOiAnMy4zJyxcbiAgJ1BybyAzNDAwR0UnOiAnMy4zJyxcblxuICAvLyBaRU4rIE1vYmlsZVxuICAnMzMwMFUnOiAnMi4xJyxcbiAgJ1BSTyAzMzAwVSc6ICcyLjEnLFxuICAnMzQ1MFUnOiAnMi4xJyxcbiAgJzM1MDBVJzogJzIuMScsXG4gICdQUk8gMzUwMFUnOiAnMi4xJyxcbiAgJzM1MDBDJzogJzIuMScsXG4gICczNTUwSCc6ICcyLjEnLFxuICAnMzU4MFUnOiAnMi4xJyxcbiAgJzM3MDBVJzogJzIuMycsXG4gICdQUk8gMzcwMFUnOiAnMi4zJyxcbiAgJzM3MDBDJzogJzIuMycsXG4gICczNzUwSCc6ICcyLjMnLFxuICAnMzc4MFUnOiAnMi4zJyxcblxuICAvLyBaRU4yIERlc2t0b3AgQ1BVU1xuICAnMzEwMCc6ICczLjYnLFxuICAnMzMwMFgnOiAnMy44JyxcbiAgJzM1MDAnOiAnMy42JyxcbiAgJzM1MDBYJzogJzMuNicsXG4gICczNjAwJzogJzMuNicsXG4gICdQcm8gMzYwMCc6ICczLjYnLFxuICAnMzYwMFgnOiAnMy44JyxcbiAgJzM2MDBYVCc6ICczLjgnLFxuICAnUHJvIDM3MDAnOiAnMy42JyxcbiAgJzM3MDBYJzogJzMuNicsXG4gICczODAwWCc6ICczLjknLFxuICAnMzgwMFhUJzogJzMuOScsXG4gICczOTAwJzogJzMuMScsXG4gICdQcm8gMzkwMCc6ICczLjEnLFxuICAnMzkwMFgnOiAnMy44JyxcbiAgJzM5MDBYVCc6ICczLjgnLFxuICAnMzk1MFgnOiAnMy41JyxcbiAgJzM5NjBYJzogJzMuOCcsXG4gICczOTcwWCc6ICczLjcnLFxuICAnMzk5MFgnOiAnMi45JyxcbiAgJzM5NDVXWCc6ICc0LjAnLFxuICAnMzk1NVdYJzogJzMuOScsXG4gICczOTc1V1gnOiAnMy41JyxcbiAgJzM5OTVXWCc6ICcyLjcnLFxuXG4gIC8vIFpFTjIgRGVza3RvcCBBUFVzXG4gICc0MzAwR0UnOiAnMy41JyxcbiAgJ1BybyA0MzAwR0UnOiAnMy41JyxcbiAgJzQzMDBHJzogJzMuOCcsXG4gICdQcm8gNDMwMEcnOiAnMy44JyxcbiAgJzQ2MDBHRSc6ICczLjMnLFxuICAnUHJvIDQ2NTBHRSc6ICczLjMnLFxuICAnNDYwMEcnOiAnMy43JyxcbiAgJ1BybyA0NjUwRyc6ICczLjcnLFxuICAnNDcwMEdFJzogJzMuMScsXG4gICdQcm8gNDc1MEdFJzogJzMuMScsXG4gICc0NzAwRyc6ICczLjYnLFxuICAnUHJvIDQ3NTBHJzogJzMuNicsXG4gICc0MzAwVSc6ICcyLjcnLFxuICAnNDQ1MFUnOiAnMi41JyxcbiAgJ1BybyA0NDUwVSc6ICcyLjUnLFxuICAnNDUwMFUnOiAnMi4zJyxcbiAgJzQ2MDBVJzogJzIuMScsXG4gICdQUk8gNDY1MFUnOiAnMi4xJyxcbiAgJzQ2ODBVJzogJzIuMScsXG4gICc0NjAwSFMnOiAnMy4wJyxcbiAgJzQ2MDBIJzogJzMuMCcsXG4gICc0NzAwVSc6ICcyLjAnLFxuICAnUFJPIDQ3NTBVJzogJzEuNycsXG4gICc0ODAwVSc6ICcxLjgnLFxuICAnNDgwMEhTJzogJzIuOScsXG4gICc0ODAwSCc6ICcyLjknLFxuICAnNDkwMEhTJzogJzMuMCcsXG4gICc0OTAwSCc6ICczLjMnLFxuICAnNTMwMFUnOiAnMi42JyxcbiAgJzU1MDBVJzogJzIuMScsXG4gICc1NzAwVSc6ICcxLjgnLFxuXG4gIC8vIFpFTjIgLSBFUFlDXG4gICc3MjMyUCc6ICczLjEnLFxuICAnNzMwMlAnOiAnMy4wJyxcbiAgJzc0MDJQJzogJzIuOCcsXG4gICc3NTAyUCc6ICcyLjUnLFxuICAnNzcwMlAnOiAnMi4wJyxcbiAgJzcyNTInOiAnMy4xJyxcbiAgJzcyNjInOiAnMy4yJyxcbiAgJzcyNzInOiAnMi45JyxcbiAgJzcyODInOiAnMi44JyxcbiAgJzczMDInOiAnMy4wJyxcbiAgJzczNTInOiAnMi4zJyxcbiAgJzc0MDInOiAnMi44JyxcbiAgJzc0NTInOiAnMi4zNScsXG4gICc3NTAyJzogJzIuNScsXG4gICc3NTMyJzogJzIuNCcsXG4gICc3NTQyJzogJzIuOScsXG4gICc3NTUyJzogJzIuMicsXG4gICc3NjQyJzogJzIuMycsXG4gICc3NjYyJzogJzIuMCcsXG4gICc3NzAyJzogJzIuMCcsXG4gICc3NzQyJzogJzIuMjUnLFxuICAnN0gxMic6ICcyLjYnLFxuICAnN0YzMic6ICczLjcnLFxuICAnN0Y1Mic6ICczLjUnLFxuICAnN0Y3Mic6ICczLjInLFxuXG4gIC8vIEVweWMgKE1pbGFuKVxuXG4gICc3NzYzJzogJzIuNDUnLFxuICAnNzcxMyc6ICcyLjAnLFxuICAnNzcxM1AnOiAnMi4wJyxcbiAgJzc2NjMnOiAnMi4wJyxcbiAgJzc2NDMnOiAnMi4zJyxcbiAgJzc1RjMnOiAnMi45NScsXG4gICc3NTQzJzogJzIuOCcsXG4gICc3NTQzUCc6ICcyLjgnLFxuICAnNzUxMyc6ICcyLjYnLFxuICAnNzQ1Myc6ICcyLjc1JyxcbiAgJzc0RjMnOiAnMy4yJyxcbiAgJzc0NDMnOiAnMi44NScsXG4gICc3NDQzUCc6ICcyLjg1JyxcbiAgJzc0MTMnOiAnMi42NScsXG4gICc3M0YzJzogJzMuNScsXG4gICc3MzQzJzogJzMuMicsXG4gICc3MzEzJzogJzMuMCcsXG4gICc3MzEzUCc6ICczLjAnLFxuICAnNzJGMyc6ICczLjcnLFxuXG4gIC8vIFpFTjNcbiAgJzU2MDBYJzogJzMuNycsXG4gICc1ODAwWCc6ICczLjgnLFxuICAnNTkwMFgnOiAnMy43JyxcbiAgJzU5NTBYJzogJzMuNCdcbn07XG5cblxuY29uc3Qgc29ja2V0VHlwZXMgPSB7XG4gIDE6ICdPdGhlcicsXG4gIDI6ICdVbmtub3duJyxcbiAgMzogJ0RhdWdodGVyIEJvYXJkJyxcbiAgNDogJ1pJRiBTb2NrZXQnLFxuICA1OiAnUmVwbGFjZW1lbnQvUGlnZ3kgQmFjaycsXG4gIDY6ICdOb25lJyxcbiAgNzogJ0xJRiBTb2NrZXQnLFxuICA4OiAnU2xvdCAxJyxcbiAgOTogJ1Nsb3QgMicsXG4gIDEwOiAnMzcwIFBpbiBTb2NrZXQnLFxuICAxMTogJ1Nsb3QgQScsXG4gIDEyOiAnU2xvdCBNJyxcbiAgMTM6ICc0MjMnLFxuICAxNDogJ0EgKFNvY2tldCA0NjIpJyxcbiAgMTU6ICc0NzgnLFxuICAxNjogJzc1NCcsXG4gIDE3OiAnOTQwJyxcbiAgMTg6ICc5MzknLFxuICAxOTogJ21QR0E2MDQnLFxuICAyMDogJ0xHQTc3MScsXG4gIDIxOiAnTEdBNzc1JyxcbiAgMjI6ICdTMScsXG4gIDIzOiAnQU0yJyxcbiAgMjQ6ICdGICgxMjA3KScsXG4gIDI1OiAnTEdBMTM2NicsXG4gIDI2OiAnRzM0JyxcbiAgMjc6ICdBTTMnLFxuICAyODogJ0MzMicsXG4gIDI5OiAnTEdBMTE1NicsXG4gIDMwOiAnTEdBMTU2NycsXG4gIDMxOiAnUEdBOTg4QScsXG4gIDMyOiAnQkdBMTI4OCcsXG4gIDMzOiAnclBHQTk4OEInLFxuICAzNDogJ0JHQTEwMjMnLFxuICAzNTogJ0JHQTEyMjQnLFxuICAzNjogJ0xHQTExNTUnLFxuICAzNzogJ0xHQTEzNTYnLFxuICAzODogJ0xHQTIwMTEnLFxuICAzOTogJ0ZTMScsXG4gIDQwOiAnRlMyJyxcbiAgNDE6ICdGTTEnLFxuICA0MjogJ0ZNMicsXG4gIDQzOiAnTEdBMjAxMS0zJyxcbiAgNDQ6ICdMR0ExMzU2LTMnLFxuICA0NTogJ0xHQTExNTAnLFxuICA0NjogJ0JHQTExNjgnLFxuICA0NzogJ0JHQTEyMzQnLFxuICA0ODogJ0JHQTEzNjQnLFxuICA0OTogJ0FNNCcsXG4gIDUwOiAnTEdBMTE1MScsXG4gIDUxOiAnQkdBMTM1NicsXG4gIDUyOiAnQkdBMTQ0MCcsXG4gIDUzOiAnQkdBMTUxNScsXG4gIDU0OiAnTEdBMzY0Ny0xJyxcbiAgNTU6ICdTUDMnLFxuICA1NjogJ1NQM3IyJyxcbiAgNTc6ICdMR0EyMDY2JyxcbiAgNTg6ICdCR0ExMzkyJyxcbiAgNTk6ICdCR0ExNTEwJyxcbiAgNjA6ICdCR0ExNTI4JyxcbiAgNjE6ICdMR0E0MTg5JyxcbiAgNjI6ICdMR0ExMjAwJyxcbiAgNjM6ICdMR0E0Njc3Jyxcbn07XG5cbmNvbnN0IHNvY2tldFR5cGVzQnlOYW1lID0ge1xuICAnTEdBMTE1MCc6ICdpNy01Nzc1QyBpMy00MzQwIGkzLTQxNzAgRzMyNTAgaTMtNDE2MFQgaTMtNDE2MCBFMy0xMjMxIEczMjU4IEczMjQwIGk3LTQ3OTBTIGk3LTQ3OTBLIGk3LTQ3OTAgaTUtNDY5MEsgaTUtNDY5MCBpNS00NTkwVCBpNS00NTkwUyBpNS00NTkwIGk1LTQ0NjAgaTMtNDM2MCBpMy00MTUwIEcxODIwIEczNDIwIEczMjIwIGk3LTQ3NzEgaTUtNDQ0MCBpMy00MzMwIGkzLTQxMzBUIGkzLTQxMzAgRTMtMTIzMCBpNy00NzcwUyBpNy00NzcwSyBpNy00NzcwIGk1LTQ2NzBLIGk1LTQ2NzAgaTUtNDU3MFQgaTUtNDU3MFMgaTUtNDU3MCBpNS00NDMwJyxcbiAgJ0xHQTExNTEnOiAnaTktOTkwMEtTIEUtMjI4OEcgRS0yMjI0IEc1NDIwIGk5LTk5MDBUIGk5LTk5MDAgaTctOTcwMFQgaTctOTcwMEYgaTctOTcwMEUgaTctOTcwMCBpNS05NjAwIGk1LTk1MDBUIGk1LTk1MDBGIGk1LTk1MDAgaTUtOTQwMFQgaTMtOTM1MEsgaTMtOTMwMCBpMy05MTAwVCBpMy05MTAwRiBpMy05MTAwIEc0OTMwIGk5LTk5MDBLRiBpNy05NzAwS0YgaTUtOTYwMEtGIGk1LTk0MDBGIGk1LTk0MDAgaTMtOTM1MEtGIGk5LTk5MDBLIGk3LTk3MDBLIGk1LTk2MDBLIEc1NTAwIEc1NDAwIGk3LTg3MDBUIGk3LTgwODZLIGk1LTg2MDAgaTUtODUwMFQgaTUtODUwMCBpNS04NDAwVCBpMy04MzAwIGkzLTgxMDBUIEc0OTAwIGk3LTg3MDBLIGk3LTg3MDAgaTUtODYwMEsgaTUtODQwMCBpMy04MzUwSyBpMy04MTAwIEUzLTEyNzAgRzQ2MDAgRzQ1NjAgaTctNzcwMFQgaTctNzcwMEsgaTctNzcwMCBpNS03NjAwSyBpNS03NjAwIGk1LTc1MDBUIGk1LTc1MDAgaTUtNzQwMCBpMy03MzUwSyBpMy03MzAwIGkzLTcxMDBUIGkzLTcxMDAgRzM5MzAgRzM5MDAgRzQ0MDAgaTctNjcwMFQgaTctNjcwMEsgaTctNjcwMCBpNS02NjAwSyBpNS02NjAwIGk1LTY1MDBUIGk1LTY1MDAgaTUtNjQwMFQgaTUtNjQwMCBpMy02MzAwIGkzLTYxMDBUIGkzLTYxMDAgRTMtMTI3MCBFMy0xMjcwIFQ0NTAwIFQ0NDAwJyxcbiAgJzExNTUnOiAnRzQ0MCBHNDYwIEc0NjUgRzQ3MCBHNTMwVCBHNTQwVCBHNTUwVCBHMTYxMFQgRzE2MjBUIEc1MzAgRzU0MCBHMTYxMCBHNTUwIEcxNjIwIEc1NTUgRzE2MzAgaTMtMjEwMFQgaTMtMjEyMFQgaTMtMzIyMFQgaTMtMzI0MFQgaTMtMzI1MFQgaTMtMjEwMCBpMy0yMTA1IGkzLTIxMDIgaTMtMzIxMCBpMy0zMjIwIGkzLTIxMjUgaTMtMjEyMCBpMy0zMjI1IGkzLTIxMzAgaTMtMzI0NSBpMy0zMjQwIGkzLTMyNTAgaTUtMzU3MFQgaTUtMjUwMFQgaTUtMjQwMFMgaTUtMjQwNVMgaTUtMjM5MFQgaTUtMzMzMFMgaTUtMjUwMFMgaTUtMzMzNVMgaTUtMjMwMCBpNS0zNDUwUyBpNS0zMzQwUyBpNS0zNDcwUyBpNS0zNDc1UyBpNS0zNDcwVCBpNS0yMzEwIGk1LTM1NTBTIGk1LTIzMjAgaTUtMzMzMCBpNS0zMzUwUCBpNS0zNDUwIGk1LTI0MDAgaTUtMzM0MCBpNS0zNTcwUyBpNS0yMzgwUCBpNS0yNDUwUCBpNS0zNDcwIGk1LTI1MDBLIGk1LTM1NTAgaTUtMjUwMCBpNS0zNTcwIGk1LTM1NzBLIGk1LTI1NTBLIGk3LTM3NzBUIGk3LTI2MDBTIGk3LTM3NzBTIGk3LTI2MDBLIGk3LTI2MDAgaTctMzc3MCBpNy0zNzcwSyBpNy0yNzAwSyBHNjIwVCBHNjMwVCBHNjQwVCBHMjAyMFQgRzY0NVQgRzIxMDBUIEcyMDMwVCBHNjIyIEc4NjBUIEc2MjAgRzYzMiBHMjEyMFQgRzYzMCBHNjQwIEcyMDEwIEc4NDAgRzIwMjAgRzg1MCBHNjQ1IEcyMDMwIEc4NjAgRzIxMjAgRzg3MCBHMjEzMCBHMjE0MCBFMy0xMjIwTCBFMy0xMjIwTCBFMy0xMjYwTCBFMy0xMjY1TCBFMy0xMjIwIEUzLTEyMjUgRTMtMTIyMCBFMy0xMjM1IEUzLTEyMjUgRTMtMTIzMCBFMy0xMjMwIEUzLTEyNDAgRTMtMTI0NSBFMy0xMjcwIEUzLTEyNzUgRTMtMTI0MCBFMy0xMjQ1IEUzLTEyNzAgRTMtMTI4MCBFMy0xMjc1IEUzLTEyOTAgRTMtMTI4MCBFMy0xMjkwJ1xufTtcblxuZnVuY3Rpb24gZ2V0U29ja2V0VHlwZXNCeU5hbWUoc3RyKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChjb25zdCBrZXkgaW4gc29ja2V0VHlwZXNCeU5hbWUpIHtcbiAgICBjb25zdCBuYW1lcyA9IHNvY2tldFR5cGVzQnlOYW1lW2tleV0uc3BsaXQoJyAnKTtcbiAgICBuYW1lcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKGVsZW1lbnQpID49IDApIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNwdU1hbnVmYWN0dXJlcihzdHIpIHtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ci5pbmRleE9mKCdpbnRlbCcpID49IDApIHsgcmVzdWx0ID0gJ0ludGVsJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2FtZCcpID49IDApIHsgcmVzdWx0ID0gJ0FNRCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdxZW11JykgPj0gMCkgeyByZXN1bHQgPSAnUUVNVSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoeWdvbicpID49IDApIHsgcmVzdWx0ID0gJ0h5Z29uJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2NlbnRhdXInKSA+PSAwKSB7IHJlc3VsdCA9ICdXaW5DaGlwL1ZpYSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCd2bXdhcmUnKSA+PSAwKSB7IHJlc3VsdCA9ICdWTXdhcmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignWGVuJykgPj0gMCkgeyByZXN1bHQgPSAnWGVuIEh5cGVydmlzb3InOyB9XG4gIGlmIChzdHIuaW5kZXhPZigndGNnJykgPj0gMCkgeyByZXN1bHQgPSAnUUVNVSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdhcHBsZScpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNwdUJyYW5kTWFudWZhY3R1cmVyKHJlcykge1xuICByZXMuYnJhbmQgPSByZXMuYnJhbmQucmVwbGFjZSgvXFwoUlxcKSsvZywgJ8KuJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgcmVzLmJyYW5kID0gcmVzLmJyYW5kLnJlcGxhY2UoL1xcKFRNXFwpKy9nLCAn4oSiJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgcmVzLmJyYW5kID0gcmVzLmJyYW5kLnJlcGxhY2UoL1xcKENcXCkrL2csICfCqScpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gIHJlcy5icmFuZCA9IHJlcy5icmFuZC5yZXBsYWNlKC9DUFUrL2csICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICByZXMubWFudWZhY3R1cmVyID0gY3B1TWFudWZhY3R1cmVyKHJlcy5icmFuZCk7XG5cbiAgbGV0IHBhcnRzID0gcmVzLmJyYW5kLnNwbGl0KCcgJyk7XG4gIHBhcnRzLnNoaWZ0KCk7XG4gIHJlcy5icmFuZCA9IHBhcnRzLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0QU1EU3BlZWQoYnJhbmQpIHtcbiAgbGV0IHJlc3VsdCA9ICcwJztcbiAgZm9yIChsZXQga2V5IGluIEFNREJhc2VGcmVxdWVuY2llcykge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEFNREJhc2VGcmVxdWVuY2llcywga2V5KSkge1xuICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0KCd8Jyk7XG4gICAgICBsZXQgZm91bmQgPSAwO1xuICAgICAgcGFydHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGJyYW5kLmluZGV4T2YoaXRlbSkgPiAtMSkge1xuICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZvdW5kID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gQU1EQmFzZUZyZXF1ZW5jaWVzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KHJlc3VsdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgLSBicmFuZCwgc3BlZWRcblxuZnVuY3Rpb24gZ2V0Q3B1KCkge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3QgVU5LTk9XTiA9ICd1bmtub3duJztcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG1hbnVmYWN0dXJlcjogVU5LTk9XTixcbiAgICAgICAgYnJhbmQ6IFVOS05PV04sXG4gICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgIGZhbWlseTogJycsXG4gICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgc3RlcHBpbmc6ICcnLFxuICAgICAgICByZXZpc2lvbjogJycsXG4gICAgICAgIHZvbHRhZ2U6ICcnLFxuICAgICAgICBzcGVlZDogMCxcbiAgICAgICAgc3BlZWRNaW46IDAsXG4gICAgICAgIHNwZWVkTWF4OiAwLFxuICAgICAgICBnb3Zlcm5vcjogJycsXG4gICAgICAgIGNvcmVzOiB1dGlsLmNvcmVzKCksXG4gICAgICAgIHBoeXNpY2FsQ29yZXM6IHV0aWwuY29yZXMoKSxcbiAgICAgICAgcGVyZm9ybWFuY2VDb3JlczogdXRpbC5jb3JlcygpLFxuICAgICAgICBlZmZpY2llbmN5Q29yZXM6IDAsXG4gICAgICAgIHByb2Nlc3NvcnM6IDEsXG4gICAgICAgIHNvY2tldDogJycsXG4gICAgICAgIGZsYWdzOiAnJyxcbiAgICAgICAgdmlydHVhbGl6YXRpb246IGZhbHNlLFxuICAgICAgICBjYWNoZToge31cbiAgICAgIH07XG4gICAgICBjcHVGbGFncygpLnRoZW4oZmxhZ3MgPT4ge1xuICAgICAgICByZXN1bHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgcmVzdWx0LnZpcnR1YWxpemF0aW9uID0gZmxhZ3MuaW5kZXhPZigndm14JykgPiAtMSB8fCBmbGFncy5pbmRleE9mKCdzdm0nKSA+IC0xO1xuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIGV4ZWMoJ3N5c2N0bCBtYWNoZGVwLmNwdSBody5jcHVmcmVxdWVuY3lfbWF4IGh3LmNwdWZyZXF1ZW5jeV9taW4gaHcucGFja2FnZXMgaHcucGh5c2ljYWxjcHVfbWF4IGh3Lm5jcHUgaHcudGJmcmVxdWVuY3kgaHcuY3B1ZmFtaWx5IGh3LmNwdXN1YmZhbWlseScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBtb2RlbGxpbmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5jcHUuYnJhbmRfc3RyaW5nJyk7XG4gICAgICAgICAgICBjb25zdCBtb2RlbGxpbmVQYXJ0cyA9IG1vZGVsbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gbW9kZWxsaW5lUGFydHNbMF0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3Qgc3BlZWQgPSBtb2RlbGxpbmVQYXJ0c1sxXSA/IG1vZGVsbGluZVBhcnRzWzFdLnRyaW0oKSA6ICcwJztcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IHBhcnNlRmxvYXQoc3BlZWQucmVwbGFjZSgvR0h6Ky9nLCAnJykpO1xuICAgICAgICAgICAgbGV0IHRiRnJlcXVlbmN5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LnRiZnJlcXVlbmN5JykgLyAxMDAwMDAwMDAwLjA7XG4gICAgICAgICAgICB0YkZyZXF1ZW5jeSA9IHRiRnJlcXVlbmN5IDwgMC4xID8gdGJGcmVxdWVuY3kgKiAxMDAgOiB0YkZyZXF1ZW5jeTtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IHJlc3VsdC5zcGVlZCA9PT0gMCA/IHRiRnJlcXVlbmN5IDogcmVzdWx0LnNwZWVkO1xuXG4gICAgICAgICAgICBfY3B1X3NwZWVkID0gcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0ID0gY3B1QnJhbmRNYW51ZmFjdHVyZXIocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1pbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVmcmVxdWVuY3lfbWluJykgPyAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdWZyZXF1ZW5jeV9taW4nKSAvIDEwMDAwMDAwMDAuMCkgOiByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNYXggPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1ZnJlcXVlbmN5X21heCcpID8gKHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVmcmVxdWVuY3lfbWF4JykgLyAxMDAwMDAwMDAwLjApIDogcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmNwdS52ZW5kb3InKSB8fCAnQXBwbGUnO1xuICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmNwdS5mYW1pbHknKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1ZmFtaWx5Jyk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5jcHUubW9kZWwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGVwcGluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmNwdS5zdGVwcGluZycpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVzdWJmYW1pbHknKTtcbiAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb3VudFByb2Nlc3NvcnMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcucGFja2FnZXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50Q29yZXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcucGh5c2ljYWxjcHVfbWF4Jyk7XG4gICAgICAgICAgICBjb25zdCBjb3VudFRocmVhZHMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcubmNwdScpO1xuICAgICAgICAgICAgaWYgKG9zLmFyY2goKSA9PT0gJ2FybTY0Jykge1xuICAgICAgICAgICAgICBjb25zdCBjbHVzdGVycyA9IGV4ZWNTeW5jKCdpb3JlZyAtYyBJT1BsYXRmb3JtRGV2aWNlIC1kIDMgLXIgfCBncmVwIGNsdXN0ZXItdHlwZScpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCBlZmZpY2llbmN5Q29yZXMgPSBjbHVzdGVycy5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YoJ1wiRVwiJykgPj0gMCkubGVuZ3RoO1xuICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtYW5jZUNvcmVzID0gY2x1c3RlcnMuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKCdcIlBcIicpID49IDApLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9ICdTT0MnO1xuICAgICAgICAgICAgICByZXN1bHQuZWZmaWNpZW5jeUNvcmVzID0gZWZmaWNpZW5jeUNvcmVzO1xuICAgICAgICAgICAgICByZXN1bHQucGVyZm9ybWFuY2VDb3JlcyA9IHBlcmZvcm1hbmNlQ29yZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRQcm9jZXNzb3JzKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wcm9jZXNzb3JzID0gcGFyc2VJbnQoY291bnRQcm9jZXNzb3JzKSB8fCAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50Q29yZXMgJiYgY291bnRUaHJlYWRzKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5jb3JlcyA9IHBhcnNlSW50KGNvdW50VGhyZWFkcykgfHwgdXRpbC5jb3JlcygpO1xuICAgICAgICAgICAgICByZXN1bHQucGh5c2ljYWxDb3JlcyA9IHBhcnNlSW50KGNvdW50Q29yZXMpIHx8IHV0aWwuY29yZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNwdUNhY2hlKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWNoZSA9IHJlcztcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgIGxldCBtb2RlbGxpbmUgPSAnJztcbiAgICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgICBpZiAob3MuY3B1cygpWzBdICYmIG9zLmNwdXMoKVswXS5tb2RlbCkgeyBtb2RlbGxpbmUgPSBvcy5jcHVzKClbMF0ubW9kZWw7IH1cbiAgICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGxzY3B1OyBlY2hvIC1uIFwiR292ZXJub3I6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3N5c3RlbS9jcHUvY3B1MC9jcHVmcmVxL3NjYWxpbmdfZ292ZXJub3IgMj4vZGV2L251bGw7IGVjaG87IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWxsaW5lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsIG5hbWUnKSB8fCBtb2RlbGxpbmU7XG4gICAgICAgICAgICBjb25zdCBtb2RlbGxpbmVQYXJ0cyA9IG1vZGVsbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gbW9kZWxsaW5lUGFydHNbMF0udHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gbW9kZWxsaW5lUGFydHNbMV0gPyBwYXJzZUZsb2F0KG1vZGVsbGluZVBhcnRzWzFdLnRyaW0oKSkgOiAwO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCAmJiAocmVzdWx0LmJyYW5kLmluZGV4T2YoJ0FNRCcpID4gLTEgfHwgcmVzdWx0LmJyYW5kLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncnl6ZW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBnZXRBTURTcGVlZChyZXN1bHQuYnJhbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gZ2V0Q3B1Q3VycmVudFNwZWVkU3luYygpO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudC5hdmcgIT09IDApIHsgcmVzdWx0LnNwZWVkID0gY3VycmVudC5hdmc7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jcHVfc3BlZWQgPSByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNaW4gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NwdSBtaW4gbWh6JykucmVwbGFjZSgvLC9nLCAnLicpKSAvIDEwLjApIC8gMTAwO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWF4ID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjcHUgbWF4IG1oeicpLnJlcGxhY2UoLywvZywgJy4nKSkgLyAxMC4wKSAvIDEwMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gY3B1QnJhbmRNYW51ZmFjdHVyZXIocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSBjcHVNYW51ZmFjdHVyZXIodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlbmRvciBpZCcpKTtcblxuICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjcHUgZmFtaWx5Jyk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWw6Jyk7XG4gICAgICAgICAgICByZXN1bHQuc3RlcHBpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3RlcHBpbmcnKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjcHUgcmV2aXNpb24nKTtcbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDFkIGNhY2hlJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwxZCkgeyByZXN1bHQuY2FjaGUubDFkID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwxZCkgKiAocmVzdWx0LmNhY2hlLmwxZC5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocmVzdWx0LmNhY2hlLmwxZC5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTsgfVxuICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxaSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMWkgY2FjaGUnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDFpKSB7IHJlc3VsdC5jYWNoZS5sMWkgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDFpKSAqIChyZXN1bHQuY2FjaGUubDFpLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChyZXN1bHQuY2FjaGUubDFpLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpOyB9XG4gICAgICAgICAgICByZXN1bHQuY2FjaGUubDIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDIgY2FjaGUnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDIpIHsgcmVzdWx0LmNhY2hlLmwyID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwyKSAqIChyZXN1bHQuY2FjaGUubDIuaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHJlc3VsdC5jYWNoZS5sMi5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTsgfVxuICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wzIGNhY2hlJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwzKSB7IHJlc3VsdC5jYWNoZS5sMyA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMykgKiAocmVzdWx0LmNhY2hlLmwzLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChyZXN1bHQuY2FjaGUubDMuaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7IH1cblxuICAgICAgICAgICAgY29uc3QgdGhyZWFkc1BlckNvcmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndGhyZWFkKHMpIHBlciBjb3JlJykgfHwgJzEnO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29ycyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzb2NrZXQocyknKSB8fCAnMSc7XG4gICAgICAgICAgICBsZXQgdGhyZWFkc1BlckNvcmVJbnQgPSBwYXJzZUludCh0aHJlYWRzUGVyQ29yZSwgMTApOyAvLyB0aHJlYWRzIHBlciBjb2RlIChub3JtYWxseSBvbmx5IGZvciBwZXJmb3JtYW5jZSBjb3JlcylcbiAgICAgICAgICAgIGxldCBwcm9jZXNzb3JzSW50ID0gcGFyc2VJbnQocHJvY2Vzc29ycywgMTApIHx8IDE7ICAvLyBudW1iZXIgb2Ygc29ja2V0cyAvICBwcm9jZXNzb3IgdW5pdHMgaW4gbWFjaGluZSAobm9ybWFsbHkgMSlcbiAgICAgICAgICAgIGNvbnN0IGNvcmVzUGVyU29ja2V0ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NvcmUocykgcGVyIHNvY2tldCcpLCAxMCk7IC8vIG51bWJlciBvZiBjb3JlcyAoZS5nLiAxNiBvbiBpMTI5MDApXG4gICAgICAgICAgICByZXN1bHQucGh5c2ljYWxDb3JlcyA9IGNvcmVzUGVyU29ja2V0ID8gY29yZXNQZXJTb2NrZXQgKiBwcm9jZXNzb3JzSW50IDogcmVzdWx0LmNvcmVzIC8gdGhyZWFkc1BlckNvcmVJbnQ7XG4gICAgICAgICAgICByZXN1bHQucGVyZm9ybWFuY2VDb3JlcyA9IHRocmVhZHNQZXJDb3JlSW50ID4gMSA/IHJlc3VsdC5jb3JlcyAtIHJlc3VsdC5waHlzaWNhbENvcmVzIDogcmVzdWx0LmNvcmVzO1xuICAgICAgICAgICAgcmVzdWx0LmVmZmljaWVuY3lDb3JlcyA9IHRocmVhZHNQZXJDb3JlSW50ID4gMSA/IHJlc3VsdC5jb3JlcyAtICh0aHJlYWRzUGVyQ29yZUludCAqIHJlc3VsdC5wZXJmb3JtYW5jZUNvcmVzKSA6IDA7XG4gICAgICAgICAgICByZXN1bHQucHJvY2Vzc29ycyA9IHByb2Nlc3NvcnNJbnQ7XG4gICAgICAgICAgICByZXN1bHQuZ292ZXJub3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZ292ZXJub3InKSB8fCAnJztcblxuICAgICAgICAgICAgLy8gVGVzdCBSYXNwYmVycnlcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmVuZG9yID09PSAnQVJNJykge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lc1JwaSA9IGZzLnJlYWRGaWxlU3luYygnL3Byb2MvY3B1aW5mbycpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCByUElSZXZpc2lvbiA9IHV0aWwuZGVjb2RlUGlDcHVpbmZvKGxpbmVzUnBpKTtcbiAgICAgICAgICAgICAgaWYgKHJQSVJldmlzaW9uLm1vZGVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmFzcGJlcnJ5JykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSByZXN1bHQubWFudWZhY3R1cmVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSByUElSZXZpc2lvbi5tYW51ZmFjdHVyZXI7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gclBJUmV2aXNpb24ucHJvY2Vzc29yO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9IHJQSVJldmlzaW9uLnJldmlzaW9uQ29kZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gJ1NPQyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc29ja2V0IHR5cGVcbiAgICAgICAgICAgIGxldCBsaW5lczIgPSBbXTtcbiAgICAgICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIOKAk3QgNCAyPi9kZXYvbnVsbCB8IGdyZXAgXCJVcGdyYWRlOiBTb2NrZXRcIjsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yMiwgc3Rkb3V0Mikge1xuICAgICAgICAgICAgICBsaW5lczIgPSBzdGRvdXQyLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAobGluZXMyICYmIGxpbmVzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdVcGdyYWRlJykucmVwbGFjZSgnU29ja2V0JywgJycpLnRyaW0oKSB8fCByZXN1bHQuc29ja2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgbGV0IG1vZGVsbGluZSA9ICcnO1xuICAgICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChvcy5jcHVzKClbMF0gJiYgb3MuY3B1cygpWzBdLm1vZGVsKSB7IG1vZGVsbGluZSA9IG9zLmNwdXMoKVswXS5tb2RlbDsgfVxuICAgICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IDQ7IGRtaWRlY29kZSAtdCA3IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCcjIGRtaWRlY29kZScpO1xuICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBkYXRhLmxlbmd0aCA+IDEgPyBkYXRhWzFdIDogJyc7XG4gICAgICAgICAgICAgIGNhY2hlID0gZGF0YS5sZW5ndGggPiAyID8gZGF0YVsyXS5zcGxpdCgnQ2FjaGUgSW5mb3JtYXRpb24nKSA6IFtdO1xuXG4gICAgICAgICAgICAgIGxpbmVzID0gcHJvY2Vzc29yLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IG1vZGVsbGluZS5zcGxpdCgnQCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IG1vZGVsbGluZS5zcGxpdCgnQCcpWzFdID8gcGFyc2VGbG9hdChtb2RlbGxpbmUuc3BsaXQoJ0AnKVsxXS50cmltKCkpIDogMDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDAgJiYgKHJlc3VsdC5icmFuZC5pbmRleE9mKCdBTUQnKSA+IC0xIHx8IHJlc3VsdC5icmFuZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3J5emVuJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gZ2V0QU1EU3BlZWQocmVzdWx0LmJyYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGdldENwdUN1cnJlbnRTcGVlZFN5bmMoKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYXZnICE9PSAwKSB7IHJlc3VsdC5zcGVlZCA9IGN1cnJlbnQuYXZnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY3B1X3NwZWVkID0gcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWluID0gcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWF4ID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYXggc3BlZWQnKS5yZXBsYWNlKC9NaHovZywgJycpKSAvIDEwLjApIC8gMTAwO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBjcHVCcmFuZE1hbnVmYWN0dXJlcihyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IGNwdU1hbnVmYWN0dXJlcih1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJykpO1xuICAgICAgICAgICAgbGV0IHNpZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIHNpZyA9IHNpZy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc2lnW2ldID0gc2lnW2ldLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSB1dGlsLmdldFZhbHVlKHNpZywgJ0ZhbWlseScsICcgJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKHNpZywgJ01vZGVsJywgJyAnLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGVwcGluZyA9IHV0aWwuZ2V0VmFsdWUoc2lnLCAnU3RlcHBpbmcnLCAnICcsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gJyc7XG4gICAgICAgICAgICBjb25zdCB2b2x0YWdlID0gcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdGFnZScpKTtcbiAgICAgICAgICAgIHJlc3VsdC52b2x0YWdlID0gaXNOYU4odm9sdGFnZSkgPyAnJyA6IHZvbHRhZ2UudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBjYWNoZVtpXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBjYWNoZVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU29ja2V0IERlc2lnbmF0aW9uJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcgJywgJy0nKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICBjYWNoZVR5cGUgPSBjYWNoZVR5cGUubGVuZ3RoID8gY2FjaGVUeXBlWzBdIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemVQYXJ0cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnN0YWxsZWQgU2l6ZScpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQoc2l6ZVBhcnRzWzBdLCAxMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHVuaXQgPSBzaXplUGFydHMubGVuZ3RoID4gMSA/IHNpemVQYXJ0c1sxXSA6ICdrYic7XG4gICAgICAgICAgICAgIHNpemUgPSBzaXplICogKHVuaXQgPT09ICdrYicgPyAxMDI0IDogKHVuaXQgPT09ICdtYicgPyAxMDI0ICogMTAyNCA6ICh1bml0ID09PSAnZ2InID8gMTAyNCAqIDEwMjQgKiAxMDI0IDogMSkpKTtcbiAgICAgICAgICAgICAgaWYgKGNhY2hlVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZVR5cGUgPT09ICdsMScpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGUgKyAnZCddID0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlICsgJ2knXSA9IHNpemUgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlXSA9IHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb2NrZXQgdHlwZVxuICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdVcGdyYWRlJykucmVwbGFjZSgnU29ja2V0JywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIC8vICMgdGhyZWFkcyAvICMgY29yZXNcbiAgICAgICAgICAgIGNvbnN0IHRocmVhZENvdW50ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3RocmVhZCBjb3VudCcpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcmVDb3VudCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjb3JlIGNvdW50JykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGNvcmVDb3VudCAmJiB0aHJlYWRDb3VudCkge1xuICAgICAgICAgICAgICByZXN1bHQuY29yZXMgPSBwYXJzZUludCh0aHJlYWRDb3VudCwgMTApO1xuICAgICAgICAgICAgICByZXN1bHQucGh5c2ljYWxDb3JlcyA9IHBhcnNlSW50KGNvcmVDb3VudCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX3Byb2Nlc3NvciB8IHNlbGVjdCBOYW1lLCBSZXZpc2lvbiwgTDJDYWNoZVNpemUsIEwzQ2FjaGVTaXplLCBNYW51ZmFjdHVyZXIsIE1heENsb2NrU3BlZWQsIERlc2NyaXB0aW9uLCBVcGdyYWRlTWV0aG9kLCBDYXB0aW9uLCBOdW1iZXJPZkxvZ2ljYWxQcm9jZXNzb3JzLCBOdW1iZXJPZkNvcmVzIHwgZmwnKSk7XG4gICAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NhY2hlTWVtb3J5IHwgc2VsZWN0IENhY2hlVHlwZSxJbnN0YWxsZWRTaXplLExldmVsIHwgZmwnKSk7XG4gICAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnKEdldC1DaW1JbnN0YW5jZSBXaW4zMl9Db21wdXRlclN5c3RlbSkuSHlwZXJ2aXNvclByZXNlbnQnKSk7XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGFbMF0uc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBsZXQgbmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKSB8fCAnJztcbiAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignQCcpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYnJhbmQgPSBuYW1lLnNwbGl0KCdAJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IG5hbWUuc3BsaXQoJ0AnKVsxXSA/IHBhcnNlRmxvYXQobmFtZS5zcGxpdCgnQCcpWzFdLnRyaW0oKSkgOiAwO1xuICAgICAgICAgICAgICAgIF9jcHVfc3BlZWQgPSByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gbmFtZS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBjcHVCcmFuZE1hbnVmYWN0dXJlcihyZXN1bHQpO1xuICAgICAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncmV2aXNpb24nLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFkID0gMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxaSA9IDA7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMmNhY2hlc2l6ZScsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsM2NhY2hlc2l6ZScsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDIpIHsgcmVzdWx0LmNhY2hlLmwyID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwyLCAxMCkgKiAxMDI0OyB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDMpIHsgcmVzdWx0LmNhY2hlLmwzID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwzLCAxMCkgKiAxMDI0OyB9XG4gICAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWF4ID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYXhjbG9ja3NwZWVkJywgJzonKS5yZXBsYWNlKC8sL2csICcuJykpIC8gMTAuMCkgLyAxMDA7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDAgJiYgKHJlc3VsdC5icmFuZC5pbmRleE9mKCdBTUQnKSA+IC0xIHx8IHJlc3VsdC5icmFuZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3J5emVuJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBnZXRBTURTcGVlZChyZXN1bHQuYnJhbmQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSByZXN1bHQuc3BlZWRNYXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWluID0gcmVzdWx0LnNwZWVkO1xuXG4gICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkZXNjcmlwdGlvbicsICc6Jykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbltpXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZhbWlseScpICYmIChpICsgMSkgPCBkZXNjcmlwdGlvbi5sZW5ndGggJiYgZGVzY3JpcHRpb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gZGVzY3JpcHRpb25baSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb25baV0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdtb2RlbCcpICYmIChpICsgMSkgPCBkZXNjcmlwdGlvbi5sZW5ndGggJiYgZGVzY3JpcHRpb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSBkZXNjcmlwdGlvbltpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbltpXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3N0ZXBwaW5nJykgJiYgKGkgKyAxKSA8IGRlc2NyaXB0aW9uLmxlbmd0aCAmJiBkZXNjcmlwdGlvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwcGluZyA9IGRlc2NyaXB0aW9uW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gc29ja2V0IHR5cGVcbiAgICAgICAgICAgICAgY29uc3Qgc29ja2V0SWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVXBncmFkZU1ldGhvZCcsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChzb2NrZXRUeXBlc1tzb2NrZXRJZF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gc29ja2V0VHlwZXNbc29ja2V0SWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNvY2tldEJ5TmFtZSA9IGdldFNvY2tldFR5cGVzQnlOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICBpZiAoc29ja2V0QnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9IHNvY2tldEJ5TmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjIHRocmVhZHMgLyAjIGNvcmVzXG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50UHJvY2Vzc29ycyA9IHV0aWwuY291bnRMaW5lcyhsaW5lcywgJ0NhcHRpb24nKTtcbiAgICAgICAgICAgICAgY29uc3QgY291bnRUaHJlYWRzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ051bWJlck9mTG9naWNhbFByb2Nlc3NvcnMnLCAnOicpO1xuICAgICAgICAgICAgICBjb25zdCBjb3VudENvcmVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ051bWJlck9mQ29yZXMnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAoY291bnRQcm9jZXNzb3JzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnByb2Nlc3NvcnMgPSBwYXJzZUludChjb3VudFByb2Nlc3NvcnMpIHx8IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvdW50Q29yZXMgJiYgY291bnRUaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzID0gcGFyc2VJbnQoY291bnRUaHJlYWRzKSB8fCB1dGlsLmNvcmVzKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsQ29yZXMgPSBwYXJzZUludChjb3VudENvcmVzKSB8fCB1dGlsLmNvcmVzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvdW50UHJvY2Vzc29ycyA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMgPSByZXN1bHQuY29yZXMgKiBjb3VudFByb2Nlc3NvcnM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsQ29yZXMgPSByZXN1bHQucGh5c2ljYWxDb3JlcyAqIGNvdW50UHJvY2Vzc29ycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGRhdGFbMV0uc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxpbmVzID0gcGFydC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhY2hlVHlwZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xldmVsJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFsbGVkU2l6ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnN0YWxsZWRTaXplJyk7XG4gICAgICAgICAgICAgICAgLy8gTDEgSW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnMycpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWkgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEwxIERhdGFcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICc0Jykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxZCA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTDEgYWxsXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnNScgJiYgIXJlc3VsdC5jYWNoZS5sMWkgJiYgIXJlc3VsdC5jYWNoZS5sMWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWkgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCkgLyAyO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxZCA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgaHlwZXJ2ID0gZGF0YVsyXSA/IGRhdGFbMl0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsaXphdGlvbiA9IGh5cGVydi5pbmRleE9mKCd0cnVlJykgIT09IC0xO1xuXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSAtIFByb2Nlc3NvciBEYXRhXG5cbmZ1bmN0aW9uIGNwdShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgZ2V0Q3B1KCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3B1ID0gY3B1O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIC0gY3VycmVudCBzcGVlZCAtIGluIEdIelxuXG5mdW5jdGlvbiBnZXRDcHVDdXJyZW50U3BlZWRTeW5jKCkge1xuXG4gIGxldCBjcHVzID0gb3MuY3B1cygpO1xuICBsZXQgbWluRnJlcSA9IDk5OTk5OTk5OTtcbiAgbGV0IG1heEZyZXEgPSAwO1xuICBsZXQgYXZnRnJlcSA9IDA7XG4gIGxldCBjb3JlcyA9IFtdO1xuXG4gIGlmIChjcHVzICYmIGNwdXMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSBpbiBjcHVzKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChjcHVzLCBpKSkge1xuICAgICAgICBsZXQgZnJlcSA9IGNwdXNbaV0uc3BlZWQgPiAxMDAgPyAoY3B1c1tpXS5zcGVlZCArIDEpIC8gMTAwMCA6IGNwdXNbaV0uc3BlZWQgLyAxMDtcbiAgICAgICAgYXZnRnJlcSA9IGF2Z0ZyZXEgKyBmcmVxO1xuICAgICAgICBpZiAoZnJlcSA+IG1heEZyZXEpIHsgbWF4RnJlcSA9IGZyZXE7IH1cbiAgICAgICAgaWYgKGZyZXEgPCBtaW5GcmVxKSB7IG1pbkZyZXEgPSBmcmVxOyB9XG4gICAgICAgIGNvcmVzLnB1c2gocGFyc2VGbG9hdChmcmVxLnRvRml4ZWQoMikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXZnRnJlcSA9IGF2Z0ZyZXEgLyBjcHVzLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBwYXJzZUZsb2F0KG1pbkZyZXEudG9GaXhlZCgyKSksXG4gICAgICBtYXg6IHBhcnNlRmxvYXQobWF4RnJlcS50b0ZpeGVkKDIpKSxcbiAgICAgIGF2ZzogcGFyc2VGbG9hdCgoYXZnRnJlcSkudG9GaXhlZCgyKSksXG4gICAgICBjb3JlczogY29yZXNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDAsXG4gICAgICBhdmc6IDAsXG4gICAgICBjb3JlczogY29yZXNcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNwdUN1cnJlbnRTcGVlZChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IGdldENwdUN1cnJlbnRTcGVlZFN5bmMoKTtcbiAgICAgIGlmIChyZXN1bHQuYXZnID09PSAwICYmIF9jcHVfc3BlZWQgIT09IDApIHtcbiAgICAgICAgY29uc3QgY3VyckNwdVNwZWVkID0gcGFyc2VGbG9hdChfY3B1X3NwZWVkKTtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIG1pbjogY3VyckNwdVNwZWVkLFxuICAgICAgICAgIG1heDogY3VyckNwdVNwZWVkLFxuICAgICAgICAgIGF2ZzogY3VyckNwdVNwZWVkLFxuICAgICAgICAgIGNvcmVzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3B1Q3VycmVudFNwZWVkID0gY3B1Q3VycmVudFNwZWVkO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIC0gdGVtcGVyYXR1cmVcbi8vIGlmIHNlbnNvcnMgYXJlIGluc3RhbGxlZFxuXG5mdW5jdGlvbiBjcHVUZW1wZXJhdHVyZShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbWFpbjogbnVsbCxcbiAgICAgICAgY29yZXM6IFtdLFxuICAgICAgICBtYXg6IG51bGwsXG4gICAgICAgIHNvY2tldDogW10sXG4gICAgICAgIGNoaXBzZXQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIC8vIENQVSBDaGlwc2V0LCBTb2NrZXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjbWQgPSAnY2F0IC9zeXMvY2xhc3MvdGhlcm1hbC90aGVybWFsX3pvbmUqL3R5cGUgIDI+L2Rldi9udWxsOyBlY2hvIFwiLS0tLS1cIjsgY2F0IC9zeXMvY2xhc3MvdGhlcm1hbC90aGVybWFsX3pvbmUqL3RlbXAgMj4vZGV2L251bGw7JztcbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnLS0tLS1cXG4nKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnRzWzBdLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzMiA9IHBhcnRzWzFdLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnYWNwaScpICYmIGxpbmVzMltpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQucHVzaChNYXRoLnJvdW5kKHBhcnNlSW50KGxpbmVzMltpXSwgMTApIC8gMTAwKSAvIDEwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdwY2gnKSAmJiBsaW5lczJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2hpcHNldCA9IE1hdGgucm91bmQocGFyc2VJbnQobGluZXMyW2ldLCAxMCkgLyAxMDApIC8gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNtZCA9ICdmb3IgbW9uIGluIC9zeXMvY2xhc3MvaHdtb24vaHdtb24qOyBkbyBmb3IgbGFiZWwgaW4gXCIkbW9uXCIvdGVtcCpfbGFiZWw7IGRvIGlmIFsgLWYgJGxhYmVsIF07IHRoZW4gdmFsdWU9JHtsYWJlbCVfKn1faW5wdXQ7IGVjaG8gJChjYXQgXCIkbGFiZWxcIilfX18kKGNhdCBcIiR2YWx1ZVwiKTsgZmk7IGRvbmU7IGRvbmU7JztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIHN0ZG91dCA9IHN0ZG91dC50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdGRpZVBvcyA9IHN0ZG91dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3RkaWUnKTtcbiAgICAgICAgICAgIGlmICh0ZGllUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdGRvdXQgPSBzdGRvdXQuc3Vic3RyaW5nKHRkaWVQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnX19fJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gcGFydHNbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFydHMubGVuZ3RoID4gMSAmJiBwYXJ0c1sxXSA/IHBhcnRzWzFdIDogJzAnO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgKGxhYmVsID09PSB1bmRlZmluZWQgfHwgKGxhYmVsICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnY29yZScpKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMucHVzaChNYXRoLnJvdW5kKHBhcnNlSW50KHZhbHVlLCAxMCkgLyAxMDApIC8gMTApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGxhYmVsICYmIHJlc3VsdC5tYWluID09PSBudWxsICYmIChsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3BhY2thZ2UnKSA+PSAwIHx8IGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncGh5c2ljYWwnKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gTWF0aC5yb3VuZChwYXJzZUludCh2YWx1ZSwgMTApIC8gMTAwKSAvIDEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubWFpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gTWF0aC5yb3VuZChyZXN1bHQuY29yZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyByZXN1bHQuY29yZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgbWF4dG1wID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcmVzdWx0LmNvcmVzKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IChtYXh0bXAgPiByZXN1bHQubWFpbikgPyBtYXh0bXAgOiByZXN1bHQubWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWFpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1heCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSByZXN1bHQubWFpbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWMoJ3NlbnNvcnMnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxldCB0ZGllVGVtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1NlY3Rpb25TdGFydHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBzZWN0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VjdGlvblN0YXJ0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1NlY3Rpb25TdGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnYWNwaScpKSB7IHNlY3Rpb24gPSAnYWNwaSc7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgncGNoJykpIHsgc2VjdGlvbiA9ICdwY2gnOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NvcmUnKSkgeyBzZWN0aW9uID0gJ2NvcmUnOyB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlY3Rpb25TdGFydHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCByZWdleCA9IC9bKy1dKFtewrBdKikvZztcbiAgICAgICAgICAgICAgICAgIGxldCB0ZW1wcyA9IGxpbmUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0UGFydCA9IGxpbmUuc3BsaXQoJzonKVswXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24gPT09ICdhY3BpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2NrZXQgdGVtcFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmluZGV4T2YoJ1RFTVAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0LnB1c2gocGFyc2VGbG9hdCh0ZW1wcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlY3Rpb24gPT09ICdwY2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaXBzZXQgdGVtcFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmluZGV4T2YoJ1RFTVAnKSAhPT0gLTEgJiYgIXJlc3VsdC5jaGlwc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNoaXBzZXQgPSBwYXJzZUZsb2F0KHRlbXBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gY3B1IHRlbXBcbiAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuaW5kZXhPZignUEhZU0lDQUwnKSAhPT0gLTEgfHwgZmlyc3RQYXJ0LmluZGV4T2YoJ1BBQ0tBR0UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBwYXJzZUZsb2F0KHRlbXBzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuaW5kZXhPZignQ09SRSAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzLnB1c2gocGFyc2VGbG9hdCh0ZW1wcykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydC5pbmRleE9mKCdURElFJykgIT09IC0xICYmIHRkaWVUZW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRkaWVUZW1wID0gcGFyc2VGbG9hdCh0ZW1wcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jb3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IE1hdGgucm91bmQocmVzdWx0LmNvcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcmVzdWx0LmNvcmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBsZXQgbWF4dG1wID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcmVzdWx0LmNvcmVzKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSAobWF4dG1wID4gcmVzdWx0Lm1haW4pID8gbWF4dG1wIDogcmVzdWx0Lm1haW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWFpbiA9PT0gbnVsbCAmJiB0ZGllVGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IHRkaWVUZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gdGRpZVRlbXA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWFpbiAhPT0gbnVsbCB8fCByZXN1bHQubWF4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcy5zdGF0KCcvc3lzL2NsYXNzL3RoZXJtYWwvdGhlcm1hbF96b25lMC90ZW1wJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKCcvc3lzL2NsYXNzL3RoZXJtYWwvdGhlcm1hbF96b25lMC90ZW1wJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBwYXJzZUZsb2F0KGxpbmVzWzBdKSAvIDEwMDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSByZXN1bHQubWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4ZWMoJy9vcHQvdmMvYmluL3ZjZ2VuY21kIG1lYXN1cmVfdGVtcCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbMF0uaW5kZXhPZignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IHBhcnNlRmxvYXQobGluZXNbMF0uc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gcmVzdWx0Lm1haW47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnc3lzY3RsIGRldi5jcHUgfCBncmVwIHRlbXAnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gcGFyc2VGbG9hdChwYXJ0c1sxXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPiByZXN1bHQubWF4KSB7IHJlc3VsdC5tYXggPSB0ZW1wOyB9XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgdGVtcDtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNvcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IE1hdGgucm91bmQoc3VtIC8gcmVzdWx0LmNvcmVzLmxlbmd0aCAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIC8qXG4gICAgICAgIGxldCBvc3hUZW1wID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvL29zeFRlbXAgPSByZXF1aXJlKCdvc3gtdGVtcGVyYXR1cmUtc2Vuc29yJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgb3N4VGVtcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9zeFRlbXApIHtcbiAgICAgICAgICAvL3Jlc3VsdCA9IG9zeFRlbXAuY3B1VGVtcGVyYXR1cmUoKTtcbiAgICAgICAgICAvLyByb3VuZCB0byAyIGRpZ2l0c1xuICAgICAgICAgIGlmIChyZXN1bHQubWFpbikge1xuICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBNYXRoLnJvdW5kKHJlc3VsdC5tYWluICogMTAwKSAvIDEwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5tYXgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXggPSBNYXRoLnJvdW5kKHJlc3VsdC5tYXggKiAxMDApIC8gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LmNvcmVzICYmIHJlc3VsdC5jb3Jlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LmNvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5jb3Jlc1tpXSA9IE1hdGgucm91bmQocmVzdWx0LmNvcmVzW2ldICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICovXG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIE1TQWNwaV9UaGVybWFsWm9uZVRlbXBlcmF0dXJlIC1OYW1lc3BhY2UgXCJyb290L3dtaVwiIHwgU2VsZWN0IEN1cnJlbnRUZW1wZXJhdHVyZScpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKS5maWx0ZXIoKGxpbmUsIGlkeCkgPT4gaWR4ID4gMCk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAocGFyc2VJbnQobGluZSwgMTApIC0gMjczMikgLyAxMDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQubWF4KSB7IHJlc3VsdC5tYXggPSB2YWx1ZTsgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuY29yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBzdW0gLyByZXN1bHQuY29yZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3B1VGVtcGVyYXR1cmUgPSBjcHVUZW1wZXJhdHVyZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSBGbGFnc1xuXG5mdW5jdGlvbiBjcHVGbGFncyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYygncmVnIHF1ZXJ5IFwiSEtFWV9MT0NBTF9NQUNISU5FXFxcXEhBUkRXQVJFXFxcXERFU0NSSVBUSU9OXFxcXFN5c3RlbVxcXFxDZW50cmFsUHJvY2Vzc29yXFxcXDBcIiAvdiBGZWF0dXJlU2V0JywgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGZsYWdfaGV4ID0gc3Rkb3V0LnNwbGl0KCcweCcpLnBvcCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgbGV0IGZsYWdfYmluX3VucGFkZGVkID0gcGFyc2VJbnQoZmxhZ19oZXgsIDE2KS50b1N0cmluZygyKTtcbiAgICAgICAgICAgICAgbGV0IGZsYWdfYmluID0gJzAnLnJlcGVhdCgzMiAtIGZsYWdfYmluX3VucGFkZGVkLmxlbmd0aCkgKyBmbGFnX2Jpbl91bnBhZGRlZDtcbiAgICAgICAgICAgICAgLy8gZW1wdHkgZmxhZ3MgYXJlIHRoZSByZXNlcnZlZCBmaWVsZHMgaW4gdGhlIENQVUlEIGZlYXR1cmUgYml0IGxpc3RcbiAgICAgICAgICAgICAgLy8gYXMgZm91bmQgb24gd2lraXBlZGlhOlxuICAgICAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DUFVJRFxuICAgICAgICAgICAgICBsZXQgYWxsX2ZsYWdzID0gW1xuICAgICAgICAgICAgICAgICdmcHUnLCAndm1lJywgJ2RlJywgJ3BzZScsICd0c2MnLCAnbXNyJywgJ3BhZScsICdtY2UnLCAnY3g4JywgJ2FwaWMnLFxuICAgICAgICAgICAgICAgICcnLCAnc2VwJywgJ210cnInLCAncGdlJywgJ21jYScsICdjbW92JywgJ3BhdCcsICdwc2UtMzYnLCAncHNuJywgJ2NsZnNoJyxcbiAgICAgICAgICAgICAgICAnJywgJ2RzJywgJ2FjcGknLCAnbW14JywgJ2Z4c3InLCAnc3NlJywgJ3NzZTInLCAnc3MnLCAnaHR0JywgJ3RtJywgJ2lhNjQnLCAncGJlJ1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IGFsbF9mbGFncy5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFnX2JpbltmXSA9PT0gJzEnICYmIGFsbF9mbGFnc1tmXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICcgKyBhbGxfZmxhZ3NbZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBsc2NwdTsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3BsaXQoJzonKVswXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0ZMQUdTJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBsaW5lLnNwbGl0KCc6JylbMV0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGZzLnJlYWRGaWxlKCcvcHJvYy9jcHVpbmZvJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZmVhdHVyZXMnLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCA0IDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBmbGFncyA9IFtdO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHRGbGFnczonKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnNwbGl0KCdcXHRWZXJzaW9uOicpWzBdLnNwbGl0KCdcXG4nKSA6IFtdO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICBsZXQgZmxhZyA9IChsaW5lLmluZGV4T2YoJygnKSA/IGxpbmUuc3BsaXQoJygnKVswXS50b0xvd2VyQ2FzZSgpIDogJycpLnRyaW0oKS5yZXBsYWNlKC9cXHQvZywgJycpO1xuICAgICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmbGFncy5qb2luKCcgJykudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3lzY3RsIG1hY2hkZXAuY3B1LmZlYXR1cmVzJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1swXS5pbmRleE9mKCdtYWNoZGVwLmNwdS5mZWF0dXJlczonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGluZXNbMF0uc3BsaXQoJzonKVsxXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNwdUZsYWdzID0gY3B1RmxhZ3M7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgQ2FjaGVcblxuZnVuY3Rpb24gY3B1Q2FjaGUoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbDFkOiBudWxsLFxuICAgICAgICBsMWk6IG51bGwsXG4gICAgICAgIGwyOiBudWxsLFxuICAgICAgICBsMzogbnVsbCxcbiAgICAgIH07XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBsc2NwdTsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0wxRCBDQUNIRScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxZCA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9VcHBlckNhc2UoKS5pbmRleE9mKCdMMUkgQ0FDSEUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWkgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTDIgQ0FDSEUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMiA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9VcHBlckNhc2UoKS5pbmRleE9mKCdMMyBDQUNIRScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmwzID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgNyAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYWNoZSA9IGRhdGEuc3BsaXQoJ0NhY2hlIEluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICBjYWNoZS5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNhY2hlW2ldLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxldCBjYWNoZVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU29ja2V0IERlc2lnbmF0aW9uJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcgJywgJy0nKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgY2FjaGVUeXBlID0gY2FjaGVUeXBlLmxlbmd0aCA/IGNhY2hlVHlwZVswXSA6ICcnO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVBhcnRzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0luc3RhbGxlZCBTaXplJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQoc2l6ZVBhcnRzWzBdLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB1bml0ID0gc2l6ZVBhcnRzLmxlbmd0aCA+IDEgPyBzaXplUGFydHNbMV0gOiAna2InO1xuICAgICAgICAgICAgc2l6ZSA9IHNpemUgKiAodW5pdCA9PT0gJ2tiJyA/IDEwMjQgOiAodW5pdCA9PT0gJ21iJyA/IDEwMjQgKiAxMDI0IDogKHVuaXQgPT09ICdnYicgPyAxMDI0ICogMTAyNCAqIDEwMjQgOiAxKSkpO1xuICAgICAgICAgICAgaWYgKGNhY2hlVHlwZSkge1xuICAgICAgICAgICAgICBpZiAoY2FjaGVUeXBlID09PSAnbDEnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZSArICdkJ10gPSBzaXplIC8gMjtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlICsgJ2knXSA9IHNpemUgLyAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGVdID0gc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzeXNjdGwgaHcubDFpY2FjaGVzaXplIGh3LmwxZGNhY2hlc2l6ZSBody5sMmNhY2hlc2l6ZSBody5sM2NhY2hlc2l6ZScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h3LmwxaWNhY2hlc2l6ZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sMWQgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHcubDFkY2FjaGVzaXplJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmwxaSA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdody5sMmNhY2hlc2l6ZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sMiA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdody5sM2NhY2hlc2l6ZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sMyA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfcHJvY2Vzc29yIHwgc2VsZWN0IEwyQ2FjaGVTaXplLCBMM0NhY2hlU2l6ZSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICByZXN1bHQubDFkID0gMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmwxaSA9IDA7XG4gICAgICAgICAgICAgIHJlc3VsdC5sMiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMmNhY2hlc2l6ZScsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5sMyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsM2NhY2hlc2l6ZScsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubDIpIHsgcmVzdWx0LmwyID0gcGFyc2VJbnQocmVzdWx0LmwyLCAxMCkgKiAxMDI0OyB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubDMpIHsgcmVzdWx0LmwzID0gcGFyc2VJbnQocmVzdWx0LmwzLCAxMCkgKiAxMDI0OyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9DYWNoZU1lbW9yeSB8IHNlbGVjdCBDYWNoZVR5cGUsSW5zdGFsbGVkU2l6ZSxMZXZlbCB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhY2hlVHlwZScpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTGV2ZWwnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbGxlZFNpemUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW5zdGFsbGVkU2l6ZScpO1xuICAgICAgICAgICAgICAgICAgLy8gTDEgSW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICczJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubDFpID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gTDEgRGF0YVxuICAgICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnNCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxZCA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEwxIGFsbFxuICAgICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnNScgJiYgIXJlc3VsdC5sMWkgJiYgIXJlc3VsdC5sMWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxaSA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWQgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCkgLyAyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3B1Q2FjaGUgPSBjcHVDYWNoZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSAtIGN1cnJlbnQgbG9hZCAtIGluICVcblxuZnVuY3Rpb24gZ2V0TG9hZCgpIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBsb2FkcyA9IG9zLmxvYWRhdmcoKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggLyB1dGlsLmNvcmVzKCk7IH0pO1xuICAgICAgbGV0IGF2Z0xvYWQgPSBwYXJzZUZsb2F0KChNYXRoLm1heC5hcHBseShNYXRoLCBsb2FkcykpLnRvRml4ZWQoMikpO1xuICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuXG4gICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKSAtIF9jdXJyZW50X2NwdS5tcztcbiAgICAgIGlmIChub3cgPj0gMjAwKSB7XG4gICAgICAgIF9jdXJyZW50X2NwdS5tcyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGNwdXMgPSBvcy5jcHVzKCk7XG4gICAgICAgIGxldCB0b3RhbFVzZXIgPSAwO1xuICAgICAgICBsZXQgdG90YWxTeXN0ZW0gPSAwO1xuICAgICAgICBsZXQgdG90YWxOaWNlID0gMDtcbiAgICAgICAgbGV0IHRvdGFsSXJxID0gMDtcbiAgICAgICAgbGV0IHRvdGFsSWRsZSA9IDA7XG4gICAgICAgIGxldCBjb3JlcyA9IFtdO1xuICAgICAgICBfY29yZWNvdW50ID0gKGNwdXMgJiYgY3B1cy5sZW5ndGgpID8gY3B1cy5sZW5ndGggOiAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2NvcmVjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY3B1ID0gY3B1c1tpXS50aW1lcztcbiAgICAgICAgICB0b3RhbFVzZXIgKz0gY3B1LnVzZXI7XG4gICAgICAgICAgdG90YWxTeXN0ZW0gKz0gY3B1LnN5cztcbiAgICAgICAgICB0b3RhbE5pY2UgKz0gY3B1Lm5pY2U7XG4gICAgICAgICAgdG90YWxJZGxlICs9IGNwdS5pZGxlO1xuICAgICAgICAgIHRvdGFsSXJxICs9IGNwdS5pcnE7XG4gICAgICAgICAgbGV0IHRtcFRpY2sgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0udG90YWxUaWNrID8gX2NwdXNbaV0udG90YWxUaWNrIDogMCk7XG4gICAgICAgICAgbGV0IHRtcExvYWQgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0udG90YWxMb2FkID8gX2NwdXNbaV0udG90YWxMb2FkIDogMCk7XG4gICAgICAgICAgbGV0IHRtcFVzZXIgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0udXNlciA/IF9jcHVzW2ldLnVzZXIgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wU3lzdGVtID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLnN5cyA/IF9jcHVzW2ldLnN5cyA6IDApO1xuICAgICAgICAgIGxldCB0bXBOaWNlID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLm5pY2UgPyBfY3B1c1tpXS5uaWNlIDogMCk7XG4gICAgICAgICAgbGV0IHRtcElkbGUgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0uaWRsZSA/IF9jcHVzW2ldLmlkbGUgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wSXJxID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLmlycSA/IF9jcHVzW2ldLmlycSA6IDApO1xuICAgICAgICAgIF9jcHVzW2ldID0gY3B1O1xuICAgICAgICAgIF9jcHVzW2ldLnRvdGFsVGljayA9IF9jcHVzW2ldLnVzZXIgKyBfY3B1c1tpXS5zeXMgKyBfY3B1c1tpXS5uaWNlICsgX2NwdXNbaV0uaXJxICsgX2NwdXNbaV0uaWRsZTtcbiAgICAgICAgICBfY3B1c1tpXS50b3RhbExvYWQgPSBfY3B1c1tpXS51c2VyICsgX2NwdXNbaV0uc3lzICsgX2NwdXNbaV0ubmljZSArIF9jcHVzW2ldLmlycTtcbiAgICAgICAgICBfY3B1c1tpXS5jdXJyZW50VGljayA9IF9jcHVzW2ldLnRvdGFsVGljayAtIHRtcFRpY2s7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZCA9IChfY3B1c1tpXS50b3RhbExvYWQgLSB0bXBMb2FkKTtcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkVXNlciA9IChfY3B1c1tpXS51c2VyIC0gdG1wVXNlcik7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZFN5c3RlbSA9IChfY3B1c1tpXS5zeXMgLSB0bXBTeXN0ZW0pO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWROaWNlID0gKF9jcHVzW2ldLm5pY2UgLSB0bXBOaWNlKTtcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkSWRsZSA9IChfY3B1c1tpXS5pZGxlIC0gdG1wSWRsZSk7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZElycSA9IChfY3B1c1tpXS5pcnEgLSB0bXBJcnEpO1xuICAgICAgICAgIGNvcmVzW2ldID0ge307XG4gICAgICAgICAgY29yZXNbaV0ubG9hZCA9IF9jcHVzW2ldLmxvYWQgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkVXNlciA9IF9jcHVzW2ldLmxvYWRVc2VyIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZFN5c3RlbSA9IF9jcHVzW2ldLmxvYWRTeXN0ZW0gLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkTmljZSA9IF9jcHVzW2ldLmxvYWROaWNlIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZElkbGUgPSBfY3B1c1tpXS5sb2FkSWRsZSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRJcnEgPSBfY3B1c1tpXS5sb2FkSXJxIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZCA9IF9jcHVzW2ldLmxvYWQ7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZFVzZXIgPSBfY3B1c1tpXS5sb2FkVXNlcjtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkU3lzdGVtID0gX2NwdXNbaV0ubG9hZFN5c3RlbTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkTmljZSA9IF9jcHVzW2ldLmxvYWROaWNlO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRJZGxlID0gX2NwdXNbaV0ubG9hZElkbGU7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZElycSA9IF9jcHVzW2ldLmxvYWRJcnE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsVGljayA9IHRvdGFsVXNlciArIHRvdGFsU3lzdGVtICsgdG90YWxOaWNlICsgdG90YWxJcnEgKyB0b3RhbElkbGU7XG4gICAgICAgIGxldCB0b3RhbExvYWQgPSB0b3RhbFVzZXIgKyB0b3RhbFN5c3RlbSArIHRvdGFsTmljZSArIHRvdGFsSXJxO1xuICAgICAgICBsZXQgY3VycmVudFRpY2sgPSB0b3RhbFRpY2sgLSBfY3VycmVudF9jcHUudGljaztcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGF2Z0xvYWQ6IGF2Z0xvYWQsXG4gICAgICAgICAgY3VycmVudExvYWQ6ICh0b3RhbExvYWQgLSBfY3VycmVudF9jcHUubG9hZCkgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICBjdXJyZW50TG9hZFVzZXI6ICh0b3RhbFVzZXIgLSBfY3VycmVudF9jcHUudXNlcikgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICBjdXJyZW50TG9hZFN5c3RlbTogKHRvdGFsU3lzdGVtIC0gX2N1cnJlbnRfY3B1LnN5c3RlbSkgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICBjdXJyZW50TG9hZE5pY2U6ICh0b3RhbE5pY2UgLSBfY3VycmVudF9jcHUubmljZSkgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICBjdXJyZW50TG9hZElkbGU6ICh0b3RhbElkbGUgLSBfY3VycmVudF9jcHUuaWRsZSkgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICBjdXJyZW50TG9hZElycTogKHRvdGFsSXJxIC0gX2N1cnJlbnRfY3B1LmlycSkgLyBjdXJyZW50VGljayAqIDEwMCxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZDogKHRvdGFsTG9hZCAtIF9jdXJyZW50X2NwdS5sb2FkKSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFVzZXI6ICh0b3RhbFVzZXIgLSBfY3VycmVudF9jcHUudXNlciksXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRTeXN0ZW06ICh0b3RhbFN5c3RlbSAtIF9jdXJyZW50X2NwdS5zeXN0ZW0pLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkTmljZTogKHRvdGFsTmljZSAtIF9jdXJyZW50X2NwdS5uaWNlKSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElkbGU6ICh0b3RhbElkbGUgLSBfY3VycmVudF9jcHUuaWRsZSksXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJcnE6ICh0b3RhbElycSAtIF9jdXJyZW50X2NwdS5pcnEpLFxuICAgICAgICAgIGNwdXM6IGNvcmVzXG4gICAgICAgIH07XG4gICAgICAgIF9jdXJyZW50X2NwdSA9IHtcbiAgICAgICAgICB1c2VyOiB0b3RhbFVzZXIsXG4gICAgICAgICAgbmljZTogdG90YWxOaWNlLFxuICAgICAgICAgIHN5c3RlbTogdG90YWxTeXN0ZW0sXG4gICAgICAgICAgaWRsZTogdG90YWxJZGxlLFxuICAgICAgICAgIGlycTogdG90YWxJcnEsXG4gICAgICAgICAgdGljazogdG90YWxUaWNrLFxuICAgICAgICAgIGxvYWQ6IHRvdGFsTG9hZCxcbiAgICAgICAgICBtczogX2N1cnJlbnRfY3B1Lm1zLFxuICAgICAgICAgIGN1cnJlbnRMb2FkOiByZXN1bHQuY3VycmVudExvYWQsXG4gICAgICAgICAgY3VycmVudExvYWRVc2VyOiByZXN1bHQuY3VycmVudExvYWRVc2VyLFxuICAgICAgICAgIGN1cnJlbnRMb2FkU3lzdGVtOiByZXN1bHQuY3VycmVudExvYWRTeXN0ZW0sXG4gICAgICAgICAgY3VycmVudExvYWROaWNlOiByZXN1bHQuY3VycmVudExvYWROaWNlLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSWRsZTogcmVzdWx0LmN1cnJlbnRMb2FkSWRsZSxcbiAgICAgICAgICBjdXJyZW50TG9hZElycTogcmVzdWx0LmN1cnJlbnRMb2FkSXJxLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkOiByZXN1bHQucmF3Q3VycmVudExvYWQsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRVc2VyOiByZXN1bHQucmF3Q3VycmVudExvYWRVc2VyLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkU3lzdGVtOiByZXN1bHQucmF3Q3VycmVudExvYWRTeXN0ZW0sXG4gICAgICAgICAgcmF3Q3VycmVudExvYWROaWNlOiByZXN1bHQucmF3Q3VycmVudExvYWROaWNlLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSWRsZTogcmVzdWx0LnJhd0N1cnJlbnRMb2FkSWRsZSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElycTogcmVzdWx0LnJhd0N1cnJlbnRMb2FkSXJxLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2NvcmVjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29yZXNbaV0gPSB7fTtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkID0gX2NwdXNbaV0ubG9hZCAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRVc2VyID0gX2NwdXNbaV0ubG9hZFVzZXIgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkU3lzdGVtID0gX2NwdXNbaV0ubG9hZFN5c3RlbSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWROaWNlID0gX2NwdXNbaV0ubG9hZE5pY2UgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkSWRsZSA9IF9jcHVzW2ldLmxvYWRJZGxlIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZElycSA9IF9jcHVzW2ldLmxvYWRJcnEgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkID0gX2NwdXNbaV0ubG9hZDtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkVXNlciA9IF9jcHVzW2ldLmxvYWRVc2VyO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRTeXN0ZW0gPSBfY3B1c1tpXS5sb2FkU3lzdGVtO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWROaWNlID0gX2NwdXNbaV0ubG9hZE5pY2U7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZElkbGUgPSBfY3B1c1tpXS5sb2FkSWRsZTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkSXJxID0gX2NwdXNbaV0ubG9hZElycTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgYXZnTG9hZDogYXZnTG9hZCxcbiAgICAgICAgICBjdXJyZW50TG9hZDogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkLFxuICAgICAgICAgIGN1cnJlbnRMb2FkVXNlcjogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkVXNlcixcbiAgICAgICAgICBjdXJyZW50TG9hZFN5c3RlbTogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkU3lzdGVtLFxuICAgICAgICAgIGN1cnJlbnRMb2FkTmljZTogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkTmljZSxcbiAgICAgICAgICBjdXJyZW50TG9hZElkbGU6IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZElkbGUsXG4gICAgICAgICAgY3VycmVudExvYWRJcnE6IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZElycSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZDogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkVXNlcjogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkVXNlcixcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFN5c3RlbTogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkU3lzdGVtLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkTmljZTogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkTmljZSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElkbGU6IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZElkbGUsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJcnE6IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZElycSxcbiAgICAgICAgICBjcHVzOiBjb3Jlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3VycmVudExvYWQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGdldExvYWQoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jdXJyZW50TG9hZCA9IGN1cnJlbnRMb2FkO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUFMgLSBmdWxsIGxvYWRcbi8vIHNpbmNlIGJvb3R1cFxuXG5mdW5jdGlvbiBnZXRGdWxsTG9hZCgpIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgY29uc3QgY3B1cyA9IG9zLmNwdXMoKTtcbiAgICAgIGxldCB0b3RhbFVzZXIgPSAwO1xuICAgICAgbGV0IHRvdGFsU3lzdGVtID0gMDtcbiAgICAgIGxldCB0b3RhbE5pY2UgPSAwO1xuICAgICAgbGV0IHRvdGFsSXJxID0gMDtcbiAgICAgIGxldCB0b3RhbElkbGUgPSAwO1xuXG4gICAgICBsZXQgcmVzdWx0ID0gMDtcblxuICAgICAgaWYgKGNwdXMgJiYgY3B1cy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNwdXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjcHUgPSBjcHVzW2ldLnRpbWVzO1xuICAgICAgICAgIHRvdGFsVXNlciArPSBjcHUudXNlcjtcbiAgICAgICAgICB0b3RhbFN5c3RlbSArPSBjcHUuc3lzO1xuICAgICAgICAgIHRvdGFsTmljZSArPSBjcHUubmljZTtcbiAgICAgICAgICB0b3RhbElycSArPSBjcHUuaXJxO1xuICAgICAgICAgIHRvdGFsSWRsZSArPSBjcHUuaWRsZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWxUaWNrcyA9IHRvdGFsSWRsZSArIHRvdGFsSXJxICsgdG90YWxOaWNlICsgdG90YWxTeXN0ZW0gKyB0b3RhbFVzZXI7XG4gICAgICAgIHJlc3VsdCA9ICh0b3RhbFRpY2tzIC0gdG90YWxJZGxlKSAvIHRvdGFsVGlja3MgKiAxMDAuMDtcblxuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZnVsbExvYWQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGdldEZ1bGxMb2FkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZnVsbExvYWQgPSBmdWxsTG9hZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gZG9ja2VyLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTMuIERvY2tlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBEb2NrZXJTb2NrZXQgPSByZXF1aXJlKCcuL2RvY2tlclNvY2tldCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5cbmxldCBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0cyA9IHt9O1xubGV0IF9kb2NrZXJfc29ja2V0O1xubGV0IF9kb2NrZXJfbGFzdF9yZWFkID0gMDtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0IGNvbnRhaW5lcnMgKHBhcmFtZXRlciBhbGw6IGdldCBhbHNvIGluYWN0aXZlL2V4aXRlZCBjb250YWluZXJzKVxuXG5mdW5jdGlvbiBkb2NrZXJJbmZvKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICBfZG9ja2VyX3NvY2tldC5nZXRJbmZvKChkYXRhKSA9PiB7XG4gICAgICAgIHJlc3VsdC5pZCA9IGRhdGEuSUQ7XG4gICAgICAgIHJlc3VsdC5jb250YWluZXJzID0gZGF0YS5Db250YWluZXJzO1xuICAgICAgICByZXN1bHQuY29udGFpbmVyc1J1bm5pbmcgPSBkYXRhLkNvbnRhaW5lcnNSdW5uaW5nO1xuICAgICAgICByZXN1bHQuY29udGFpbmVyc1BhdXNlZCA9IGRhdGEuQ29udGFpbmVyc1BhdXNlZDtcbiAgICAgICAgcmVzdWx0LmNvbnRhaW5lcnNTdG9wcGVkID0gZGF0YS5Db250YWluZXJzU3RvcHBlZDtcbiAgICAgICAgcmVzdWx0LmltYWdlcyA9IGRhdGEuSW1hZ2VzO1xuICAgICAgICByZXN1bHQuZHJpdmVyID0gZGF0YS5Ecml2ZXI7XG4gICAgICAgIHJlc3VsdC5tZW1vcnlMaW1pdCA9IGRhdGEuTWVtb3J5TGltaXQ7XG4gICAgICAgIHJlc3VsdC5zd2FwTGltaXQgPSBkYXRhLlN3YXBMaW1pdDtcbiAgICAgICAgcmVzdWx0Lmtlcm5lbE1lbW9yeSA9IGRhdGEuS2VybmVsTWVtb3J5O1xuICAgICAgICByZXN1bHQuY3B1Q2ZzUGVyaW9kID0gZGF0YS5DcHVDZnNQZXJpb2Q7XG4gICAgICAgIHJlc3VsdC5jcHVDZnNRdW90YSA9IGRhdGEuQ3B1Q2ZzUXVvdGE7XG4gICAgICAgIHJlc3VsdC5jcHVTaGFyZXMgPSBkYXRhLkNQVVNoYXJlcztcbiAgICAgICAgcmVzdWx0LmNwdVNldCA9IGRhdGEuQ1BVU2V0O1xuICAgICAgICByZXN1bHQuaXB2NEZvcndhcmRpbmcgPSBkYXRhLklQdjRGb3J3YXJkaW5nO1xuICAgICAgICByZXN1bHQuYnJpZGdlTmZJcHRhYmxlcyA9IGRhdGEuQnJpZGdlTmZJcHRhYmxlcztcbiAgICAgICAgcmVzdWx0LmJyaWRnZU5mSXA2dGFibGVzID0gZGF0YS5CcmlkZ2VOZklwNnRhYmxlcztcbiAgICAgICAgcmVzdWx0LmRlYnVnID0gZGF0YS5EZWJ1ZztcbiAgICAgICAgcmVzdWx0Lm5mZCA9IGRhdGEuTkZkO1xuICAgICAgICByZXN1bHQub29tS2lsbERpc2FibGUgPSBkYXRhLk9vbUtpbGxEaXNhYmxlO1xuICAgICAgICByZXN1bHQubmdvcm91dGluZXMgPSBkYXRhLk5Hb3JvdXRpbmVzO1xuICAgICAgICByZXN1bHQuc3lzdGVtVGltZSA9IGRhdGEuU3lzdGVtVGltZTtcbiAgICAgICAgcmVzdWx0LmxvZ2dpbmdEcml2ZXIgPSBkYXRhLkxvZ2dpbmdEcml2ZXI7XG4gICAgICAgIHJlc3VsdC5jZ3JvdXBEcml2ZXIgPSBkYXRhLkNncm91cERyaXZlcjtcbiAgICAgICAgcmVzdWx0Lm5FdmVudHNMaXN0ZW5lciA9IGRhdGEuTkV2ZW50c0xpc3RlbmVyO1xuICAgICAgICByZXN1bHQua2VybmVsVmVyc2lvbiA9IGRhdGEuS2VybmVsVmVyc2lvbjtcbiAgICAgICAgcmVzdWx0Lm9wZXJhdGluZ1N5c3RlbSA9IGRhdGEuT3BlcmF0aW5nU3lzdGVtO1xuICAgICAgICByZXN1bHQub3NUeXBlID0gZGF0YS5PU1R5cGU7XG4gICAgICAgIHJlc3VsdC5hcmNoaXRlY3R1cmUgPSBkYXRhLkFyY2hpdGVjdHVyZTtcbiAgICAgICAgcmVzdWx0Lm5jcHUgPSBkYXRhLk5DUFU7XG4gICAgICAgIHJlc3VsdC5tZW1Ub3RhbCA9IGRhdGEuTWVtVG90YWw7XG4gICAgICAgIHJlc3VsdC5kb2NrZXJSb290RGlyID0gZGF0YS5Eb2NrZXJSb290RGlyO1xuICAgICAgICByZXN1bHQuaHR0cFByb3h5ID0gZGF0YS5IdHRwUHJveHk7XG4gICAgICAgIHJlc3VsdC5odHRwc1Byb3h5ID0gZGF0YS5IdHRwc1Byb3h5O1xuICAgICAgICByZXN1bHQubm9Qcm94eSA9IGRhdGEuTm9Qcm94eTtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSBkYXRhLk5hbWU7XG4gICAgICAgIHJlc3VsdC5sYWJlbHMgPSBkYXRhLkxhYmVscztcbiAgICAgICAgcmVzdWx0LmV4cGVyaW1lbnRhbEJ1aWxkID0gZGF0YS5FeHBlcmltZW50YWxCdWlsZDtcbiAgICAgICAgcmVzdWx0LnNlcnZlclZlcnNpb24gPSBkYXRhLlNlcnZlclZlcnNpb247XG4gICAgICAgIHJlc3VsdC5jbHVzdGVyU3RvcmUgPSBkYXRhLkNsdXN0ZXJTdG9yZTtcbiAgICAgICAgcmVzdWx0LmNsdXN0ZXJBZHZlcnRpc2UgPSBkYXRhLkNsdXN0ZXJBZHZlcnRpc2U7XG4gICAgICAgIHJlc3VsdC5kZWZhdWx0UnVudGltZSA9IGRhdGEuRGVmYXVsdFJ1bnRpbWU7XG4gICAgICAgIHJlc3VsdC5saXZlUmVzdG9yZUVuYWJsZWQgPSBkYXRhLkxpdmVSZXN0b3JlRW5hYmxlZDtcbiAgICAgICAgcmVzdWx0Lmlzb2xhdGlvbiA9IGRhdGEuSXNvbGF0aW9uO1xuICAgICAgICByZXN1bHQuaW5pdEJpbmFyeSA9IGRhdGEuSW5pdEJpbmFyeTtcbiAgICAgICAgcmVzdWx0LnByb2R1Y3RMaWNlbnNlID0gZGF0YS5Qcm9kdWN0TGljZW5zZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckluZm8gPSBkb2NrZXJJbmZvO1xuXG5mdW5jdGlvbiBkb2NrZXJJbWFnZXMoYWxsLCBjYWxsYmFjaykge1xuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGFsbCkgJiYgIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBhbGw7XG4gICAgYWxsID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhbGwgPT09ICdzdHJpbmcnICYmIGFsbCA9PT0gJ3RydWUnKSB7XG4gICAgYWxsID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGFsbCAhPT0gJ2Jvb2xlYW4nICYmIGFsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWxsID0gZmFsc2U7XG4gIH1cblxuICBhbGwgPSBhbGwgfHwgZmFsc2U7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcblxuICAgICAgX2RvY2tlcl9zb2NrZXQubGlzdEltYWdlcyhhbGwsIGRhdGEgPT4ge1xuICAgICAgICBsZXQgZG9ja2VySW1hZ2VzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9ja2VySW1hZ2VzID0gZGF0YTtcbiAgICAgICAgICBpZiAoZG9ja2VySW1hZ2VzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2NrZXJJbWFnZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGRvY2tlckltYWdlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGRvY2tlckltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuTmFtZXMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQuTmFtZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGVsZW1lbnQuTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuTmFtZSA9IGVsZW1lbnQuTmFtZXNbMF0ucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3b3JrbG9hZC5wdXNoKGRvY2tlckltYWdlc0luc3BlY3QoZWxlbWVudC5JZC50cmltKCksIGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdvcmtsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb250YWluZXIgaW5zcGVjdCAoZm9yIG9uZSBjb250YWluZXIpXG5cbmZ1bmN0aW9uIGRvY2tlckltYWdlc0luc3BlY3QoaW1hZ2VJRCwgcGF5bG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGltYWdlSUQgPSBpbWFnZUlEIHx8ICcnO1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZUlEICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW1hZ2VJRFNhbml0aXplZCA9ICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICcnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGltYWdlSUQsIHRydWUpKS50cmltKCk7XG4gICAgICBpZiAoaW1hZ2VJRFNhbml0aXplZCkge1xuXG4gICAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kb2NrZXJfc29ja2V0Lmluc3BlY3RJbWFnZShpbWFnZUlEU2FuaXRpemVkLnRyaW0oKSwgZGF0YSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBpZDogcGF5bG9hZC5JZCxcbiAgICAgICAgICAgICAgY29udGFpbmVyOiBkYXRhLkNvbnRhaW5lcixcbiAgICAgICAgICAgICAgY29tbWVudDogZGF0YS5Db21tZW50LFxuICAgICAgICAgICAgICBvczogZGF0YS5PcyxcbiAgICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBkYXRhLkFyY2hpdGVjdHVyZSxcbiAgICAgICAgICAgICAgcGFyZW50OiBkYXRhLlBhcmVudCxcbiAgICAgICAgICAgICAgZG9ja2VyVmVyc2lvbjogZGF0YS5Eb2NrZXJWZXJzaW9uLFxuICAgICAgICAgICAgICBzaXplOiBkYXRhLlNpemUsXG4gICAgICAgICAgICAgIHNoYXJlZFNpemU6IHBheWxvYWQuU2hhcmVkU2l6ZSxcbiAgICAgICAgICAgICAgdmlydHVhbFNpemU6IGRhdGEuVmlydHVhbFNpemUsXG4gICAgICAgICAgICAgIGF1dGhvcjogZGF0YS5BdXRob3IsXG4gICAgICAgICAgICAgIGNyZWF0ZWQ6IGRhdGEuQ3JlYXRlZCA/IE1hdGgucm91bmQobmV3IERhdGUoZGF0YS5DcmVhdGVkKS5nZXRUaW1lKCkgLyAxMDAwKSA6IDAsXG4gICAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZzogZGF0YS5Db250YWluZXJDb25maWcgPyBkYXRhLkNvbnRhaW5lckNvbmZpZyA6IHt9LFxuICAgICAgICAgICAgICBncmFwaERyaXZlcjogZGF0YS5HcmFwaERyaXZlciA/IGRhdGEuR3JhcGhEcml2ZXIgOiB7fSxcbiAgICAgICAgICAgICAgcmVwb0RpZ2VzdHM6IGRhdGEuUmVwb0RpZ2VzdHMgPyBkYXRhLlJlcG9EaWdlc3RzIDoge30sXG4gICAgICAgICAgICAgIHJlcG9UYWdzOiBkYXRhLlJlcG9UYWdzID8gZGF0YS5SZXBvVGFncyA6IHt9LFxuICAgICAgICAgICAgICBjb25maWc6IGRhdGEuQ29uZmlnID8gZGF0YS5Db25maWcgOiB7fSxcbiAgICAgICAgICAgICAgcm9vdEZTOiBkYXRhLlJvb3RGUyA/IGRhdGEuUm9vdEZTIDoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJJbWFnZXMgPSBkb2NrZXJJbWFnZXM7XG5cbmZ1bmN0aW9uIGRvY2tlckNvbnRhaW5lcnMoYWxsLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIGluQ29udGFpbmVycyhjb250YWluZXJzLCBpZCkge1xuICAgIGxldCBmaWx0ZXJlZCA9IGNvbnRhaW5lcnMuZmlsdGVyKG9iaiA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgSWRcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIChvYmouSWQgJiYgKG9iai5JZCA9PT0gaWQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKGZpbHRlcmVkLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oYWxsKSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGFsbDtcbiAgICBhbGwgPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGFsbCA9PT0gJ3N0cmluZycgJiYgYWxsID09PSAndHJ1ZScpIHtcbiAgICBhbGwgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYWxsICE9PSAnYm9vbGVhbicgJiYgYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbGwgPSBmYWxzZTtcbiAgfVxuXG4gIGFsbCA9IGFsbCB8fCBmYWxzZTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuXG4gICAgICBfZG9ja2VyX3NvY2tldC5saXN0Q29udGFpbmVycyhhbGwsIGRhdGEgPT4ge1xuICAgICAgICBsZXQgZG9ja2VyX2NvbnRhaW5lcnMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2NrZXJfY29udGFpbmVycyA9IGRhdGE7XG4gICAgICAgICAgaWYgKGRvY2tlcl9jb250YWluZXJzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2NrZXJfY29udGFpbmVycykgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgZG9ja2VyX2NvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gR0MgaW4gX2RvY2tlcl9jb250YWluZXJfc3RhdHNcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0cykge1xuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChfZG9ja2VyX2NvbnRhaW5lcl9zdGF0cywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5Db250YWluZXJzKGRvY2tlcl9jb250YWluZXJzLCBrZXkpKSB7IGRlbGV0ZSBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0c1trZXldOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9ja2VyX2NvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lk5hbWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50Lk5hbWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBlbGVtZW50Lk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lk5hbWUgPSBlbGVtZW50Lk5hbWVzWzBdLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya2xvYWQucHVzaChkb2NrZXJDb250YWluZXJJbnNwZWN0KGVsZW1lbnQuSWQudHJpbSgpLCBlbGVtZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh3b3JrbG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBHQyBpbiBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0c1xuICAgICAgICAgIGZvciAobGV0IGtleSBpbiBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0cykge1xuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoX2RvY2tlcl9jb250YWluZXJfc3RhdHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpbkNvbnRhaW5lcnMoZG9ja2VyX2NvbnRhaW5lcnMsIGtleSkpIHsgZGVsZXRlIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzW2tleV07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnRhaW5lciBpbnNwZWN0IChmb3Igb25lIGNvbnRhaW5lcilcblxuZnVuY3Rpb24gZG9ja2VyQ29udGFpbmVySW5zcGVjdChjb250YWluZXJJRCwgcGF5bG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnRhaW5lcklEID0gY29udGFpbmVySUQgfHwgJyc7XG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lcklEICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGFpbmVySWRTYW5pdGl6ZWQgPSAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhjb250YWluZXJJRCwgdHJ1ZSkpLnRyaW0oKTtcbiAgICAgIGlmIChjb250YWluZXJJZFNhbml0aXplZCkge1xuXG4gICAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kb2NrZXJfc29ja2V0LmdldEluc3BlY3QoY29udGFpbmVySWRTYW5pdGl6ZWQudHJpbSgpLCBkYXRhID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGlkOiBwYXlsb2FkLklkLFxuICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLk5hbWUsXG4gICAgICAgICAgICAgIGltYWdlOiBwYXlsb2FkLkltYWdlLFxuICAgICAgICAgICAgICBpbWFnZUlEOiBwYXlsb2FkLkltYWdlSUQsXG4gICAgICAgICAgICAgIGNvbW1hbmQ6IHBheWxvYWQuQ29tbWFuZCxcbiAgICAgICAgICAgICAgY3JlYXRlZDogcGF5bG9hZC5DcmVhdGVkLFxuICAgICAgICAgICAgICBzdGFydGVkOiBkYXRhLlN0YXRlICYmIGRhdGEuU3RhdGUuU3RhcnRlZEF0ID8gTWF0aC5yb3VuZChuZXcgRGF0ZShkYXRhLlN0YXRlLlN0YXJ0ZWRBdCkuZ2V0VGltZSgpIC8gMTAwMCkgOiAwLFxuICAgICAgICAgICAgICBmaW5pc2hlZDogZGF0YS5TdGF0ZSAmJiBkYXRhLlN0YXRlLkZpbmlzaGVkQXQgJiYgIWRhdGEuU3RhdGUuRmluaXNoZWRBdC5zdGFydHNXaXRoKCcwMDAxLTAxLTAxJykgPyBNYXRoLnJvdW5kKG5ldyBEYXRlKGRhdGEuU3RhdGUuRmluaXNoZWRBdCkuZ2V0VGltZSgpIC8gMTAwMCkgOiAwLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuQ3JlYXRlZCA/IGRhdGEuQ3JlYXRlZCA6ICcnLFxuICAgICAgICAgICAgICBzdGFydGVkQXQ6IGRhdGEuU3RhdGUgJiYgZGF0YS5TdGF0ZS5TdGFydGVkQXQgPyBkYXRhLlN0YXRlLlN0YXJ0ZWRBdCA6ICcnLFxuICAgICAgICAgICAgICBmaW5pc2hlZEF0OiBkYXRhLlN0YXRlICYmIGRhdGEuU3RhdGUuRmluaXNoZWRBdCAmJiAhZGF0YS5TdGF0ZS5GaW5pc2hlZEF0LnN0YXJ0c1dpdGgoJzAwMDEtMDEtMDEnKSA/IGRhdGEuU3RhdGUuRmluaXNoZWRBdCA6ICcnLFxuICAgICAgICAgICAgICBzdGF0ZTogcGF5bG9hZC5TdGF0ZSxcbiAgICAgICAgICAgICAgcmVzdGFydENvdW50OiBkYXRhLlJlc3RhcnRDb3VudCB8fCAwLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogZGF0YS5QbGF0Zm9ybSB8fCAnJyxcbiAgICAgICAgICAgICAgZHJpdmVyOiBkYXRhLkRyaXZlciB8fCAnJyxcbiAgICAgICAgICAgICAgcG9ydHM6IHBheWxvYWQuUG9ydHMsXG4gICAgICAgICAgICAgIG1vdW50czogcGF5bG9hZC5Nb3VudHMsXG4gICAgICAgICAgICAgIC8vIGhvc3Rjb25maWc6IHBheWxvYWQuSG9zdENvbmZpZyxcbiAgICAgICAgICAgICAgLy8gbmV0d29yazogcGF5bG9hZC5OZXR3b3JrU2V0dGluZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckNvbnRhaW5lcnMgPSBkb2NrZXJDb250YWluZXJzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaGVscGVyIGZ1bmN0aW9ucyBmb3IgY2FsY3VsYXRpb24gb2YgZG9ja2VyIHN0YXRzXG5cbmZ1bmN0aW9uIGRvY2tlcl9jYWxjQ1BVUGVyY2VudChjcHVfc3RhdHMsIHByZWNwdV9zdGF0cykge1xuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAcHJvcGVydHkge29iamVjdH0gIGNwdV91c2FnZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gIGNwdV91c2FnZS50b3RhbF91c2FnZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gIHN5c3RlbV9jcHVfdXNhZ2VcbiAgICogQHByb3BlcnR5IHtvYmplY3R9ICBjcHVfdXNhZ2VcbiAgICogQHByb3BlcnR5IHtBcnJheX0gIGNwdV91c2FnZS5wZXJjcHVfdXNhZ2VcbiAgICovXG5cbiAgaWYgKCFfd2luZG93cykge1xuICAgIGxldCBjcHVQZXJjZW50ID0gMC4wO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgY2hhbmdlIGZvciB0aGUgY3B1IHVzYWdlIG9mIHRoZSBjb250YWluZXIgaW4gYmV0d2VlbiByZWFkaW5nc1xuICAgIGxldCBjcHVEZWx0YSA9IGNwdV9zdGF0cy5jcHVfdXNhZ2UudG90YWxfdXNhZ2UgLSBwcmVjcHVfc3RhdHMuY3B1X3VzYWdlLnRvdGFsX3VzYWdlO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgY2hhbmdlIGZvciB0aGUgZW50aXJlIHN5c3RlbSBiZXR3ZWVuIHJlYWRpbmdzXG4gICAgbGV0IHN5c3RlbURlbHRhID0gY3B1X3N0YXRzLnN5c3RlbV9jcHVfdXNhZ2UgLSBwcmVjcHVfc3RhdHMuc3lzdGVtX2NwdV91c2FnZTtcblxuICAgIGlmIChzeXN0ZW1EZWx0YSA+IDAuMCAmJiBjcHVEZWx0YSA+IDAuMCkge1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjaGFuZ2UgZm9yIHRoZSBjcHUgdXNhZ2Ugb2YgdGhlIGNvbnRhaW5lciBpbiBiZXR3ZWVuIHJlYWRpbmdzXG4gICAgICBpZiAocHJlY3B1X3N0YXRzLm9ubGluZV9jcHVzKSB7XG4gICAgICAgIGNwdVBlcmNlbnQgPSAoY3B1RGVsdGEgLyBzeXN0ZW1EZWx0YSkgKiBwcmVjcHVfc3RhdHMub25saW5lX2NwdXMgKiAxMDAuMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjcHVQZXJjZW50ID0gKGNwdURlbHRhIC8gc3lzdGVtRGVsdGEpICogY3B1X3N0YXRzLmNwdV91c2FnZS5wZXJjcHVfdXNhZ2UubGVuZ3RoICogMTAwLjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNwdVBlcmNlbnQ7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hbm9TZWNOb3cgPSB1dGlsLm5hbm9TZWNvbmRzKCk7XG4gICAgbGV0IGNwdVBlcmNlbnQgPSAwLjA7XG4gICAgaWYgKF9kb2NrZXJfbGFzdF9yZWFkID4gMCkge1xuICAgICAgbGV0IHBvc3NJbnRlcnZhbHMgPSAobmFub1NlY05vdyAtIF9kb2NrZXJfbGFzdF9yZWFkKTsgLy8gIC8gMTAwICogb3MuY3B1cygpLmxlbmd0aDtcbiAgICAgIGxldCBpbnRlcnZhbHNVc2VkID0gY3B1X3N0YXRzLmNwdV91c2FnZS50b3RhbF91c2FnZSAtIHByZWNwdV9zdGF0cy5jcHVfdXNhZ2UudG90YWxfdXNhZ2U7XG4gICAgICBpZiAocG9zc0ludGVydmFscyA+IDApIHtcbiAgICAgICAgY3B1UGVyY2VudCA9IDEwMC4wICogaW50ZXJ2YWxzVXNlZCAvIHBvc3NJbnRlcnZhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIF9kb2NrZXJfbGFzdF9yZWFkID0gbmFub1NlY05vdztcbiAgICByZXR1cm4gY3B1UGVyY2VudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb2NrZXJfY2FsY05ldHdvcmtJTyhuZXR3b3Jrcykge1xuICBsZXQgcng7XG4gIGxldCB3eDtcbiAgZm9yIChsZXQga2V5IGluIG5ldHdvcmtzKSB7XG4gICAgLy8gc2tpcCBsb29wIGlmIHRoZSBwcm9wZXJ0eSBpcyBmcm9tIHByb3RvdHlwZVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChuZXR3b3Jrcywga2V5KSkgeyBjb250aW51ZTsgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgcnhfYnl0ZXNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIHR4X2J5dGVzXG4gICAgICovXG4gICAgbGV0IG9iaiA9IG5ldHdvcmtzW2tleV07XG4gICAgcnggPSArb2JqLnJ4X2J5dGVzO1xuICAgIHd4ID0gK29iai50eF9ieXRlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHJ4LFxuICAgIHd4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRvY2tlcl9jYWxjQmxvY2tJTyhibGtpb19zdGF0cykge1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIHI6IDAsXG4gICAgdzogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICBpb19zZXJ2aWNlX2J5dGVzX3JlY3Vyc2l2ZVxuICAgKi9cbiAgaWYgKGJsa2lvX3N0YXRzICYmIGJsa2lvX3N0YXRzLmlvX3NlcnZpY2VfYnl0ZXNfcmVjdXJzaXZlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChibGtpb19zdGF0cy5pb19zZXJ2aWNlX2J5dGVzX3JlY3Vyc2l2ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgYmxraW9fc3RhdHMuaW9fc2VydmljZV9ieXRlc19yZWN1cnNpdmUubGVuZ3RoID4gMCkge1xuICAgIGJsa2lvX3N0YXRzLmlvX3NlcnZpY2VfYnl0ZXNfcmVjdXJzaXZlLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBvcFxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICB2YWx1ZVxuICAgICAgICovXG5cbiAgICAgIGlmIChlbGVtZW50Lm9wICYmIGVsZW1lbnQub3AudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWQnICYmIGVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnIgKz0gZWxlbWVudC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Lm9wICYmIGVsZW1lbnQub3AudG9Mb3dlckNhc2UoKSA9PT0gJ3dyaXRlJyAmJiBlbGVtZW50LnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC53ICs9IGVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZG9ja2VyQ29udGFpbmVyU3RhdHMoY29udGFpbmVySURzLCBjYWxsYmFjaykge1xuXG4gIGxldCBjb250YWluZXJBcnJheSA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNvbnRhaW5lcklEcykgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY29udGFpbmVySURzO1xuICAgICAgICBjb250YWluZXJBcnJheSA9IFsnKiddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVySURzID0gY29udGFpbmVySURzIHx8ICcqJztcbiAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJJRHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKFtdKTsgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVySURzU2FuaXRpemVkID0gJyc7XG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZC5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZC5fX3Byb3RvX18ucmVwbGFjZSA9IHV0aWwuc3RyaW5nUmVwbGFjZTtcbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkLl9fcHJvdG9fXy50cmltID0gdXRpbC5zdHJpbmdUcmltO1xuXG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZCA9IGNvbnRhaW5lcklEcztcbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkID0gY29udGFpbmVySURzU2FuaXRpemVkLnRyaW0oKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcklEc1Nhbml0aXplZCAhPT0gJyonKSB7XG4gICAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkID0gJyc7XG4gICAgICAgICAgY29uc3QgcyA9ICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICcnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGNvbnRhaW5lcklEcywgdHJ1ZSkpLnRyaW0oKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc1tpXS5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgICAgICAgIGNvbnN0IHNsID0gc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoc2wgJiYgc2xbMF0gJiYgIXNsWzFdKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkID0gY29udGFpbmVySURzU2FuaXRpemVkICsgc2xbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSBjb250YWluZXJJRHNTYW5pdGl6ZWQudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLCsvZywgJ3wnKTtcbiAgICAgICAgY29udGFpbmVyQXJyYXkgPSBjb250YWluZXJJRHNTYW5pdGl6ZWQuc3BsaXQoJ3wnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICBpZiAoY29udGFpbmVyQXJyYXkubGVuZ3RoICYmIGNvbnRhaW5lckFycmF5WzBdLnRyaW0oKSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnRhaW5lckFycmF5ID0gW107XG4gICAgICAgIGRvY2tlckNvbnRhaW5lcnMoKS50aGVuKGFsbENvbnRhaW5lcnMgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGNvbnRhaW5lciBvZiBhbGxDb250YWluZXJzKSB7XG4gICAgICAgICAgICBjb250YWluZXJBcnJheS5wdXNoKGNvbnRhaW5lci5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250YWluZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvY2tlckNvbnRhaW5lclN0YXRzKGNvbnRhaW5lckFycmF5LmpvaW4oJywnKSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgY29udGFpbmVySUQgb2YgY29udGFpbmVyQXJyYXkpIHtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKGRvY2tlckNvbnRhaW5lclN0YXRzU2luZ2xlKGNvbnRhaW5lcklELnRyaW0oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrbG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb250YWluZXIgc3RhdHMgKGZvciBvbmUgY29udGFpbmVyKVxuXG5mdW5jdGlvbiBkb2NrZXJDb250YWluZXJTdGF0c1NpbmdsZShjb250YWluZXJJRCkge1xuICBjb250YWluZXJJRCA9IGNvbnRhaW5lcklEIHx8ICcnO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGlkOiBjb250YWluZXJJRCxcbiAgICBtZW1Vc2FnZTogMCxcbiAgICBtZW1MaW1pdDogMCxcbiAgICBtZW1QZXJjZW50OiAwLFxuICAgIGNwdVBlcmNlbnQ6IDAsXG4gICAgcGlkczogMCxcbiAgICBuZXRJTzoge1xuICAgICAgcng6IDAsXG4gICAgICB3eDogMFxuICAgIH0sXG4gICAgYmxvY2tJTzoge1xuICAgICAgcjogMCxcbiAgICAgIHc6IDBcbiAgICB9LFxuICAgIHJlc3RhcnRDb3VudDogMCxcbiAgICBjcHVTdGF0czoge30sXG4gICAgcHJlY3B1U3RhdHM6IHt9LFxuICAgIG1lbW9yeVN0YXRzOiB7fSxcbiAgICBuZXR3b3Jrczoge30sXG4gIH07XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5lcklEKSB7XG5cbiAgICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2RvY2tlcl9zb2NrZXQuZ2V0SW5zcGVjdChjb250YWluZXJJRCwgZGF0YUluc3BlY3QgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfZG9ja2VyX3NvY2tldC5nZXRTdGF0cyhjb250YWluZXJJRCwgZGF0YSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXRzID0gZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmICghc3RhdHMubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lbVVzYWdlID0gKHN0YXRzLm1lbW9yeV9zdGF0cyAmJiBzdGF0cy5tZW1vcnlfc3RhdHMudXNhZ2UgPyBzdGF0cy5tZW1vcnlfc3RhdHMudXNhZ2UgOiAwKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZW1MaW1pdCA9IChzdGF0cy5tZW1vcnlfc3RhdHMgJiYgc3RhdHMubWVtb3J5X3N0YXRzLmxpbWl0ID8gc3RhdHMubWVtb3J5X3N0YXRzLmxpbWl0IDogMCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWVtUGVyY2VudCA9IChzdGF0cy5tZW1vcnlfc3RhdHMgJiYgc3RhdHMubWVtb3J5X3N0YXRzLnVzYWdlICYmIHN0YXRzLm1lbW9yeV9zdGF0cy5saW1pdCA/IHN0YXRzLm1lbW9yeV9zdGF0cy51c2FnZSAvIHN0YXRzLm1lbW9yeV9zdGF0cy5saW1pdCAqIDEwMC4wIDogMCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY3B1UGVyY2VudCA9IChzdGF0cy5jcHVfc3RhdHMgJiYgc3RhdHMucHJlY3B1X3N0YXRzID8gZG9ja2VyX2NhbGNDUFVQZXJjZW50KHN0YXRzLmNwdV9zdGF0cywgc3RhdHMucHJlY3B1X3N0YXRzKSA6IDApO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnBpZHMgPSAoc3RhdHMucGlkc19zdGF0cyAmJiBzdGF0cy5waWRzX3N0YXRzLmN1cnJlbnQgPyBzdGF0cy5waWRzX3N0YXRzLmN1cnJlbnQgOiAwKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXN0YXJ0Q291bnQgPSAoZGF0YUluc3BlY3QuUmVzdGFydENvdW50ID8gZGF0YUluc3BlY3QuUmVzdGFydENvdW50IDogMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhdHMubmV0d29ya3MpIHsgcmVzdWx0Lm5ldElPID0gZG9ja2VyX2NhbGNOZXR3b3JrSU8oc3RhdHMubmV0d29ya3MpOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuYmxraW9fc3RhdHMpIHsgcmVzdWx0LmJsb2NrSU8gPSBkb2NrZXJfY2FsY0Jsb2NrSU8oc3RhdHMuYmxraW9fc3RhdHMpOyB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY3B1U3RhdHMgPSAoc3RhdHMuY3B1X3N0YXRzID8gc3RhdHMuY3B1X3N0YXRzIDoge30pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnByZWNwdVN0YXRzID0gKHN0YXRzLnByZWNwdV9zdGF0cyA/IHN0YXRzLnByZWNwdV9zdGF0cyA6IHt9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZW1vcnlTdGF0cyA9IChzdGF0cy5tZW1vcnlfc3RhdHMgPyBzdGF0cy5tZW1vcnlfc3RhdHMgOiB7fSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubmV0d29ya3MgPSAoc3RhdHMubmV0d29ya3MgPyBzdGF0cy5uZXR3b3JrcyA6IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJDb250YWluZXJTdGF0cyA9IGRvY2tlckNvbnRhaW5lclN0YXRzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29udGFpbmVyIHByb2Nlc3NlcyAoZm9yIG9uZSBjb250YWluZXIpXG5cbmZ1bmN0aW9uIGRvY2tlckNvbnRhaW5lclByb2Nlc3Nlcyhjb250YWluZXJJRCwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnRhaW5lcklEID0gY29udGFpbmVySUQgfHwgJyc7XG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lcklEICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGFpbmVySWRTYW5pdGl6ZWQgPSAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhjb250YWluZXJJRCwgdHJ1ZSkpLnRyaW0oKTtcblxuICAgICAgaWYgKGNvbnRhaW5lcklkU2FuaXRpemVkKSB7XG5cbiAgICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2RvY2tlcl9zb2NrZXQuZ2V0UHJvY2Vzc2VzKGNvbnRhaW5lcklkU2FuaXRpemVkLCBkYXRhID0+IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gIFRpdGxlc1xuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICBQcm9jZXNzZXNcbiAgICAgICAgICAgKiovXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuVGl0bGVzICYmIGRhdGEuUHJvY2Vzc2VzKSB7XG4gICAgICAgICAgICAgIGxldCB0aXRsZXMgPSBkYXRhLlRpdGxlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsZXQgcG9zX3BpZCA9IHRpdGxlcy5pbmRleE9mKCdQSUQnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19wcGlkID0gdGl0bGVzLmluZGV4T2YoJ1BQSUQnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19wZ2lkID0gdGl0bGVzLmluZGV4T2YoJ1BHSUQnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc192c3ogPSB0aXRsZXMuaW5kZXhPZignVlNaJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfdGltZSA9IHRpdGxlcy5pbmRleE9mKCdUSU1FJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfZWxhcHNlZCA9IHRpdGxlcy5pbmRleE9mKCdFTEFQU0VEJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfbmkgPSB0aXRsZXMuaW5kZXhPZignTkknKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19ydXNlciA9IHRpdGxlcy5pbmRleE9mKCdSVVNFUicpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3VzZXIgPSB0aXRsZXMuaW5kZXhPZignVVNFUicpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3Jncm91cCA9IHRpdGxlcy5pbmRleE9mKCdSR1JPVVAnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19ncm91cCA9IHRpdGxlcy5pbmRleE9mKCdHUk9VUCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3N0YXQgPSB0aXRsZXMuaW5kZXhPZignU1RBVCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3JzcyA9IHRpdGxlcy5pbmRleE9mKCdSU1MnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19jb21tYW5kID0gdGl0bGVzLmluZGV4T2YoJ0NPTU1BTkQnKTtcblxuICAgICAgICAgICAgICBkYXRhLlByb2Nlc3Nlcy5mb3JFYWNoKHByb2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHBpZEhvc3Q6IChwb3NfcGlkID49IDAgPyBwcm9jZXNzW3Bvc19waWRdIDogJycpLFxuICAgICAgICAgICAgICAgICAgcHBpZDogKHBvc19wcGlkID49IDAgPyBwcm9jZXNzW3Bvc19wcGlkXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHBnaWQ6IChwb3NfcGdpZCA+PSAwID8gcHJvY2Vzc1twb3NfcGdpZF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICB1c2VyOiAocG9zX3VzZXIgPj0gMCA/IHByb2Nlc3NbcG9zX3VzZXJdIDogJycpLFxuICAgICAgICAgICAgICAgICAgcnVzZXI6IChwb3NfcnVzZXIgPj0gMCA/IHByb2Nlc3NbcG9zX3J1c2VyXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIGdyb3VwOiAocG9zX2dyb3VwID49IDAgPyBwcm9jZXNzW3Bvc19ncm91cF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICByZ3JvdXA6IChwb3Nfcmdyb3VwID49IDAgPyBwcm9jZXNzW3Bvc19yZ3JvdXBdIDogJycpLFxuICAgICAgICAgICAgICAgICAgc3RhdDogKHBvc19zdGF0ID49IDAgPyBwcm9jZXNzW3Bvc19zdGF0XSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IChwb3NfdGltZSA+PSAwID8gcHJvY2Vzc1twb3NfdGltZV0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBlbGFwc2VkOiAocG9zX2VsYXBzZWQgPj0gMCA/IHByb2Nlc3NbcG9zX2VsYXBzZWRdIDogJycpLFxuICAgICAgICAgICAgICAgICAgbmljZTogKHBvc19uaSA+PSAwID8gcHJvY2Vzc1twb3NfbmldIDogJycpLFxuICAgICAgICAgICAgICAgICAgcnNzOiAocG9zX3JzcyA+PSAwID8gcHJvY2Vzc1twb3NfcnNzXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHZzejogKHBvc192c3ogPj0gMCA/IHByb2Nlc3NbcG9zX3Zzel0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiAocG9zX2NvbW1hbmQgPj0gMCA/IHByb2Nlc3NbcG9zX2NvbW1hbmRdIDogJycpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzID0gZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzO1xuXG5mdW5jdGlvbiBkb2NrZXJWb2x1bWVzKGNhbGxiYWNrKSB7XG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICB9XG4gICAgICBfZG9ja2VyX3NvY2tldC5saXN0Vm9sdW1lcygoZGF0YSkgPT4ge1xuICAgICAgICBsZXQgZG9ja2VyVm9sdW1lcyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY2tlclZvbHVtZXMgPSBkYXRhO1xuICAgICAgICAgIGlmIChkb2NrZXJWb2x1bWVzICYmIGRvY2tlclZvbHVtZXMuVm9sdW1lcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9ja2VyVm9sdW1lcy5Wb2x1bWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBkb2NrZXJWb2x1bWVzLlZvbHVtZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBkb2NrZXJWb2x1bWVzLlZvbHVtZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50Lk5hbWUsXG4gICAgICAgICAgICAgICAgZHJpdmVyOiBlbGVtZW50LkRyaXZlcixcbiAgICAgICAgICAgICAgICBsYWJlbHM6IGVsZW1lbnQuTGFiZWxzLFxuICAgICAgICAgICAgICAgIG1vdW50cG9pbnQ6IGVsZW1lbnQuTW91bnRwb2ludCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBlbGVtZW50Lk9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2NvcGU6IGVsZW1lbnQuU2NvcGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlZDogZWxlbWVudC5DcmVhdGVkQXQgPyBNYXRoLnJvdW5kKG5ldyBEYXRlKGVsZW1lbnQuQ3JlYXRlZEF0KS5nZXRUaW1lKCkgLyAxMDAwKSA6IDAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJWb2x1bWVzID0gZG9ja2VyVm9sdW1lcztcblxuZnVuY3Rpb24gZG9ja2VyQWxsKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgZG9ja2VyQ29udGFpbmVycyh0cnVlKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlc3VsdCkgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgbCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY2tlckNvbnRhaW5lclN0YXRzKGVsZW1lbnQuaWQpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAvLyBpbmNsdWRlIHN0YXRzIGluIGFycmF5XG4gICAgICAgICAgICAgIGVsZW1lbnQubWVtVXNhZ2UgPSByZXNbMF0ubWVtVXNhZ2U7XG4gICAgICAgICAgICAgIGVsZW1lbnQubWVtTGltaXQgPSByZXNbMF0ubWVtTGltaXQ7XG4gICAgICAgICAgICAgIGVsZW1lbnQubWVtUGVyY2VudCA9IHJlc1swXS5tZW1QZXJjZW50O1xuICAgICAgICAgICAgICBlbGVtZW50LmNwdVBlcmNlbnQgPSByZXNbMF0uY3B1UGVyY2VudDtcbiAgICAgICAgICAgICAgZWxlbWVudC5waWRzID0gcmVzWzBdLnBpZHM7XG4gICAgICAgICAgICAgIGVsZW1lbnQubmV0SU8gPSByZXNbMF0ubmV0SU87XG4gICAgICAgICAgICAgIGVsZW1lbnQuYmxvY2tJTyA9IHJlc1swXS5ibG9ja0lPO1xuICAgICAgICAgICAgICBlbGVtZW50LmNwdVN0YXRzID0gcmVzWzBdLmNwdVN0YXRzO1xuICAgICAgICAgICAgICBlbGVtZW50LnByZWNwdVN0YXRzID0gcmVzWzBdLnByZWNwdVN0YXRzO1xuICAgICAgICAgICAgICBlbGVtZW50Lm1lbW9yeVN0YXRzID0gcmVzWzBdLm1lbW9yeVN0YXRzO1xuICAgICAgICAgICAgICBlbGVtZW50Lm5ldHdvcmtzID0gcmVzWzBdLm5ldHdvcmtzO1xuXG4gICAgICAgICAgICAgIGRvY2tlckNvbnRhaW5lclByb2Nlc3NlcyhlbGVtZW50LmlkKS50aGVuKHByb2Nlc3NlcyA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wcm9jZXNzZXMgPSBwcm9jZXNzZXM7XG5cbiAgICAgICAgICAgICAgICBsIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gYWxsIGRvbmU/P1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJBbGwgPSBkb2NrZXJBbGw7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGRvY2tlclNvY2tldHMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxMy4gRG9ja2VyU29ja2V0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IGlzV2luID0gcmVxdWlyZSgnb3MnKS50eXBlKCkgPT09ICdXaW5kb3dzX05UJztcbmNvbnN0IHNvY2tldFBhdGggPSBpc1dpbiA/ICcvLy4vcGlwZS9kb2NrZXJfZW5naW5lJyA6ICcvdmFyL3J1bi9kb2NrZXIuc29jayc7XG5cbmNsYXNzIERvY2tlclNvY2tldCB7XG5cbiAgZ2V0SW5mbyhjYWxsYmFjaykge1xuICAgIHRyeSB7XG5cbiAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovaW5mbyBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBsaXN0SW1hZ2VzKGFsbCwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuXG4gICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2ltYWdlcy9qc29uJyArIChhbGwgPyAnP2FsbD0xJyA6ICcnKSArICcgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgaW5zcGVjdEltYWdlKGlkLCBjYWxsYmFjaykge1xuICAgIGlkID0gaWQgfHwgJyc7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovaW1hZ2VzLycgKyBpZCArICcvanNvbj9zdHJlYW09MCBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGxpc3RDb250YWluZXJzKGFsbCwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuXG4gICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2NvbnRhaW5lcnMvanNvbicgKyAoYWxsID8gJz9hbGw9MScgOiAnJykgKyAnIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGdldFN0YXRzKGlkLCBjYWxsYmFjaykge1xuICAgIGlkID0gaWQgfHwgJyc7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovY29udGFpbmVycy8nICsgaWQgKyAnL3N0YXRzP3N0cmVhbT0wIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0SW5zcGVjdChpZCwgY2FsbGJhY2spIHtcbiAgICBpZCA9IGlkIHx8ICcnO1xuICAgIGlmIChpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2NvbnRhaW5lcnMvJyArIGlkICsgJy9qc29uP3N0cmVhbT0wIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvY2Vzc2VzKGlkLCBjYWxsYmFjaykge1xuICAgIGlkID0gaWQgfHwgJyc7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovY29udGFpbmVycy8nICsgaWQgKyAnL3RvcD9wc19hcmdzPS1vcGlkLHBwaWQscGdpZCx2c3osdGltZSxldGltZSxuaWNlLHJ1c2VyLHVzZXIscmdyb3VwLGdyb3VwLHN0YXQscnNzLGFyZ3MgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBsaXN0Vm9sdW1lcyhjYWxsYmFjaykge1xuICAgIHRyeSB7XG5cbiAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovdm9sdW1lcyBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEb2NrZXJTb2NrZXQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGZpbGVzeXN0ZW0uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA4LiBGaWxlIFN5c3RlbVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgZXhlY1Byb21pc2VTYXZlID0gdXRpbC5wcm9taXNpZnlTYXZlKHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmxldCBfZnNfc3BlZWQgPSB7fTtcbmxldCBfZGlza19pbyA9IHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRlMgLSBtb3VudGVkIGZpbGUgc3lzdGVtc1xuXG5mdW5jdGlvbiBmc1NpemUoY2FsbGJhY2spIHtcblxuICBsZXQgbWFjT3NEaXNrcyA9IFtdO1xuICBsZXQgb3NNb3VudHMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXRtYWNPc0ZzVHlwZShmcykge1xuICAgIGlmICghZnMuc3RhcnRzV2l0aCgnLycpKSB7IHJldHVybiAnTkZTJzsgfVxuICAgIGNvbnN0IHBhcnRzID0gZnMuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBmc1Nob3J0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbWFjT3NEaXNrc1NpbmdsZSA9IG1hY09zRGlza3MuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pbmRleE9mKGZzU2hvcnQpID49IDApO1xuICAgIGlmIChtYWNPc0Rpc2tzU2luZ2xlLmxlbmd0aCA9PT0gMSAmJiBtYWNPc0Rpc2tzU2luZ2xlWzBdLmluZGV4T2YoJ0FQRlMnKSA+PSAwKSB7IHJldHVybiAnQVBGUyc7IH1cbiAgICByZXR1cm4gJ0hGUyc7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbnV4VG1wRnMoZnMpIHtcbiAgICBjb25zdCBsaW51eFRtcEZpbGVTeXN0ZW1zID0gWydyb290ZnMnLCAndW5pb25mcycsICdzcXVhc2hmcycsICdjcmFtZnMnLCAnaW5pdHJkJywgJ2luaXRyYW1mcycsICdkZXZ0bXBmcycsICd0bXBmcycsICd1ZGV2JywgJ2RldmZzJywgJ3NwZWNmcycsICd0eXBlJywgJ2FwcGltYWdlZCddO1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBsaW51eFRtcEZpbGVTeXN0ZW1zLmZvckVhY2gobGludXhGcyA9PiB7XG4gICAgICBpZiAoZnMudG9Mb3dlckNhc2UoKS5pbmRleE9mKGxpbnV4RnMpID49IDApIHsgcmVzdWx0ID0gdHJ1ZTsgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJMaW5lcyhzdGRvdXQpIHtcbiAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgaWYgKHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlsZXN5c3RlbScpKSB7XG4gICAgICBsZXQgcmVtb3ZlTGluZXMgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZXNbaV0gJiYgbGluZXNbaV0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdmaWxlc3lzdGVtJykpIHtcbiAgICAgICAgICByZW1vdmVMaW5lcyA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTGluZXM7IGkrKykge1xuICAgICAgICBsaW5lcy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURmKGxpbmVzKSB7XG4gICAgbGV0IGRhdGEgPSBbXTtcbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICBpZiAobGluZSAmJiAoKGxpbmVbMF0uc3RhcnRzV2l0aCgnLycpKSB8fCAobGluZVs2XSAmJiBsaW5lWzZdID09PSAnLycpIHx8IChsaW5lWzBdLmluZGV4T2YoJy8nKSA+IDApIHx8IChsaW5lWzBdLmluZGV4T2YoJzonKSA9PT0gMSkgfHwgIV9kYXJ3aW4gJiYgIWlzTGludXhUbXBGcyhsaW5lWzFdKSkpIHtcbiAgICAgICAgICBjb25zdCBmcyA9IGxpbmVbMF07XG4gICAgICAgICAgY29uc3QgZnNUeXBlID0gKChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgPyBsaW5lWzFdIDogZ2V0bWFjT3NGc1R5cGUobGluZVswXSkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludCgoKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSA/IGxpbmVbMl0gOiBsaW5lWzFdKSkgKiAxMDI0O1xuICAgICAgICAgIGNvbnN0IHVzZWQgPSBwYXJzZUludCgoKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSA/IGxpbmVbM10gOiBsaW5lWzJdKSkgKiAxMDI0O1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHBhcnNlSW50KCgoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpID8gbGluZVs0XSA6IGxpbmVbM10pKSAqIDEwMjQ7XG4gICAgICAgICAgY29uc3QgdXNlID0gcGFyc2VGbG9hdCgoMTAwLjAgKiAodXNlZCAvICh1c2VkICsgYXZhaWxhYmxlKSkpLnRvRml4ZWQoMikpO1xuICAgICAgICAgIGxldCBydyA9IG9zTW91bnRzICYmIE9iamVjdC5rZXlzKG9zTW91bnRzKS5sZW5ndGggPiAwID8gb3NNb3VudHNbZnNdIHx8IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICBsaW5lLnNwbGljZSgwLCAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpID8gNiA6IDUpO1xuICAgICAgICAgIGNvbnN0IG1vdW50ID0gbGluZS5qb2luKCcgJyk7XG4gICAgICAgICAgaWYgKCFkYXRhLmZpbmQoZWwgPT4gKGVsLmZzID09PSBmcyAmJiBlbC50eXBlID09PSBmc1R5cGUpKSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgIHR5cGU6IGZzVHlwZSxcbiAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgdXNlZCxcbiAgICAgICAgICAgICAgYXZhaWxhYmxlLFxuICAgICAgICAgICAgICB1c2UsXG4gICAgICAgICAgICAgIG1vdW50LFxuICAgICAgICAgICAgICByd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBkYXRhID0gW107XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJyc7XG4gICAgICAgIG1hY09zRGlza3MgPSBbXTtcbiAgICAgICAgb3NNb3VudHMgPSB7fTtcbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBjbWQgPSAnZGYgLWtQJztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFjT3NEaXNrcyA9IGV4ZWNTeW5jKCdkaXNrdXRpbCBsaXN0JykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gIWxpbmUuc3RhcnRzV2l0aCgnLycpICYmIGxpbmUuaW5kZXhPZignOicpID4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhlY1N5bmMoJ21vdW50JykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbGluZS5zdGFydHNXaXRoKCcvJyk7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgIG9zTW91bnRzW2xpbmUuc3BsaXQoJyAnKVswXV0gPSBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmVhZC1vbmx5JykgPT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICBjbWQgPSAnZGYgLWxrUFR4IHNxdWFzaGZzJztcbiAgICAgICAgICBleGVjU3luYygnY2F0IC9wcm9jL21vdW50cyAyPi9kZXYvbnVsbCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLnN0YXJ0c1dpdGgoJy8nKTtcbiAgICAgICAgICB9KS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBvc01vdW50c1tsaW5lLnNwbGl0KCcgJylbMF1dID0gbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3J3JykgPj0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIGNtZCA9ICdkZiAtbGtQVCc7XG4gICAgICAgICAgZXhlY1N5bmMoJ21vdW50JykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgb3NNb3VudHNbbGluZS5zcGxpdCgnICcpWzBdXSA9IGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyZWFkLW9ubHknKSA9PT0gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IGZpbHRlckxpbmVzKHN0ZG91dCk7XG4gICAgICAgICAgZGF0YSA9IHBhcnNlRGYobGluZXMpO1xuICAgICAgICAgIGlmICghZXJyb3IgfHwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ2RmIC1rUFQnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGZpbHRlckxpbmVzKHN0ZG91dCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBhcnNlRGYobGluZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHV0aWwud21pYygnbG9naWNhbGRpc2sgZ2V0IENhcHRpb24sRmlsZVN5c3RlbSxGcmVlU3BhY2UsU2l6ZScpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX2xvZ2ljYWxkaXNrIHwgc2VsZWN0IEFjY2VzcyxDYXB0aW9uLEZpbGVTeXN0ZW0sRnJlZVNwYWNlLFNpemUgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NpemUnLCAnOicpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVlID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnZnJlZXNwYWNlJywgJzonKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FwdGlvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXB0aW9uJywgJzonKTtcbiAgICAgICAgICAgICAgICBjb25zdCByd1ZhbHVlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2FjY2VzcycsICc6Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcncgPSByd1ZhbHVlID8gKHV0aWwudG9JbnQocndWYWx1ZSkgIT09IDEpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnM6IGNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdmaWxlc3lzdGVtJywgJzonKSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlZDogc2l6ZSAtIGZyZWUsXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogZnJlZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlOiBwYXJzZUZsb2F0KCgoMTAwLjAgKiAoc2l6ZSAtIGZyZWUpKSAvIHNpemUpLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgICAgICAgICBtb3VudDogY2FwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcndcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5mc1NpemUgPSBmc1NpemU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGUyAtIG9wZW4gZmlsZXMgY291bnRcblxuZnVuY3Rpb24gZnNPcGVuRmlsZXMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBhbGxvY2F0ZWQ6IG51bGwsXG4gICAgICAgIGF2YWlsYWJsZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXNjdGwgLWkga2Vybi5tYXhmaWxlcyBrZXJuLm51bV9maWxlcyBrZXJuLm9wZW5fZmlsZXMnO1xuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm1heGZpbGVzJywgJzonKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmFsbG9jYXRlZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm51bV9maWxlcycsICc6JyksIDEwKSB8fCBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5vcGVuX2ZpbGVzJywgJzonKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmF2YWlsYWJsZSA9IHJlc3VsdC5tYXggLSByZXN1bHQuYWxsb2NhdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKCcvcHJvYy9zeXMvZnMvZmlsZS1ucicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzWzBdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0ucmVwbGFjZSgvXFxzKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWxsb2NhdGVkID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXZhaWxhYmxlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5hdmFpbGFibGUpIHsgcmVzdWx0LmF2YWlsYWJsZSA9IHJlc3VsdC5tYXggLSByZXN1bHQuYWxsb2NhdGVkOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5yZWFkRmlsZSgnL3Byb2Mvc3lzL2ZzL2ZpbGUtbWF4JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSBwYXJzZUludChsaW5lc1swXSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5mc09wZW5GaWxlcyA9IGZzT3BlbkZpbGVzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGlza3NcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhzKSB7XG4gIHJldHVybiBwYXJzZUludChzLnN1YnN0cihzLmluZGV4T2YoJyAoJykgKyAyLCBzLmluZGV4T2YoJyBCeXRlcyknKSAtIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGV2aWNlcyhsaW5lcykge1xuICBsZXQgZGV2aWNlcyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxpbmVbMF0gPT09ICcqJykge1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKCFkZXZpY2VzW2ldKSB7XG4gICAgICAgICAgICBkZXZpY2VzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgaWRlbnRpZmllcjogJycsXG4gICAgICAgICAgICAgIHR5cGU6ICdkaXNrJyxcbiAgICAgICAgICAgICAgZnNUeXBlOiAnJyxcbiAgICAgICAgICAgICAgbW91bnQ6ICcnLFxuICAgICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgICBwaHlzaWNhbDogJ0hERCcsXG4gICAgICAgICAgICAgIHV1aWQ6ICcnLFxuICAgICAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgICAgICAgc2VyaWFsOiAnJyxcbiAgICAgICAgICAgICAgcmVtb3ZhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgcHJvdG9jb2w6ICcnLFxuICAgICAgICAgICAgICBncm91cDogJycsXG4gICAgICAgICAgICAgIGRldmljZTogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udHJpbSgpLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvICsvZywgJycpO1xuICAgICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgIGlmICgnREVWSUNFSURFTlRJRklFUicgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0uaWRlbnRpZmllciA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdERVZJQ0VOT0RFJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5uYW1lID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ1ZPTFVNRU5BTUUnID09PSBwYXJ0c1swXSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzWzFdLmluZGV4T2YoJ05vdCBhcHBsaWNhYmxlJykgPT09IC0xKSB7IGRldmljZXNbaV0ubGFiZWwgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ1BST1RPQ09MJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5wcm90b2NvbCA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdESVNLU0laRScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0uc2l6ZSA9IHBhcnNlQnl0ZXMocGFydHNbMV0pOyB9XG4gICAgICAgICAgaWYgKCdGSUxFU1lTVEVNUEVSU09OQUxJVFknID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLmZzVHlwZSA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdNT1VOVFBPSU5UJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5tb3VudCA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdWT0xVTUVVVUlEJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS51dWlkID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ1JFQUQtT05MWU1FRElBJyA9PT0gcGFydHNbMF0gJiYgcGFydHNbMV0gPT09ICdZZXMnKSB7IGRldmljZXNbaV0ucGh5c2ljYWwgPSAnQ0QvRFZEJzsgfVxuICAgICAgICAgIGlmICgnU09MSURTVEFURScgPT09IHBhcnRzWzBdICYmIHBhcnRzWzFdID09PSAnWWVzJykgeyBkZXZpY2VzW2ldLnBoeXNpY2FsID0gJ1NTRCc7IH1cbiAgICAgICAgICBpZiAoJ1ZJUlRVQUwnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnR5cGUgPSAndmlydHVhbCc7IH1cbiAgICAgICAgICBpZiAoJ1JFTU9WQUJMRU1FRElBJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5yZW1vdmFibGUgPSAocGFydHNbMV0gPT09ICdSZW1vdmFibGUnKTsgfVxuICAgICAgICAgIGlmICgnUEFSVElUSU9OVFlQRScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0udHlwZSA9ICdwYXJ0JzsgfVxuICAgICAgICAgIGlmICgnREVWSUNFL01FRElBTkFNRScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0ubW9kZWwgPSBwYXJ0c1sxXTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRldmljZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmxrKGxpbmVzKSB7XG4gIGxldCBkYXRhID0gW107XG5cbiAgbGluZXMuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGluZSA9IGRlY29kZVVSSUNvbXBvbmVudChsaW5lLnJlcGxhY2UoL1xcXFx4L2csICclJykpO1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKTtcbiAgICAgIGxldCBkaXNrID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICduYW1lJzogZGlzay5uYW1lLFxuICAgICAgICAndHlwZSc6IGRpc2sudHlwZSxcbiAgICAgICAgJ2ZzVHlwZSc6IGRpc2suZnNUeXBlLFxuICAgICAgICAnbW91bnQnOiBkaXNrLm1vdW50cG9pbnQsXG4gICAgICAgICdzaXplJzogcGFyc2VJbnQoZGlzay5zaXplKSxcbiAgICAgICAgJ3BoeXNpY2FsJzogKGRpc2sudHlwZSA9PT0gJ2Rpc2snID8gKGRpc2sucm90YSA9PT0gJzAnID8gJ1NTRCcgOiAnSEREJykgOiAoZGlzay50eXBlID09PSAncm9tJyA/ICdDRC9EVkQnIDogJycpKSxcbiAgICAgICAgJ3V1aWQnOiBkaXNrLnV1aWQsXG4gICAgICAgICdsYWJlbCc6IGRpc2subGFiZWwsXG4gICAgICAgICdtb2RlbCc6IChkaXNrLm1vZGVsIHx8ICcnKS50cmltKCksXG4gICAgICAgICdzZXJpYWwnOiBkaXNrLnNlcmlhbCxcbiAgICAgICAgJ3JlbW92YWJsZSc6IGRpc2sucm0gPT09ICcxJyxcbiAgICAgICAgJ3Byb3RvY29sJzogZGlzay50cmFuLFxuICAgICAgICAnZ3JvdXAnOiBkaXNrLmdyb3VwIHx8ICcnLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9KTtcbiAgZGF0YSA9IHV0aWwudW5pcXVlKGRhdGEpO1xuICBkYXRhID0gdXRpbC5zb3J0QnlLZXkoZGF0YSwgWyd0eXBlJywgJ25hbWUnXSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVNZGFibURhdGEobGluZXMpIHtcbiAgY29uc3QgcmFpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZF9sZXZlbCcsICc9Jyk7XG4gIGNvbnN0IGxhYmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21kX25hbWUnLCAnPScpOyAvLyA8LSBnZXQgbGFiZWwgaW5mb1xuICBjb25zdCB1dWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21kX3V1aWQnLCAnPScpOyAvLyA8LSBnZXQgdXVpZCBpbmZvXG4gIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21kX2RldmljZV9kZXYnKSAmJiBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignL2Rldi8nKSA+IDApIHtcbiAgICAgIG1lbWJlcnMucHVzaChsaW5lLnNwbGl0KCcvZGV2LycpWzFdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJhaWQsXG4gICAgbGFiZWwsXG4gICAgdXVpZCxcbiAgICBtZW1iZXJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJhaWRNYXRjaExpbnV4KGRhdGEpIHtcbiAgLy8gZm9yIGFsbCBibG9jayBkZXZpY2VzIG9mIHR5cGUgXCJyYWlkJVwiXG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aCgncmFpZCcpKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoYG1kYWRtIC0tZXhwb3J0IC0tZGV0YWlsIC9kZXYvJHtlbGVtZW50Lm5hbWV9YCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IG1kRGF0YSA9IGRlY29kZU1kYWJtRGF0YShsaW5lcyk7XG5cbiAgICAgICAgZWxlbWVudC5sYWJlbCA9IG1kRGF0YS5sYWJlbDsgLy8gPC0gYXNzaWduIGxhYmVsIGluZm9cbiAgICAgICAgZWxlbWVudC51dWlkID0gbWREYXRhLnV1aWQ7IC8vIDwtIGFzc2lnbiB1dWlkIGluZm9cblxuICAgICAgICBpZiAobWREYXRhLm1lbWJlcnMgJiYgbWREYXRhLm1lbWJlcnMubGVuZ3RoICYmIG1kRGF0YS5yYWlkID09PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGJsb2NrZGV2aWNlID0+IHtcbiAgICAgICAgICAgIGlmIChibG9ja2RldmljZS5mc1R5cGUgPT09ICdsaW51eF9yYWlkX21lbWJlcicgJiYgbWREYXRhLm1lbWJlcnMuaW5kZXhPZihibG9ja2RldmljZS5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGJsb2NrZGV2aWNlLmdyb3VwID0gZWxlbWVudC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrZGV2aWNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXREZXZpY2VzTGludXgoZGF0YSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aCgnZGlzaycpKSB7XG4gICAgICByZXN1bHQucHVzaChlbGVtZW50Lm5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRGV2aWNlc0xpbnV4KGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IGRhdGE7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGdldERldmljZXNMaW51eChkYXRhKTtcbiAgICByZXN1bHQgPSByZXN1bHQubWFwKGJsb2NrZGV2aWNlID0+IHtcbiAgICAgIGlmIChibG9ja2RldmljZS50eXBlLnN0YXJ0c1dpdGgoJ3BhcnQnKSB8fCBibG9ja2RldmljZS50eXBlLnN0YXJ0c1dpdGgoJ2Rpc2snKSkge1xuICAgICAgICBkZXZpY2VzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKGJsb2NrZGV2aWNlLm5hbWUuc3RhcnRzV2l0aChlbGVtZW50KSkge1xuICAgICAgICAgICAgYmxvY2tkZXZpY2UuZGV2aWNlID0gJy9kZXYvJyArIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9ja2RldmljZTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldERldmljZXNNYWMoZGF0YSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aCgnZGlzaycpKSB7XG4gICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgbW9kZWw6IGVsZW1lbnQubW9kZWwsIGRldmljZTogZWxlbWVudC5uYW1lIH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoJ3ZpcnR1YWwnKSkge1xuICAgICAgbGV0IGRldmljZSA9ICcnO1xuICAgICAgcmVzdWx0LmZvckVhY2goZSA9PiB7XG4gICAgICAgIGlmIChlLm1vZGVsID09PSBlbGVtZW50Lm1vZGVsKSB7XG4gICAgICAgICAgZGV2aWNlID0gZS5kZXZpY2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgbW9kZWw6IGVsZW1lbnQubW9kZWwsIGRldmljZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXRjaERldmljZXNNYWMoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0gZGF0YTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZXZpY2VzID0gZ2V0RGV2aWNlc01hYyhkYXRhKTtcbiAgICByZXN1bHQgPSByZXN1bHQubWFwKGJsb2NrZGV2aWNlID0+IHtcbiAgICAgIGlmIChibG9ja2RldmljZS50eXBlLnN0YXJ0c1dpdGgoJ3BhcnQnKSB8fCBibG9ja2RldmljZS50eXBlLnN0YXJ0c1dpdGgoJ2Rpc2snKSB8fCBibG9ja2RldmljZS50eXBlLnN0YXJ0c1dpdGgoJ3ZpcnR1YWwnKSkge1xuICAgICAgICBkZXZpY2VzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKGJsb2NrZGV2aWNlLm5hbWUuc3RhcnRzV2l0aChlbGVtZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICBibG9ja2RldmljZS5kZXZpY2UgPSBlbGVtZW50LmRldmljZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2NrZGV2aWNlO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2aWNlc1dpbihkaXNrRHJpdmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBkaXNrRHJpdmVzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBlbGVtZW50LnNwbGl0KCdcXHJcXG4nKTtcbiAgICBjb25zdCBkZXZpY2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGV2aWNlSUQnLCAnOicpO1xuICAgIGxldCBwYXJ0aXRpb25zID0gZWxlbWVudC5zcGxpdCgnQHtEZXZpY2VJRD0nKTtcbiAgICBpZiAocGFydGl0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICBwYXJ0aXRpb25zID0gcGFydGl0aW9ucy5zbGljZSgxKTtcbiAgICAgIHBhcnRpdGlvbnMuZm9yRWFjaChwYXJ0aXRpb24gPT4ge1xuICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IHBhcnRpdGlvbi5zcGxpdCgnOycpWzBdLnRvVXBwZXJDYXNlKCksIGRldmljZSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRGV2aWNlc1dpbihkYXRhLCBkaXNrRHJpdmVzKSB7XG4gIGNvbnN0IGRldmljZXMgPSBnZXREZXZpY2VzV2luKGRpc2tEcml2ZXMpO1xuICBkYXRhLm1hcChlbGVtZW50ID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlc0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcigoZSkgPT4geyByZXR1cm4gZS5uYW1lID09PSBlbGVtZW50Lm5hbWUudG9VcHBlckNhc2UoKTsgfSk7XG4gICAgaWYgKGZpbHRlcmVzRGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50LmRldmljZSA9IGZpbHRlcmVzRGV2aWNlc1swXS5kZXZpY2U7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGJsa1N0ZG91dFRvT2JqZWN0KHN0ZG91dCkge1xuICByZXR1cm4gc3Rkb3V0LnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgvTkFNRT0vZywgJ3tcIm5hbWVcIjonKVxuICAgIC5yZXBsYWNlKC9GU1RZUEU9L2csICcsXCJmc1R5cGVcIjonKVxuICAgIC5yZXBsYWNlKC9UWVBFPS9nLCAnLFwidHlwZVwiOicpXG4gICAgLnJlcGxhY2UoL1NJWkU9L2csICcsXCJzaXplXCI6JylcbiAgICAucmVwbGFjZSgvTU9VTlRQT0lOVD0vZywgJyxcIm1vdW50cG9pbnRcIjonKVxuICAgIC5yZXBsYWNlKC9VVUlEPS9nLCAnLFwidXVpZFwiOicpXG4gICAgLnJlcGxhY2UoL1JPVEE9L2csICcsXCJyb3RhXCI6JylcbiAgICAucmVwbGFjZSgvUk89L2csICcsXCJyb1wiOicpXG4gICAgLnJlcGxhY2UoL1JNPS9nLCAnLFwicm1cIjonKVxuICAgIC5yZXBsYWNlKC9UUkFOPS9nLCAnLFwidHJhblwiOicpXG4gICAgLnJlcGxhY2UoL1NFUklBTD0vZywgJyxcInNlcmlhbFwiOicpXG4gICAgLnJlcGxhY2UoL0xBQkVMPS9nLCAnLFwibGFiZWxcIjonKVxuICAgIC5yZXBsYWNlKC9NT0RFTD0vZywgJyxcIm1vZGVsXCI6JylcbiAgICAucmVwbGFjZSgvT1dORVI9L2csICcsXCJvd25lclwiOicpXG4gICAgLnJlcGxhY2UoL0dST1VQPS9nLCAnLFwiZ3JvdXBcIjonKVxuICAgIC5yZXBsYWNlKC9cXG4vZywgJ31cXG4nKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tEZXZpY2VzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93aWtpLnVidW50dXVzZXJzLmRlL2xzYmxrL1xuICAgICAgICAvLyBleGVjKFwibHNibGsgLWJvIE5BTUUsVFlQRSxTSVpFLEZTVFlQRSxNT1VOVFBPSU5ULFVVSUQsUk9UQSxSTyxUUkFOLFNFUklBTCxMQUJFTCxNT0RFTCxPV05FUixHUk9VUCxNT0RFLEFMSUdOTUVOVCxNSU4tSU8sT1BULUlPLFBIWS1TRUMsTE9HLVNFQyxTQ0hFRCxSUS1TSVpFLFJBLFdTQU1FXCIsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgIGV4ZWMoJ2xzYmxrIC1iUG8gTkFNRSxUWVBFLFNJWkUsRlNUWVBFLE1PVU5UUE9JTlQsVVVJRCxST1RBLFJPLFJNLFRSQU4sU0VSSUFMLExBQkVMLE1PREVMLE9XTkVSIDI+L2Rldi9udWxsJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gYmxrU3Rkb3V0VG9PYmplY3Qoc3Rkb3V0KS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBkYXRhID0gcGFyc2VCbGsobGluZXMpO1xuICAgICAgICAgICAgZGF0YSA9IHJhaWRNYXRjaExpbnV4KGRhdGEpO1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGV2aWNlc0xpbnV4KGRhdGEpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygnbHNibGsgLWJQbyBOQU1FLFRZUEUsU0laRSxGU1RZUEUsTU9VTlRQT0lOVCxVVUlELFJPVEEsUk8sUk0sTEFCRUwsTU9ERUwsT1dORVIgMj4vZGV2L251bGwnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGJsa1N0ZG91dFRvT2JqZWN0KHN0ZG91dCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJzZUJsayhsaW5lcyk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHJhaWRNYXRjaExpbnV4KGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnZGlza3V0aWwgaW5mbyAtYWxsJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgLy8gcGFyc2UgbGluZXMgaW50byB0ZW1wIGFycmF5IG9mIGRldmljZXNcbiAgICAgICAgICAgIGRhdGEgPSBwYXJzZURldmljZXMobGluZXMpO1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGV2aWNlc01hYyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBkcml2ZXR5cGVzID0gWydVbmtub3duJywgJ05vUm9vdCcsICdSZW1vdmFibGUnLCAnTG9jYWwnLCAnTmV0d29yaycsICdDRC9EVkQnLCAnUkFNJ107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdXRpbC53bWljKCdsb2dpY2FsZGlzayBnZXQgQ2FwdGlvbixEZXNjcmlwdGlvbixEZXZpY2VJRCxEcml2ZVR5cGUsRmlsZVN5c3RlbSxGcmVlU3BhY2UsTmFtZSxTaXplLFZvbHVtZU5hbWUsVm9sdW1lU2VyaWFsTnVtYmVyIC92YWx1ZScpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAvLyB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9sb2dpY2FsZGlzayB8IHNlbGVjdCBDYXB0aW9uLERyaXZlVHlwZSxOYW1lLEZpbGVTeXN0ZW0sU2l6ZSxWb2x1bWVTZXJpYWxOdW1iZXIsVm9sdW1lTmFtZSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSAtQ2xhc3NOYW1lIFdpbjMyX0xvZ2ljYWxEaXNrIHwgc2VsZWN0IENhcHRpb24sRHJpdmVUeXBlLE5hbWUsRmlsZVN5c3RlbSxTaXplLFZvbHVtZVNlcmlhbE51bWJlcixWb2x1bWVOYW1lIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1XbWlPYmplY3QgLUNsYXNzIFdpbjMyX2Rpc2tkcml2ZSB8IFNlbGVjdC1PYmplY3QgLVByb3BlcnR5IFBOUERldmljZUlkLERldmljZUlELCBNb2RlbCwgU2l6ZSwgQHtMPVxcJ1BhcnRpdGlvbnNcXCc7IEU9eyRfLkdldFJlbGF0ZWQoXFwnV2luMzJfRGlza1BhcnRpdGlvblxcJykuR2V0UmVsYXRlZChcXCdXaW4zMl9Mb2dpY2FsRGlza1xcJykgfCBTZWxlY3QtT2JqZWN0IC1Qcm9wZXJ0eSBEZXZpY2VJRCwgVm9sdW1lTmFtZSwgU2l6ZSwgRnJlZVNwYWNlfX0gfCBmbCcpKTtcbiAgICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9naWNhbERpc2tzID0gcmVzLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgbGV0IGRpc2tEcml2ZXMgPSByZXMucmVzdWx0c1sxXS50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBsb2dpY2FsRGlza3MuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBkcml2ZXR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZHJpdmV0eXBlJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKGRyaXZldHlwZSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6JyksXG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FwdGlvbicsICc6JyksXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZGlzaycsXG4gICAgICAgICAgICAgICAgICBmc1R5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdmaWxlc3lzdGVtJywgJzonKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgbW91bnQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXB0aW9uJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzaXplJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIHBoeXNpY2FsOiAoZHJpdmV0eXBlID49IDAgJiYgZHJpdmV0eXBlIDw9IDYpID8gZHJpdmV0eXBlc1tkcml2ZXR5cGVdIDogZHJpdmV0eXBlc1swXSxcbiAgICAgICAgICAgICAgICAgIHV1aWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x1bWVzZXJpYWxudW1iZXInLCAnOicpLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x1bWVuYW1lJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHVtZXNlcmlhbG51bWJlcicsICc6JyksXG4gICAgICAgICAgICAgICAgICByZW1vdmFibGU6IGRyaXZldHlwZSA9PT0gJzInLFxuICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6ICcnLFxuICAgICAgICAgICAgICAgICAgZ3JvdXA6ICcnLFxuICAgICAgICAgICAgICAgICAgZGV2aWNlOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG1hdGNoIGRldmljZXNcbiAgICAgICAgICAgIGRhdGEgPSBtYXRjaERldmljZXNXaW4oZGF0YSwgZGlza0RyaXZlcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgLy8gd2lsbCBmb2xsb3dcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuYmxvY2tEZXZpY2VzID0gYmxvY2tEZXZpY2VzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRlMgLSBzcGVlZFxuXG5mdW5jdGlvbiBjYWxjRnNTcGVlZChyeCwgd3gpIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICByeDogMCxcbiAgICB3eDogMCxcbiAgICB0eDogMCxcbiAgICByeF9zZWM6IG51bGwsXG4gICAgd3hfc2VjOiBudWxsLFxuICAgIHR4X3NlYzogbnVsbCxcbiAgICBtczogMFxuICB9O1xuXG4gIGlmIChfZnNfc3BlZWQgJiYgX2ZzX3NwZWVkLm1zKSB7XG4gICAgcmVzdWx0LnJ4ID0gcng7XG4gICAgcmVzdWx0Lnd4ID0gd3g7XG4gICAgcmVzdWx0LnR4ID0gcmVzdWx0LnJ4ICsgcmVzdWx0Lnd4O1xuICAgIHJlc3VsdC5tcyA9IERhdGUubm93KCkgLSBfZnNfc3BlZWQubXM7XG4gICAgcmVzdWx0LnJ4X3NlYyA9IChyZXN1bHQucnggLSBfZnNfc3BlZWQuYnl0ZXNfcmVhZCkgLyAocmVzdWx0Lm1zIC8gMTAwMCk7XG4gICAgcmVzdWx0Lnd4X3NlYyA9IChyZXN1bHQud3ggLSBfZnNfc3BlZWQuYnl0ZXNfd3JpdGUpIC8gKHJlc3VsdC5tcyAvIDEwMDApO1xuICAgIHJlc3VsdC50eF9zZWMgPSByZXN1bHQucnhfc2VjICsgcmVzdWx0Lnd4X3NlYztcbiAgICBfZnNfc3BlZWQucnhfc2VjID0gcmVzdWx0LnJ4X3NlYztcbiAgICBfZnNfc3BlZWQud3hfc2VjID0gcmVzdWx0Lnd4X3NlYztcbiAgICBfZnNfc3BlZWQudHhfc2VjID0gcmVzdWx0LnR4X3NlYztcbiAgICBfZnNfc3BlZWQuYnl0ZXNfcmVhZCA9IHJlc3VsdC5yeDtcbiAgICBfZnNfc3BlZWQuYnl0ZXNfd3JpdGUgPSByZXN1bHQud3g7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX292ZXJhbGwgPSByZXN1bHQucnggKyByZXN1bHQud3g7XG4gICAgX2ZzX3NwZWVkLm1zID0gRGF0ZS5ub3coKTtcbiAgICBfZnNfc3BlZWQubGFzdF9tcyA9IHJlc3VsdC5tcztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucnggPSByeDtcbiAgICByZXN1bHQud3ggPSB3eDtcbiAgICByZXN1bHQudHggPSByZXN1bHQucnggKyByZXN1bHQud3g7XG4gICAgX2ZzX3NwZWVkLnJ4X3NlYyA9IG51bGw7XG4gICAgX2ZzX3NwZWVkLnd4X3NlYyA9IG51bGw7XG4gICAgX2ZzX3NwZWVkLnR4X3NlYyA9IG51bGw7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX3JlYWQgPSByZXN1bHQucng7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX3dyaXRlID0gcmVzdWx0Lnd4O1xuICAgIF9mc19zcGVlZC5ieXRlc19vdmVyYWxsID0gcmVzdWx0LnJ4ICsgcmVzdWx0Lnd4O1xuICAgIF9mc19zcGVlZC5tcyA9IERhdGUubm93KCk7XG4gICAgX2ZzX3NwZWVkLmxhc3RfbXMgPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZzU3RhdHMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmIChfd2luZG93cyB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9zdW5vcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgcng6IDAsXG4gICAgICAgIHd4OiAwLFxuICAgICAgICB0eDogMCxcbiAgICAgICAgcnhfc2VjOiBudWxsLFxuICAgICAgICB3eF9zZWM6IG51bGwsXG4gICAgICAgIHR4X3NlYzogbnVsbCxcbiAgICAgICAgbXM6IDBcbiAgICAgIH07XG5cbiAgICAgIGxldCByeCA9IDA7XG4gICAgICBsZXQgd3ggPSAwO1xuICAgICAgaWYgKChfZnNfc3BlZWQgJiYgIV9mc19zcGVlZC5tcykgfHwgKF9mc19zcGVlZCAmJiBfZnNfc3BlZWQubXMgJiYgRGF0ZS5ub3coKSAtIF9mc19zcGVlZC5tcyA+PSA1MDApKSB7XG4gICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAvLyBleGVjKFwiZGYgLWsgfCBncmVwIC9kZXYvXCIsIGZ1bmN0aW9uKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBleGVjKCdsc2JsayAtciAyPi9kZXYvbnVsbCB8IGdyZXAgLycsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBmc19maWx0ZXIgPSBbXTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBpZiAoZnNfZmlsdGVyLmluZGV4T2YobGluZVswXSkgPT09IC0xKSB7IGZzX2ZpbHRlci5wdXNoKGxpbmVbMF0pOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gZnNfZmlsdGVyLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgICAgZXhlYygnY2F0IC9wcm9jL2Rpc2tzdGF0cyB8IGVncmVwIFwiJyArIG91dHB1dCArICdcIicsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICByeCArPSBwYXJzZUludChsaW5lWzVdKSAqIDUxMjtcbiAgICAgICAgICAgICAgICAgICAgICB3eCArPSBwYXJzZUludChsaW5lWzldKSAqIDUxMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjRnNTcGVlZChyeCwgd3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIGV4ZWMoJ2lvcmVnIC1jIElPQmxvY2tTdG9yYWdlRHJpdmVyIC1rIFN0YXRpc3RpY3MgLXIgLXcwIHwgc2VkIC1uIFwiL0lPQmxvY2tTdG9yYWdlRHJpdmVyLywvU3RhdGlzdGljcy9wXCIgfCBncmVwIFwiU3RhdGlzdGljc1wiIHwgdHIgLWNkIFwiMDEyMzQ1Njc4OTAsXFxuXCInLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgICAgcnggKz0gcGFyc2VJbnQobGluZVsyXSk7XG4gICAgICAgICAgICAgICAgICB3eCArPSBwYXJzZUludChsaW5lWzldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjRnNTcGVlZChyeCwgd3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5tcyA9IF9mc19zcGVlZC5sYXN0X21zO1xuICAgICAgICByZXN1bHQucnggPSBfZnNfc3BlZWQuYnl0ZXNfcmVhZDtcbiAgICAgICAgcmVzdWx0Lnd4ID0gX2ZzX3NwZWVkLmJ5dGVzX3dyaXRlO1xuICAgICAgICByZXN1bHQudHggPSBfZnNfc3BlZWQuYnl0ZXNfcmVhZCArIF9mc19zcGVlZC5ieXRlc193cml0ZTtcbiAgICAgICAgcmVzdWx0LnJ4X3NlYyA9IF9mc19zcGVlZC5yeF9zZWM7XG4gICAgICAgIHJlc3VsdC53eF9zZWMgPSBfZnNfc3BlZWQud3hfc2VjO1xuICAgICAgICByZXN1bHQudHhfc2VjID0gX2ZzX3NwZWVkLnR4X3NlYztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmZzU3RhdHMgPSBmc1N0YXRzO1xuXG5mdW5jdGlvbiBjYWxjRGlza0lPKHJJTywgd0lPLCByV2FpdFRpbWUsIHdXYWl0VGltZSwgdFdhaXRUaW1lKSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgcklPOiAwLFxuICAgIHdJTzogMCxcbiAgICB0SU86IDAsXG4gICAgcklPX3NlYzogbnVsbCxcbiAgICB3SU9fc2VjOiBudWxsLFxuICAgIHRJT19zZWM6IG51bGwsXG4gICAgcldhaXRUaW1lOiAwLFxuICAgIHdXYWl0VGltZTogMCxcbiAgICB0V2FpdFRpbWU6IDAsXG4gICAgcldhaXRQZXJjZW50OiBudWxsLFxuICAgIHdXYWl0UGVyY2VudDogbnVsbCxcbiAgICB0V2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgbXM6IDBcbiAgfTtcbiAgaWYgKF9kaXNrX2lvICYmIF9kaXNrX2lvLm1zKSB7XG4gICAgcmVzdWx0LnJJTyA9IHJJTztcbiAgICByZXN1bHQud0lPID0gd0lPO1xuICAgIHJlc3VsdC50SU8gPSBySU8gKyB3SU87XG4gICAgcmVzdWx0Lm1zID0gRGF0ZS5ub3coKSAtIF9kaXNrX2lvLm1zO1xuICAgIHJlc3VsdC5ySU9fc2VjID0gKHJlc3VsdC5ySU8gLSBfZGlza19pby5ySU8pIC8gKHJlc3VsdC5tcyAvIDEwMDApO1xuICAgIHJlc3VsdC53SU9fc2VjID0gKHJlc3VsdC53SU8gLSBfZGlza19pby53SU8pIC8gKHJlc3VsdC5tcyAvIDEwMDApO1xuICAgIHJlc3VsdC50SU9fc2VjID0gcmVzdWx0LnJJT19zZWMgKyByZXN1bHQud0lPX3NlYztcbiAgICByZXN1bHQucldhaXRUaW1lID0gcldhaXRUaW1lO1xuICAgIHJlc3VsdC53V2FpdFRpbWUgPSB3V2FpdFRpbWU7XG4gICAgcmVzdWx0LnRXYWl0VGltZSA9IHRXYWl0VGltZTtcbiAgICByZXN1bHQucldhaXRQZXJjZW50ID0gKHJlc3VsdC5yV2FpdFRpbWUgLSBfZGlza19pby5yV2FpdFRpbWUpICogMTAwIC8gKHJlc3VsdC5tcyk7XG4gICAgcmVzdWx0LndXYWl0UGVyY2VudCA9IChyZXN1bHQud1dhaXRUaW1lIC0gX2Rpc2tfaW8ud1dhaXRUaW1lKSAqIDEwMCAvIChyZXN1bHQubXMpO1xuICAgIHJlc3VsdC50V2FpdFBlcmNlbnQgPSAocmVzdWx0LnRXYWl0VGltZSAtIF9kaXNrX2lvLnRXYWl0VGltZSkgKiAxMDAgLyAocmVzdWx0Lm1zKTtcbiAgICBfZGlza19pby5ySU8gPSBySU87XG4gICAgX2Rpc2tfaW8ud0lPID0gd0lPO1xuICAgIF9kaXNrX2lvLnJJT19zZWMgPSByZXN1bHQucklPX3NlYztcbiAgICBfZGlza19pby53SU9fc2VjID0gcmVzdWx0LndJT19zZWM7XG4gICAgX2Rpc2tfaW8udElPX3NlYyA9IHJlc3VsdC50SU9fc2VjO1xuICAgIF9kaXNrX2lvLnJXYWl0VGltZSA9IHJXYWl0VGltZTtcbiAgICBfZGlza19pby53V2FpdFRpbWUgPSB3V2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8udFdhaXRUaW1lID0gdFdhaXRUaW1lO1xuICAgIF9kaXNrX2lvLnJXYWl0UGVyY2VudCA9IHJlc3VsdC5yV2FpdFBlcmNlbnQ7XG4gICAgX2Rpc2tfaW8ud1dhaXRQZXJjZW50ID0gcmVzdWx0LndXYWl0UGVyY2VudDtcbiAgICBfZGlza19pby50V2FpdFBlcmNlbnQgPSByZXN1bHQudFdhaXRQZXJjZW50O1xuICAgIF9kaXNrX2lvLmxhc3RfbXMgPSByZXN1bHQubXM7XG4gICAgX2Rpc2tfaW8ubXMgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5ySU8gPSBySU87XG4gICAgcmVzdWx0LndJTyA9IHdJTztcbiAgICByZXN1bHQudElPID0gcklPICsgd0lPO1xuICAgIHJlc3VsdC5yV2FpdFRpbWUgPSByV2FpdFRpbWU7XG4gICAgcmVzdWx0LndXYWl0VGltZSA9IHdXYWl0VGltZTtcbiAgICByZXN1bHQudFdhaXRUaW1lID0gdFdhaXRUaW1lO1xuICAgIF9kaXNrX2lvLnJJTyA9IHJJTztcbiAgICBfZGlza19pby53SU8gPSB3SU87XG4gICAgX2Rpc2tfaW8ucklPX3NlYyA9IG51bGw7XG4gICAgX2Rpc2tfaW8ud0lPX3NlYyA9IG51bGw7XG4gICAgX2Rpc2tfaW8udElPX3NlYyA9IG51bGw7XG4gICAgX2Rpc2tfaW8ucldhaXRUaW1lID0gcldhaXRUaW1lO1xuICAgIF9kaXNrX2lvLndXYWl0VGltZSA9IHdXYWl0VGltZTtcbiAgICBfZGlza19pby50V2FpdFRpbWUgPSB0V2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8ucldhaXRQZXJjZW50ID0gbnVsbDtcbiAgICBfZGlza19pby53V2FpdFBlcmNlbnQgPSBudWxsO1xuICAgIF9kaXNrX2lvLnRXYWl0UGVyY2VudCA9IG51bGw7XG4gICAgX2Rpc2tfaW8ubGFzdF9tcyA9IDA7XG4gICAgX2Rpc2tfaW8ubXMgPSBEYXRlLm5vdygpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRpc2tzSU8oY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHJJTzogMCxcbiAgICAgICAgd0lPOiAwLFxuICAgICAgICB0SU86IDAsXG4gICAgICAgIHJJT19zZWM6IG51bGwsXG4gICAgICAgIHdJT19zZWM6IG51bGwsXG4gICAgICAgIHRJT19zZWM6IG51bGwsXG4gICAgICAgIHJXYWl0VGltZTogMCxcbiAgICAgICAgd1dhaXRUaW1lOiAwLFxuICAgICAgICB0V2FpdFRpbWU6IDAsXG4gICAgICAgIHJXYWl0UGVyY2VudDogbnVsbCxcbiAgICAgICAgd1dhaXRQZXJjZW50OiBudWxsLFxuICAgICAgICB0V2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgICAgIG1zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHJJTyA9IDA7XG4gICAgICBsZXQgd0lPID0gMDtcbiAgICAgIGxldCByV2FpdFRpbWUgPSAwO1xuICAgICAgbGV0IHdXYWl0VGltZSA9IDA7XG4gICAgICBsZXQgdFdhaXRUaW1lID0gMDtcblxuICAgICAgaWYgKChfZGlza19pbyAmJiAhX2Rpc2tfaW8ubXMpIHx8IChfZGlza19pbyAmJiBfZGlza19pby5tcyAmJiBEYXRlLm5vdygpIC0gX2Rpc2tfaW8ubXMgPj0gNTAwKSkge1xuICAgICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICAvLyBwcmludHMgQmxvY2sgbGF5ZXIgc3RhdGlzdGljcyBmb3IgYWxsIG1vdW50ZWQgdm9sdW1lc1xuICAgICAgICAgIC8vIHZhciBjbWQgPSBcImZvciBtb3VudCBpbiBgbHNibGsgfCBncmVwIC8gfCBzZWQgLXIgJ3Mv4pSCIOKUlOKUgC8vJyB8IGN1dCAtZCAnICcgLWYgMWA7IGRvIGNhdCAvc3lzL2Jsb2NrLyRtb3VudC9zdGF0IHwgc2VkIC1yICdzLyArLzsvZycgfCBzZWQgLXIgJ3MvXjsvLyc7IGRvbmVcIjtcbiAgICAgICAgICAvLyB2YXIgY21kID0gXCJmb3IgbW91bnQgaW4gYGxzYmxrIHwgZ3JlcCAvIHwgc2VkICdzL1vilILilJTilIDilJxdLy9nJyB8IGF3ayAneyQxPSQxfTsxJyB8IGN1dCAtZCAnICcgLWYgMSB8IHNvcnQgLXVgOyBkbyBjYXQgL3N5cy9ibG9jay8kbW91bnQvc3RhdCB8IHNlZCAtciAncy8gKy87L2cnIHwgc2VkIC1yICdzL147Ly8nOyBkb25lXCI7XG4gICAgICAgICAgbGV0IGNtZCA9ICdmb3IgbW91bnQgaW4gYGxzYmxrIDI+L2Rldi9udWxsIHwgZ3JlcCBcIiBkaXNrIFwiIHwgc2VkIFwicy9b4pSC4pSU4pSA4pScXS8vZ1wiIHwgYXdrIFxcJ3skMT0kMX07MVxcJyB8IGN1dCAtZCBcIiBcIiAtZiAxIHwgc29ydCAtdWA7IGRvIGNhdCAvc3lzL2Jsb2NrLyRtb3VudC9zdGF0IHwgc2VkIC1yIFwicy8gKy87L2dcIiB8IHNlZCAtciBcInMvXjsvL1wiOyBkb25lJztcblxuICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlbXB0eSBsaW5lc1xuICAgICAgICAgICAgICAgIGlmICghbGluZSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIC8vIHN1bSByL3dJTyBvZiBhbGwgZGlza3MgdG8gY29tcHV0ZSBhbGwgZGlza3MgSU9cbiAgICAgICAgICAgICAgICBsZXQgc3RhdHMgPSBsaW5lLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgcklPICs9IHBhcnNlSW50KHN0YXRzWzBdKTtcbiAgICAgICAgICAgICAgICB3SU8gKz0gcGFyc2VJbnQoc3RhdHNbNF0pO1xuICAgICAgICAgICAgICAgIHJXYWl0VGltZSArPSBwYXJzZUludChzdGF0c1szXSk7XG4gICAgICAgICAgICAgICAgd1dhaXRUaW1lICs9IHBhcnNlSW50KHN0YXRzWzddKTtcbiAgICAgICAgICAgICAgICB0V2FpdFRpbWUgKz0gcGFyc2VJbnQoc3RhdHNbMTBdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNEaXNrSU8ocklPLCB3SU8sIHJXYWl0VGltZSwgd1dhaXRUaW1lLCB0V2FpdFRpbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBleGVjKCdpb3JlZyAtYyBJT0Jsb2NrU3RvcmFnZURyaXZlciAtayBTdGF0aXN0aWNzIC1yIC13MCB8IHNlZCAtbiBcIi9JT0Jsb2NrU3RvcmFnZURyaXZlci8sL1N0YXRpc3RpY3MvcFwiIHwgZ3JlcCBcIlN0YXRpc3RpY3NcIiB8IHRyIC1jZCBcIjAxMjM0NTY3ODkwLFxcblwiJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICAgIHJJTyArPSBwYXJzZUludChsaW5lWzEwXSk7XG4gICAgICAgICAgICAgICAgICB3SU8gKz0gcGFyc2VJbnQobGluZVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY0Rpc2tJTyhySU8sIHdJTywgcldhaXRUaW1lLCB3V2FpdFRpbWUsIHRXYWl0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnJJTyA9IF9kaXNrX2lvLnJJTztcbiAgICAgICAgcmVzdWx0LndJTyA9IF9kaXNrX2lvLndJTztcbiAgICAgICAgcmVzdWx0LnRJTyA9IF9kaXNrX2lvLnJJTyArIF9kaXNrX2lvLndJTztcbiAgICAgICAgcmVzdWx0Lm1zID0gX2Rpc2tfaW8ubGFzdF9tcztcbiAgICAgICAgcmVzdWx0LnJJT19zZWMgPSBfZGlza19pby5ySU9fc2VjO1xuICAgICAgICByZXN1bHQud0lPX3NlYyA9IF9kaXNrX2lvLndJT19zZWM7XG4gICAgICAgIHJlc3VsdC50SU9fc2VjID0gX2Rpc2tfaW8udElPX3NlYztcbiAgICAgICAgcmVzdWx0LnJXYWl0VGltZSA9IF9kaXNrX2lvLnJXYWl0VGltZTtcbiAgICAgICAgcmVzdWx0LndXYWl0VGltZSA9IF9kaXNrX2lvLndXYWl0VGltZTtcbiAgICAgICAgcmVzdWx0LnRXYWl0VGltZSA9IF9kaXNrX2lvLnRXYWl0VGltZTtcbiAgICAgICAgcmVzdWx0LnJXYWl0UGVyY2VudCA9IF9kaXNrX2lvLnJXYWl0UGVyY2VudDtcbiAgICAgICAgcmVzdWx0LndXYWl0UGVyY2VudCA9IF9kaXNrX2lvLndXYWl0UGVyY2VudDtcbiAgICAgICAgcmVzdWx0LnRXYWl0UGVyY2VudCA9IF9kaXNrX2lvLnRXYWl0UGVyY2VudDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRpc2tzSU8gPSBkaXNrc0lPO1xuXG5mdW5jdGlvbiBkaXNrTGF5b3V0KGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gZ2V0VmVuZG9yRnJvbU1vZGVsKG1vZGVsKSB7XG4gICAgY29uc3QgZGlza01hbnVmYWN0dXJlcnMgPSBbXG4gICAgICB7IHBhdHRlcm46ICdXRVNURVJOLionLCBtYW51ZmFjdHVyZXI6ICdXZXN0ZXJuIERpZ2l0YWwnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeV0RDLionLCBtYW51ZmFjdHVyZXI6ICdXZXN0ZXJuIERpZ2l0YWwnIH0sXG4gICAgICB7IHBhdHRlcm46ICdXRC4qJywgbWFudWZhY3R1cmVyOiAnV2VzdGVybiBEaWdpdGFsJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnVE9TSElCQS4qJywgbWFudWZhY3R1cmVyOiAnVG9zaGliYScgfSxcbiAgICAgIHsgcGF0dGVybjogJ0hJVEFDSEkuKicsIG1hbnVmYWN0dXJlcjogJ0hpdGFjaGknIH0sXG4gICAgICB7IHBhdHRlcm46ICdeSUMuKicsIG1hbnVmYWN0dXJlcjogJ0hpdGFjaGknIH0sXG4gICAgICB7IHBhdHRlcm46ICdeSFRTLionLCBtYW51ZmFjdHVyZXI6ICdIaXRhY2hpJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnU0FORElTSy4qJywgbWFudWZhY3R1cmVyOiAnU2FuRGlzaycgfSxcbiAgICAgIHsgcGF0dGVybjogJ0tJTkdTVE9OLionLCBtYW51ZmFjdHVyZXI6ICdLaW5nc3RvbiBUZWNobm9sb2d5JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXlNPTlkuKicsIG1hbnVmYWN0dXJlcjogJ1NvbnknIH0sXG4gICAgICB7IHBhdHRlcm46ICdUUkFOU0NFTkQuKicsIG1hbnVmYWN0dXJlcjogJ1RyYW5zY2VuZCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ1NBTVNVTkcuKicsIG1hbnVmYWN0dXJlcjogJ1NhbXN1bmcnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeU1QoPyFJXFxcXCApLionLCBtYW51ZmFjdHVyZXI6ICdTZWFnYXRlJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXlNUSVxcXFwgLionLCBtYW51ZmFjdHVyZXI6ICdTaW1wbGVUZWNoJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXkQuLi4tLionLCBtYW51ZmFjdHVyZXI6ICdJQk0nIH0sXG4gICAgICB7IHBhdHRlcm46ICdeSUJNLionLCBtYW51ZmFjdHVyZXI6ICdJQk0nIH0sXG4gICAgICB7IHBhdHRlcm46ICdeRlVKSVRTVS4qJywgbWFudWZhY3R1cmVyOiAnRnVqaXRzdScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15NUC4qJywgbWFudWZhY3R1cmVyOiAnRnVqaXRzdScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15NSy4qJywgbWFudWZhY3R1cmVyOiAnVG9zaGliYScgfSxcbiAgICAgIHsgcGF0dGVybjogJ01BWFRPLionLCBtYW51ZmFjdHVyZXI6ICdNYXh0b3InIH0sXG4gICAgICB7IHBhdHRlcm46ICdQSU9ORUVSLionLCBtYW51ZmFjdHVyZXI6ICdQaW9uZWVyJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnUEhJTElQUy4qJywgbWFudWZhY3R1cmVyOiAnUGhpbGlwcycgfSxcbiAgICAgIHsgcGF0dGVybjogJ1FVQU5UVU0uKicsIG1hbnVmYWN0dXJlcjogJ1F1YW50dW0gVGVjaG5vbG9neScgfSxcbiAgICAgIHsgcGF0dGVybjogJ0ZJUkVCQUxMLionLCBtYW51ZmFjdHVyZXI6ICdRdWFudHVtIFRlY2hub2xvZ3knIH0sXG4gICAgICB7IHBhdHRlcm46ICdeVkJPWC4qJywgbWFudWZhY3R1cmVyOiAnVmlydHVhbEJveCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ0NPUlNBSVIuKicsIG1hbnVmYWN0dXJlcjogJ0NvcnNhaXIgQ29tcG9uZW50cycgfSxcbiAgICAgIHsgcGF0dGVybjogJ0NSVUNJQUwuKicsIG1hbnVmYWN0dXJlcjogJ0NydWNpYWwnIH0sXG4gICAgICB7IHBhdHRlcm46ICdFQ00uKicsIG1hbnVmYWN0dXJlcjogJ0VDTScgfSxcbiAgICAgIHsgcGF0dGVybjogJ0lOVEVMLionLCBtYW51ZmFjdHVyZXI6ICdJTlRFTCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ0VWTy4qJywgbWFudWZhY3R1cmVyOiAnU2Ftc3VuZycgfSxcbiAgICAgIHsgcGF0dGVybjogJ0FQUExFLionLCBtYW51ZmFjdHVyZXI6ICdBcHBsZScgfSxcbiAgICBdO1xuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgbW9kZWwgPSBtb2RlbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgZGlza01hbnVmYWN0dXJlcnMuZm9yRWFjaCgobWFudWZhY3R1cmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlID0gUmVnRXhwKG1hbnVmYWN0dXJlci5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKHJlLnRlc3QobW9kZWwpKSB7IHJlc3VsdCA9IG1hbnVmYWN0dXJlci5tYW51ZmFjdHVyZXI7IH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGNvbnN0IGNvbW1pdFJlc3VsdCA9IHJlcyA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc1tpXS5CU0ROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfTtcblxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IGNtZCA9ICcnO1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGxldCBjbWRGdWxsU21hcnQgPSAnJztcblxuICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGxzYmxrIC1hYmxKTyAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gc3Rkb3V0LnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IFtdO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEpTT04gPSBKU09OLnBhcnNlKG91dCk7XG4gICAgICAgICAgICAgICAgaWYgKG91dEpTT04gJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChvdXRKU09OLCAnYmxvY2tkZXZpY2VzJykpIHtcbiAgICAgICAgICAgICAgICAgIGRldmljZXMgPSBvdXRKU09OLmJsb2NrZGV2aWNlcy5maWx0ZXIoaXRlbSA9PiB7IHJldHVybiAoaXRlbS50eXBlID09PSAnZGlzaycpICYmIGl0ZW0uc2l6ZSA+IDAgJiYgKGl0ZW0ubW9kZWwgIT09IG51bGwgfHwgKGl0ZW0ubW91bnRwb2ludCA9PT0gbnVsbCAmJiBpdGVtLmxhYmVsID09PSBudWxsICYmIGl0ZW0uZnN0eXBlID09PSBudWxsICYmIGl0ZW0ucGFydHR5cGUgPT09IG51bGwgJiYgaXRlbS5wYXRoICYmIGl0ZW0ucGF0aC5pbmRleE9mKCcvcmFtJykgIT09IDAgJiYgaXRlbS5wYXRoLmluZGV4T2YoJy9sb29wJykgIT09IDAgJiYgaXRlbVsnZGlzYy1tYXgnXSAmJiBpdGVtWydkaXNjLW1heCddICE9PSAwKSk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9sZGVyIHZlcnNpb24gb2YgbHNibGtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQyID0gZXhlY1N5bmMoJ2V4cG9ydCBMQ19BTEw9QzsgbHNibGsgLWJQbyBOQU1FLFRZUEUsU0laRSxGU1RZUEUsTU9VTlRQT0lOVCxVVUlELFJPVEEsUk8sUk0sTEFCRUwsTU9ERUwsT1dORVIsR1JPVVAgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gYmxrU3Rkb3V0VG9PYmplY3Qob3V0Mikuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZUJsayhsaW5lcyk7XG4gICAgICAgICAgICAgICAgZGV2aWNlcyA9IGRhdGEuZmlsdGVyKGl0ZW0gPT4geyByZXR1cm4gKGl0ZW0udHlwZSA9PT0gJ2Rpc2snKSAmJiBpdGVtLnNpemUgPiAwICYmICgoaXRlbS5tb2RlbCAhPT0gbnVsbCAmJiBpdGVtLm1vZGVsICE9PSAnJykgfHwgKGl0ZW0ubW91bnQgPT09ICcnICYmIGl0ZW0ubGFiZWwgPT09ICcnICYmIGl0ZW0uZnNUeXBlID09PSAnJykpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZWRpdW1UeXBlID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgQlNETmFtZSA9ICcvZGV2LycgKyBkZXZpY2UubmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dpY2FsID0gZGV2aWNlLm5hbWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIG1lZGl1bVR5cGUgPSBleGVjU3luYygnY2F0IC9zeXMvYmxvY2svJyArIGxvZ2ljYWwgKyAnL3F1ZXVlL3JvdGF0aW9uYWwgMj4vZGV2L251bGwnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGludGVyZmFjZVR5cGUgPSBkZXZpY2UudHJhbiA/IGRldmljZS50cmFuLnRvVXBwZXJDYXNlKCkudHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyZmFjZVR5cGUgPT09ICdOVk1FJykge1xuICAgICAgICAgICAgICAgICAgbWVkaXVtVHlwZSA9ICcyJztcbiAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGUgPSAnUENJZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGRldmljZTogQlNETmFtZSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IChtZWRpdW1UeXBlID09PSAnMCcgPyAnU1NEJyA6IChtZWRpdW1UeXBlID09PSAnMScgPyAnSEQnIDogKG1lZGl1bVR5cGUgPT09ICcyJyA/ICdOVk1lJyA6IChkZXZpY2UubW9kZWwgJiYgZGV2aWNlLm1vZGVsLmluZGV4T2YoJ1NTRCcpID4gLTEgPyAnU1NEJyA6IChkZXZpY2UubW9kZWwgJiYgZGV2aWNlLm1vZGVsLmluZGV4T2YoJ05WTScpID4gLTEgPyAnTlZNZScgOiAnSEQnKSkpKSksXG4gICAgICAgICAgICAgICAgICBuYW1lOiBkZXZpY2UubW9kZWwgfHwgJycsXG4gICAgICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbChkZXZpY2UubW9kZWwpIHx8IChkZXZpY2UudmVuZG9yID8gZGV2aWNlLnZlbmRvci50cmltKCkgOiAnJyksXG4gICAgICAgICAgICAgICAgICBzaXplOiBkZXZpY2Uuc2l6ZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWN0b3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0b3RhbEN5bGluZGVyczogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsSGVhZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0b3RhbFNlY3RvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0b3RhbFRyYWNrczogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRyYWNrc1BlckN5bGluZGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2VjdG9yc1BlclRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZmlybXdhcmVSZXZpc2lvbjogZGV2aWNlLnJldiA/IGRldmljZS5yZXYudHJpbSgpIDogJycsXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IGRldmljZS5zZXJpYWwgPyBkZXZpY2Uuc2VyaWFsLnRyaW0oKSA6ICcnLFxuICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZTogaW50ZXJmYWNlVHlwZSxcbiAgICAgICAgICAgICAgICAgIHNtYXJ0U3RhdHVzOiAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIEJTRE5hbWU6IEJTRE5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbWQgKz0gYHByaW50ZiBcIlxcbiR7QlNETmFtZX18XCI7IHNtYXJ0Y3RsIC1IICR7QlNETmFtZX0gfCBncmVwIG92ZXJhbGw7YDtcbiAgICAgICAgICAgICAgICBjbWRGdWxsU21hcnQgKz0gYCR7Y21kRnVsbFNtYXJ0ID8gJ3ByaW50ZiBcIixcIjsnIDogJyd9c21hcnRjdGwgLWEgLWogJHtCU0ROYW1lfTtgO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIFMuTS5BLlIuVC4gc3RhdHVzXG4gICAgICAgICAgaWYgKGNtZEZ1bGxTbWFydCkge1xuICAgICAgICAgICAgZXhlYyhjbWRGdWxsU21hcnQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGBbJHtzdGRvdXR9XWApO1xuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChkaXNrID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc2tCU0ROYW1lID0gZGlzay5zbWFydGN0bC5hcmd2W2Rpc2suc21hcnRjdGwuYXJndi5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5CU0ROYW1lID09PSBkaXNrQlNETmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydFN0YXR1cyA9IChkaXNrLnNtYXJ0X3N0YXR1cy5wYXNzZWQgPyAnT2snIDogKGRpc2suc21hcnRfc3RhdHVzLnBhc3NlZCA9PT0gZmFsc2UgPyAnUHJlZGljdGVkIEZhaWx1cmUnIDogJ3Vua25vd24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2sudGVtcGVyYXR1cmUgJiYgZGlzay50ZW1wZXJhdHVyZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0udGVtcGVyYXR1cmUgPSBkaXNrLnRlbXBlcmF0dXJlLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydERhdGEgPSBkaXNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29tbWl0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21kKSB7XG4gICAgICAgICAgICAgICAgICBjbWQgPSBjbWQgKyAncHJpbnRmIFwiXFxuXCInO1xuICAgICAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJTRE5hbWUgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0czIgPSBwYXJ0c1sxXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzMlsxXSA9IHBhcnRzMlsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHBhcnRzMlsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLkJTRE5hbWUgPT09IEJTRE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0U3RhdHVzID0gKHN0YXR1cyA9PT0gJ3Bhc3NlZCcgPyAnT2snIDogKHN0YXR1cyA9PT0gJ2ZhaWxlZCEnID8gJ1ByZWRpY3RlZCBGYWlsdXJlJyA6ICd1bmtub3duJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbW1pdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N5c3RlbV9wcm9maWxlciBTUFNlcmlhbEFUQURhdGFUeXBlIFNQTlZNZURhdGFUeXBlIFNQVVNCRGF0YVR5cGUnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBieSB0eXBlOlxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbGV0IGxpbmVzU0FUQSA9IFtdO1xuICAgICAgICAgICAgbGV0IGxpbmVzTlZNZSA9IFtdO1xuICAgICAgICAgICAgbGV0IGxpbmVzVVNCID0gW107XG4gICAgICAgICAgICBsZXQgZGF0YVR5cGUgPSAnU0FUQSc7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICBpZiAobGluZSA9PT0gJ05WTUV4cHJlc3M6JykgeyBkYXRhVHlwZSA9ICdOVk1lJzsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lID09PSAnVVNCOicpIHsgZGF0YVR5cGUgPSAnVVNCJzsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lID09PSAnU0FUQS9TQVRBIEV4cHJlc3M6JykgeyBkYXRhVHlwZSA9ICdTQVRBJzsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ1NBVEEnKSB7IGxpbmVzU0FUQS5wdXNoKGxpbmUpOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnTlZNZScpIHsgbGluZXNOVk1lLnB1c2gobGluZSk7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdVU0InKSB7IGxpbmVzVVNCLnB1c2gobGluZSk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gU2VyaWFsIEFUQSBEcml2ZXNcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBsaW5lc1NBVEEuam9pbignXFxuJykuc3BsaXQoJyBQaHlzaWNhbCBJbnRlcmNvbm5lY3Q6ICcpO1xuICAgICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlID0gJ0ludGVyZmFjZVR5cGU6ICcgKyBkZXZpY2U7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWRpdW1UeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01lZGl1bSBUeXBlJywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVN0ciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXBhY2l0eScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJTRE5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNEIE5hbWUnLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0cikge1xuICAgICAgICAgICAgICAgICAgbGV0IHNpemVWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0ci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyLm1hdGNoKC9cXCgoW14pXSspXFwpLylbMV0ucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKC8sL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbWFydFN0YXR1c1N0cmluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTLk0uQS5SLlQuIHN0YXR1cycsICc6JywgdHJ1ZSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXZpY2U6IEJTRE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWVkaXVtVHlwZS5zdGFydHNXaXRoKCdTb2xpZCcpID8gJ1NTRCcgOiAnSEQnLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWFudWZhY3R1cmVyJywgJzonLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWN0b3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxDeWxpbmRlcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxIZWFkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNlY3RvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxUcmFja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2tzUGVyQ3lsaW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgc2VjdG9yc1BlclRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGZpcm13YXJlUmV2aXNpb246IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSZXZpc2lvbicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbCBOdW1iZXInLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW50ZXJmYWNlVHlwZScsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0U3RhdHVzOiBzbWFydFN0YXR1c1N0cmluZyA9PT0gJ3ZlcmlmaWVkJyA/ICdPSycgOiBzbWFydFN0YXR1c1N0cmluZyB8fCAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgQlNETmFtZTogQlNETmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gY21kICsgJ3ByaW50ZiBcIlxcbicgKyBCU0ROYW1lICsgJ3xcIjsgZGlza3V0aWwgaW5mbyAvZGV2LycgKyBCU0ROYW1lICsgJyB8IGdyZXAgU01BUlQ7JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTlZNRSBEcml2ZXNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gbGluZXNOVk1lLmpvaW4oJ1xcbicpLnNwbGl0KCdcXG5cXG4gICAgICAgICAgQ2FwYWNpdHk6Jyk7XG4gICAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2UgPSAnIUNhcGFjaXR5OiAnICsgZGV2aWNlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua1dpZHRoID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2xpbmsgd2lkdGgnLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplU3RyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJyFjYXBhY2l0eScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJTRE5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNEIE5hbWUnLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0cikge1xuICAgICAgICAgICAgICAgICAgbGV0IHNpemVWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0ci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyLm1hdGNoKC9cXCgoW14pXSspXFwpLylbMV0ucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKC8sL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbWFydFN0YXR1c1N0cmluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTLk0uQS5SLlQuIHN0YXR1cycsICc6JywgdHJ1ZSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXZpY2U6IEJTRE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ05WTWUnLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWN0b3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxDeWxpbmRlcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxIZWFkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNlY3RvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxUcmFja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2tzUGVyQ3lsaW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgc2VjdG9yc1BlclRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGZpcm13YXJlUmV2aXNpb246IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSZXZpc2lvbicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbCBOdW1iZXInLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlOiAoJ1BDSWUgJyArIGxpbmtXaWR0aCkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0U3RhdHVzOiBzbWFydFN0YXR1c1N0cmluZyA9PT0gJ3ZlcmlmaWVkJyA/ICdPSycgOiBzbWFydFN0YXR1c1N0cmluZyB8fCAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgQlNETmFtZTogQlNETmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gY21kICsgJ3ByaW50ZiBcIlxcbicgKyBCU0ROYW1lICsgJ3xcIjsgZGlza3V0aWwgaW5mbyAvZGV2LycgKyBCU0ROYW1lICsgJyB8IGdyZXAgU01BUlQ7JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVTQiBEcml2ZXNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gbGluZXNVU0Iuam9pbignXFxuJykucmVwbGFjZUFsbCgnTWVkaWE6XFxuICcsICdNb2RlbDonKS5zcGxpdCgnXFxuXFxuICAgICAgICAgIFByb2R1Y3QgSUQ6Jyk7XG4gICAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVTdHIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwYWNpdHknLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCU0ROYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTRCBOYW1lJywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVTdHIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBzaXplVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHNpemVTdHIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0ci5tYXRjaCgvXFwoKFteKV0rKVxcKS8pWzFdLnJlcGxhY2UoL1xcLi9nLCAnJykucmVwbGFjZSgvLC9nLCAnJykucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc21hcnRTdGF0dXNTdHJpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUy5NLkEuUi5ULiBzdGF0dXMnLCAnOicsIHRydWUpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgZGV2aWNlOiBCU0ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdVU0InLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpLnJlcGxhY2VBbGwoJzonLCAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBieXRlc1BlclNlY3RvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEN5bGluZGVyczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEhlYWRzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2VjdG9yczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRyYWNrczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja3NQZXJDeWxpbmRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBzZWN0b3JzUGVyVHJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgZmlybXdhcmVSZXZpc2lvbjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JldmlzaW9uJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsIE51bWJlcicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGU6ICdVU0InLFxuICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0U3RhdHVzOiBzbWFydFN0YXR1c1N0cmluZyA9PT0gJ3ZlcmlmaWVkJyA/ICdPSycgOiBzbWFydFN0YXR1c1N0cmluZyB8fCAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgQlNETmFtZTogQlNETmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gY21kICsgJ3ByaW50ZiBcIlxcbicgKyBCU0ROYW1lICsgJ3xcIjsgZGlza3V0aWwgaW5mbyAvZGV2LycgKyBCU0ROYW1lICsgJyB8IGdyZXAgU01BUlQ7JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbWQpIHtcbiAgICAgICAgICAgICAgY21kID0gY21kICsgJ3ByaW50ZiBcIlxcblwiJztcbiAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IEJTRE5hbWUgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMyID0gcGFydHNbMV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMyWzFdID0gcGFydHMyWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSBwYXJ0czJbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0uQlNETmFtZSA9PT0gQlNETmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydFN0YXR1cyA9IChzdGF0dXMgPT09ICdub3Qgc3VwcG9ydGVkJyA/ICdub3Qgc3VwcG9ydGVkJyA6IChzdGF0dXMgPT09ICd2ZXJpZmllZCcgPyAnT2snIDogKHN0YXR1cyA9PT0gJ2ZhaWxpbmcnID8gJ1ByZWRpY3RlZCBGYWlsdXJlJyA6ICd1bmtub3duJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2ldLkJTRE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtpXS5CU0ROYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfRGlza0RyaXZlIHwgc2VsZWN0IENhcHRpb24sU2l6ZSxTdGF0dXMsUE5QRGV2aWNlSWQsRGV2aWNlSWQsQnl0ZXNQZXJTZWN0b3IsVG90YWxDeWxpbmRlcnMsVG90YWxIZWFkcyxUb3RhbFNlY3RvcnMsVG90YWxUcmFja3MsVHJhY2tzUGVyQ3lsaW5kZXIsU2VjdG9yc1BlclRyYWNrLEZpcm13YXJlUmV2aXNpb24sU2VyaWFsTnVtYmVyLEludGVyZmFjZVR5cGUgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LVBoeXNpY2FsRGlzayB8IHNlbGVjdCBCdXNUeXBlLE1lZGlhVHlwZSxGcmllbmRseU5hbWUsTW9kZWwsU2VyaWFsTnVtYmVyLFNpemUgfCBmbCcpKTtcbiAgICAgICAgICBpZiAodXRpbC5zbWFydE1vblRvb2xzSW5zdGFsbGVkKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNtYXJ0RGV2ID0gSlNPTi5wYXJzZShleGVjU3luYygnc21hcnRjdGwgLS1zY2FuIC1qJykpO1xuICAgICAgICAgICAgICBpZiAoc21hcnREZXYgJiYgc21hcnREZXYuZGV2aWNlcyAmJiBzbWFydERldi5kZXZpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzbWFydERldi5kZXZpY2VzLmZvckVhY2goKGRldikgPT4ge1xuICAgICAgICAgICAgICAgICAgd29ya2xvYWQucHVzaChleGVjUHJvbWlzZVNhdmUoYHNtYXJ0Y3RsIC1qIC1hICR7ZGV2Lm5hbWV9YCwgdXRpbC5leGVjT3B0c1dpbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGRldmljZXMgPSBkYXRhLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaXplJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGF0dXMnLCAnOicpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGRldmljZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RldmljZUlkJywgJzonKSwgIC8vIGNoYW5nZWQgZnJvbSBQTlBEZXZpY2VJZCB0byBEZXZpY2VJRCAoYmUgYmUgYWJsZSB0byBtYXRjaCBkZXZpY2VzKVxuICAgICAgICAgICAgICAgICAgdHlwZTogZGV2aWNlLmluZGV4T2YoJ1NTRCcpID4gLTEgPyAnU1NEJyA6ICdIRCcsICAvLyBqdXN0IGEgc3RhcnRpbmcgcG9pbnQgLi4uIGJldHRlcjogTVNGVF9QaHlzaWNhbERpc2sgLSBNZWRpYSBUeXBlIC4uLiBzZWUgYmVsb3dcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonLCB0cnVlKS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VJbnQoc2l6ZSksXG4gICAgICAgICAgICAgICAgICBieXRlc1BlclNlY3RvcjogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J5dGVzUGVyU2VjdG9yJywgJzonKSksXG4gICAgICAgICAgICAgICAgICB0b3RhbEN5bGluZGVyczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsQ3lsaW5kZXJzJywgJzonKSksXG4gICAgICAgICAgICAgICAgICB0b3RhbEhlYWRzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWxIZWFkcycsICc6JykpLFxuICAgICAgICAgICAgICAgICAgdG90YWxTZWN0b3JzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWxTZWN0b3JzJywgJzonKSksXG4gICAgICAgICAgICAgICAgICB0b3RhbFRyYWNrczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsVHJhY2tzJywgJzonKSksXG4gICAgICAgICAgICAgICAgICB0cmFja3NQZXJDeWxpbmRlcjogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RyYWNrc1BlckN5bGluZGVyJywgJzonKSksXG4gICAgICAgICAgICAgICAgICBzZWN0b3JzUGVyVHJhY2s6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZWN0b3JzUGVyVHJhY2snLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIGZpcm13YXJlUmV2aXNpb246IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGaXJtd2FyZVJldmlzaW9uJywgJzonKS50cmltKCksXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWxOdW1iZXInLCAnOicpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnRlcmZhY2VUeXBlJywgJzonKS50cmltKCksXG4gICAgICAgICAgICAgICAgICBzbWFydFN0YXR1czogKHN0YXR1cyA9PT0gJ29rJyA/ICdPaycgOiAoc3RhdHVzID09PSAnZGVncmFkZWQnID8gJ0RlZ3JhZGVkJyA6IChzdGF0dXMgPT09ICdwcmVkIGZhaWwnID8gJ1ByZWRpY3RlZCBGYWlsdXJlJyA6ICdVbmtub3duJykpKSxcbiAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRldmljZXMgPSBkYXRhLnJlc3VsdHNbMV0uc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcmlhbE51bSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWxOdW1iZXInLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGcmllbmRseU5hbWUnLCAnOicpLnRyaW0oKS5yZXBsYWNlKCdNc2Z0ICcsICdNaWNyb3NvZnQnKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaXplJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGludGVyZmFjZVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnVzVHlwZScsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBsZXQgbWVkaWFUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01lZGlhVHlwZScsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAobWVkaWFUeXBlID09PSAnMycgfHwgbWVkaWFUeXBlID09PSAnSEREJykgeyBtZWRpYVR5cGUgPSAnSEQnOyB9XG4gICAgICAgICAgICAgIGlmIChtZWRpYVR5cGUgPT09ICc0JykgeyBtZWRpYVR5cGUgPSAnU1NEJzsgfVxuICAgICAgICAgICAgICBpZiAobWVkaWFUeXBlID09PSAnNScpIHsgbWVkaWFUeXBlID0gJ1NDTSc7IH1cbiAgICAgICAgICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gJ1Vuc3BlY2lmaWVkJyAmJiAobW9kZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2aXJ0dWFsJykgPiAtMSB8fCBtb2RlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3Zib3gnKSA+IC0xKSkgeyBtZWRpYVR5cGUgPSAnVmlydHVhbCc7IH1cbiAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHV0aWwuZmluZE9iamVjdEJ5S2V5KHJlc3VsdCwgJ3NlcmlhbE51bScsIHNlcmlhbE51bSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IC0xIHx8IHNlcmlhbE51bSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGkgPSB1dGlsLmZpbmRPYmplY3RCeUtleShyZXN1bHQsICduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbaV0udHlwZSA9IG1lZGlhVHlwZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5pbnRlcmZhY2VUeXBlID0gaW50ZXJmYWNlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUy5NLkEuUi5UXG4gICAgICAgICAgICBkYXRhLnJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGRhdGEucmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZGF0YS5yZXN1bHRzLmZvckVhY2goKHNtYXJ0U3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNtYXJ0RGF0YSA9IEpTT04ucGFyc2Uoc21hcnRTdHIpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNtYXJ0RGF0YS5zZXJpYWxfbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbE51bSA9IHNtYXJ0RGF0YS5zZXJpYWxfbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IHV0aWwuZmluZE9iamVjdEJ5S2V5KHJlc3VsdCwgJ3NlcmlhbE51bScsIHNlcmlhbE51bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0U3RhdHVzID0gKHNtYXJ0RGF0YS5zbWFydF9zdGF0dXMgJiYgc21hcnREYXRhLnNtYXJ0X3N0YXR1cy5wYXNzZWQgPyAnT2snIDogKHNtYXJ0RGF0YS5zbWFydF9zdGF0dXMgJiYgc21hcnREYXRhLnNtYXJ0X3N0YXR1cy5wYXNzZWQgPT09IGZhbHNlID8gJ1ByZWRpY3RlZCBGYWlsdXJlJyA6ICd1bmtub3duJykpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzbWFydERhdGEudGVtcGVyYXR1cmUgJiYgc21hcnREYXRhLnRlbXBlcmF0dXJlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS50ZW1wZXJhdHVyZSA9IHNtYXJ0RGF0YS50ZW1wZXJhdHVyZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnREYXRhID0gc21hcnREYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGlza0xheW91dCA9IGRpc2tMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGdyYXBoaWNzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gNy4gR3JhcGhpY3MgKGNvbnRyb2xsZXIsIGRpc3BsYXkpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbmxldCBfbnZpZGlhU21pUGF0aCA9ICcnO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5sZXQgX3Jlc29sdXRpb25YID0gMDtcbmxldCBfcmVzb2x1dGlvblkgPSAwO1xubGV0IF9waXhlbERlcHRoID0gMDtcbmxldCBfcmVmcmVzaFJhdGUgPSAwO1xuXG5jb25zdCB2aWRlb1R5cGVzID0ge1xuICAnLTInOiAnVU5JTklUSUFMSVpFRCcsXG4gICctMSc6ICdPVEhFUicsXG4gICcwJzogJ0hEMTUnLFxuICAnMSc6ICdTVklERU8nLFxuICAnMic6ICdDb21wb3NpdGUgdmlkZW8nLFxuICAnMyc6ICdDb21wb25lbnQgdmlkZW8nLFxuICAnNCc6ICdEVkknLFxuICAnNSc6ICdIRE1JJyxcbiAgJzYnOiAnTFZEUycsXG4gICc4JzogJ0RfSlBOJyxcbiAgJzknOiAnU0RJJyxcbiAgJzEwJzogJ0RQJyxcbiAgJzExJzogJ0RQIGVtYmVkZGVkJyxcbiAgJzEyJzogJ1VESScsXG4gICcxMyc6ICdVREkgZW1iZWRkZWQnLFxuICAnMTQnOiAnU0RUVkRPTkdMRScsXG4gICcxNSc6ICdNSVJBQ0FTVCcsXG4gICcyMTQ3NDgzNjQ4JzogJ0lOVEVSTkFMJ1xufTtcblxuZnVuY3Rpb24gZ2V0VmVuZG9yRnJvbU1vZGVsKG1vZGVsKSB7XG4gIGNvbnN0IG1hbnVmYWN0dXJlcnMgPSBbXG4gICAgeyBwYXR0ZXJuOiAnXkxHLisnLCBtYW51ZmFjdHVyZXI6ICdMRycgfSxcbiAgICB7IHBhdHRlcm46ICdeQkVOUS4rJywgbWFudWZhY3R1cmVyOiAnQmVuUScgfSxcbiAgICB7IHBhdHRlcm46ICdeQVNVUy4rJywgbWFudWZhY3R1cmVyOiAnQXN1cycgfSxcbiAgICB7IHBhdHRlcm46ICdeREVMTC4rJywgbWFudWZhY3R1cmVyOiAnRGVsbCcgfSxcbiAgICB7IHBhdHRlcm46ICdeU0FNU1VORy4rJywgbWFudWZhY3R1cmVyOiAnU2Ftc3VuZycgfSxcbiAgICB7IHBhdHRlcm46ICdeVklFV1NPTi4rJywgbWFudWZhY3R1cmVyOiAnVmlld1NvbmljJyB9LFxuICAgIHsgcGF0dGVybjogJ15TT05ZLisnLCBtYW51ZmFjdHVyZXI6ICdTb255JyB9LFxuICAgIHsgcGF0dGVybjogJ15BQ0VSLisnLCBtYW51ZmFjdHVyZXI6ICdBY2VyJyB9LFxuICAgIHsgcGF0dGVybjogJ15BT0MuKycsIG1hbnVmYWN0dXJlcjogJ0FPQyBNb25pdG9ycycgfSxcbiAgICB7IHBhdHRlcm46ICdeSFAuKycsIG1hbnVmYWN0dXJlcjogJ0hQJyB9LFxuICAgIHsgcGF0dGVybjogJ15FSVpPLj8nLCBtYW51ZmFjdHVyZXI6ICdFaXpvJyB9LFxuICAgIHsgcGF0dGVybjogJ15QSElMSVBTLj8nLCBtYW51ZmFjdHVyZXI6ICdQaGlsaXBzJyB9LFxuICAgIHsgcGF0dGVybjogJ15JSVlBTUEuPycsIG1hbnVmYWN0dXJlcjogJ0lpeWFtYScgfSxcbiAgICB7IHBhdHRlcm46ICdeU0hBUlAuPycsIG1hbnVmYWN0dXJlcjogJ1NoYXJwJyB9LFxuICAgIHsgcGF0dGVybjogJ15ORUMuPycsIG1hbnVmYWN0dXJlcjogJ05FQycgfSxcbiAgICB7IHBhdHRlcm46ICdeTEVOT1ZPLj8nLCBtYW51ZmFjdHVyZXI6ICdMZW5vdm8nIH0sXG4gICAgeyBwYXR0ZXJuOiAnQ09NUEFRLj8nLCBtYW51ZmFjdHVyZXI6ICdDb21wYXEnIH0sXG4gICAgeyBwYXR0ZXJuOiAnQVBQTEUuPycsIG1hbnVmYWN0dXJlcjogJ0FwcGxlJyB9LFxuICAgIHsgcGF0dGVybjogJ0lOVEVMLj8nLCBtYW51ZmFjdHVyZXI6ICdJbnRlbCcgfSxcbiAgICB7IHBhdHRlcm46ICdBTUQuPycsIG1hbnVmYWN0dXJlcjogJ0FNRCcgfSxcbiAgICB7IHBhdHRlcm46ICdOVklESUEuPycsIG1hbnVmYWN0dXJlcjogJ05WRElBJyB9LFxuICBdO1xuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKG1vZGVsKSB7XG4gICAgbW9kZWwgPSBtb2RlbC50b1VwcGVyQ2FzZSgpO1xuICAgIG1hbnVmYWN0dXJlcnMuZm9yRWFjaCgobWFudWZhY3R1cmVyKSA9PiB7XG4gICAgICBjb25zdCByZSA9IFJlZ0V4cChtYW51ZmFjdHVyZXIucGF0dGVybik7XG4gICAgICBpZiAocmUudGVzdChtb2RlbCkpIHsgcmVzdWx0ID0gbWFudWZhY3R1cmVyLm1hbnVmYWN0dXJlcjsgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldFZlbmRvckZyb21JZChpZCkge1xuICBjb25zdCB2ZW5kb3JzID0ge1xuICAgICc2MTAnOiAnQXBwbGUnLFxuICAgICcxZTZkJzogJ0xHJyxcbiAgICAnMTBhYyc6ICdERUxMJyxcbiAgICAnNGRkOSc6ICdTb255JyxcbiAgICAnMzhhMyc6ICdORUMnLFxuICB9O1xuICByZXR1cm4gdmVuZG9yc1tpZF0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIHZlbmRvclRvSWQoc3RyKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgc3RyID0gKHN0ciB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHN0ci5pbmRleE9mKCdhcHBsZScpID49IDApIHsgcmVzdWx0ID0gJzB4MDVhYyc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ252aWRpYScpID49IDApIHsgcmVzdWx0ID0gJzB4MTBkZSc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2ludGVsJykgPj0gMCkgeyByZXN1bHQgPSAnMHg4MDg2JzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignYXRpJykgPj0gMCB8fCBzdHIuaW5kZXhPZignYW1kJykgPj0gMCkgeyByZXN1bHQgPSAnMHgxMDAyJzsgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1ldGFsVmVyc2lvbihpZCkge1xuICBjb25zdCBmYW1pbGllcyA9IHtcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHltYWMxJzogJ21hYzEnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseW1hYzInOiAnbWFjMicsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGUxJzogJ2FwcGxlMScsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGUyJzogJ2FwcGxlMicsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGUzJzogJ2FwcGxlMycsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGU0JzogJ2FwcGxlNCcsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGU1JzogJ2FwcGxlNScsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGU2JzogJ2FwcGxlNicsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5YXBwbGU3JzogJ2FwcGxlNycsXG4gICAgJ3NwZGlzcGxheXNfbWV0YWxmZWF0dXJlc2V0ZmFtaWx5MTEnOiAnZmFtaWx5MV92MScsXG4gICAgJ3NwZGlzcGxheXNfbWV0YWxmZWF0dXJlc2V0ZmFtaWx5MTInOiAnZmFtaWx5MV92MicsXG4gICAgJ3NwZGlzcGxheXNfbWV0YWxmZWF0dXJlc2V0ZmFtaWx5MTMnOiAnZmFtaWx5MV92MycsXG4gICAgJ3NwZGlzcGxheXNfbWV0YWxmZWF0dXJlc2V0ZmFtaWx5MTQnOiAnZmFtaWx5MV92NCcsXG4gICAgJ3NwZGlzcGxheXNfbWV0YWxmZWF0dXJlc2V0ZmFtaWx5MjEnOiAnZmFtaWx5Ml92MSdcbiAgfTtcbiAgcmV0dXJuIGZhbWlsaWVzW2lkXSB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ3JhcGhpY3MoY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzRGFyd2luKGdyYXBoaWNzQXJyKSB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29udHJvbGxlcnM6IFtdLFxuICAgICAgZGlzcGxheXM6IFtdXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgZ3JhcGhpY3NBcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAvLyBjb250cm9sbGVyc1xuICAgICAgICBjb25zdCBidXMgPSAoKGl0ZW0uc3BwY2lfYnVzIHx8ICcnKS5pbmRleE9mKCdidWlsdGluJykgPiAtMSA/ICdCdWlsdC1JbicgOiAoKGl0ZW0uc3BwY2lfYnVzIHx8ICcnKS5pbmRleE9mKCdwY2llJykgPiAtMSA/ICdQQ0llJyA6ICcnKSk7XG4gICAgICAgIGNvbnN0IHZyYW0gPSAocGFyc2VJbnQoKGl0ZW0uc3BkaXNwbGF5c192cmFtIHx8ICcnKSwgMTApIHx8IDApICogKCgoaXRlbS5zcGRpc3BsYXlzX3ZyYW0gfHwgJycpLmluZGV4T2YoJ0dCJykgPiAtMSkgPyAxMDI0IDogMSk7XG4gICAgICAgIGNvbnN0IHZyYW1EeW4gPSAocGFyc2VJbnQoKGl0ZW0uc3BkaXNwbGF5c192cmFtX3NoYXJlZCB8fCAnJyksIDEwKSB8fCAwKSAqICgoKGl0ZW0uc3BkaXNwbGF5c192cmFtX3NoYXJlZCB8fCAnJykuaW5kZXhPZignR0InKSA+IC0xKSA/IDEwMjQgOiAxKTtcbiAgICAgICAgbGV0IG1ldGFsVmVyc2lvbiA9IGdldE1ldGFsVmVyc2lvbihpdGVtLnNwZGlzcGxheXNfbWV0YWwgfHwgaXRlbS5zcGRpc3BsYXlzX21ldGFsZmFtaWx5IHx8ICcnKTtcbiAgICAgICAgcmVzLmNvbnRyb2xsZXJzLnB1c2goe1xuICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKGl0ZW0uc3BkaXNwbGF5c192ZW5kb3IgfHwgJycpIHx8IGl0ZW0uc3BkaXNwbGF5c192ZW5kb3IgfHwgJycsXG4gICAgICAgICAgbW9kZWw6IGl0ZW0uc3BwY2lfbW9kZWwgfHwgJycsXG4gICAgICAgICAgYnVzLFxuICAgICAgICAgIHZyYW1EeW5hbWljOiBidXMgPT09ICdCdWlsdC1JbicsXG4gICAgICAgICAgdnJhbTogdnJhbSB8fCB2cmFtRHluIHx8IG51bGwsXG4gICAgICAgICAgZGV2aWNlSWQ6IGl0ZW1bJ3NwZGlzcGxheXNfZGV2aWNlLWlkJ10gfHwgJycsXG4gICAgICAgICAgdmVuZG9ySWQ6IGl0ZW1bJ3NwZGlzcGxheXNfdmVuZG9yLWlkJ10gfHwgdmVuZG9yVG9JZCgoaXRlbVsnc3BkaXNwbGF5c192ZW5kb3InXSB8fCAnJykgKyAoaXRlbS5zcHBjaV9tb2RlbCB8fCAnJykpLFxuICAgICAgICAgIGV4dGVybmFsOiAoaXRlbS5zcHBjaV9kZXZpY2VfdHlwZSA9PT0gJ3NwZGlzcGxheXNfZWdwdScpLFxuICAgICAgICAgIGNvcmVzOiBpdGVtWydzcHBjaV9jb3JlcyddIHx8IG51bGwsXG4gICAgICAgICAgbWV0YWxWZXJzaW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRpc3BsYXlzXG4gICAgICAgIGlmIChpdGVtLnNwZGlzcGxheXNfbmRydnMgJiYgaXRlbS5zcGRpc3BsYXlzX25kcnZzLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW0uc3BkaXNwbGF5c19uZHJ2cy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwbGF5SXRlbSkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvblR5cGUgPSBkaXNwbGF5SXRlbVsnc3BkaXNwbGF5c19jb25uZWN0aW9uX3R5cGUnXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uUGFydHMgPSAoZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX3Jlc29sdXRpb24nXSB8fCAnJykuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gY3VycmVudFJlc29sdXRpb25QYXJ0c1swXS5zcGxpdCgneCcpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxQYXJ0cyA9IChkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfcGl4ZWxzJ10gfHwgJycpLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgICBjb25zdCBwaXhlbERlcHRoU3RyaW5nID0gZGlzcGxheUl0ZW1bJ3NwZGlzcGxheXNfZGVwdGgnXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbCA9IGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5LXNlcmlhbC1udW1iZXInXSB8fCBkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheS1zZXJpYWwtbnVtYmVyMiddIHx8IG51bGw7XG4gICAgICAgICAgICByZXMuZGlzcGxheXMucHVzaCh7XG4gICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbUlkKGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5LXZlbmRvci1pZCddIHx8ICcnKSB8fCBnZXRWZW5kb3JGcm9tTW9kZWwoZGlzcGxheUl0ZW1bJ19uYW1lJ10gfHwgJycpLFxuICAgICAgICAgICAgICB2ZW5kb3JJZDogZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXktdmVuZG9yLWlkJ10gfHwgJycsXG4gICAgICAgICAgICAgIG1vZGVsOiBkaXNwbGF5SXRlbVsnX25hbWUnXSB8fCAnJyxcbiAgICAgICAgICAgICAgcHJvZHVjdGlvblllYXI6IGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5LXllYXInXSB8fCBudWxsLFxuICAgICAgICAgICAgICBzZXJpYWw6IHNlcmlhbCAhPT0gJzAnID8gc2VyaWFsIDogbnVsbCxcbiAgICAgICAgICAgICAgZGlzcGxheUlkOiBkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheUlEJ10gfHwgbnVsbCxcbiAgICAgICAgICAgICAgbWFpbjogZGlzcGxheUl0ZW1bJ3NwZGlzcGxheXNfbWFpbiddID8gZGlzcGxheUl0ZW1bJ3NwZGlzcGxheXNfbWFpbiddID09PSAnc3BkaXNwbGF5c195ZXMnIDogZmFsc2UsXG4gICAgICAgICAgICAgIGJ1aWx0aW46IChkaXNwbGF5SXRlbVsnc3BkaXNwbGF5c19kaXNwbGF5X3R5cGUnXSB8fCAnJykuaW5kZXhPZignYnVpbHQtaW4nKSA+IC0xLFxuICAgICAgICAgICAgICBjb25uZWN0aW9uOiAoKGNvbm5lY3Rpb25UeXBlLmluZGV4T2YoJ19pbnRlcm5hbCcpID4gLTEpID8gJ0ludGVybmFsJyA6ICgoY29ubmVjdGlvblR5cGUuaW5kZXhPZignX2Rpc3BsYXlwb3J0JykgPiAtMSkgPyAnRGlzcGxheSBQb3J0JyA6ICgoY29ubmVjdGlvblR5cGUuaW5kZXhPZignX2hkbWknKSA+IC0xKSA/ICdIRE1JJyA6IG51bGwpKSksXG4gICAgICAgICAgICAgIHNpemVYOiBudWxsLFxuICAgICAgICAgICAgICBzaXplWTogbnVsbCxcbiAgICAgICAgICAgICAgcGl4ZWxEZXB0aDogKHBpeGVsRGVwdGhTdHJpbmcgPT09ICdDR1NUaGlydHlCaXRDb2xvcicgPyAzMCA6IChwaXhlbERlcHRoU3RyaW5nID09PSAnQ0dTVGhpcnR5dHdvQml0Q29sb3InID8gMzIgOiAocGl4ZWxEZXB0aFN0cmluZyA9PT0gJ0NHU1R3ZW50eWZvdXJCaXRDb2xvcicgPyAyNCA6IG51bGwpKSksXG4gICAgICAgICAgICAgIHJlc29sdXRpb25YOiBwaXhlbFBhcnRzLmxlbmd0aCA+IDEgPyBwYXJzZUludChwaXhlbFBhcnRzWzBdLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uWTogcGl4ZWxQYXJ0cy5sZW5ndGggPiAxID8gcGFyc2VJbnQocGl4ZWxQYXJ0c1sxXSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgY3VycmVudFJlc1g6IGN1cnJlbnRSZXNvbHV0aW9uLmxlbmd0aCA+IDEgPyBwYXJzZUludChjdXJyZW50UmVzb2x1dGlvblswXSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgY3VycmVudFJlc1k6IGN1cnJlbnRSZXNvbHV0aW9uLmxlbmd0aCA+IDEgPyBwYXJzZUludChjdXJyZW50UmVzb2x1dGlvblsxXSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgICAgICAgICBwb3NpdGlvblk6IDAsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZWZyZXNoUmF0ZTogY3VycmVudFJlc29sdXRpb25QYXJ0cy5sZW5ndGggPiAxID8gcGFyc2VJbnQoY3VycmVudFJlc29sdXRpb25QYXJ0c1sxXSwgMTApIDogbnVsbCxcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNMaW51eENvbnRyb2xsZXJzKGxpbmVzKSB7XG4gICAgbGV0IGNvbnRyb2xsZXJzID0gW107XG4gICAgbGV0IGN1cnJlbnRDb250cm9sbGVyID0ge1xuICAgICAgdmVuZG9yOiAnJyxcbiAgICAgIG1vZGVsOiAnJyxcbiAgICAgIGJ1czogJycsXG4gICAgICBidXNBZGRyZXNzOiAnJyxcbiAgICAgIHZyYW06IG51bGwsXG4gICAgICB2cmFtRHluYW1pYzogZmFsc2UsXG4gICAgICBwY2lJRDogJydcbiAgICB9O1xuICAgIGxldCBpc0dyYXBoaWNzQ29udHJvbGxlciA9IGZhbHNlO1xuICAgIC8vIFBDSSBidXMgSURzXG4gICAgbGV0IHBjaUlEcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBwY2lJRHMgPSBleGVjU3luYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgOSAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMIHwgZ3JlcCBcIkJ1cyBBZGRyZXNzOiBcIicpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY2lJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGNpSURzW2ldID0gcGNpSURzW2ldLnJlcGxhY2UoJ0J1cyBBZGRyZXNzOicsICcnKS5yZXBsYWNlKCcwMDAwOicsICcnKS50cmltKCk7XG4gICAgICB9XG4gICAgICBwY2lJRHMgPSBwY2lJRHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwgIT0gbnVsbCAmJiBlbDtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICBpZiAoJycgIT09IGxpbmUudHJpbSgpKSB7XG4gICAgICAgIGlmICgnICcgIT09IGxpbmVbMF0gJiYgJ1xcdCcgIT09IGxpbmVbMF0pIHsgICAgICAgIC8vIGZpcnN0IGxpbmUgb2YgbmV3IGVudHJ5XG4gICAgICAgICAgbGV0IGlzRXh0ZXJuYWwgPSAocGNpSURzLmluZGV4T2YobGluZS5zcGxpdCgnICcpWzBdKSA+PSAwKTtcbiAgICAgICAgICBsZXQgdmdhcG9zID0gbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyB2Z2EgJyk7XG4gICAgICAgICAgbGV0IF8zZGNvbnRyb2xsZXJwb3MgPSBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignM2QgY29udHJvbGxlcicpO1xuICAgICAgICAgIGlmICh2Z2Fwb3MgIT09IC0xIHx8IF8zZGNvbnRyb2xsZXJwb3MgIT09IC0xKSB7ICAgICAgICAgLy8gVkdBXG4gICAgICAgICAgICBpZiAoXzNkY29udHJvbGxlcnBvcyAhPT0gLTEgJiYgdmdhcG9zID09PSAtMSkge1xuICAgICAgICAgICAgICB2Z2Fwb3MgPSBfM2Rjb250cm9sbGVycG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciB8fCBjdXJyZW50Q29udHJvbGxlci5tb2RlbCB8fCBjdXJyZW50Q29udHJvbGxlci5idXMgfHwgY3VycmVudENvbnRyb2xsZXIudnJhbSAhPT0gbnVsbCB8fCBjdXJyZW50Q29udHJvbGxlci52cmFtRHluYW1pYykgeyAvLyBhbHJlYWR5IGEgY29udHJvbGxlciBmb3VuZFxuICAgICAgICAgICAgICBjb250cm9sbGVycy5wdXNoKGN1cnJlbnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIgPSB7XG4gICAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgICBtb2RlbDogJycsXG4gICAgICAgICAgICAgICAgYnVzOiAnJyxcbiAgICAgICAgICAgICAgICBidXNBZGRyZXNzOiAnJyxcbiAgICAgICAgICAgICAgICB2cmFtOiBudWxsLFxuICAgICAgICAgICAgICAgIHZyYW1EeW5hbWljOiBmYWxzZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGNpSURDYW5kaWRhdGUgPSBsaW5lLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICBpZiAoL1tcXGRhLWZBLUZdezJ9OltcXGRhLWZBLUZdezJ9XFwuW1xcZGEtZkEtRl0vLnRlc3QocGNpSURDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLmJ1c0FkZHJlc3MgPSBwY2lJRENhbmRpZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzR3JhcGhpY3NDb250cm9sbGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBlbmRwb3MgPSBsaW5lLnNlYXJjaCgvXFxbWzAtOWEtZl17NH06WzAtOWEtZl17NH1dfCQvKTtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3Vic3RyKHZnYXBvcywgZW5kcG9zIC0gdmdhcG9zKS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIuYnVzQWRkcmVzcyA9IGxpbmUuc3Vic3RyKDAsIHZnYXBvcykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2NvcnBvcmF0aW9uJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciA9IHBhcnRzWzFdLnN1YnN0cigwLCBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2NvcnBvcmF0aW9uJykgKyAxMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLm1vZGVsID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY29ycG9yYXRpb24nKSArIDExLCAyMDApLnRyaW0oKS5zcGxpdCgnKCcpWzBdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLmJ1cyA9IChwY2lJRHMubGVuZ3RoID4gMCAmJiBpc0V4dGVybmFsKSA/ICdQQ0llJyA6ICdPbmJvYXJkJztcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52cmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52cmFtRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGluYy4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwYXJ0c1sxXS5tYXRjaCgvXS9nKSB8fCBbXSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudmVuZG9yID0gcGFydHNbMV0uc3Vic3RyKDAsIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignXScpICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIubW9kZWwgPSBwYXJ0c1sxXS5zdWJzdHIocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCddJykgKyAxLCAyMDApLnRyaW0oKS5zcGxpdCgnKCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudmVuZG9yID0gcGFydHNbMV0uc3Vic3RyKDAsIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGluYy4nKSArIDUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLm1vZGVsID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGluYy4nKSArIDUsIDIwMCkudHJpbSgpLnNwbGl0KCcoJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5idXMgPSAocGNpSURzLmxlbmd0aCA+IDAgJiYgaXNFeHRlcm5hbCkgPyAnUENJZScgOiAnT25ib2FyZCc7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudnJhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudnJhbUR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBsdGQuJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgocGFydHNbMV0ubWF0Y2goL10vZykgfHwgW10pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciA9IHBhcnRzWzFdLnN1YnN0cigwLCBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ10nKSArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLm1vZGVsID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignXScpICsgMSwgMjAwKS50cmltKCkuc3BsaXQoJygnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciA9IHBhcnRzWzFdLnN1YnN0cigwLCBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBsdGQuJykgKyA1KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5tb2RlbCA9IHBhcnRzWzFdLnN1YnN0cihwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBsdGQuJykgKyA1LCAyMDApLnRyaW0oKS5zcGxpdCgnKCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0dyYXBoaWNzQ29udHJvbGxlciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNHcmFwaGljc0NvbnRyb2xsZXIpIHsgLy8gd2l0aGluIFZHQSBkZXRhaWxzXG4gICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzWzBdLnJlcGxhY2UoLyArL2csICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RldmljZW5hbWUnKSAhPT0gLTEgJiYgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvbmJvYXJkJykgIT09IC0xKSB7IGN1cnJlbnRDb250cm9sbGVyLmJ1cyA9ICdPbmJvYXJkJzsgfVxuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzWzBdLnJlcGxhY2UoLyArL2csICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3JlZ2lvbicpICE9PSAtMSAmJiBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21lbW9yeScpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IG1lbXBhcnRzID0gcGFydHNbMV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChtZW1wYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZyYW0gPSBwYXJzZUludChtZW1wYXJ0c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VycmVudENvbnRyb2xsZXIudmVuZG9yIHx8IGN1cnJlbnRDb250cm9sbGVyLm1vZGVsIHx8IGN1cnJlbnRDb250cm9sbGVyLmJ1cyB8fCBjdXJyZW50Q29udHJvbGxlci5idXNBZGRyZXNzIHx8IGN1cnJlbnRDb250cm9sbGVyLnZyYW0gIT09IG51bGwgfHwgY3VycmVudENvbnRyb2xsZXIudnJhbUR5bmFtaWMpIHsgLy8gYWxyZWFkeSBhIGNvbnRyb2xsZXIgZm91bmRcbiAgICAgIGNvbnRyb2xsZXJzLnB1c2goY3VycmVudENvbnRyb2xsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNMaW51eENsaW5mbyhjb250cm9sbGVycywgbGluZXMpIHtcbiAgICBjb25zdCBmaWVsZFBhdHRlcm4gPSAvXFxbKFteXFxdXSspXFxdXFxzKyhcXHcrKVxccysoLiopLztcbiAgICBjb25zdCBkZXZpY2VzID0gbGluZXMucmVkdWNlKChkZXZpY2VzLCBsaW5lKSA9PiB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkUGF0dGVybi5leGVjKGxpbmUudHJpbSgpKTtcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBpZiAoIWRldmljZXNbZmllbGRbMV1dKSB7XG4gICAgICAgICAgZGV2aWNlc1tmaWVsZFsxXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkZXZpY2VzW2ZpZWxkWzFdXVtmaWVsZFsyXV0gPSBmaWVsZFszXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH0sIHt9KTtcbiAgICBmb3IgKGxldCBkZXZpY2VJZCBpbiBkZXZpY2VzKSB7XG4gICAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzW2RldmljZUlkXTtcbiAgICAgIGlmIChkZXZpY2VbJ0NMX0RFVklDRV9UWVBFJ10gPT09ICdDTF9ERVZJQ0VfVFlQRV9HUFUnKSB7XG4gICAgICAgIGxldCBidXNBZGRyZXNzO1xuICAgICAgICBpZiAoZGV2aWNlWydDTF9ERVZJQ0VfVE9QT0xPR1lfQU1EJ10pIHtcbiAgICAgICAgICBjb25zdCBiZGYgPSBkZXZpY2VbJ0NMX0RFVklDRV9UT1BPTE9HWV9BTUQnXS5tYXRjaCgvW2EtekEtWjAtOV0rOlxcZCtcXC5cXGQrLyk7XG4gICAgICAgICAgaWYgKGJkZikge1xuICAgICAgICAgICAgYnVzQWRkcmVzcyA9IGJkZlswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGV2aWNlWydDTF9ERVZJQ0VfUENJX0JVU19JRF9OViddICYmIGRldmljZVsnQ0xfREVWSUNFX1BDSV9TTE9UX0lEX05WJ10pIHtcbiAgICAgICAgICBjb25zdCBidXMgPSBwYXJzZUludChkZXZpY2VbJ0NMX0RFVklDRV9QQ0lfQlVTX0lEX05WJ10pO1xuICAgICAgICAgIGNvbnN0IHNsb3QgPSBwYXJzZUludChkZXZpY2VbJ0NMX0RFVklDRV9QQ0lfU0xPVF9JRF9OViddKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGJ1cykgJiYgIWlzTmFOKHNsb3QpKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gYnVzICYgMHhmZjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoc2xvdCA+PiAzKSAmIDB4ZmY7XG4gICAgICAgICAgICBjb25zdCBmID0gc2xvdCAmIDB4MDc7XG4gICAgICAgICAgICBidXNBZGRyZXNzID0gYCR7Yi50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7ZC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LiR7Zn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVzQWRkcmVzcykge1xuICAgICAgICAgIGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnMuZmluZChjb250cm9sbGVyID0+IGNvbnRyb2xsZXIuYnVzQWRkcmVzcyA9PT0gYnVzQWRkcmVzcyk7XG4gICAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0ge1xuICAgICAgICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICAgICAgICBtb2RlbDogJycsXG4gICAgICAgICAgICAgIGJ1czogJycsXG4gICAgICAgICAgICAgIGJ1c0FkZHJlc3MsXG4gICAgICAgICAgICAgIHZyYW06IG51bGwsXG4gICAgICAgICAgICAgIHZyYW1EeW5hbWljOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIudmVuZG9yID0gZGV2aWNlWydDTF9ERVZJQ0VfVkVORE9SJ107XG4gICAgICAgICAgaWYgKGRldmljZVsnQ0xfREVWSUNFX0JPQVJEX05BTUVfQU1EJ10pIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIubW9kZWwgPSBkZXZpY2VbJ0NMX0RFVklDRV9CT0FSRF9OQU1FX0FNRCddO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLm1vZGVsID0gZGV2aWNlWydDTF9ERVZJQ0VfTkFNRSddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtZW1vcnkgPSBwYXJzZUludChkZXZpY2VbJ0NMX0RFVklDRV9HTE9CQUxfTUVNX1NJWkUnXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihtZW1vcnkpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnZyYW0gPSBNYXRoLnJvdW5kKG1lbW9yeSAvIDEwMjQgLyAxMDI0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TnZpZGlhU21pKCkge1xuICAgIGlmIChfbnZpZGlhU21pUGF0aCkge1xuICAgICAgcmV0dXJuIF9udmlkaWFTbWlQYXRoO1xuICAgIH1cblxuICAgIGlmIChfd2luZG93cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmFzZVBhdGggPSB1dGlsLldJTkRJUiArICdcXFxcU3lzdGVtMzJcXFxcRHJpdmVyU3RvcmVcXFxcRmlsZVJlcG9zaXRvcnknO1xuICAgICAgICAvLyBmaW5kIGFsbCBkaXJlY3RvcmllcyB0aGF0IGhhdmUgYW4gbnZpZGlhLXNtaS5leGUgZmlsZVxuICAgICAgICBjb25zdCBjYW5kaWRhdGVEaXJzID0gZnMucmVhZGRpclN5bmMoYmFzZVBhdGgpLmZpbHRlcihkaXIgPT4ge1xuICAgICAgICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhbYmFzZVBhdGgsIGRpcl0uam9pbignLycpKS5pbmNsdWRlcygnbnZpZGlhLXNtaS5leGUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVzZSB0aGUgZGlyZWN0b3J5IHdpdGggdGhlIG1vc3QgcmVjZW50bHkgY3JlYXRlZCBudmlkaWEtc21pLmV4ZSBmaWxlXG4gICAgICAgIGNvbnN0IHRhcmdldERpciA9IGNhbmRpZGF0ZURpcnMucmVkdWNlKChwcmV2RGlyLCBjdXJyZW50RGlyKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNOdmlkaWFTbWkgPSBmcy5zdGF0U3luYyhbYmFzZVBhdGgsIHByZXZEaXIsICdudmlkaWEtc21pLmV4ZSddLmpvaW4oJy8nKSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudE52aWRpYVNtaSA9IGZzLnN0YXRTeW5jKFtiYXNlUGF0aCwgY3VycmVudERpciwgJ252aWRpYS1zbWkuZXhlJ10uam9pbignLycpKTtcbiAgICAgICAgICByZXR1cm4gKHByZXZpb3VzTnZpZGlhU21pLmN0aW1lTXMgPiBjdXJyZW50TnZpZGlhU21pLmN0aW1lTXMpID8gcHJldkRpciA6IGN1cnJlbnREaXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0YXJnZXREaXIpIHtcbiAgICAgICAgICBfbnZpZGlhU21pUGF0aCA9IFtiYXNlUGF0aCwgdGFyZ2V0RGlyLCAnbnZpZGlhLXNtaS5leGUnXS5qb2luKCcvJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfbGludXgpIHtcbiAgICAgIF9udmlkaWFTbWlQYXRoID0gJ252aWRpYS1zbWknO1xuICAgIH1cbiAgICByZXR1cm4gX252aWRpYVNtaVBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiBudmlkaWFTbWkob3B0aW9ucykge1xuICAgIGNvbnN0IG52aWRpYVNtaUV4ZSA9IGdldE52aWRpYVNtaSgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuZXhlY09wdHNXaW47XG4gICAgaWYgKG52aWRpYVNtaUV4ZSkge1xuICAgICAgY29uc3QgbnZpZGlhU21pT3B0cyA9ICctLXF1ZXJ5LWdwdT1kcml2ZXJfdmVyc2lvbixwY2kuc3ViX2RldmljZV9pZCxuYW1lLHBjaS5idXNfaWQsZmFuLnNwZWVkLG1lbW9yeS50b3RhbCxtZW1vcnkudXNlZCxtZW1vcnkuZnJlZSx1dGlsaXphdGlvbi5ncHUsdXRpbGl6YXRpb24ubWVtb3J5LHRlbXBlcmF0dXJlLmdwdSx0ZW1wZXJhdHVyZS5tZW1vcnkscG93ZXIuZHJhdyxwb3dlci5saW1pdCxjbG9ja3MuZ3IsY2xvY2tzLm1lbSAtLWZvcm1hdD1jc3Ysbm9oZWFkZXIsbm91bml0cyc7XG4gICAgICBjb25zdCBjbWQgPSBudmlkaWFTbWlFeGUgKyAnICcgKyBudmlkaWFTbWlPcHRzICsgKF9saW51eCA/ICcgIDI+L2Rldi9udWxsJyA6ICcnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGV4ZWNTeW5jKGNtZCwgb3B0aW9ucykudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG52aWRpYURldmljZXMoKSB7XG5cbiAgICBmdW5jdGlvbiBzYWZlUGFyc2VOdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmIChbbnVsbCwgdW5kZWZpbmVkXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZG91dCA9IG52aWRpYVNtaSgpO1xuICAgIGlmICghc3Rkb3V0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZ3B1cyA9IHN0ZG91dC5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGxldCByZXN1bHRzID0gZ3B1cy5tYXAoZ3B1ID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0dGVkRGF0YSA9IGdwdS5zcGxpdCgnLCAnKS5tYXAodmFsdWUgPT4gdmFsdWUuaW5jbHVkZXMoJ04vQScpID8gdW5kZWZpbmVkIDogdmFsdWUpO1xuICAgICAgaWYgKHNwbGl0dGVkRGF0YS5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJpdmVyVmVyc2lvbjogc3BsaXR0ZWREYXRhWzBdLFxuICAgICAgICAgIHN1YkRldmljZUlkOiBzcGxpdHRlZERhdGFbMV0sXG4gICAgICAgICAgbmFtZTogc3BsaXR0ZWREYXRhWzJdLFxuICAgICAgICAgIHBjaUJ1czogc3BsaXR0ZWREYXRhWzNdLFxuICAgICAgICAgIGZhblNwZWVkOiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzRdKSxcbiAgICAgICAgICBtZW1vcnlUb3RhbDogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs1XSksXG4gICAgICAgICAgbWVtb3J5VXNlZDogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs2XSksXG4gICAgICAgICAgbWVtb3J5RnJlZTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs3XSksXG4gICAgICAgICAgdXRpbGl6YXRpb25HcHU6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbOF0pLFxuICAgICAgICAgIHV0aWxpemF0aW9uTWVtb3J5OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzldKSxcbiAgICAgICAgICB0ZW1wZXJhdHVyZUdwdTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxMF0pLFxuICAgICAgICAgIHRlbXBlcmF0dXJlTWVtb3J5OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzExXSksXG4gICAgICAgICAgcG93ZXJEcmF3OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzEyXSksXG4gICAgICAgICAgcG93ZXJMaW1pdDogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxM10pLFxuICAgICAgICAgIGNsb2NrQ29yZTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxNF0pLFxuICAgICAgICAgIGNsb2NrTWVtb3J5OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzE1XSksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICByZXR1cm4gKCdwY2lCdXMnIGluIGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDb250cm9sbGVyTnZpZGlhKGNvbnRyb2xsZXIsIG52aWRpYSkge1xuICAgIGlmIChudmlkaWEuZHJpdmVyVmVyc2lvbikgeyBjb250cm9sbGVyLmRyaXZlclZlcnNpb24gPSBudmlkaWEuZHJpdmVyVmVyc2lvbjsgfVxuICAgIGlmIChudmlkaWEuc3ViRGV2aWNlSWQpIHsgY29udHJvbGxlci5zdWJEZXZpY2VJZCA9IG52aWRpYS5zdWJEZXZpY2VJZDsgfVxuICAgIGlmIChudmlkaWEubmFtZSkgeyBjb250cm9sbGVyLm5hbWUgPSBudmlkaWEubmFtZTsgfVxuICAgIGlmIChudmlkaWEucGNpQnVzKSB7IGNvbnRyb2xsZXIucGNpQnVzID0gbnZpZGlhLnBjaUJ1czsgfVxuICAgIGlmIChudmlkaWEuZmFuU3BlZWQpIHsgY29udHJvbGxlci5mYW5TcGVlZCA9IG52aWRpYS5mYW5TcGVlZDsgfVxuICAgIGlmIChudmlkaWEubWVtb3J5VG90YWwpIHtcbiAgICAgIGNvbnRyb2xsZXIubWVtb3J5VG90YWwgPSBudmlkaWEubWVtb3J5VG90YWw7XG4gICAgICBjb250cm9sbGVyLnZyYW0gPSBudmlkaWEubWVtb3J5VG90YWw7XG4gICAgICBjb250cm9sbGVyLnZyYW1EeW5hbWljID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChudmlkaWEubWVtb3J5VXNlZCkgeyBjb250cm9sbGVyLm1lbW9yeVVzZWQgPSBudmlkaWEubWVtb3J5VXNlZDsgfVxuICAgIGlmIChudmlkaWEubWVtb3J5RnJlZSkgeyBjb250cm9sbGVyLm1lbW9yeUZyZWUgPSBudmlkaWEubWVtb3J5RnJlZTsgfVxuICAgIGlmIChudmlkaWEudXRpbGl6YXRpb25HcHUpIHsgY29udHJvbGxlci51dGlsaXphdGlvbkdwdSA9IG52aWRpYS51dGlsaXphdGlvbkdwdTsgfVxuICAgIGlmIChudmlkaWEudXRpbGl6YXRpb25NZW1vcnkpIHsgY29udHJvbGxlci51dGlsaXphdGlvbk1lbW9yeSA9IG52aWRpYS51dGlsaXphdGlvbk1lbW9yeTsgfVxuICAgIGlmIChudmlkaWEudGVtcGVyYXR1cmVHcHUpIHsgY29udHJvbGxlci50ZW1wZXJhdHVyZUdwdSA9IG52aWRpYS50ZW1wZXJhdHVyZUdwdTsgfVxuICAgIGlmIChudmlkaWEudGVtcGVyYXR1cmVNZW1vcnkpIHsgY29udHJvbGxlci50ZW1wZXJhdHVyZU1lbW9yeSA9IG52aWRpYS50ZW1wZXJhdHVyZU1lbW9yeTsgfVxuICAgIGlmIChudmlkaWEucG93ZXJEcmF3KSB7IGNvbnRyb2xsZXIucG93ZXJEcmF3ID0gbnZpZGlhLnBvd2VyRHJhdzsgfVxuICAgIGlmIChudmlkaWEucG93ZXJMaW1pdCkgeyBjb250cm9sbGVyLnBvd2VyTGltaXQgPSBudmlkaWEucG93ZXJMaW1pdDsgfVxuICAgIGlmIChudmlkaWEuY2xvY2tDb3JlKSB7IGNvbnRyb2xsZXIuY2xvY2tDb3JlID0gbnZpZGlhLmNsb2NrQ29yZTsgfVxuICAgIGlmIChudmlkaWEuY2xvY2tNZW1vcnkpIHsgY29udHJvbGxlci5jbG9ja01lbW9yeSA9IG52aWRpYS5jbG9ja01lbW9yeTsgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc0xpbnV4RWRpZChlZGlkKSB7XG4gICAgLy8gcGFyc2VuIEVESURcbiAgICAvLyAtLT4gbW9kZWxcbiAgICAvLyAtLT4gcmVzb2x1dGlvbnhcbiAgICAvLyAtLT4gcmVzb2x1dGlvbnlcbiAgICAvLyAtLT4gYnVpbHRpbiA9IGZhbHNlXG4gICAgLy8gLS0+IHBpeGVsZGVwdGggKD8pXG4gICAgLy8gLS0+IHNpemV4XG4gICAgLy8gLS0+IHNpemV5XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIHZlbmRvcjogJycsXG4gICAgICBtb2RlbDogJycsXG4gICAgICBkZXZpY2VOYW1lOiAnJyxcbiAgICAgIG1haW46IGZhbHNlLFxuICAgICAgYnVpbHRpbjogZmFsc2UsXG4gICAgICBjb25uZWN0aW9uOiAnJyxcbiAgICAgIHNpemVYOiBudWxsLFxuICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICBwaXhlbERlcHRoOiBudWxsLFxuICAgICAgcmVzb2x1dGlvblg6IG51bGwsXG4gICAgICByZXNvbHV0aW9uWTogbnVsbCxcbiAgICAgIGN1cnJlbnRSZXNYOiBudWxsLFxuICAgICAgY3VycmVudFJlc1k6IG51bGwsXG4gICAgICBwb3NpdGlvblg6IDAsXG4gICAgICBwb3NpdGlvblk6IDAsXG4gICAgICBjdXJyZW50UmVmcmVzaFJhdGU6IG51bGxcbiAgICB9O1xuICAgIC8vIGZpbmQgZmlyc3QgXCJEZXRhaWxlZCBUaW1pbmcgRGVzY3JpcHRpb25cIlxuICAgIGxldCBzdGFydCA9IDEwODtcbiAgICBpZiAoZWRpZC5zdWJzdHIoc3RhcnQsIDYpID09PSAnMDAwMDAwJykge1xuICAgICAgc3RhcnQgKz0gMzY7XG4gICAgfVxuICAgIGlmIChlZGlkLnN1YnN0cihzdGFydCwgNikgPT09ICcwMDAwMDAnKSB7XG4gICAgICBzdGFydCArPSAzNjtcbiAgICB9XG4gICAgaWYgKGVkaWQuc3Vic3RyKHN0YXJ0LCA2KSA9PT0gJzAwMDAwMCcpIHtcbiAgICAgIHN0YXJ0ICs9IDM2O1xuICAgIH1cbiAgICBpZiAoZWRpZC5zdWJzdHIoc3RhcnQsIDYpID09PSAnMDAwMDAwJykge1xuICAgICAgc3RhcnQgKz0gMzY7XG4gICAgfVxuICAgIHJlc3VsdC5yZXNvbHV0aW9uWCA9IHBhcnNlSW50KCcweDAnICsgZWRpZC5zdWJzdHIoc3RhcnQgKyA4LCAxKSArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgNCwgMikpO1xuICAgIHJlc3VsdC5yZXNvbHV0aW9uWSA9IHBhcnNlSW50KCcweDAnICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAxNCwgMSkgKyBlZGlkLnN1YnN0cihzdGFydCArIDEwLCAyKSk7XG4gICAgcmVzdWx0LnNpemVYID0gcGFyc2VJbnQoJzB4MCcgKyBlZGlkLnN1YnN0cihzdGFydCArIDI4LCAxKSArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMjQsIDIpKTtcbiAgICByZXN1bHQuc2l6ZVkgPSBwYXJzZUludCgnMHgwJyArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMjksIDEpICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAyNiwgMikpO1xuICAgIC8vIG1vbml0b3IgbmFtZVxuICAgIHN0YXJ0ID0gZWRpZC5pbmRleE9mKCcwMDAwMDBmYzAwJyk7IC8vIGZpbmQgZmlyc3QgXCJNb25pdG9yIERlc2NyaXB0aW9uIERhdGFcIlxuICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICBsZXQgbW9kZWxfcmF3ID0gZWRpZC5zdWJzdHIoc3RhcnQgKyAxMCwgMjYpO1xuICAgICAgaWYgKG1vZGVsX3Jhdy5pbmRleE9mKCcwYScpICE9PSAtMSkge1xuICAgICAgICBtb2RlbF9yYXcgPSBtb2RlbF9yYXcuc3Vic3RyKDAsIG1vZGVsX3Jhdy5pbmRleE9mKCcwYScpKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChtb2RlbF9yYXcubGVuZ3RoID4gMikge1xuICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IG1vZGVsX3Jhdy5tYXRjaCgvLnsxLDJ9L2cpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodiwgMTYpKTtcbiAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0Lm1vZGVsID0gJyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzTGludXhEaXNwbGF5cyhsaW5lcywgZGVwdGgpIHtcbiAgICBsZXQgZGlzcGxheXMgPSBbXTtcbiAgICBsZXQgY3VycmVudERpc3BsYXkgPSB7XG4gICAgICB2ZW5kb3I6ICcnLFxuICAgICAgbW9kZWw6ICcnLFxuICAgICAgZGV2aWNlTmFtZTogJycsXG4gICAgICBtYWluOiBmYWxzZSxcbiAgICAgIGJ1aWx0aW46IGZhbHNlLFxuICAgICAgY29ubmVjdGlvbjogJycsXG4gICAgICBzaXplWDogbnVsbCxcbiAgICAgIHNpemVZOiBudWxsLFxuICAgICAgcGl4ZWxEZXB0aDogbnVsbCxcbiAgICAgIHJlc29sdXRpb25YOiBudWxsLFxuICAgICAgcmVzb2x1dGlvblk6IG51bGwsXG4gICAgICBjdXJyZW50UmVzWDogbnVsbCxcbiAgICAgIGN1cnJlbnRSZXNZOiBudWxsLFxuICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgY3VycmVudFJlZnJlc2hSYXRlOiBudWxsXG4gICAgfTtcbiAgICBsZXQgaXNfZWRpZCA9IGZhbHNlO1xuICAgIGxldCBpc19jdXJyZW50ID0gZmFsc2U7XG4gICAgbGV0IGVkaWRfcmF3ID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7ICAgICAgICAvLyBzdGFydCB3aXRoIHNlY29uZCBsaW5lXG4gICAgICBpZiAoJycgIT09IGxpbmVzW2ldLnRyaW0oKSkge1xuICAgICAgICBpZiAoJyAnICE9PSBsaW5lc1tpXVswXSAmJiAnXFx0JyAhPT0gbGluZXNbaV1bMF0gJiYgbGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgY29ubmVjdGVkICcpICE9PSAtMSkgeyAgICAgICAgLy8gZmlyc3QgbGluZSBvZiBuZXcgZW50cnlcbiAgICAgICAgICBpZiAoY3VycmVudERpc3BsYXkubW9kZWwgfHwgY3VycmVudERpc3BsYXkubWFpbiB8fCBjdXJyZW50RGlzcGxheS5idWlsdGluIHx8IGN1cnJlbnREaXNwbGF5LmNvbm5lY3Rpb24gfHwgY3VycmVudERpc3BsYXkuc2l6ZVggIT09IG51bGwgfHwgY3VycmVudERpc3BsYXkucGl4ZWxEZXB0aCAhPT0gbnVsbCB8fCBjdXJyZW50RGlzcGxheS5yZXNvbHV0aW9uWCAhPT0gbnVsbCkgeyAgICAgICAgIC8vIHB1c2ggbGFzdCBkaXNwbGF5IHRvIGFycmF5XG4gICAgICAgICAgICBkaXNwbGF5cy5wdXNoKGN1cnJlbnREaXNwbGF5KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5ID0ge1xuICAgICAgICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICAgICAgICBtb2RlbDogJycsXG4gICAgICAgICAgICAgIG1haW46IGZhbHNlLFxuICAgICAgICAgICAgICBidWlsdGluOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29ubmVjdGlvbjogJycsXG4gICAgICAgICAgICAgIHNpemVYOiBudWxsLFxuICAgICAgICAgICAgICBzaXplWTogbnVsbCxcbiAgICAgICAgICAgICAgcGl4ZWxEZXB0aDogbnVsbCxcbiAgICAgICAgICAgICAgcmVzb2x1dGlvblg6IG51bGwsXG4gICAgICAgICAgICAgIHJlc29sdXRpb25ZOiBudWxsLFxuICAgICAgICAgICAgICBjdXJyZW50UmVzWDogbnVsbCxcbiAgICAgICAgICAgICAgY3VycmVudFJlc1k6IG51bGwsXG4gICAgICAgICAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgICAgICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgICAgICAgICBjdXJyZW50UmVmcmVzaFJhdGU6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG4gICAgICAgICAgY3VycmVudERpc3BsYXkuY29ubmVjdGlvbiA9IHBhcnRzWzBdO1xuICAgICAgICAgIGN1cnJlbnREaXNwbGF5Lm1haW4gPSBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBwcmltYXJ5ICcpID49IDA7XG4gICAgICAgICAgY3VycmVudERpc3BsYXkuYnVpbHRpbiA9IChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2VkcCcpID49IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHJlYWQgRURJRCBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoaXNfZWRpZCkge1xuICAgICAgICAgIGlmIChsaW5lc1tpXS5zZWFyY2goL1xcU3wkLykgPiBzdGFydCkge1xuICAgICAgICAgICAgZWRpZF9yYXcgKz0gbGluZXNbaV0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnNlbiBFRElEXG4gICAgICAgICAgICBsZXQgZWRpZF9kZWNvZGVkID0gcGFyc2VMaW5lc0xpbnV4RWRpZChlZGlkX3Jhdyk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS52ZW5kb3IgPSBlZGlkX2RlY29kZWQudmVuZG9yO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkubW9kZWwgPSBlZGlkX2RlY29kZWQubW9kZWw7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5yZXNvbHV0aW9uWCA9IGVkaWRfZGVjb2RlZC5yZXNvbHV0aW9uWDtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnJlc29sdXRpb25ZID0gZWRpZF9kZWNvZGVkLnJlc29sdXRpb25ZO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkuc2l6ZVggPSBlZGlkX2RlY29kZWQuc2l6ZVg7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5zaXplWSA9IGVkaWRfZGVjb2RlZC5zaXplWTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnBpeGVsRGVwdGggPSBkZXB0aDtcbiAgICAgICAgICAgIGlzX2VkaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZWRpZDonKSA+PSAwKSB7XG4gICAgICAgICAgaXNfZWRpZCA9IHRydWU7XG4gICAgICAgICAgc3RhcnQgPSBsaW5lc1tpXS5zZWFyY2goL1xcU3wkLyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignKmN1cnJlbnQnKSA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgcGFydHMxID0gbGluZXNbaV0uc3BsaXQoJygnKTtcbiAgICAgICAgICBpZiAocGFydHMxICYmIHBhcnRzMS5sZW5ndGggPiAxICYmIHBhcnRzMVswXS5pbmRleE9mKCd4JykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzUGFydHMgPSBwYXJ0czFbMF0udHJpbSgpLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5jdXJyZW50UmVzWCA9IHV0aWwudG9JbnQocmVzUGFydHNbMF0pO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkuY3VycmVudFJlc1kgPSB1dGlsLnRvSW50KHJlc1BhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNfY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2N1cnJlbnQgJiYgbGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjbG9jaycpID49IDAgJiYgbGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoeicpID49IDAgJiYgbGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2OiBoZWlnaHQnKSA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgcGFydHMxID0gbGluZXNbaV0uc3BsaXQoJ2Nsb2NrJyk7XG4gICAgICAgICAgaWYgKHBhcnRzMSAmJiBwYXJ0czEubGVuZ3RoID4gMSAmJiBwYXJ0czFbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoeicpID49IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LmN1cnJlbnRSZWZyZXNoUmF0ZSA9IHV0aWwudG9JbnQocGFydHMxWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNfY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVzaGVuIGRpc3BsYXlzXG4gICAgaWYgKGN1cnJlbnREaXNwbGF5Lm1vZGVsIHx8IGN1cnJlbnREaXNwbGF5Lm1haW4gfHwgY3VycmVudERpc3BsYXkuYnVpbHRpbiB8fCBjdXJyZW50RGlzcGxheS5jb25uZWN0aW9uIHx8IGN1cnJlbnREaXNwbGF5LnNpemVYICE9PSBudWxsIHx8IGN1cnJlbnREaXNwbGF5LnBpeGVsRGVwdGggIT09IG51bGwgfHwgY3VycmVudERpc3BsYXkucmVzb2x1dGlvblggIT09IG51bGwpIHsgIC8vIHN0aWxsIGluZm9ybWF0aW9uIHRoZXJlXG4gICAgICBkaXNwbGF5cy5wdXNoKGN1cnJlbnREaXNwbGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BsYXlzO1xuICB9XG5cbiAgLy8gZnVuY3Rpb24gc3RhcnRzIGhlcmVcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBjb250cm9sbGVyczogW10sXG4gICAgICAgIGRpc3BsYXlzOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIC14bWwgLWRldGFpbExldmVsIGZ1bGwgU1BEaXNwbGF5c0RhdGFUeXBlJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlTGluZXNEYXJ3aW4odXRpbC5wbGlzdFBhcnNlcihvdXRwdXQpWzBdLl9pdGVtcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Rkb3V0ID0gZXhlY1N5bmMoJ2RlZmF1bHRzIHJlYWQgL0xpYnJhcnkvUHJlZmVyZW5jZXMvY29tLmFwcGxlLndpbmRvd3NlcnZlci5wbGlzdCAyPi9kZXYvbnVsbDtkZWZhdWx0cyByZWFkIC9MaWJyYXJ5L1ByZWZlcmVuY2VzL2NvbS5hcHBsZS53aW5kb3dzZXJ2ZXIuZGlzcGxheXMucGxpc3QgMj4vZGV2L251bGw7IGVjaG8gXCJcIicpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gKHN0ZG91dCB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHV0aWwucGxpc3RSZWFkZXIob3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bJ0NvbmZpZ3MnXSAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWydDb25maWdzJ11bMF0gJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVsnQ29uZmlncyddWzBdWydEaXNwbGF5Q29uZmlnJ10pIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bJ0NvbmZpZ3MnXVswXVsnRGlzcGxheUNvbmZpZyddO1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGN1cnJlbnQuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvWydDdXJyZW50SW5mbyddICYmICdPcmlnaW5YJyBpbiBvWydDdXJyZW50SW5mbyddICYmIHJlc3VsdC5kaXNwbGF5cyAmJiByZXN1bHQuZGlzcGxheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1tpXS5wb3NpdGlvblggPSBvWydDdXJyZW50SW5mbyddWydPcmlnaW5YJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvWydDdXJyZW50SW5mbyddICYmICdPcmlnaW5ZJyBpbiBvWydDdXJyZW50SW5mbyddICYmIHJlc3VsdC5kaXNwbGF5cyAmJiByZXN1bHQuZGlzcGxheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1tpXS5wb3NpdGlvblkgPSBvWydDdXJyZW50SW5mbyddWydPcmlnaW5ZJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqWydEaXNwbGF5QW55VXNlclNldHMnXSAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddLmxlbmd0aCA+IDAgJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVswXS5sZW5ndGggPiAwICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bMF1bMF1bJ0Rpc3BsYXlJRCddKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWzBdO1xuICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgIGN1cnJlbnQuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgnT3JpZ2luWCcgaW4gbyAmJiByZXN1bHQuZGlzcGxheXMgJiYgcmVzdWx0LmRpc3BsYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbaV0ucG9zaXRpb25YID0gb1snT3JpZ2luWCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ09yaWdpblknIGluIG8gJiYgcmVzdWx0LmRpc3BsYXlzICYmIHJlc3VsdC5kaXNwbGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzW2ldLnBvc2l0aW9uWSA9IG9bJ09yaWdpblknXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9bJ01vZGUnXSAmJiAnQml0c1BlclBpeGVsJyBpbiBvWydNb2RlJ10gJiYgcmVzdWx0LmRpc3BsYXlzICYmIHJlc3VsdC5kaXNwbGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzW2ldLnBpeGVsRGVwdGggPSBvWydNb2RlJ11bJ0JpdHNQZXJQaXhlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgLy8gUmFzcGJlcnJ5OiBodHRwczovL2VsaW51eC5vcmcvUlBJX3ZjZ2VuY21kX3VzYWdlXG4gICAgICAgIGlmICh1dGlsLmlzUmFzcGJlcnJ5KCkgJiYgdXRpbC5pc1Jhc3BiaWFuKCkpIHtcbiAgICAgICAgICBsZXQgY21kID0gJ2Zic2V0IC1zIHwgZ3JlcCBcXCdtb2RlIFwiXFwnOyB2Y2dlbmNtZCBnZXRfbWVtIGdwdTsgdHZzZXJ2aWNlIC1zOyB0dnNlcnZpY2UgLW47JztcbiAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAzICYmIGxpbmVzWzBdLmluZGV4T2YoJ21vZGUgXCInKSA+PSAtMSAmJiBsaW5lc1syXS5pbmRleE9mKCcweDEyMDAwYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5yZXBsYWNlKCdtb2RlJywgJycpLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCkuc3BsaXQoJ3gnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgICAgICAgICAgICBtb2RlbDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2RldmljZV9uYW1lJywgJz0nKSxcbiAgICAgICAgICAgICAgICAgIG1haW46IHRydWUsXG4gICAgICAgICAgICAgICAgICBidWlsdGluOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246ICdIRE1JJyxcbiAgICAgICAgICAgICAgICAgIHNpemVYOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICAgICAgICAgICAgICBwaXhlbERlcHRoOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvblg6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgICAgICAgICAgICByZXNvbHV0aW9uWTogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNYOiBudWxsLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFJlc1k6IG51bGwsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvblg6IDAsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvblk6IDAsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UmVmcmVzaFJhdGU6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEgJiYgc3Rkb3V0LnRvU3RyaW5nKCkuaW5kZXhPZignZ3B1PScpID49IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2ZW5kb3I6ICdCcm9hZGNvbScsXG4gICAgICAgICAgICAgICAgbW9kZWw6ICdWaWRlb0NvcmUgSVYnLFxuICAgICAgICAgICAgICAgIGJ1czogJycsXG4gICAgICAgICAgICAgICAgdnJhbTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2dwdScsICc9JykucmVwbGFjZSgnTScsICcnKSxcbiAgICAgICAgICAgICAgICB2cmFtRHluYW1pYzogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjbWQgPSAnbHNwY2kgLXZ2diAgMj4vZGV2L251bGwnO1xuICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycyA9IHBhcnNlTGluZXNMaW51eENvbnRyb2xsZXJzKGxpbmVzKTtcbiAgICAgICAgICAgICAgY29uc3QgbnZpZGlhRGF0YSA9IG52aWRpYURldmljZXMoKTtcbiAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYmUgcmV3cml0dGVuIC4uLiB1c2luZyBubyBzcHJlYWQgb3BlcmF0b3JzXG4gICAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycyA9IHJlc3VsdC5jb250cm9sbGVycy5tYXAoKGNvbnRyb2xsZXIpID0+IHsgLy8gbWF0Y2ggYnkgYnVzQWRkcmVzc1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUNvbnRyb2xsZXJOdmlkaWEoY29udHJvbGxlciwgbnZpZGlhRGF0YS5maW5kKChjb250cikgPT4gY29udHIucGNpQnVzLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoY29udHJvbGxlci5idXNBZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB8fCB7fSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNtZCA9ICdjbGluZm8gLS1yYXcnO1xuICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzID0gcGFyc2VMaW5lc0xpbnV4Q2xpbmZvKHJlc3VsdC5jb250cm9sbGVycywgbGluZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBjbWQgPSAneGRweWluZm8gMj4vZGV2L251bGwgfCBncmVwIFxcJ2RlcHRoIG9mIHJvb3Qgd2luZG93XFwnIHwgYXdrIFxcJ3sgcHJpbnQgJDUgfVxcJyc7XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgZGVwdGggPSBwYXJzZUludChsaW5lc1swXSkgfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNtZCA9ICd4cmFuZHIgLS12ZXJib3NlIDI+L2Rldi9udWxsJztcbiAgICAgICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXMgPSBwYXJzZUxpbmVzTGludXhEaXNwbGF5cyhsaW5lcywgZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZ3MudGVjaG5ldC5taWNyb3NvZnQuY29tL2hleXNjcmlwdGluZ2d1eS8yMDEzLzEwLzAzL3VzZS1wb3dlcnNoZWxsLXRvLWRpc2NvdmVyLW11bHRpLW1vbml0b3ItaW5mb3JtYXRpb24vXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2YmxvZ3MubWljcm9zb2Z0LmNvbS9zY3JpcHRpbmcvdXNlLXBvd2Vyc2hlbGwtdG8tZGlzY292ZXItbXVsdGktbW9uaXRvci1pbmZvcm1hdGlvbi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2Ugd2luMzJfVmlkZW9Db250cm9sbGVyIHwgZmwgKicpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnZ3AgXCJIS0xNOlxcXFxTWVNURU1cXFxcQ29udHJvbFNldDAwMVxcXFxDb250cm9sXFxcXENsYXNzXFxcXHs0ZDM2ZTk2OC1lMzI1LTExY2UtYmZjMS0wODAwMmJlMTAzMTh9XFxcXCpcIiAtRXJyb3JBY3Rpb24gU2lsZW50bHlDb250aW51ZSB8IHdoZXJlIE1hdGNoaW5nRGV2aWNlSWQgJG51bGwgLU5FIHwgc2VsZWN0IE1hdGNoaW5nRGV2aWNlSWQsSGFyZHdhcmVJbmZvcm1hdGlvbi5xd01lbW9yeVNpemUgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIHdpbjMyX2Rlc2t0b3Btb25pdG9yIHwgZmwgKicpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIC1OYW1lc3BhY2Ugcm9vdFxcXFx3bWkgLUNsYXNzTmFtZSBXbWlNb25pdG9yQmFzaWNEaXNwbGF5UGFyYW1zIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0FkZC1UeXBlIC1Bc3NlbWJseU5hbWUgU3lzdGVtLldpbmRvd3MuRm9ybXM7IFtTeXN0ZW0uV2luZG93cy5Gb3Jtcy5TY3JlZW5dOjpBbGxTY3JlZW5zJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgLU5hbWVzcGFjZSByb290XFxcXHdtaSAtQ2xhc3NOYW1lIFdtaU1vbml0b3JDb25uZWN0aW9uUGFyYW1zIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ2d3bWkgV21pTW9uaXRvcklEIC1OYW1lc3BhY2Ugcm9vdFxcXFx3bWkgfCBGb3JFYWNoLU9iamVjdCB7KCgkXy5NYW51ZmFjdHVyZXJOYW1lIC1ub3RtYXRjaCAwIHwgZm9yZWFjaCB7W2NoYXJdJF99KSAtam9pbiBcIlwiKSArIFwifFwiICsgKCgkXy5Qcm9kdWN0Q29kZUlEIC1ub3RtYXRjaCAwIHwgZm9yZWFjaCB7W2NoYXJdJF99KSAtam9pbiBcIlwiKSArIFwifFwiICsgKCgkXy5Vc2VyRnJpZW5kbHlOYW1lIC1ub3RtYXRjaCAwIHwgZm9yZWFjaCB7W2NoYXJdJF99KSAtam9pbiBcIlwiKSArIFwifFwiICsgKCgkXy5TZXJpYWxOdW1iZXJJRCAtbm90bWF0Y2ggMCB8IGZvcmVhY2gge1tjaGFyXSRffSkgLWpvaW4gXCJcIikgKyBcInxcIiArICRfLkluc3RhbmNlTmFtZX0nKSk7XG5cbiAgICAgICAgICBjb25zdCBudmlkaWFEYXRhID0gbnZpZGlhRGV2aWNlcygpO1xuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gY29udHJvbGxlciArIHZyYW1cbiAgICAgICAgICAgIGxldCBjc2VjdGlvbnMgPSBkYXRhWzBdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGxldCB2c2VjdGlvbnMgPSBkYXRhWzFdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycyA9IHBhcnNlTGluZXNXaW5kb3dzQ29udHJvbGxlcnMoY3NlY3Rpb25zLCB2c2VjdGlvbnMpO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzID0gcmVzdWx0LmNvbnRyb2xsZXJzLm1hcCgoY29udHJvbGxlcikgPT4geyAvLyBtYXRjaCBieSBzdWJEZXZpY2VJZFxuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci52ZW5kb3IudG9Mb3dlckNhc2UoKSA9PT0gJ252aWRpYScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VDb250cm9sbGVyTnZpZGlhKGNvbnRyb2xsZXIsIG52aWRpYURhdGEuZmluZChkZXZpY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHdpbmRvd3NTdWJEZXZpY2VJZCA9IChjb250cm9sbGVyLnN1YkRldmljZUlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbnZpZGlhU3ViRGV2aWNlSWRQYXJ0cyA9IGRldmljZS5zdWJEZXZpY2VJZC5zcGxpdCgneCcpO1xuICAgICAgICAgICAgICAgICAgbGV0IG52aWRpYVN1YkRldmljZUlkID0gbnZpZGlhU3ViRGV2aWNlSWRQYXJ0cy5sZW5ndGggPiAxID8gbnZpZGlhU3ViRGV2aWNlSWRQYXJ0c1sxXS50b0xvd2VyQ2FzZSgpIDogbnZpZGlhU3ViRGV2aWNlSWRQYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoRGlmZmVyZW5jZSA9IE1hdGguYWJzKHdpbmRvd3NTdWJEZXZpY2VJZC5sZW5ndGggLSBudmlkaWFTdWJEZXZpY2VJZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd3NTdWJEZXZpY2VJZC5sZW5ndGggPiBudmlkaWFTdWJEZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhEaWZmZXJlbmNlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBudmlkaWFTdWJEZXZpY2VJZCA9ICcwJyArIG52aWRpYVN1YkRldmljZUlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvd3NTdWJEZXZpY2VJZC5sZW5ndGggPCBudmlkaWFTdWJEZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhEaWZmZXJlbmNlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dzU3ViRGV2aWNlSWQgPSAnMCcgKyB3aW5kb3dzU3ViRGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dzU3ViRGV2aWNlSWQgPT09IG52aWRpYVN1YkRldmljZUlkO1xuICAgICAgICAgICAgICAgIH0pIHx8IHt9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRpc3BsYXlzXG4gICAgICAgICAgICBsZXQgZHNlY3Rpb25zID0gZGF0YVsyXS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAvLyByZXN1bHQuZGlzcGxheXMgPSBwYXJzZUxpbmVzV2luZG93c0Rpc3BsYXlzKGRzZWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZHNlY3Rpb25zWzBdLnRyaW0oKSA9PT0gJycpIHsgZHNlY3Rpb25zLnNoaWZ0KCk7IH1cbiAgICAgICAgICAgIGlmIChkc2VjdGlvbnMubGVuZ3RoICYmIGRzZWN0aW9uc1tkc2VjdGlvbnMubGVuZ3RoIC0gMV0udHJpbSgpID09PSAnJykgeyBkc2VjdGlvbnMucG9wKCk7IH1cblxuICAgICAgICAgICAgLy8gbW9uaXRvciAocG93ZXJzaGVsbClcbiAgICAgICAgICAgIGxldCBtc2VjdGlvbnMgPSBkYXRhWzNdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoJ0FjdGl2ZSAnKTtcbiAgICAgICAgICAgIG1zZWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBmb3Jtcy5zY3JlZW5zIChwb3dlcnNoZWxsKVxuICAgICAgICAgICAgbGV0IHNzZWN0aW9ucyA9IGRhdGFbNF0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgnQml0c1BlclBpeGVsICcpO1xuICAgICAgICAgICAgc3NlY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gcGFyYW1zIChwb3dlcnNoZWxsKSAtIHZpZGVvIHR5cGVcbiAgICAgICAgICAgIGxldCB0c2VjdGlvbnMgPSBkYXRhWzVdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIHRzZWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBtb25pdG9yIElEIChwb3dlcnNoZWxsKSAtIG1vZGVsIC8gdmVuZG9yXG4gICAgICAgICAgICBjb25zdCByZXMgPSBkYXRhWzZdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoL1xcbi8pO1xuICAgICAgICAgICAgbGV0IGlzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgcmVzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZWxlbWVudC5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgICAgaXNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdmVuZG9yOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgbW9kZWw6IHBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsOiBwYXJ0c1szXSxcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6IHBhcnRzWzRdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQuZGlzcGxheXMgPSBwYXJzZUxpbmVzV2luZG93c0Rpc3BsYXlzUG93ZXJzaGVsbChzc2VjdGlvbnMsIG1zZWN0aW9ucywgZHNlY3Rpb25zLCB0c2VjdGlvbnMsIGlzZWN0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZGlzcGxheXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChfcmVzb2x1dGlvblgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbMF0ucmVzb2x1dGlvblggPSBfcmVzb2x1dGlvblg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZGlzcGxheXNbMF0uY3VycmVudFJlc1gpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1swXS5jdXJyZW50UmVzWCA9IF9yZXNvbHV0aW9uWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9yZXNvbHV0aW9uWSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1swXS5yZXNvbHV0aW9uWSA9IF9yZXNvbHV0aW9uWTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRpc3BsYXlzWzBdLmN1cnJlbnRSZXNZID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbMF0uY3VycmVudFJlc1kgPSBfcmVzb2x1dGlvblk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfcGl4ZWxEZXB0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1swXS5waXhlbERlcHRoID0gX3BpeGVsRGVwdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5cyA9IHJlc3VsdC5kaXNwbGF5cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIGlmIChfcmVmcmVzaFJhdGUgJiYgIWVsZW1lbnQuY3VycmVudFJlZnJlc2hSYXRlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jdXJyZW50UmVmcmVzaFJhdGUgPSBfcmVmcmVzaFJhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzV2luZG93c0NvbnRyb2xsZXJzKHNlY3Rpb25zLCB2ZWN0aW9ucykge1xuICAgIGNvbnN0IG1lbW9yeVNpemVzID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIHZlY3Rpb25zKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh2ZWN0aW9ucywgaSkpIHtcbiAgICAgICAgaWYgKHZlY3Rpb25zW2ldLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHZlY3Rpb25zW2ldLnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgY29uc3QgbWF0Y2hpbmdEZXZpY2VJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYXRjaGluZ0RldmljZUlkJykubWF0Y2goL1BDSVxcXFwoVkVOX1swLTlBLUZdezR9KSYoREVWX1swLTlBLUZdezR9KSg/OiYoU1VCU1lTX1swLTlBLUZdezh9KSk/KD86JihSRVZfWzAtOUEtRl17Mn0pKT8vaSk7XG4gICAgICAgICAgaWYgKG1hdGNoaW5nRGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YWRXb3JkbWVtb3J5U2l6ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdIYXJkd2FyZUluZm9ybWF0aW9uLnF3TWVtb3J5U2l6ZScpKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocXVhZFdvcmRtZW1vcnlTaXplKSkge1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlSWQgPSBtYXRjaGluZ0RldmljZUlkWzFdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBtYXRjaGluZ0RldmljZUlkWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGluZ0RldmljZUlkWzNdKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQgKz0gJyYnICsgbWF0Y2hpbmdEZXZpY2VJZFszXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaGluZ0RldmljZUlkWzRdKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQgKz0gJyYnICsgbWF0Y2hpbmdEZXZpY2VJZFs0XS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1lbW9yeVNpemVzW2RldmljZUlkXSA9IHF1YWRXb3JkbWVtb3J5U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29udHJvbGxlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpIGluIHNlY3Rpb25zKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChzZWN0aW9ucywgaSkpIHtcbiAgICAgICAgaWYgKHNlY3Rpb25zW2ldLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzZWN0aW9uc1tpXS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxldCBwbnBEZXZpY2VJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQTlBEZXZpY2VJRCcsICc6JykubWF0Y2goL1BDSVxcXFwoVkVOX1swLTlBLUZdezR9KSYoREVWX1swLTlBLUZdezR9KSg/OiYoU1VCU1lTX1swLTlBLUZdezh9KSk/KD86JihSRVZfWzAtOUEtRl17Mn0pKT8vaSk7XG4gICAgICAgICAgbGV0IHN1YkRldmljZUlkID0gbnVsbDtcbiAgICAgICAgICBsZXQgbWVtb3J5U2l6ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHBucERldmljZUlkKSB7XG4gICAgICAgICAgICBzdWJEZXZpY2VJZCA9IHBucERldmljZUlkWzNdIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHN1YkRldmljZUlkKSB7XG4gICAgICAgICAgICAgIHN1YkRldmljZUlkID0gc3ViRGV2aWNlSWQuc3BsaXQoJ18nKVsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggUENJIGRldmljZSBpZGVudGlmaWVyICh0aGVyZSdzIGFuIG9yZGVyIG9mIGluY3JlYXNpbmcgZ2VuZXJhbGl0eSk6XG4gICAgICAgICAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzLWhhcmR3YXJlL2RyaXZlcnMvaW5zdGFsbC9pZGVudGlmaWVycy1mb3ItcGNpLWRldmljZXNcblxuICAgICAgICAgICAgLy8gUENJXFxWRU5fdig0KSZERVZfZCg0KSZTVUJTWVNfcyg0KW4oNCkmUkVWX3IoMilcbiAgICAgICAgICAgIGlmIChtZW1vcnlTaXplID09IG51bGwgJiYgcG5wRGV2aWNlSWRbM10gJiYgcG5wRGV2aWNlSWRbNF0pIHtcbiAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBwbnBEZXZpY2VJZFsxXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbMl0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzNdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFs0XS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChtZW1vcnlTaXplcywgZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5U2l6ZSA9IG1lbW9yeVNpemVzW2RldmljZUlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQQ0lcXFZFTl92KDQpJkRFVl9kKDQpJlNVQlNZU19zKDQpbig0KVxuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPT0gbnVsbCAmJiBwbnBEZXZpY2VJZFszXSkge1xuICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IHBucERldmljZUlkWzFdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFsyXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbM10udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobWVtb3J5U2l6ZXMsIGRldmljZUlkKSkge1xuICAgICAgICAgICAgICAgIG1lbW9yeVNpemUgPSBtZW1vcnlTaXplc1tkZXZpY2VJZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUENJXFxWRU5fdig0KSZERVZfZCg0KSZSRVZfcigyKVxuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPT0gbnVsbCAmJiBwbnBEZXZpY2VJZFs0XSkge1xuICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IHBucERldmljZUlkWzFdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFsyXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbNF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobWVtb3J5U2l6ZXMsIGRldmljZUlkKSkge1xuICAgICAgICAgICAgICAgIG1lbW9yeVNpemUgPSBtZW1vcnlTaXplc1tkZXZpY2VJZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUENJXFxWRU5fdig0KSZERVZfZCg0KVxuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IHBucERldmljZUlkWzFdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChtZW1vcnlTaXplcywgZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5U2l6ZSA9IG1lbW9yeVNpemVzW2RldmljZUlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRyb2xsZXJzLnB1c2goe1xuICAgICAgICAgICAgdmVuZG9yOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQWRhcHRlckNvbXBhdGliaWxpdHknLCAnOicpLFxuICAgICAgICAgICAgbW9kZWw6IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKSxcbiAgICAgICAgICAgIGJ1czogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BOUERldmljZUlEJywgJzonKS5zdGFydHNXaXRoKCdQQ0knKSA/ICdQQ0knIDogJycsXG4gICAgICAgICAgICB2cmFtOiAobWVtb3J5U2l6ZSA9PSBudWxsID8gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQWRhcHRlclJBTScsICc6JykpIDogbWVtb3J5U2l6ZSkgLyAxMDI0IC8gMTAyNCxcbiAgICAgICAgICAgIHZyYW1EeW5hbWljOiAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ZpZGVvTWVtb3J5VHlwZScsICc6JykgPT09ICcyJyksXG4gICAgICAgICAgICBzdWJEZXZpY2VJZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9yZXNvbHV0aW9uWCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0N1cnJlbnRIb3Jpem9udGFsUmVzb2x1dGlvbicsICc6JykpIHx8IF9yZXNvbHV0aW9uWDtcbiAgICAgICAgICBfcmVzb2x1dGlvblkgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDdXJyZW50VmVydGljYWxSZXNvbHV0aW9uJywgJzonKSkgfHwgX3Jlc29sdXRpb25ZO1xuICAgICAgICAgIF9yZWZyZXNoUmF0ZSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0N1cnJlbnRSZWZyZXNoUmF0ZScsICc6JykpIHx8IF9yZWZyZXNoUmF0ZTtcbiAgICAgICAgICBfcGl4ZWxEZXB0aCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0N1cnJlbnRCaXRzUGVyUGl4ZWwnLCAnOicpKSB8fCBfcGl4ZWxEZXB0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzV2luZG93c0Rpc3BsYXlzUG93ZXJzaGVsbChzc2VjdGlvbnMsIG1zZWN0aW9ucywgZHNlY3Rpb25zLCB0c2VjdGlvbnMsIGlzZWN0aW9ucykge1xuICAgIGxldCBkaXNwbGF5cyA9IFtdO1xuICAgIGxldCB2ZW5kb3IgPSAnJztcbiAgICBsZXQgbW9kZWwgPSAnJztcbiAgICBsZXQgZGV2aWNlSUQgPSAnJztcbiAgICBsZXQgcmVzb2x1dGlvblggPSAwO1xuICAgIGxldCByZXNvbHV0aW9uWSA9IDA7XG4gICAgaWYgKGRzZWN0aW9ucyAmJiBkc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgbGluZXNEaXNwbGF5ID0gZHNlY3Rpb25zWzBdLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXNEaXNwbGF5LCAnTW9uaXRvck1hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXNEaXNwbGF5LCAnTmFtZScsICc6Jyk7XG4gICAgICBkZXZpY2VJRCA9IHV0aWwuZ2V0VmFsdWUobGluZXNEaXNwbGF5LCAnUE5QRGV2aWNlSUQnLCAnOicpLnJlcGxhY2UoLyZhbXA7L2csICcmJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJlc29sdXRpb25YID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzRGlzcGxheSwgJ1NjcmVlbldpZHRoJywgJzonKSk7XG4gICAgICByZXNvbHV0aW9uWSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lc0Rpc3BsYXksICdTY3JlZW5IZWlnaHQnLCAnOicpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzc2VjdGlvbnNbaV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICBzc2VjdGlvbnNbaV0gPSAnQml0c1BlclBpeGVsICcgKyBzc2VjdGlvbnNbaV07XG4gICAgICAgIG1zZWN0aW9uc1tpXSA9ICdBY3RpdmUgJyArIG1zZWN0aW9uc1tpXTtcbiAgICAgICAgLy8gdHNlY3Rpb25zIGNhbiBiZSBlbXB0eSBPUiB1bmRlZmluZWQgb24gZWFybGllciB2ZXJzaW9ucyBvZiBwb3dlcnNoZWxsICg8PTIuMClcbiAgICAgICAgLy8gVGFnIGNvbm5lY3Rpb24gdHlwZSBhcyBVTktOT1dOIGJ5IGRlZmF1bHQgaWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nXG4gICAgICAgIGlmICh0c2VjdGlvbnMubGVuZ3RoID09PSAwIHx8IHRzZWN0aW9uc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHNlY3Rpb25zW2ldID0gJ1Vua25vd24nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lc1NjcmVlbiA9IHNzZWN0aW9uc1tpXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxldCBsaW5lc01vbml0b3IgPSBtc2VjdGlvbnNbaV0uc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGxldCBsaW5lc0Nvbm5lY3Rpb24gPSB0c2VjdGlvbnNbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBiaXRzUGVyUGl4ZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzU2NyZWVuLCAnQml0c1BlclBpeGVsJyk7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHV0aWwuZ2V0VmFsdWUobGluZXNTY3JlZW4sICdCb3VuZHMnKS5yZXBsYWNlKCd7JywgJycpLnJlcGxhY2UoJ30nLCAnJykucmVwbGFjZSgvPS9nLCAnOicpLnNwbGl0KCcsJyk7XG4gICAgICAgIGNvbnN0IHByaW1hcnkgPSB1dGlsLmdldFZhbHVlKGxpbmVzU2NyZWVuLCAnUHJpbWFyeScpO1xuICAgICAgICBjb25zdCBzaXplWCA9IHV0aWwuZ2V0VmFsdWUobGluZXNNb25pdG9yLCAnTWF4SG9yaXpvbnRhbEltYWdlU2l6ZScpO1xuICAgICAgICBjb25zdCBzaXplWSA9IHV0aWwuZ2V0VmFsdWUobGluZXNNb25pdG9yLCAnTWF4VmVydGljYWxJbWFnZVNpemUnKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VOYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lc01vbml0b3IsICdJbnN0YW5jZU5hbWUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB2aWRlb091dHB1dFRlY2hub2xvZ3kgPSB1dGlsLmdldFZhbHVlKGxpbmVzQ29ubmVjdGlvbiwgJ1ZpZGVvT3V0cHV0VGVjaG5vbG9neScpO1xuICAgICAgICBjb25zdCBkZXZpY2VOYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lc1NjcmVlbiwgJ0RldmljZU5hbWUnKTtcbiAgICAgICAgbGV0IGRpc3BsYXlWZW5kb3IgPSAnJztcbiAgICAgICAgbGV0IGRpc3BsYXlNb2RlbCA9ICcnO1xuICAgICAgICBpc2VjdGlvbnMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudC5pbnN0YW5jZUlkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChpbnN0YW5jZU5hbWUpICYmIHZlbmRvci5zdGFydHNXaXRoKCcoJykgJiYgbW9kZWwuc3RhcnRzV2l0aCgnUG5QJykpIHtcbiAgICAgICAgICAgIGRpc3BsYXlWZW5kb3IgPSBlbGVtZW50LnZlbmRvcjtcbiAgICAgICAgICAgIGRpc3BsYXlNb2RlbCA9IGVsZW1lbnQubW9kZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGxheXMucHVzaCh7XG4gICAgICAgICAgdmVuZG9yOiBpbnN0YW5jZU5hbWUuc3RhcnRzV2l0aChkZXZpY2VJRCkgJiYgZGlzcGxheVZlbmRvciA9PT0gJycgPyB2ZW5kb3IgOiBkaXNwbGF5VmVuZG9yLFxuICAgICAgICAgIG1vZGVsOiBpbnN0YW5jZU5hbWUuc3RhcnRzV2l0aChkZXZpY2VJRCkgJiYgZGlzcGxheU1vZGVsID09PSAnJyA/IG1vZGVsIDogZGlzcGxheU1vZGVsLFxuICAgICAgICAgIGRldmljZU5hbWUsXG4gICAgICAgICAgbWFpbjogcHJpbWFyeS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScsXG4gICAgICAgICAgYnVpbHRpbjogdmlkZW9PdXRwdXRUZWNobm9sb2d5ID09PSAnMjE0NzQ4MzY0OCcsXG4gICAgICAgICAgY29ubmVjdGlvbjogdmlkZW9PdXRwdXRUZWNobm9sb2d5ICYmIHZpZGVvVHlwZXNbdmlkZW9PdXRwdXRUZWNobm9sb2d5XSA/IHZpZGVvVHlwZXNbdmlkZW9PdXRwdXRUZWNobm9sb2d5XSA6ICcnLFxuICAgICAgICAgIHJlc29sdXRpb25YOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnV2lkdGgnLCAnOicpKSxcbiAgICAgICAgICByZXNvbHV0aW9uWTogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ0hlaWdodCcsICc6JykpLFxuICAgICAgICAgIHNpemVYOiBzaXplWCA/IHBhcnNlSW50KHNpemVYLCAxMCkgOiBudWxsLFxuICAgICAgICAgIHNpemVZOiBzaXplWSA/IHBhcnNlSW50KHNpemVZLCAxMCkgOiBudWxsLFxuICAgICAgICAgIHBpeGVsRGVwdGg6IGJpdHNQZXJQaXhlbCxcbiAgICAgICAgICBjdXJyZW50UmVzWDogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ1dpZHRoJywgJzonKSksXG4gICAgICAgICAgY3VycmVudFJlc1k6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdIZWlnaHQnLCAnOicpKSxcbiAgICAgICAgICBwb3NpdGlvblg6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdYJywgJzonKSksXG4gICAgICAgICAgcG9zaXRpb25ZOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnWScsICc6JykpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNzZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRpc3BsYXlzLnB1c2goe1xuICAgICAgICB2ZW5kb3IsXG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtYWluOiB0cnVlLFxuICAgICAgICBzaXplWDogbnVsbCxcbiAgICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICAgIHJlc29sdXRpb25YLFxuICAgICAgICByZXNvbHV0aW9uWSxcbiAgICAgICAgcGl4ZWxEZXB0aDogbnVsbCxcbiAgICAgICAgY3VycmVudFJlc1g6IHJlc29sdXRpb25YLFxuICAgICAgICBjdXJyZW50UmVzWTogcmVzb2x1dGlvblksXG4gICAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgICAgcG9zaXRpb25ZOiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BsYXlzO1xuICB9XG59XG5cbmV4cG9ydHMuZ3JhcGhpY3MgPSBncmFwaGljcztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gaW5kZXguanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ29udHJpYnV0b3JzOiAgR3VpbGxhdW1lIExlZ3JhaW4gKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVncmFpbilcbi8vICAgICAgICAgICAgICAgIFJpY2NhcmRvIE5vdmFnbGlhIChodHRwczovL2dpdGh1Yi5jb20vcmljaHkyNClcbi8vICAgICAgICAgICAgICAgIFF1ZW50aW4gQnVzdXR0aWwgKGh0dHBzOi8vZ2l0aHViLmNvbS9CdXp1dClcbi8vICAgICAgICAgICAgICAgIExhcHNpbyAoaHR0cHM6Ly9naXRodWIuY29tL2xhcHNpbylcbi8vICAgICAgICAgICAgICAgIGNzeSAoaHR0cHM6Ly9naXRodWIuY29tL2NzeTE5ODMpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVwZW5kZW5jaWVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGxpYl92ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHN5c3RlbSA9IHJlcXVpcmUoJy4vc3lzdGVtJyk7XG5jb25zdCBvc0luZm8gPSByZXF1aXJlKCcuL29zaW5mbycpO1xuY29uc3QgY3B1ID0gcmVxdWlyZSgnLi9jcHUnKTtcbmNvbnN0IG1lbW9yeSA9IHJlcXVpcmUoJy4vbWVtb3J5Jyk7XG5jb25zdCBiYXR0ZXJ5ID0gcmVxdWlyZSgnLi9iYXR0ZXJ5Jyk7XG5jb25zdCBncmFwaGljcyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKTtcbmNvbnN0IGZpbGVzeXN0ZW0gPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKTtcbmNvbnN0IG5ldHdvcmsgPSByZXF1aXJlKCcuL25ldHdvcmsnKTtcbmNvbnN0IHdpZmkgPSByZXF1aXJlKCcuL3dpZmknKTtcbmNvbnN0IHByb2Nlc3NlcyA9IHJlcXVpcmUoJy4vcHJvY2Vzc2VzJyk7XG5jb25zdCB1c2VycyA9IHJlcXVpcmUoJy4vdXNlcnMnKTtcbmNvbnN0IGludGVybmV0ID0gcmVxdWlyZSgnLi9pbnRlcm5ldCcpO1xuY29uc3QgZG9ja2VyID0gcmVxdWlyZSgnLi9kb2NrZXInKTtcbmNvbnN0IHZib3ggPSByZXF1aXJlKCcuL3ZpcnR1YWxib3gnKTtcbmNvbnN0IHByaW50ZXIgPSByZXF1aXJlKCcuL3ByaW50ZXInKTtcbmNvbnN0IHVzYiA9IHJlcXVpcmUoJy4vdXNiJyk7XG5jb25zdCBhdWRpbyA9IHJlcXVpcmUoJy4vYXVkaW8nKTtcbmNvbnN0IGJsdWV0b290aCA9IHJlcXVpcmUoJy4vYmx1ZXRvb3RoJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaW5pdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pZiAoX3dpbmRvd3MpIHtcbiAgdXRpbC5nZXRDb2RlcGFnZSgpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHZW5lcmFsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gIHJldHVybiBsaWJfdmVyc2lvbjtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2V0IHN0YXRpYyBhbmQgZHluYW1pYyBkYXRhIChhbGwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBnZXQgc3RhdGljIGRhdGEgLSB0aGV5IHNob3VsZCBub3QgY2hhbmdlIHVudGlsIHJlc3RhcnRlZFxuXG5mdW5jdGlvbiBnZXRTdGF0aWNEYXRhKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCBkYXRhID0ge307XG5cbiAgICAgIGRhdGEudmVyc2lvbiA9IHZlcnNpb24oKTtcblxuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzeXN0ZW0uc3lzdGVtKCksXG4gICAgICAgIHN5c3RlbS5iaW9zKCksXG4gICAgICAgIHN5c3RlbS5iYXNlYm9hcmQoKSxcbiAgICAgICAgc3lzdGVtLmNoYXNzaXMoKSxcbiAgICAgICAgb3NJbmZvLm9zSW5mbygpLFxuICAgICAgICBvc0luZm8udXVpZCgpLFxuICAgICAgICBvc0luZm8udmVyc2lvbnMoKSxcbiAgICAgICAgY3B1LmNwdSgpLFxuICAgICAgICBjcHUuY3B1RmxhZ3MoKSxcbiAgICAgICAgZ3JhcGhpY3MuZ3JhcGhpY3MoKSxcbiAgICAgICAgbmV0d29yay5uZXR3b3JrSW50ZXJmYWNlcygpLFxuICAgICAgICBtZW1vcnkubWVtTGF5b3V0KCksXG4gICAgICAgIGZpbGVzeXN0ZW0uZGlza0xheW91dCgpXG4gICAgICBdKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5zeXN0ZW0gPSByZXNbMF07XG4gICAgICAgIGRhdGEuYmlvcyA9IHJlc1sxXTtcbiAgICAgICAgZGF0YS5iYXNlYm9hcmQgPSByZXNbMl07XG4gICAgICAgIGRhdGEuY2hhc3NpcyA9IHJlc1szXTtcbiAgICAgICAgZGF0YS5vcyA9IHJlc1s0XTtcbiAgICAgICAgZGF0YS51dWlkID0gcmVzWzVdO1xuICAgICAgICBkYXRhLnZlcnNpb25zID0gcmVzWzZdO1xuICAgICAgICBkYXRhLmNwdSA9IHJlc1s3XTtcbiAgICAgICAgZGF0YS5jcHUuZmxhZ3MgPSByZXNbOF07XG4gICAgICAgIGRhdGEuZ3JhcGhpY3MgPSByZXNbOV07XG4gICAgICAgIGRhdGEubmV0ID0gcmVzWzEwXTtcbiAgICAgICAgZGF0YS5tZW1MYXlvdXQgPSByZXNbMTFdO1xuICAgICAgICBkYXRhLmRpc2tMYXlvdXQgPSByZXNbMTJdO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0IGFsbCBkeW5hbWljIGRhdGEgLSBlLmcuIGZvciBtb25pdG9yaW5nIGFnZW50c1xuLy8gbWF5IHRha2Ugc29tZSBzZWNvbmRzIHRvIGdldCBhbGwgZGF0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDIgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG5lZWRlZFxuLy8gLSBzcnY6IFx0XHRjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBzZXJ2aWNlcyB0byBtb25pdG9yIGUuZy4gXCJteXNxbCwgYXBhY2hlLCBwb3N0Z3Jlc3FsXCJcbi8vIC0gaWZhY2U6XHRkZWZpbmUgbmV0d29yayBpbnRlcmZhY2UgZm9yIHdoaWNoIHlvdSBsaWtlIHRvIG1vbml0b3IgbmV0d29yayBzcGVlZCBlLmcuIFwiZXRoMFwiXG5cbmZ1bmN0aW9uIGdldER5bmFtaWNEYXRhKHNydiwgaWZhY2UsIGNhbGxiYWNrKSB7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihpZmFjZSkpIHtcbiAgICBjYWxsYmFjayA9IGlmYWNlO1xuICAgIGlmYWNlID0gJyc7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihzcnYpKSB7XG4gICAgY2FsbGJhY2sgPSBzcnY7XG4gICAgc3J2ID0gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgaWZhY2UgPSBpZmFjZSB8fCBuZXR3b3JrLmdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG4gICAgICBzcnYgPSBzcnYgfHwgJyc7XG5cbiAgICAgIC8vIHVzZSBjbG9zdXJlIHRvIHRyYWNrIMaSIGNvbXBsZXRpb25cbiAgICAgIGxldCBmdW5jdGlvblByb2Nlc3NlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCB0b3RhbEZ1bmN0aW9ucyA9IDE1O1xuICAgICAgICBpZiAoX3dpbmRvd3MpIHsgdG90YWxGdW5jdGlvbnMgPSAxMzsgfVxuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgeyB0b3RhbEZ1bmN0aW9ucyA9IDExOyB9XG4gICAgICAgIGlmIChfc3Vub3MpIHsgdG90YWxGdW5jdGlvbnMgPSA2OyB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoLS10b3RhbEZ1bmN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuXG4gICAgICBsZXQgZGF0YSA9IHt9O1xuXG4gICAgICAvLyBnZXQgdGltZVxuICAgICAgZGF0YS50aW1lID0gb3NJbmZvLnRpbWUoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gIHZlcnNpb25zXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIHZlcnNpb25zLm5vZGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgdmVyc2lvbnMudjhcbiAgICAgICAqL1xuICAgICAgZGF0YS5ub2RlID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICAgICAgZGF0YS52OCA9IHByb2Nlc3MudmVyc2lvbnMudjg7XG5cbiAgICAgIGNwdS5jcHVDdXJyZW50U3BlZWQoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5jcHVDdXJyZW50U3BlZWQgPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcblxuICAgICAgdXNlcnMudXNlcnMoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS51c2VycyA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzZXMucHJvY2Vzc2VzKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEucHJvY2Vzc2VzID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNwdS5jdXJyZW50TG9hZCgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLmN1cnJlbnRMb2FkID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghX3N1bm9zKSB7XG4gICAgICAgIGNwdS5jcHVUZW1wZXJhdHVyZSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEudGVtcCA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfb3BlbmJzZCAmJiAhX2ZyZWVic2QgJiYgIV9uZXRic2QgJiYgIV9zdW5vcykge1xuICAgICAgICBuZXR3b3JrLm5ldHdvcmtTdGF0cyhpZmFjZSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5uZXR3b3JrU3RhdHMgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3N1bm9zKSB7XG4gICAgICAgIG5ldHdvcmsubmV0d29ya0Nvbm5lY3Rpb25zKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5uZXR3b3JrQ29ubmVjdGlvbnMgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG1lbW9yeS5tZW0oKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5tZW0gPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFfc3Vub3MpIHtcbiAgICAgICAgYmF0dGVyeSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEuYmF0dGVyeSA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfc3Vub3MpIHtcbiAgICAgICAgcHJvY2Vzc2VzLnNlcnZpY2VzKHNydikudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5zZXJ2aWNlcyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfc3Vub3MpIHtcbiAgICAgICAgZmlsZXN5c3RlbS5mc1NpemUoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLmZzU2l6ZSA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfd2luZG93cyAmJiAhX29wZW5ic2QgJiYgIV9mcmVlYnNkICYmICFfbmV0YnNkICYmICFfc3Vub3MpIHtcbiAgICAgICAgZmlsZXN5c3RlbS5mc1N0YXRzKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5mc1N0YXRzID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV93aW5kb3dzICYmICFfb3BlbmJzZCAmJiAhX2ZyZWVic2QgJiYgIV9uZXRic2QgJiYgIV9zdW5vcykge1xuICAgICAgICBmaWxlc3lzdGVtLmRpc2tzSU8oKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLmRpc2tzSU8gPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX29wZW5ic2QgJiYgIV9mcmVlYnNkICYmICFfbmV0YnNkICYmICFfc3Vub3MpIHtcbiAgICAgICAgd2lmaS53aWZpTmV0d29ya3MoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLndpZmlOZXR3b3JrcyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJuZXQuaW5ldExhdGVuY3koKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5pbmV0TGF0ZW5jeSA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdldCBhbGwgZGF0YSBhdCBvbmNlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgbmVlZGVkXG4vLyAtIHNydjogXHRcdGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHNlcnZpY2VzIHRvIG1vbml0b3IgZS5nLiBcIm15c3FsLCBhcGFjaGUsIHBvc3RncmVzcWxcIlxuLy8gLSBpZmFjZTpcdGRlZmluZSBuZXR3b3JrIGludGVyZmFjZSBmb3Igd2hpY2ggeW91IGxpa2UgdG8gbW9uaXRvciBuZXR3b3JrIHNwZWVkIGUuZy4gXCJldGgwXCJcblxuZnVuY3Rpb24gZ2V0QWxsRGF0YShzcnYsIGlmYWNlLCBjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB7fTtcblxuICAgICAgaWYgKGlmYWNlICYmIHV0aWwuaXNGdW5jdGlvbihpZmFjZSkgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gaWZhY2U7XG4gICAgICAgIGlmYWNlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcnYgJiYgdXRpbC5pc0Z1bmN0aW9uKHNydikgJiYgIWlmYWNlICYmICFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IHNydjtcbiAgICAgICAgc3J2ID0gJyc7XG4gICAgICAgIGlmYWNlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGdldFN0YXRpY0RhdGEoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YSA9IHJlcztcbiAgICAgICAgZ2V0RHluYW1pY0RhdGEoc3J2LCBpZmFjZSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHJlcykge1xuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwocmVzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGRhdGFba2V5XSA9IHJlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZhbHVlT2JqZWN0LCBjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGFsbFByb21pc2VzID0gT2JqZWN0LmtleXModmFsdWVPYmplY3QpXG4gICAgICAgIC5maWx0ZXIoZnVuYyA9PiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBmdW5jKSkpXG4gICAgICAgIC5tYXAoZnVuYyA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdmFsdWVPYmplY3RbZnVuY10uc3Vic3RyaW5nKHZhbHVlT2JqZWN0W2Z1bmNdLmxhc3RJbmRleE9mKCcoJykgKyAxLCB2YWx1ZU9iamVjdFtmdW5jXS5sYXN0SW5kZXhPZignKScpKTtcbiAgICAgICAgICBsZXQgZnVuY1dpdGhvdXRQYXJhbXMgPSBmdW5jLmluZGV4T2YoJyknKSA+PSAwID8gZnVuYy5zcGxpdCgnKScpWzFdLnRyaW0oKSA6IGZ1bmM7XG4gICAgICAgICAgZnVuY1dpdGhvdXRQYXJhbXMgPSBmdW5jLmluZGV4T2YoJ3wnKSA+PSAwID8gZnVuYy5zcGxpdCgnfCcpWzBdLnRyaW0oKSA6IGZ1bmNXaXRob3V0UGFyYW1zO1xuICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzW2Z1bmNXaXRob3V0UGFyYW1zXShwYXJhbXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0c1tmdW5jV2l0aG91dFBhcmFtc10oJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIFByb21pc2UuYWxsKGFsbFByb21pc2VzKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZU9iamVjdCkge1xuICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlT2JqZWN0LCBrZXkpICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywga2V5KSAmJiBkYXRhLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZU9iamVjdFtrZXldID09PSAnKicgfHwgdmFsdWVPYmplY3Rba2V5XSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGtleXMgPSB2YWx1ZU9iamVjdFtrZXldO1xuICAgICAgICAgICAgICBsZXQgZmlsdGVyID0gJyc7XG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAvLyByZW1vdmUgcGFyYW1zXG4gICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoJyknKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IGtleXMuc3BsaXQoJyknKVsxXS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZXh0cmFjdCBmaWx0ZXIgYW5kIHJlbW92ZSBpdCBmcm9tIGtleXNcbiAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZignfCcpID49IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZXlzLnNwbGl0KCd8JylbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGZpbHRlclBhcnRzID0gZmlsdGVyLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgICAgICAgICBrZXlzID0ga2V5cy5zcGxpdCgnfCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBrZXlzID0ga2V5cy5yZXBsYWNlKC8sL2csICcgJykucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBpZiAoZGF0YVtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAvLyByZXN1bHQgaXMgaW4gYW4gYXJyYXksIGdvIHRocm91Z2ggYWxsIGVsZW1lbnRzIG9mIGFycmF5IGFuZCBwaWNrIG9ubHkgdGhlIHJpZ2h0IG9uZXNcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgZGF0YVtpXS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGlhbFJlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYgKGtleXNbMF0gPT09ICcqJyB8fCBrZXlzWzBdID09PSAnYWxsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUmVzID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50LCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUmVzW2tdID0gZWxlbWVudFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGZpbHRlciwgdGhlbiBqdXN0IHRha2UgdGhvc2UgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXJQYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChwYXJ0aWFsUmVzLCBmaWx0ZXJQYXJ0c1swXS50cmltKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJ0aWFsUmVzW2ZpbHRlclBhcnRzWzBdLnRyaW0oKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSBwYXJzZUZsb2F0KGZpbHRlclBhcnRzWzFdLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQXJyYXkucHVzaChwYXJ0aWFsUmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwudG9Mb3dlckNhc2UoKSA9PT0gZmlsdGVyUGFydHNbMV0udHJpbSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQXJyYXkucHVzaChwYXJ0aWFsUmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQXJyYXkucHVzaChwYXJ0aWFsUmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcGFydGlhbEFycmF5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsUmVzID0ge307XG4gICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFbaV0sIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFJlc1trXSA9IGRhdGFbaV1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwYXJ0aWFsUmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZU9iamVjdCwgaW50ZXJ2YWwsIGNhbGxiYWNrKSB7XG4gIGxldCBfZGF0YSA9IG51bGw7XG5cbiAgY29uc3QgcmVzdWx0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGdldCh2YWx1ZU9iamVjdCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KF9kYXRhKSAhPT0gSlNPTi5zdHJpbmdpZnkoZGF0YSkpIHtcbiAgICAgICAgX2RhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGludGVydmFsKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXhwb3J0IGFsbCBsaWJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLnN5c3RlbSA9IHN5c3RlbS5zeXN0ZW07XG5leHBvcnRzLmJpb3MgPSBzeXN0ZW0uYmlvcztcbmV4cG9ydHMuYmFzZWJvYXJkID0gc3lzdGVtLmJhc2Vib2FyZDtcbmV4cG9ydHMuY2hhc3NpcyA9IHN5c3RlbS5jaGFzc2lzO1xuXG5leHBvcnRzLnRpbWUgPSBvc0luZm8udGltZTtcbmV4cG9ydHMub3NJbmZvID0gb3NJbmZvLm9zSW5mbztcbmV4cG9ydHMudmVyc2lvbnMgPSBvc0luZm8udmVyc2lvbnM7XG5leHBvcnRzLnNoZWxsID0gb3NJbmZvLnNoZWxsO1xuZXhwb3J0cy51dWlkID0gb3NJbmZvLnV1aWQ7XG5cbmV4cG9ydHMuY3B1ID0gY3B1LmNwdTtcbmV4cG9ydHMuY3B1RmxhZ3MgPSBjcHUuY3B1RmxhZ3M7XG5leHBvcnRzLmNwdUNhY2hlID0gY3B1LmNwdUNhY2hlO1xuZXhwb3J0cy5jcHVDdXJyZW50U3BlZWQgPSBjcHUuY3B1Q3VycmVudFNwZWVkO1xuZXhwb3J0cy5jcHVUZW1wZXJhdHVyZSA9IGNwdS5jcHVUZW1wZXJhdHVyZTtcbmV4cG9ydHMuY3VycmVudExvYWQgPSBjcHUuY3VycmVudExvYWQ7XG5leHBvcnRzLmZ1bGxMb2FkID0gY3B1LmZ1bGxMb2FkO1xuXG5leHBvcnRzLm1lbSA9IG1lbW9yeS5tZW07XG5leHBvcnRzLm1lbUxheW91dCA9IG1lbW9yeS5tZW1MYXlvdXQ7XG5cbmV4cG9ydHMuYmF0dGVyeSA9IGJhdHRlcnk7XG5cbmV4cG9ydHMuZ3JhcGhpY3MgPSBncmFwaGljcy5ncmFwaGljcztcblxuZXhwb3J0cy5mc1NpemUgPSBmaWxlc3lzdGVtLmZzU2l6ZTtcbmV4cG9ydHMuZnNPcGVuRmlsZXMgPSBmaWxlc3lzdGVtLmZzT3BlbkZpbGVzO1xuZXhwb3J0cy5ibG9ja0RldmljZXMgPSBmaWxlc3lzdGVtLmJsb2NrRGV2aWNlcztcbmV4cG9ydHMuZnNTdGF0cyA9IGZpbGVzeXN0ZW0uZnNTdGF0cztcbmV4cG9ydHMuZGlza3NJTyA9IGZpbGVzeXN0ZW0uZGlza3NJTztcbmV4cG9ydHMuZGlza0xheW91dCA9IGZpbGVzeXN0ZW0uZGlza0xheW91dDtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlRGVmYXVsdCA9IG5ldHdvcmsubmV0d29ya0ludGVyZmFjZURlZmF1bHQ7XG5leHBvcnRzLm5ldHdvcmtHYXRld2F5RGVmYXVsdCA9IG5ldHdvcmsubmV0d29ya0dhdGV3YXlEZWZhdWx0O1xuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlcyA9IG5ldHdvcmsubmV0d29ya0ludGVyZmFjZXM7XG5leHBvcnRzLm5ldHdvcmtTdGF0cyA9IG5ldHdvcmsubmV0d29ya1N0YXRzO1xuZXhwb3J0cy5uZXR3b3JrQ29ubmVjdGlvbnMgPSBuZXR3b3JrLm5ldHdvcmtDb25uZWN0aW9ucztcblxuZXhwb3J0cy53aWZpTmV0d29ya3MgPSB3aWZpLndpZmlOZXR3b3JrcztcbmV4cG9ydHMud2lmaUludGVyZmFjZXMgPSB3aWZpLndpZmlJbnRlcmZhY2VzO1xuZXhwb3J0cy53aWZpQ29ubmVjdGlvbnMgPSB3aWZpLndpZmlDb25uZWN0aW9ucztcblxuZXhwb3J0cy5zZXJ2aWNlcyA9IHByb2Nlc3Nlcy5zZXJ2aWNlcztcbmV4cG9ydHMucHJvY2Vzc2VzID0gcHJvY2Vzc2VzLnByb2Nlc3NlcztcbmV4cG9ydHMucHJvY2Vzc0xvYWQgPSBwcm9jZXNzZXMucHJvY2Vzc0xvYWQ7XG5cbmV4cG9ydHMudXNlcnMgPSB1c2Vycy51c2VycztcblxuZXhwb3J0cy5pbmV0Q2hlY2tzaXRlID0gaW50ZXJuZXQuaW5ldENoZWNrc2l0ZTtcbmV4cG9ydHMuaW5ldExhdGVuY3kgPSBpbnRlcm5ldC5pbmV0TGF0ZW5jeTtcblxuZXhwb3J0cy5kb2NrZXJJbmZvID0gZG9ja2VyLmRvY2tlckluZm87XG5leHBvcnRzLmRvY2tlckltYWdlcyA9IGRvY2tlci5kb2NrZXJJbWFnZXM7XG5leHBvcnRzLmRvY2tlckNvbnRhaW5lcnMgPSBkb2NrZXIuZG9ja2VyQ29udGFpbmVycztcbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVyU3RhdHMgPSBkb2NrZXIuZG9ja2VyQ29udGFpbmVyU3RhdHM7XG5leHBvcnRzLmRvY2tlckNvbnRhaW5lclByb2Nlc3NlcyA9IGRvY2tlci5kb2NrZXJDb250YWluZXJQcm9jZXNzZXM7XG5leHBvcnRzLmRvY2tlclZvbHVtZXMgPSBkb2NrZXIuZG9ja2VyVm9sdW1lcztcbmV4cG9ydHMuZG9ja2VyQWxsID0gZG9ja2VyLmRvY2tlckFsbDtcblxuZXhwb3J0cy52Ym94SW5mbyA9IHZib3gudmJveEluZm87XG5cbmV4cG9ydHMucHJpbnRlciA9IHByaW50ZXIucHJpbnRlcjtcblxuZXhwb3J0cy51c2IgPSB1c2IudXNiO1xuXG5leHBvcnRzLmF1ZGlvID0gYXVkaW8uYXVkaW87XG5leHBvcnRzLmJsdWV0b290aERldmljZXMgPSBibHVldG9vdGguYmx1ZXRvb3RoRGV2aWNlcztcblxuZXhwb3J0cy5nZXRTdGF0aWNEYXRhID0gZ2V0U3RhdGljRGF0YTtcbmV4cG9ydHMuZ2V0RHluYW1pY0RhdGEgPSBnZXREeW5hbWljRGF0YTtcbmV4cG9ydHMuZ2V0QWxsRGF0YSA9IGdldEFsbERhdGE7XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMub2JzZXJ2ZSA9IG9ic2VydmU7XG5cbmV4cG9ydHMucG93ZXJTaGVsbFN0YXJ0ID0gdXRpbC5wb3dlclNoZWxsU3RhcnQ7XG5leHBvcnRzLnBvd2VyU2hlbGxSZWxlYXNlID0gdXRpbC5wb3dlclNoZWxsUmVsZWFzZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gaW50ZXJuZXQuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxMi4gSW50ZXJuZXRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNoZWNrIGlmIGV4dGVybmFsIHNpdGUgaXMgYXZhaWxhYmxlXG5cbmZ1bmN0aW9uIGluZXRDaGVja3NpdGUodXJsLCBjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIG1zOiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBsZXQgdXJsU2FuaXRpemVkID0gJyc7XG4gICAgICBjb25zdCBzID0gdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKHVybCwgdHJ1ZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNbaV0uX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICAgIGNvbnN0IHNsID0gc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChzbCAmJiBzbFswXSAmJiAhc2xbMV0gJiYgc2xbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB1cmxTYW5pdGl6ZWQgPSB1cmxTYW5pdGl6ZWQgKyBzbFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC51cmwgPSB1cmxTYW5pdGl6ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodXJsU2FuaXRpemVkICYmICF1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSkge1xuICAgICAgICAgIHVybFNhbml0aXplZC5fX3Byb3RvX18uc3RhcnRzV2l0aCA9IHV0aWwuc3RyaW5nU3RhcnRXaXRoO1xuICAgICAgICAgIGlmICh1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnZmlsZTonKSB8fCB1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnZ29waGVyOicpIHx8IHVybFNhbml0aXplZC5zdGFydHNXaXRoKCd0ZWxuZXQ6JykgfHwgdXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ21haWx0bzonKSB8fCB1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbmV3czonKSB8fCB1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbm50cDonKSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2RhcndpbiB8fCBfc3Vub3MpIHtcbiAgICAgICAgICAgIGxldCBhcmdzID0gWyctSScsICctLWNvbm5lY3QtdGltZW91dCcsICc1JywgJy1tJywgJzUnXTtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh1cmxTYW5pdGl6ZWQpO1xuICAgICAgICAgICAgbGV0IGNtZCA9ICdjdXJsJztcbiAgICAgICAgICAgIHV0aWwuZXhlY1NhZmUoY21kLCBhcmdzKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsZXQgc3RhdHVzQ29kZSA9IGxpbmVzWzBdICYmIGxpbmVzWzBdLmluZGV4T2YoJyAnKSA+PSAwID8gcGFyc2VJbnQobGluZXNbMF0uc3BsaXQoJyAnKVsxXSwgMTApIDogNDA0O1xuICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gc3RhdHVzQ29kZSB8fCA0MDQ7XG4gICAgICAgICAgICAgIHJlc3VsdC5vayA9IChzdGF0dXNDb2RlID09PSAyMDAgfHwgc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMiB8fCBzdGF0dXNDb2RlID09PSAzMDQpO1xuICAgICAgICAgICAgICByZXN1bHQubXMgPSAocmVzdWx0Lm9rID8gRGF0ZS5ub3coKSAtIHQgOiBudWxsKTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfd2luZG93cykgeyAgIC8vIGlmIHRoaXMgaXMgc3RhYmxlLCB0aGlzIGNhbiBiZSB1c2VkIGZvciBhbGwgT1MgdHlwZXNcbiAgICAgICAgICAgIGNvbnN0IGh0dHAgPSAodXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gcmVxdWlyZSgnaHR0cHMnKSA6IHJlcXVpcmUoJ2h0dHAnKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBodHRwLmdldCh1cmxTYW5pdGl6ZWQsIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gc3RhdHVzQ29kZSB8fCA0MDQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9rID0gKHN0YXR1c0NvZGUgPT09IDIwMCB8fCBzdGF0dXNDb2RlID09PSAzMDEgfHwgc3RhdHVzQ29kZSA9PT0gMzAyIHx8IHN0YXR1c0NvZGUgPT09IDMwNCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubXMgPSAocmVzdWx0Lm9rID8gRGF0ZS5ub3coKSAtIHQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlcy5vbignZGF0YScsICgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1zID0gKHJlc3VsdC5vayA/IERhdGUubm93KCkgLSB0IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5pbmV0Q2hlY2tzaXRlID0gaW5ldENoZWNrc2l0ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNoZWNrIGluZXQgbGF0ZW5jeVxuXG5mdW5jdGlvbiBpbmV0TGF0ZW5jeShob3N0LCBjYWxsYmFjaykge1xuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGhvc3QpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gaG9zdDtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBob3N0ID0gaG9zdCB8fCAnOC44LjguOCc7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGxldCBob3N0U2FuaXRpemVkID0gJyc7XG4gICAgICBjb25zdCBzID0gKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJzguOC44LjgnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGhvc3QsIHRydWUpKS50cmltKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgaWYgKCEoc1tpXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIHNbaV0uX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICAgIGNvbnN0IHNsID0gc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChzbCAmJiBzbFswXSAmJiAhc2xbMV0pIHtcbiAgICAgICAgICAgIGhvc3RTYW5pdGl6ZWQgPSBob3N0U2FuaXRpemVkICsgc2xbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob3N0U2FuaXRpemVkLl9fcHJvdG9fXy5zdGFydHNXaXRoID0gdXRpbC5zdHJpbmdTdGFydFdpdGg7XG4gICAgICBpZiAoaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCdmaWxlOicpIHx8IGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnZ29waGVyOicpIHx8IGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgndGVsbmV0OicpIHx8IGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbWFpbHRvOicpIHx8IGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbmV3czonKSB8fCBob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ25udHA6JykpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgbGV0IHBhcmFtcztcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luKSB7XG4gICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICBwYXJhbXMgPSBbJy1jJywgJzInLCAnLXcnLCAnMycsIGhvc3RTYW5pdGl6ZWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgcGFyYW1zID0gWyctYycsICcyJywgJy10JywgJzMnLCBob3N0U2FuaXRpemVkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIHBhcmFtcyA9IFsnLWMyJywgJy10MycsIGhvc3RTYW5pdGl6ZWRdO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BpbmcnLCBwYXJhbXMpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKS5maWx0ZXIoKGxpbmUpID0+IChsaW5lLmluZGV4T2YoJ3J0dCcpID49IDAgfHwgbGluZS5pbmRleE9mKCdyb3VuZC10cmlwJykgPj0gMCB8fCBsaW5lLmluZGV4T2YoJ2F2ZycpID49IDApKS5qb2luKCdcXG4nKTtcblxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZVsxXS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gWyctcycsICctYScsIGhvc3RTYW5pdGl6ZWQsICc1NicsICcyJ107XG4gICAgICAgIGNvbnN0IGZpbHQgPSAnYXZnJztcbiAgICAgICAgdXRpbC5leGVjU2FmZSgncGluZycsIHBhcmFtcywgeyB0aW1lb3V0OiAzMDAwIH0pLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YoZmlsdCkgPj0gMCkuam9pbignXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lWzFdLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VGbG9hdChwYXJ0c1sxXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtob3N0U2FuaXRpemVkLCAnLW4nLCAnMSddO1xuICAgICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BpbmcnLCBwYXJhbXMsIHV0aWwuZXhlY09wdHNXaW4pLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsaW5lLnRvTG93ZXJDYXNlKCkubWF0Y2goL21zL2cpIHx8IFtdKS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBpZiAobC5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQobFtsLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmluZXRMYXRlbmN5ID0gaW5ldExhdGVuY3k7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIG1lbW9yeS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDUuIE1lbW9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmNvbnN0IE9TWF9SQU1fbWFudWZhY3R1cmVycyA9IHtcbiAgJzB4MDE0Ric6ICdUcmFuc2NlbmQgSW5mb3JtYXRpb24nLFxuICAnMHgyQzAwJzogJ01pY3JvbiBUZWNobm9sb2d5IEluYy4nLFxuICAnMHg4MDJDJzogJ01pY3JvbiBUZWNobm9sb2d5IEluYy4nLFxuICAnMHg4MEFEJzogJ0h5bml4IFNlbWljb25kdWN0b3IgSW5jLicsXG4gICcweDgwQ0UnOiAnU2Ftc3VuZyBFbGVjdHJvbmljcyBJbmMuJyxcbiAgJzB4QUQwMCc6ICdIeW5peCBTZW1pY29uZHVjdG9yIEluYy4nLFxuICAnMHhDRTAwJzogJ1NhbXN1bmcgRWxlY3Ryb25pY3MgSW5jLicsXG4gICcweDAyRkUnOiAnRWxwaWRhJyxcbiAgJzB4NTEwNSc6ICdRaW1vbmRhIEFHIGkuIEluLicsXG4gICcweDg1NTEnOiAnUWltb25kYSBBRyBpLiBJbi4nLFxuICAnMHg4NTlCJzogJ0NydWNpYWwnLFxuICAnMHgwNENEJzogJ0ctU2tpbGwnXG59O1xuXG5jb25zdCBMSU5VWF9SQU1fbWFudWZhY3R1cmVycyA9IHtcbiAgJzAxN0EnOiAnQXBhY2VyJyxcbiAgJzAxOTgnOiAnSHlwZXJYJyxcbiAgJzAyOUUnOiAnQ29yc2FpcicsXG4gICcwNENCJzogJ0EtREFUQScsXG4gICcwNENEJzogJ0ctU2tpbGwnLFxuICAnMDU5Qic6ICdDcnVjaWFsJyxcbiAgJzAwQ0UnOiAnU2Ftc3VuZycsXG4gICcxMzE1JzogJ0NydXRpYWwnLFxuICAnMDE0Ric6ICdUcmFuc2NlbmQgSW5mb3JtYXRpb24nLFxuICAnMkMwMCc6ICdNaWNyb24gVGVjaG5vbG9neSBJbmMuJyxcbiAgJzgwMkMnOiAnTWljcm9uIFRlY2hub2xvZ3kgSW5jLicsXG4gICc4MEFEJzogJ0h5bml4IFNlbWljb25kdWN0b3IgSW5jLicsXG4gICc4MENFJzogJ1NhbXN1bmcgRWxlY3Ryb25pY3MgSW5jLicsXG4gICdBRDAwJzogJ0h5bml4IFNlbWljb25kdWN0b3IgSW5jLicsXG4gICdDRTAwJzogJ1NhbXN1bmcgRWxlY3Ryb25pY3MgSW5jLicsXG4gICcwMkZFJzogJ0VscGlkYScsXG4gICc1MTA1JzogJ1FpbW9uZGEgQUcgaS4gSW4uJyxcbiAgJzg1NTEnOiAnUWltb25kYSBBRyBpLiBJbi4nLFxuICAnODU5Qic6ICdDcnVjaWFsJ1xufTtcblxuLy8gX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgIFIgQSBNICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICBIIEQgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX198ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCAgICAgICAgYWN0aXZlICAgICAgICAgICAgIGJ1ZmZlcnMvY2FjaGUgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19ffF9fX19fX19fX3xfX19fX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgICB1c2VkICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZWUgICB8ICAgdXNlZCAgICAgICBmcmVlICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICBzd2FwICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19ffFxuXG4vLyBmcmVlIChvbGRlciB2ZXJzaW9ucylcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICMgZnJlZVxuLy8gICAgICAgICAgICAgIHRvdGFsICAgICAgIHVzZWQgICAgICAgIGZyZWUgICAgIHNoYXJlZCAgICBidWZmZXJzICAgICBjYWNoZWRcbi8vIE1lbTogICAgICAgICAxNjAzOCAoMSkgICAxNTY1MyAoMikgICAzODQgKDMpICAwICg0KSAgICAgMjM2ICg1KSAgICAgMTQ3ODggKDYpXG4vLyAtLysgYnVmZmVycy9jYWNoZTogICAgICAgNjI4ICg3KSAgICAgMTU0MDkgKDgpXG4vLyBTd2FwOiAgICAgICAgMTYzNzEgICAgICAgICA4MyAgICAgIDE2Mjg4XG4vL1xuLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICAgICBSIEEgTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuLy8gfCBhY3RpdmUgKDItKDUrNikgPSA3KSB8ICBhdmFpbGFibGUgKDMrNSs2ID0gOCkgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX198XG4vLyB8ICAgICAgICBhY3RpdmUgICAgICAgIHwgIGJ1ZmZlcnMvY2FjaGUgKDUrNikgICAgfCAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgdXNlZCAoMikgICAgICAgICAgICAgICAgICAgICB8IGZyZWUgKDMpICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKDEpICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG5cbi8vXG4vLyBmcmVlIChzaW5jZSBmcmVlIHZvbiBwcm9jcHMtbmcgMy4zLjEwKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIyBmcmVlXG4vLyAgICAgICAgICAgICAgdG90YWwgICAgICAgdXNlZCAgICAgICAgZnJlZSAgICAgc2hhcmVkICAgIGJ1ZmZlcnMvY2FjaGUgICBhdmFpbGFibGVcbi8vIE1lbTogICAgICAgICAxNjAzOCAoMSkgICA2MjggKDIpICAgICAzODYgKDMpICAwICg0KSAgICAgMTUwMjQgKDUpICAgICAxNDc4OCAoNilcbi8vIFN3YXA6ICAgICAgICAxNjM3MSAgICAgICAgIDgzICAgICAgMTYyODhcbi8vXG4vLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIFIgQSBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBhdmFpbGFibGUgKDYpIGVzdGltYXRlZCAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX3xcbi8vIHwgICAgIGFjdGl2ZSAoMikgICAgICAgfCAgIGJ1ZmZlcnMvY2FjaGUgKDUpICAgICB8IGZyZWUgKDMpICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKDEpICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4vL1xuLy8gUmVmZXJlbmNlOiBodHRwOi8vd3d3LnNvZnR3YXJlLWFyY2hpdGVjdC5uZXQvYmxvZy9hcnRpY2xlL2RhdGUvMjAxNS8wNi8xMi8tODI2YzZlNTA1Mi5odG1sXG5cbi8vIC9wcm9jcy9tZW1pbmZvIC0gc2FtcGxlIChhbGwgaW4ga0IpXG4vL1xuLy8gTWVtVG90YWw6IDMyODA2MzgwIGtCXG4vLyBNZW1GcmVlOiAxNzk3Nzc0NCBrQlxuLy8gTWVtQXZhaWxhYmxlOiAxOTc2ODk3MiBrQlxuLy8gQnVmZmVyczogNTE3MDI4IGtCXG4vLyBDYWNoZWQ6IDIxNjE4NzYga0Jcbi8vIFN3YXBDYWNoZWQ6IDQ1NiBrQlxuLy8gQWN0aXZlOiAxMjA4MTE3NiBrQlxuLy8gSW5hY3RpdmU6IDIxNjQ2MTYga0Jcbi8vIEFjdGl2ZShhbm9uKTogMTA4MzI4ODQga0Jcbi8vIEluYWN0aXZlKGFub24pOiAxNDc3MjcyIGtCXG4vLyBBY3RpdmUoZmlsZSk6IDEyNDgyOTIga0Jcbi8vIEluYWN0aXZlKGZpbGUpOiA2ODczNDQga0Jcbi8vIFVuZXZpY3RhYmxlOiAwIGtCXG4vLyBNbG9ja2VkOiAwIGtCXG4vLyBTd2FwVG90YWw6IDE2NzY4ODkyIGtCXG4vLyBTd2FwRnJlZTogMTY3NjgzMDQga0Jcbi8vIERpcnR5OiAyNjgga0Jcbi8vIFdyaXRlYmFjazogMCBrQlxuLy8gQW5vblBhZ2VzOiAxMTU2ODgzMiBrQlxuLy8gTWFwcGVkOiA3MTk5OTIga0Jcbi8vIFNobWVtOiA3NDMyNzIga0Jcbi8vIFNsYWI6IDMzNTcxNiBrQlxuLy8gU1JlY2xhaW1hYmxlOiAyNTYzNjQga0Jcbi8vIFNVbnJlY2xhaW06IDc5MzUyIGtCXG5cbmZ1bmN0aW9uIG1lbShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICB0b3RhbDogb3MudG90YWxtZW0oKSxcbiAgICAgICAgZnJlZTogb3MuZnJlZW1lbSgpLFxuICAgICAgICB1c2VkOiBvcy50b3RhbG1lbSgpIC0gb3MuZnJlZW1lbSgpLFxuXG4gICAgICAgIGFjdGl2ZTogb3MudG90YWxtZW0oKSAtIG9zLmZyZWVtZW0oKSwgICAgIC8vIHRlbXBvcmFyaWx5IChmYWxsYmFjaylcbiAgICAgICAgYXZhaWxhYmxlOiBvcy5mcmVlbWVtKCksICAgICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgKGZhbGxiYWNrKVxuICAgICAgICBidWZmZXJzOiAwLFxuICAgICAgICBjYWNoZWQ6IDAsXG4gICAgICAgIHNsYWI6IDAsXG4gICAgICAgIGJ1ZmZjYWNoZTogMCxcblxuICAgICAgICBzd2FwdG90YWw6IDAsXG4gICAgICAgIHN3YXB1c2VkOiAwLFxuICAgICAgICBzd2FwZnJlZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBmcy5yZWFkRmlsZSgnL3Byb2MvbWVtaW5mbycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQudG90YWwgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWVtdG90YWwnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LnRvdGFsID0gcmVzdWx0LnRvdGFsID8gcmVzdWx0LnRvdGFsICogMTAyNCA6IG9zLnRvdGFsbWVtKCk7XG4gICAgICAgICAgICByZXN1bHQuZnJlZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZW1mcmVlJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5mcmVlID0gcmVzdWx0LmZyZWUgPyByZXN1bHQuZnJlZSAqIDEwMjQgOiBvcy5mcmVlbWVtKCk7XG4gICAgICAgICAgICByZXN1bHQudXNlZCA9IHJlc3VsdC50b3RhbCAtIHJlc3VsdC5mcmVlO1xuXG4gICAgICAgICAgICByZXN1bHQuYnVmZmVycyA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdidWZmZXJzJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5idWZmZXJzID0gcmVzdWx0LmJ1ZmZlcnMgPyByZXN1bHQuYnVmZmVycyAqIDEwMjQgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LmNhY2hlZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYWNoZWQnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmNhY2hlZCA9IHJlc3VsdC5jYWNoZWQgPyByZXN1bHQuY2FjaGVkICogMTAyNCA6IDA7XG4gICAgICAgICAgICByZXN1bHQuc2xhYiA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzbGFiJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5zbGFiID0gcmVzdWx0LnNsYWIgPyByZXN1bHQuc2xhYiAqIDEwMjQgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LmJ1ZmZjYWNoZSA9IHJlc3VsdC5idWZmZXJzICsgcmVzdWx0LmNhY2hlZCArIHJlc3VsdC5zbGFiO1xuXG4gICAgICAgICAgICBsZXQgYXZhaWxhYmxlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21lbWF2YWlsYWJsZScpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuYXZhaWxhYmxlID0gYXZhaWxhYmxlID8gYXZhaWxhYmxlICogMTAyNCA6IHJlc3VsdC5mcmVlICsgcmVzdWx0LmJ1ZmZjYWNoZTtcbiAgICAgICAgICAgIHJlc3VsdC5hY3RpdmUgPSByZXN1bHQudG90YWwgLSByZXN1bHQuYXZhaWxhYmxlO1xuXG4gICAgICAgICAgICByZXN1bHQuc3dhcHRvdGFsID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N3YXB0b3RhbCcpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuc3dhcHRvdGFsID0gcmVzdWx0LnN3YXB0b3RhbCA/IHJlc3VsdC5zd2FwdG90YWwgKiAxMDI0IDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwZnJlZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzd2FwZnJlZScpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuc3dhcGZyZWUgPSByZXN1bHQuc3dhcGZyZWUgPyByZXN1bHQuc3dhcGZyZWUgKiAxMDI0IDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdXNlZCA9IHJlc3VsdC5zd2FwdG90YWwgLSByZXN1bHQuc3dhcGZyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJy9zYmluL3N5c2N0bCBody5yZWFsbWVtIGh3LnBoeXNtZW0gdm0uc3RhdHMudm0udl9wYWdlX2NvdW50IHZtLnN0YXRzLnZtLnZfd2lyZV9jb3VudCB2bS5zdGF0cy52bS52X2FjdGl2ZV9jb3VudCB2bS5zdGF0cy52bS52X2luYWN0aXZlX2NvdW50IHZtLnN0YXRzLnZtLnZfY2FjaGVfY291bnQgdm0uc3RhdHMudm0udl9mcmVlX2NvdW50IHZtLnN0YXRzLnZtLnZfcGFnZV9zaXplJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBwYWdlc2l6ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2bS5zdGF0cy52bS52X3BhZ2Vfc2l6ZScpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBpbmFjdGl2ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2bS5zdGF0cy52bS52X2luYWN0aXZlX2NvdW50JyksIDEwKSAqIHBhZ2VzaXplO1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm0uc3RhdHMudm0udl9jYWNoZV9jb3VudCcpLCAxMCkgKiBwYWdlc2l6ZTtcblxuICAgICAgICAgICAgcmVzdWx0LnRvdGFsID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LnJlYWxtZW0nKSwgMTApO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdC50b3RhbCkpIHsgcmVzdWx0LnRvdGFsID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LnBoeXNtZW0nKSwgMTApOyB9XG4gICAgICAgICAgICByZXN1bHQuZnJlZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2bS5zdGF0cy52bS52X2ZyZWVfY291bnQnKSwgMTApICogcGFnZXNpemU7XG4gICAgICAgICAgICByZXN1bHQuYnVmZmNhY2hlID0gaW5hY3RpdmUgKyBjYWNoZTtcbiAgICAgICAgICAgIHJlc3VsdC5hdmFpbGFibGUgPSByZXN1bHQuYnVmZmNhY2hlICsgcmVzdWx0LmZyZWU7XG4gICAgICAgICAgICByZXN1bHQuYWN0aXZlID0gcmVzdWx0LnRvdGFsIC0gcmVzdWx0LmZyZWUgLSByZXN1bHQuYnVmZmNhY2hlO1xuXG4gICAgICAgICAgICByZXN1bHQuc3dhcHRvdGFsID0gMDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwZnJlZSA9IDA7XG4gICAgICAgICAgICByZXN1bHQuc3dhcHVzZWQgPSAwO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IHBhZ2VTaXplID0gNDA5NjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc3lzUHBhZ2VTaXplID0gdXRpbC50b0ludChleGVjU3luYygnc3lzY3RsIC1uIHZtLnBhZ2VzaXplJykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgcGFnZVNpemUgPSBzeXNQcGFnZVNpemUgfHwgcGFnZVNpemU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBleGVjKCd2bV9zdGF0IDI+L2Rldi9udWxsIHwgZ3JlcCBcIlBhZ2VzIGFjdGl2ZVwiJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5hY3RpdmUgPSBwYXJzZUludChsaW5lc1swXS5zcGxpdCgnOicpWzFdLCAxMCkgKiBwYWdlU2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5idWZmY2FjaGUgPSByZXN1bHQudXNlZCAtIHJlc3VsdC5hY3RpdmU7XG4gICAgICAgICAgICByZXN1bHQuYXZhaWxhYmxlID0gcmVzdWx0LmZyZWUgKyByZXN1bHQuYnVmZmNhY2hlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjKCdzeXNjdGwgLW4gdm0uc3dhcHVzYWdlIDI+L2Rldi9udWxsJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdGxpbmUgPSBsaW5lc1swXS5yZXBsYWNlKC8sL2csICcuJykucmVwbGFjZSgvTS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVBcnJheSA9IGZpcnN0bGluZS50cmltKCkuc3BsaXQoJyAgJyk7XG4gICAgICAgICAgICAgICAgbGluZUFycmF5LmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3RvdGFsJykgIT09IC0xKSB7IHJlc3VsdC5zd2FwdG90YWwgPSBwYXJzZUZsb2F0KGxpbmUuc3BsaXQoJz0nKVsxXS50cmltKCkpICogMTAyNCAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndXNlZCcpICE9PSAtMSkgeyByZXN1bHQuc3dhcHVzZWQgPSBwYXJzZUZsb2F0KGxpbmUuc3BsaXQoJz0nKVsxXS50cmltKCkpICogMTAyNCAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZnJlZScpICE9PSAtMSkgeyByZXN1bHQuc3dhcGZyZWUgPSBwYXJzZUZsb2F0KGxpbmUuc3BsaXQoJz0nKVsxXS50cmltKCkpICogMTAyNCAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IHN3YXB0b3RhbCA9IDA7XG4gICAgICAgIGxldCBzd2FwdXNlZCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUGFnZUZpbGVVc2FnZSB8IFNlbGVjdCBBbGxvY2F0ZWRCYXNlU2l6ZSwgQ3VycmVudFVzYWdlJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJykuZmlsdGVyKChsaW5lLCBpZHgpID0+IGlkeCA+IDApO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCkuc3BsaXQoL1xcc1xccysvKTtcbiAgICAgICAgICAgICAgICAgIHN3YXB0b3RhbCA9IHN3YXB0b3RhbCArIChwYXJzZUludChsaW5lWzBdLCAxMCkgfHwgMCk7XG4gICAgICAgICAgICAgICAgICBzd2FwdXNlZCA9IHN3YXB1c2VkICsgKHBhcnNlSW50KGxpbmVbMV0sIDEwKSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnN3YXB0b3RhbCA9IHN3YXB0b3RhbCAqIDEwMjQgKiAxMDI0O1xuICAgICAgICAgICAgcmVzdWx0LnN3YXB1c2VkID0gc3dhcHVzZWQgKiAxMDI0ICogMTAyNDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwZnJlZSA9IHJlc3VsdC5zd2FwdG90YWwgLSByZXN1bHQuc3dhcHVzZWQ7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5tZW0gPSBtZW07XG5cbmZ1bmN0aW9uIG1lbUxheW91dChjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIGdldE1hbnVmYWN0dXJlckRhcndpbihtYW5JZCkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE9TWF9SQU1fbWFudWZhY3R1cmVycywgbWFuSWQpKSB7XG4gICAgICByZXR1cm4gKE9TWF9SQU1fbWFudWZhY3R1cmVyc1ttYW5JZF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFuSWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXJMaW51eChtYW5JZCkge1xuICAgIGNvbnN0IG1hbklkU2VhcmNoID0gbWFuSWQucmVwbGFjZSgnMHgnLCAnJykudG9VcHBlckNhc2UoKTtcbiAgICBpZiAobWFuSWRTZWFyY2gubGVuZ3RoID09PSA0ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoTElOVVhfUkFNX21hbnVmYWN0dXJlcnMsIG1hbklkU2VhcmNoKSkge1xuICAgICAgcmV0dXJuIChMSU5VWF9SQU1fbWFudWZhY3R1cmVyc1ttYW5JZFNlYXJjaF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFuSWQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgbWVtb3J5IDI+L2Rldi9udWxsIHwgZ3JlcCAtaUUgXCJTaXplOnxUeXBlfFNwZWVkfE1hbnVmYWN0dXJlcnxGb3JtIEZhY3RvcnxMb2NhdG9yfE1lbW9yeSBEZXZpY2V8U2VyaWFsIE51bWJlcnxWb2x0YWdlfFBhcnQgTnVtYmVyXCI7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGRldmljZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnTWVtb3J5IERldmljZScpO1xuICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZVN0cmluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaXplJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzaXplU3RyaW5nLmluZGV4T2YoJ0dCJykgPj0gMCA/IHBhcnNlSW50KHNpemVTdHJpbmcsIDEwKSAqIDEwMjQgKiAxMDI0ICogMTAyNCA6IHBhcnNlSW50KHNpemVTdHJpbmcsIDEwKSAqIDEwMjQgKiAxMDI0O1xuICAgICAgICAgICAgICBsZXQgYmFuayA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCYW5rIExvY2F0b3InKTtcbiAgICAgICAgICAgICAgaWYgKGJhbmsudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdiYWQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYmFuayA9ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2l6ZScpLCAxMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsIFdpZHRoJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFXaWR0aCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RhdGEgV2lkdGgnKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgIGJhbmssXG4gICAgICAgICAgICAgICAgICB0eXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHlwZTonKSxcbiAgICAgICAgICAgICAgICAgIGVjYzogZGF0YVdpZHRoICYmIHRvdGFsV2lkdGggPyB0b3RhbFdpZHRoID4gZGF0YVdpZHRoIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZ3VyZWQgQ2xvY2sgU3BlZWQ6JykgPyBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlndXJlZCBDbG9jayBTcGVlZDonKSwgMTApIDogKHV0aWwuZ2V0VmFsdWUobGluZXMsICdTcGVlZDonKSA/IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTcGVlZDonKSwgMTApIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Zvcm0gRmFjdG9yOicpLFxuICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiBnZXRNYW51ZmFjdHVyZXJMaW51eCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWFudWZhY3R1cmVyOicpKSxcbiAgICAgICAgICAgICAgICAgIHBhcnROdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYXJ0IE51bWJlcjonKSxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbCBOdW1iZXI6JyksXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlndXJlZCBWb2x0YWdlOicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWluaW11bSBWb2x0YWdlOicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1heDogcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWF4aW11bSBWb2x0YWdlOicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgICAgICBiYW5rLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0VtcHR5JyxcbiAgICAgICAgICAgICAgICAgIGVjYzogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IDAsXG4gICAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRm9ybSBGYWN0b3I6JyksXG4gICAgICAgICAgICAgICAgICBwYXJ0TnVtOiAnJyxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogJycsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIHNpemU6IG9zLnRvdGFsbWVtKCksXG4gICAgICAgICAgICAgIGJhbms6ICcnLFxuICAgICAgICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgICAgICAgZWNjOiBudWxsLFxuICAgICAgICAgICAgICBjbG9ja1NwZWVkOiAwLFxuICAgICAgICAgICAgICBmb3JtRmFjdG9yOiAnJyxcbiAgICAgICAgICAgICAgcGFydE51bTogJycsXG4gICAgICAgICAgICAgIHNlcmlhbE51bTogJycsXG4gICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBudWxsLFxuICAgICAgICAgICAgICB2b2x0YWdlTWluOiBudWxsLFxuICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBudWxsLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRyeSBSYXNwYmVycnkgUElcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxldCBzdGRvdXQgPSBleGVjU3luYygnY2F0IC9wcm9jL2NwdWluZm8gMj4vZGV2L251bGwnKTtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsZXQgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaGFyZHdhcmUnLCAnOicsIHRydWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3JldmlzaW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChtb2RlbCA9PT0gJ0JDTTI4MzUnIHx8IG1vZGVsID09PSAnQkNNMjcwOCcgfHwgbW9kZWwgPT09ICdCQ00yNzA5JyB8fCBtb2RlbCA9PT0gJ0JDTTI4MzUnIHx8IG1vZGVsID09PSAnQkNNMjgzNycpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb2NrU3BlZWQgPSB7XG4gICAgICAgICAgICAgICAgICAnMCc6IDQwMCxcbiAgICAgICAgICAgICAgICAgICcxJzogNDUwLFxuICAgICAgICAgICAgICAgICAgJzInOiA0NTAsXG4gICAgICAgICAgICAgICAgICAnMyc6IDMyMDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS50eXBlID0gJ0xQRERSMic7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLnR5cGUgPSB2ZXJzaW9uICYmIHZlcnNpb25bMl0gJiYgdmVyc2lvblsyXSA9PT0gJzMnID8gJ0xQRERSNCcgOiByZXN1bHRbMF0udHlwZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0uZWNjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLmNsb2NrU3BlZWQgPSB2ZXJzaW9uICYmIHZlcnNpb25bMl0gJiYgY2xvY2tTcGVlZFt2ZXJzaW9uWzJdXSB8fCA0MDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLmNsb2NrU3BlZWQgPSB2ZXJzaW9uICYmIHZlcnNpb25bNF0gJiYgdmVyc2lvbls0XSA9PT0gJ2QnID8gNTAwIDogcmVzdWx0WzBdLmNsb2NrU3BlZWQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLmZvcm1GYWN0b3IgPSAnU29DJztcblxuICAgICAgICAgICAgICAgIHN0ZG91dCA9IGV4ZWNTeW5jKCd2Y2dlbmNtZCBnZXRfY29uZmlnIHNkcmFtX2ZyZXEgMj4vZGV2L251bGwnKTtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJlcSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZHJhbV9mcmVxJywgJz0nLCB0cnVlKSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZyZXEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFswXS5jbG9ja1NwZWVkID0gZnJlcTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGRvdXQgPSBleGVjU3luYygndmNnZW5jbWQgbWVhc3VyZV92b2x0cyBzZHJhbV9wIDI+L2Rldi9udWxsJyk7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgbGV0IHZvbHRhZ2UgPSBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x0JywgJz0nLCB0cnVlKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAodm9sdGFnZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdLnZvbHRhZ2VDb25maWd1cmVkID0gdm9sdGFnZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFswXS52b2x0YWdlTWluID0gdm9sdGFnZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFswXS52b2x0YWdlTWF4ID0gdm9sdGFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzeXN0ZW1fcHJvZmlsZXIgU1BNZW1vcnlEYXRhVHlwZScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgYWxsTGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBlY2NTdGF0dXMgPSB1dGlsLmdldFZhbHVlKGFsbExpbmVzLCAnZWNjJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbGV0IGRldmljZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnICAgICAgICBCQU5LICcpO1xuICAgICAgICAgICAgbGV0IGhhc0JhbmsgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRldmljZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGRldmljZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnICAgICAgICBESU1NJyk7XG4gICAgICAgICAgICAgIGhhc0JhbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGJhbmsgPSAoaGFzQmFuayA/ICdCQU5LICcgOiAnRElNTScpICsgbGluZXNbMF0udHJpbSgpLnNwbGl0KCcvJylbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIFNpemUnKSk7XG4gICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSAqIDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICAgICAgICAgIGJhbms6IGJhbmssXG4gICAgICAgICAgICAgICAgICB0eXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIFR5cGU6JyksXG4gICAgICAgICAgICAgICAgICBlY2M6IGVjY1N0YXR1cyA/IGVjY1N0YXR1cyA9PT0gJ2VuYWJsZWQnIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgU3BlZWQ6JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6ICcnLFxuICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiBnZXRNYW51ZmFjdHVyZXJEYXJ3aW4odXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBNYW51ZmFjdHVyZXI6JykpLFxuICAgICAgICAgICAgICAgICAgcGFydE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBQYXJ0IE51bWJlcjonKSxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBTZXJpYWwgTnVtYmVyOicpLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1heDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgICAgICAgYmFuazogYmFuayxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdFbXB0eScsXG4gICAgICAgICAgICAgICAgICBlY2M6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiAwLFxuICAgICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogJycsXG4gICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICAgICAgICAgICAgcGFydE51bTogJycsXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06ICcnLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1heDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgIE1lbW9yeTonKSk7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgIFR5cGU6Jyk7XG4gICAgICAgICAgICBpZiAoc2l6ZSAmJiB0eXBlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplICogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgICAgICAgIGJhbms6ICcwJyxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGVjYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogMCxcbiAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiAnJyxcbiAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6ICdBcHBsZScsXG4gICAgICAgICAgICAgICAgcGFydE51bTogJycsXG4gICAgICAgICAgICAgICAgc2VyaWFsTnVtOiAnJyxcbiAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiBudWxsLFxuICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IG51bGwsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGNvbnN0IG1lbW9yeVR5cGVzID0gJ1Vua25vd258T3RoZXJ8RFJBTXxTeW5jaHJvbm91cyBEUkFNfENhY2hlIERSQU18RURPfEVEUkFNfFZSQU18U1JBTXxSQU18Uk9NfEZMQVNIfEVFUFJPTXxGRVBST018RVBST018Q0RSQU18M0RSQU18U0RSQU18U0dSQU18UkRSQU18RERSfEREUjJ8RERSMiBGQi1ESU1NfFJlc2VydmVkfEREUjN8RkJEMnxERFI0fExQRERSfExQRERSMnxMUEREUjN8TFBERFI0Jy5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCBGb3JtRmFjdG9ycyA9ICdVbmtub3dufE90aGVyfFNJUHxESVB8WklQfFNPSnxQcm9wcmlldGFyeXxTSU1NfERJTU18VFNPUHxQR0F8UklNTXxTT0RJTU18U1JJTU18U01EfFNTTVB8UUZQfFRRRlB8U09JQ3xMQ0N8UExDQ3xCR0F8RlBCR0F8TEdBJy5zcGxpdCgnfCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUGh5c2ljYWxNZW1vcnkgfCBzZWxlY3QgRGF0YVdpZHRoLFRvdGFsV2lkdGgsQ2FwYWNpdHksQmFua0xhYmVsLE1lbW9yeVR5cGUsU01CSU9TTWVtb3J5VHlwZSxDb25maWd1cmVkQ2xvY2tTcGVlZCxGb3JtRmFjdG9yLE1hbnVmYWN0dXJlcixQYXJ0TnVtYmVyLFNlcmlhbE51bWJlcixDb25maWd1cmVkVm9sdGFnZSxNaW5Wb2x0YWdlLE1heFZvbHRhZ2UgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhV2lkdGggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdEYXRhV2lkdGgnLCAnOicpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWxXaWR0aCcsICc6JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwYWNpdHknLCAnOicpLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgICBiYW5rOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQmFua0xhYmVsJywgJzonKSwgLy8gQmFua0xhYmVsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1lbW9yeVR5cGVzW3BhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNZW1vcnlUeXBlJywgJzonKSwgMTApIHx8IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTTUJJT1NNZW1vcnlUeXBlJywgJzonKSwgMTApXSxcbiAgICAgICAgICAgICAgICAgICAgZWNjOiBkYXRhV2lkdGggJiYgdG90YWxXaWR0aCA/IHRvdGFsV2lkdGggPiBkYXRhV2lkdGggOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZ3VyZWRDbG9ja1NwZWVkJywgJzonKSwgMTApIHx8IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTcGVlZCcsICc6JyksIDEwKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiBGb3JtRmFjdG9yc1twYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRm9ybUZhY3RvcicsICc6JyksIDEwKSB8fCAwXSxcbiAgICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWFudWZhY3R1cmVyJywgJzonKSxcbiAgICAgICAgICAgICAgICAgICAgcGFydE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhcnROdW1iZXInLCAnOicpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWxOdW1iZXInLCAnOicpLFxuICAgICAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogKHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWd1cmVkVm9sdGFnZScsICc6JyksIDEwKSB8fCAwKSAvIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogKHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNaW5Wb2x0YWdlJywgJzonKSwgMTApIHx8IDApIC8gMTAwMC4wLFxuICAgICAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiAocGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01heFZvbHRhZ2UnLCAnOicpLCAxMCkgfHwgMCkgLyAxMDAwLjAsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm1lbUxheW91dCA9IG1lbUxheW91dDtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBuZXR3b3JrLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gOS4gTmV0d29ya1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmxldCBfbmV0d29yayA9IHt9O1xubGV0IF9kZWZhdWx0X2lmYWNlID0gJyc7XG5sZXQgX2lmYWNlcyA9IHt9O1xubGV0IF9kaGNwTmljcyA9IFtdO1xubGV0IF9uZXR3b3JrSW50ZXJmYWNlcyA9IFtdO1xubGV0IF9tYWMgPSB7fTtcbmxldCBwYXRoVG9JcDtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKSB7XG5cbiAgbGV0IGlmYWNlbmFtZSA9ICcnO1xuICBsZXQgaWZhY2VuYW1lRmlyc3QgPSAnJztcbiAgdHJ5IHtcbiAgICBsZXQgaWZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcblxuICAgIGxldCBzY29wZWlkID0gOTk5OTtcblxuICAgIC8vIGZhbGxiYWNrIC0gXCJmaXJzdFwiIGV4dGVybmFsIGludGVyZmFjZSAoc29ydGVkIGJ5IHNjb3BlaWQpXG4gICAgZm9yIChsZXQgZGV2IGluIGlmYWNlcykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBkZXYpKSB7XG4gICAgICAgIGlmYWNlc1tkZXZdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLmludGVybmFsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWZhY2VuYW1lRmlyc3QgPSBpZmFjZW5hbWVGaXJzdCB8fCBkZXY7IC8vIGZhbGxiYWNrIGlmIG5vIHNjb3BlaWRcbiAgICAgICAgICAgIGlmIChkZXRhaWxzLnNjb3BlaWQgJiYgZGV0YWlscy5zY29wZWlkIDwgc2NvcGVpZCkge1xuICAgICAgICAgICAgICBpZmFjZW5hbWUgPSBkZXY7XG4gICAgICAgICAgICAgIHNjb3BlaWQgPSBkZXRhaWxzLnNjb3BlaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWZhY2VuYW1lID0gaWZhY2VuYW1lIHx8IGlmYWNlbmFtZUZpcnN0IHx8ICcnO1xuXG4gICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAvLyBodHRwczovL3d3dy5pbmV0ZGFlbW9uLmNvbS90dXRvcmlhbHMvaW50ZXJuZXQvaXAvcm91dGluZy9kZWZhdWx0X3JvdXRlLnNodG1sXG4gICAgICBsZXQgZGVmYXVsdElwID0gJyc7XG4gICAgICBjb25zdCBjbWQgPSAnbmV0c3RhdCAtcic7XG4gICAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhjbWQsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgICAgY29uc3QgbGluZXMgPSByZXN1bHQudG9TdHJpbmcoKS5zcGxpdChvcy5FT0wpO1xuICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignMC4wLjAuMCAwLjAuMC4wJykgPiAtMSAmJiAhKC9bYS16QS1aXS8udGVzdChsaW5lKSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgIGRlZmF1bHRJcCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGVmYXVsdElwKSB7XG4gICAgICAgIGZvciAobGV0IGRldiBpbiBpZmFjZXMpIHtcbiAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIGRldikpIHtcbiAgICAgICAgICAgIGlmYWNlc1tkZXZdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5hZGRyZXNzICYmIGRldGFpbHMuYWRkcmVzcyA9PT0gZGVmYXVsdElwKSB7XG4gICAgICAgICAgICAgICAgaWZhY2VuYW1lID0gZGV2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9saW51eCkge1xuICAgICAgbGV0IGNtZCA9ICdpcCByb3V0ZSAyPiAvZGV2L251bGwgfCBncmVwIGRlZmF1bHQnO1xuICAgICAgbGV0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCk7XG4gICAgICBsZXQgcGFydHMgPSByZXN1bHQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0uc3BsaXQoL1xccysvKTtcbiAgICAgIGlmIChwYXJ0c1swXSA9PT0gJ25vbmUnICYmIHBhcnRzWzVdKSB7XG4gICAgICAgIGlmYWNlbmFtZSA9IHBhcnRzWzVdO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0c1s0XSkge1xuICAgICAgICBpZmFjZW5hbWUgPSBwYXJ0c1s0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlmYWNlbmFtZS5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICBpZmFjZW5hbWUgPSBpZmFjZW5hbWUuc3BsaXQoJzonKVsxXS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGFyd2luIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX3N1bm9zKSB7XG4gICAgICBsZXQgY21kID0gJyc7XG4gICAgICBpZiAoX2xpbnV4KSB7IGNtZCA9ICdpcCByb3V0ZSAyPiAvZGV2L251bGwgfCBncmVwIGRlZmF1bHQgfCBhd2sgXFwne3ByaW50ICQ1fVxcJyc7IH1cbiAgICAgIGlmIChfZGFyd2luKSB7IGNtZCA9ICdyb3V0ZSAtbiBnZXQgZGVmYXVsdCAyPi9kZXYvbnVsbCB8IGdyZXAgaW50ZXJmYWNlOiB8IGF3ayBcXCd7cHJpbnQgJDJ9XFwnJzsgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX3N1bm9zKSB7IGNtZCA9ICdyb3V0ZSBnZXQgMC4wLjAuMCB8IGdyZXAgaW50ZXJmYWNlOic7IH1cbiAgICAgIGxldCByZXN1bHQgPSBleGVjU3luYyhjbWQpO1xuICAgICAgaWZhY2VuYW1lID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgaWYgKGlmYWNlbmFtZS5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICBpZmFjZW5hbWUgPSBpZmFjZW5hbWUuc3BsaXQoJzonKVsxXS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgaWYgKGlmYWNlbmFtZSkgeyBfZGVmYXVsdF9pZmFjZSA9IGlmYWNlbmFtZTsgfVxuICByZXR1cm4gX2RlZmF1bHRfaWZhY2U7XG59XG5cbmV4cG9ydHMuZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UgPSBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZTtcblxuZnVuY3Rpb24gZ2V0TWFjQWRkcmVzc2VzKCkge1xuICBsZXQgaWZhY2UgPSAnJztcbiAgbGV0IG1hYyA9ICcnO1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgIGlmICh0eXBlb2YgcGF0aFRvSXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKCd3aGljaCBpcCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLmluZGV4T2YoJzonKSA9PT0gLTEgJiYgbGluZXNbMF0uaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgICAgcGF0aFRvSXAgPSBsaW5lc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoVG9JcCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHBhdGhUb0lwID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyAnICsgKChwYXRoVG9JcCkgPyBwYXRoVG9JcCArICcgbGluayBzaG93IHVwJyA6ICcvc2Jpbi9pZmNvbmZpZycpICsgJzsgdW5zZXQgTENfQUxMJztcbiAgICAgIGxldCByZXMgPSBleGVjU3luYyhjbWQpO1xuICAgICAgY29uc3QgbGluZXMgPSByZXMudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXSAmJiBsaW5lc1tpXVswXSAhPT0gJyAnKSB7XG4gICAgICAgICAgaWYgKHBhdGhUb0lwKSB7XG4gICAgICAgICAgICBsZXQgbmV4dGxpbmUgPSBsaW5lc1tpICsgMV0udHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpZiAobmV4dGxpbmVbMF0gPT09ICdsaW5rL2V0aGVyJykge1xuICAgICAgICAgICAgICBpZmFjZSA9IGxpbmVzW2ldLnNwbGl0KCcgJylbMV07XG4gICAgICAgICAgICAgIGlmYWNlID0gaWZhY2Uuc2xpY2UoMCwgaWZhY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIG1hYyA9IG5leHRsaW5lWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZmFjZSA9IGxpbmVzW2ldLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICBtYWMgPSBsaW5lc1tpXS5zcGxpdCgnSFdhZGRyICcpWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpZmFjZSAmJiBtYWMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpZmFjZV0gPSBtYWMudHJpbSgpO1xuICAgICAgICAgICAgaWZhY2UgPSAnJztcbiAgICAgICAgICAgIG1hYyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfVxuICBpZiAoX2Rhcndpbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbWQgPSAnL3NiaW4vaWZjb25maWcnO1xuICAgICAgbGV0IHJlcyA9IGV4ZWNTeW5jKGNtZCk7XG4gICAgICBjb25zdCBsaW5lcyA9IHJlcy50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldICYmIGxpbmVzW2ldWzBdICE9PSAnXFx0JyAmJiBsaW5lc1tpXS5pbmRleE9mKCc6JykgPiAwKSB7XG4gICAgICAgICAgaWZhY2UgPSBsaW5lc1tpXS5zcGxpdCgnOicpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmVzW2ldLmluZGV4T2YoJ1xcdGV0aGVyICcpID09PSAwKSB7XG4gICAgICAgICAgbWFjID0gbGluZXNbaV0uc3BsaXQoJ1xcdGV0aGVyICcpWzFdO1xuICAgICAgICAgIGlmIChpZmFjZSAmJiBtYWMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpZmFjZV0gPSBtYWMudHJpbSgpO1xuICAgICAgICAgICAgaWZhY2UgPSAnJztcbiAgICAgICAgICAgIG1hYyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrSW50ZXJmYWNlRGVmYXVsdChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlRGVmYXVsdCA9IG5ldHdvcmtJbnRlcmZhY2VEZWZhdWx0O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTkVUIC0gaW50ZXJmYWNlc1xuXG5mdW5jdGlvbiBwYXJzZUxpbmVzV2luZG93c05pY3Moc2VjdGlvbnMsIG5jb25maWdzZWN0aW9ucykge1xuICBsZXQgbmljcyA9IFtdO1xuICBmb3IgKGxldCBpIGluIHNlY3Rpb25zKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoc2VjdGlvbnMsIGkpKSB7XG5cbiAgICAgIGlmIChzZWN0aW9uc1tpXS50cmltKCkgIT09ICcnKSB7XG5cbiAgICAgICAgbGV0IGxpbmVzID0gc2VjdGlvbnNbaV0udHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgbGV0IGxpbmVzTmljQ29uZmlnID0gbmNvbmZpZ3NlY3Rpb25zICYmIG5jb25maWdzZWN0aW9uc1tpXSA/IG5jb25maWdzZWN0aW9uc1tpXS50cmltKCkuc3BsaXQoJ1xcclxcbicpIDogW107XG4gICAgICAgIGxldCBuZXRFbmFibGVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05ldEVuYWJsZWQnLCAnOicpO1xuICAgICAgICBsZXQgYWRhcHRlclR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQWRhcHRlclR5cGVJRCcsICc6JykgPT09ICc5JyA/ICd3aXJlbGVzcycgOiAnd2lyZWQnO1xuICAgICAgICBsZXQgaWZhY2VuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05hbWUnLCAnOicpLnJlcGxhY2UoL1xcXS9nLCAnKScpLnJlcGxhY2UoL1xcWy9nLCAnKCcpO1xuICAgICAgICBsZXQgaWZhY2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmV0Q29ubmVjdGlvbklEJywgJzonKS5yZXBsYWNlKC9cXF0vZywgJyknKS5yZXBsYWNlKC9cXFsvZywgJygnKTtcbiAgICAgICAgaWYgKGlmYWNlbmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpLWZpJykgPj0gMCB8fCBpZmFjZW5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aXJlbGVzcycpID49IDApIHtcbiAgICAgICAgICBhZGFwdGVyVHlwZSA9ICd3aXJlbGVzcyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldEVuYWJsZWQgIT09ICcnKSB7XG4gICAgICAgICAgY29uc3Qgc3BlZWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3BlZWQnLCAnOicpLnRyaW0oKSwgMTApIC8gMTAwMDAwMDtcbiAgICAgICAgICBuaWNzLnB1c2goe1xuICAgICAgICAgICAgbWFjOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTUFDQWRkcmVzcycsICc6JykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGRoY3A6IHV0aWwuZ2V0VmFsdWUobGluZXNOaWNDb25maWcsICdkaGNwRW5hYmxlZCcsICc6JykudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgbmFtZTogaWZhY2VuYW1lLFxuICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICBuZXRFbmFibGVkOiBuZXRFbmFibGVkID09PSAnVFJVRScsXG4gICAgICAgICAgICBzcGVlZDogaXNOYU4oc3BlZWQpID8gbnVsbCA6IHNwZWVkLFxuICAgICAgICAgICAgb3BlcnN0YXRlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmV0Q29ubmVjdGlvblN0YXR1cycsICc6JykgPT09ICcyJyA/ICd1cCcgOiAnZG93bicsXG4gICAgICAgICAgICB0eXBlOiBhZGFwdGVyVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuaWNzO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzTmljcygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgY21kID0gJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9OZXR3b3JrQWRhcHRlciB8IGZsIConICsgJzsgZWNobyBcXCcjLSMtIy0jXFwnOyc7XG4gICAgICBjbWQgKz0gJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9OZXR3b3JrQWRhcHRlckNvbmZpZ3VyYXRpb24gfCBmbCBESENQRW5hYmxlZCcgKyAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbChjbWQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnIy0jLSMtIycpO1xuICAgICAgICAgIGNvbnN0IG5zZWN0aW9ucyA9IChkYXRhWzBdIHx8ICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgIGNvbnN0IG5jb25maWdzZWN0aW9ucyA9IChkYXRhWzFdIHx8ICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgIHJlc29sdmUocGFyc2VMaW5lc1dpbmRvd3NOaWNzKG5zZWN0aW9ucywgbmNvbmZpZ3NlY3Rpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NETlNzdWZmaXhlcygpIHtcblxuICBsZXQgaWZhY2UgPSB7fTtcblxuICBsZXQgZG5zU3VmZml4ZXMgPSB7XG4gICAgcHJpbWFyeUROUzogJycsXG4gICAgZXhpdENvZGU6IDAsXG4gICAgaWZhY2VzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IGlwY29uZmlnID0gZXhlY1N5bmMoJ2lwY29uZmlnIC9hbGwnLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICBjb25zdCBpcGNvbmZpZ0FycmF5ID0gaXBjb25maWcuc3BsaXQoJ1xcclxcblxcclxcbicpO1xuXG4gICAgaXBjb25maWdBcnJheS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuXG4gICAgICBpZiAoaW5kZXggPT0gMSkge1xuICAgICAgICBjb25zdCBsb25nUHJpbWFyeUROUyA9IGVsZW1lbnQuc3BsaXQoJ1xcclxcbicpLmZpbHRlcigoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0ROUycpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUROUyA9IGxvbmdQcmltYXJ5RE5TWzBdLnN1YnN0cmluZyhsb25nUHJpbWFyeUROU1swXS5sYXN0SW5kZXhPZignOicpICsgMSk7XG4gICAgICAgIGRuc1N1ZmZpeGVzLnByaW1hcnlETlMgPSBwcmltYXJ5RE5TLnRyaW0oKTtcbiAgICAgICAgaWYgKCFkbnNTdWZmaXhlcy5wcmltYXJ5RE5TKSB7IGRuc1N1ZmZpeGVzLnByaW1hcnlETlMgPSAnTm90IGRlZmluZWQnOyB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPiAxKSB7XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50LnN1YnN0cmluZyhlbGVtZW50Lmxhc3RJbmRleE9mKCcgJykgKyAxKS5yZXBsYWNlKCc6JywgJycpO1xuICAgICAgICAgIGlmYWNlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TcGVjaWZpY0ROUyA9IGVsZW1lbnQuc3BsaXQoJ1xcclxcbicpLmZpbHRlcigoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9VcHBlckNhc2UoKS5pbmNsdWRlcygnRE5TJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZG5zU3VmZml4ID0gY29ubmVjdGlvblNwZWNpZmljRE5TWzBdLnN1YnN0cmluZyhjb25uZWN0aW9uU3BlY2lmaWNETlNbMF0ubGFzdEluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICAgIGlmYWNlLmRuc1N1ZmZpeCA9IGRuc1N1ZmZpeC50cmltKCk7XG4gICAgICAgICAgZG5zU3VmZml4ZXMuaWZhY2VzLnB1c2goaWZhY2UpO1xuICAgICAgICAgIGlmYWNlID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkbnNTdWZmaXhlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpbWFyeUROUzogJycsXG4gICAgICBleGl0Q29kZTogMCxcbiAgICAgIGlmYWNlczogW10sXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzSWZhY2VETlNzdWZmaXgoaWZhY2VzLCBpZmFjZW5hbWUpIHtcbiAgbGV0IGRuc1N1ZmZpeCA9ICcnO1xuICAvLyBBZGRpbmcgKC4pIHRvIGVuc3VyZSBpZmFjZW5hbWUgY29tcGF0aWJpbGl0eSB3aGVuIGR1cGxpY2F0ZWQgaWZhY2UtbmFtZXNcbiAgY29uc3QgaW50ZXJmYWNlTmFtZSA9IGlmYWNlbmFtZSArICcuJztcbiAgdHJ5IHtcbiAgICBjb25zdCBjb25uZWN0aW9uRG5zU3VmZml4ID0gaWZhY2VzLmZpbHRlcigoaWZhY2UpID0+IHtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VOYW1lLmluY2x1ZGVzKGlmYWNlLm5hbWUgKyAnLicpO1xuICAgIH0pLm1hcCgoaWZhY2UpID0+IGlmYWNlLmRuc1N1ZmZpeCk7XG4gICAgaWYgKGNvbm5lY3Rpb25EbnNTdWZmaXhbMF0pIHtcbiAgICAgIGRuc1N1ZmZpeCA9IGNvbm5lY3Rpb25EbnNTdWZmaXhbMF07XG4gICAgfVxuICAgIGlmICghZG5zU3VmZml4KSB7IGRuc1N1ZmZpeCA9ICcnOyB9XG4gICAgcmV0dXJuIGRuc1N1ZmZpeDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NXaXJlZFByb2ZpbGVzSW5mb3JtYXRpb24oKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoJ25ldHNoIGxhbiBzaG93IHByb2ZpbGVzJywgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgY29uc3QgcHJvZmlsZUxpc3QgPSByZXN1bHQuc3BsaXQoJ1xcclxcblByb2ZpbGUgb24gaW50ZXJmYWNlJyk7XG4gICAgcmV0dXJuIHByb2ZpbGVMaXN0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDEgJiYgZXJyb3Iuc3Rkb3V0LmluY2x1ZGVzKCdBdXRvQ29uZmlnJykpIHtcbiAgICAgIHJldHVybiAnRGlzYWJsZWQnO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c1dpcmVsZXNzSWZhY2VTU0lEKGludGVyZmFjZU5hbWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhgbmV0c2ggd2xhbiBzaG93ICBpbnRlcmZhY2UgbmFtZT1cIiR7aW50ZXJmYWNlTmFtZX1cIiB8IGZpbmRzdHIgXCJTU0lEXCJgLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICBjb25zdCBTU0lEID0gcmVzdWx0LnNwbGl0KCdcXHJcXG4nKS5zaGlmdCgpO1xuICAgIGNvbnN0IHBhcnNlU1NJRCA9IFNTSUQuc3BsaXQoJzonKS5wb3AoKTtcbiAgICByZXR1cm4gcGFyc2VTU0lEO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnVW5rbm93bic7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFdpbmRvd3NJRUVFODAyMXgoY29ubmVjdGlvblR5cGUsIGlmYWNlLCBpZmFjZXMpIHtcbiAgbGV0IGk4MDIxeCA9IHtcbiAgICBzdGF0ZTogJ1Vua25vd24nLFxuICAgIHByb3RvY29sOiAnVW5rbm93bicsXG4gIH07XG5cbiAgaWYgKGlmYWNlcyA9PT0gJ0Rpc2FibGVkJykge1xuICAgIGk4MDIxeC5zdGF0ZSA9ICdEaXNhYmxlZCc7XG4gICAgaTgwMjF4LnByb3RvY29sID0gJ05vdCBkZWZpbmVkJztcbiAgICByZXR1cm4gaTgwMjF4O1xuICB9XG5cbiAgaWYgKGNvbm5lY3Rpb25UeXBlID09ICd3aXJlZCcgJiYgaWZhY2VzLmxlbmd0aCA+IDApIHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IDgwMi4xeCBpbmZvcm1hdGlvbiBieSBpbnRlcmZhY2UgbmFtZVxuICAgICAgY29uc3QgaWZhY2U4MDIxeEluZm8gPSBpZmFjZXMuZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pbmNsdWRlcyhpZmFjZSArICdcXHJcXG4nKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXJyYXlJZmFjZTgwMjF4SW5mbyA9IGlmYWNlODAyMXhJbmZvLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgIGNvbnN0IHN0YXRlODAyMXggPSBhcnJheUlmYWNlODAyMXhJbmZvLmZpbmQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaW5jbHVkZXMoJzgwMi4xeCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdGF0ZTgwMjF4LmluY2x1ZGVzKCdEaXNhYmxlZCcpKSB7XG4gICAgICAgIGk4MDIxeC5zdGF0ZSA9ICdEaXNhYmxlZCc7XG4gICAgICAgIGk4MDIxeC5wcm90b2NvbCA9ICdOb3QgZGVmaW5lZCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlODAyMXguaW5jbHVkZXMoJ0VuYWJsZWQnKSkge1xuICAgICAgICBjb25zdCBwcm90b2NvbDgwMjF4ID0gYXJyYXlJZmFjZTgwMjF4SW5mby5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaW5jbHVkZXMoJ0VBUCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaTgwMjF4LnByb3RvY29sID0gcHJvdG9jb2w4MDIxeC5zcGxpdCgnOicpLnBvcCgpO1xuICAgICAgICBpODAyMXguc3RhdGUgPSAnRW5hYmxlZCc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBpODAyMXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25UeXBlID09ICd3aXJlbGVzcycpIHtcblxuICAgIGxldCBpODAyMXhTdGF0ZSA9ICcnO1xuICAgIGxldCBpODAyMXhQcm90b2NvbCA9ICcnO1xuXG5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBTU0lEID0gZ2V0V2luZG93c1dpcmVsZXNzSWZhY2VTU0lEKGlmYWNlKTtcbiAgICAgIGlmIChTU0lEICE9PSAnVW5rbm93bicpIHtcbiAgICAgICAgaTgwMjF4U3RhdGUgPSBleGVjU3luYyhgbmV0c2ggd2xhbiBzaG93IHByb2ZpbGVzIFwiJHtTU0lEfVwiIHwgZmluZHN0ciBcIjgwMi4xWFwiYCwgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgICAgIGk4MDIxeFByb3RvY29sID0gZXhlY1N5bmMoYG5ldHNoIHdsYW4gc2hvdyBwcm9maWxlcyBcIiR7U1NJRH1cIiB8IGZpbmRzdHIgXCJFQVBcImAsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaTgwMjF4U3RhdGUuaW5jbHVkZXMoJzonKSAmJiBpODAyMXhQcm90b2NvbC5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIGk4MDIxeC5zdGF0ZSA9IGk4MDIxeFN0YXRlLnNwbGl0KCc6JykucG9wKCk7XG4gICAgICAgIGk4MDIxeC5wcm90b2NvbCA9IGk4MDIxeFByb3RvY29sLnNwbGl0KCc6JykucG9wKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDEgJiYgZXJyb3Iuc3Rkb3V0LmluY2x1ZGVzKCdBdXRvQ29uZmlnJykpIHtcbiAgICAgICAgaTgwMjF4LnN0YXRlID0gJ0Rpc2FibGVkJztcbiAgICAgICAgaTgwMjF4LnByb3RvY29sID0gJ05vdCBkZWZpbmVkJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpODAyMXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk4MDIxeDtcbn1cblxuZnVuY3Rpb24gc3BsaXRTZWN0aW9uc05pY3MobGluZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzZWN0aW9uID0gW107XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAoIWxpbmUuc3RhcnRzV2l0aCgnXFx0JykgJiYgIWxpbmUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICBpZiAoc2VjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2VjdGlvbik7XG4gICAgICAgIHNlY3Rpb24gPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VjdGlvbi5wdXNoKGxpbmUpO1xuICB9KTtcbiAgaWYgKHNlY3Rpb24ubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goc2VjdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW5lc0Rhcndpbk5pY3Moc2VjdGlvbnMpIHtcbiAgbGV0IG5pY3MgPSBbXTtcbiAgc2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICBsZXQgbmljID0ge1xuICAgICAgaWZhY2U6ICcnLFxuICAgICAgbXR1OiBudWxsLFxuICAgICAgbWFjOiAnJyxcbiAgICAgIGlwNjogJycsXG4gICAgICBpcDQ6ICcnLFxuICAgICAgc3BlZWQ6IG51bGwsXG4gICAgICB0eXBlOiAnJyxcbiAgICAgIG9wZXJzdGF0ZTogJycsXG4gICAgICBkdXBsZXg6ICcnLFxuICAgICAgaW50ZXJuYWw6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBmaXJzdCA9IHNlY3Rpb25bMF07XG4gICAgbmljLmlmYWNlID0gZmlyc3Quc3BsaXQoJzonKVswXS50cmltKCk7XG4gICAgbGV0IHBhcnRzID0gZmlyc3Quc3BsaXQoJz4gbXR1Jyk7XG4gICAgbmljLm10dSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJzZUludChwYXJ0c1sxXSwgMTApIDogbnVsbDtcbiAgICBpZiAoaXNOYU4obmljLm10dSkpIHtcbiAgICAgIG5pYy5tdHUgPSBudWxsO1xuICAgIH1cbiAgICBuaWMuaW50ZXJuYWwgPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2xvb3BiYWNrJykgPiAtMTtcbiAgICBzZWN0aW9uLmZvckVhY2gobGluZSA9PiB7XG4gICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnZXRoZXIgJykpIHtcbiAgICAgICAgbmljLm1hYyA9IGxpbmUuc3BsaXQoJ2V0aGVyICcpWzFdLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2luZXQ2ICcpICYmICFuaWMuaXA2KSB7XG4gICAgICAgIG5pYy5pcDYgPSBsaW5lLnNwbGl0KCdpbmV0NiAnKVsxXS50b0xvd2VyQ2FzZSgpLnNwbGl0KCclJylbMF0uc3BsaXQoJyAnKVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdpbmV0ICcpICYmICFuaWMuaXA0KSB7XG4gICAgICAgIG5pYy5pcDQgPSBsaW5lLnNwbGl0KCdpbmV0ICcpWzFdLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKVswXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgc3BlZWQgPSB1dGlsLmdldFZhbHVlKHNlY3Rpb24sICdsaW5rIHJhdGUnKTtcbiAgICBuaWMuc3BlZWQgPSBzcGVlZCA/IHBhcnNlRmxvYXQoc3BlZWQpIDogbnVsbDtcbiAgICBpZiAobmljLnNwZWVkID09PSBudWxsKSB7XG4gICAgICBzcGVlZCA9IHV0aWwuZ2V0VmFsdWUoc2VjdGlvbiwgJ3VwbGluayByYXRlJyk7XG4gICAgICBuaWMuc3BlZWQgPSBzcGVlZCA/IHBhcnNlRmxvYXQoc3BlZWQpIDogbnVsbDtcbiAgICAgIGlmIChuaWMuc3BlZWQgIT09IG51bGwgJiYgc3BlZWQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdnYnBzJykgPj0gMCkge1xuICAgICAgICBuaWMuc3BlZWQgPSBuaWMuc3BlZWQgKiAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3BlZWQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdnYnBzJykgPj0gMCkge1xuICAgICAgICBuaWMuc3BlZWQgPSBuaWMuc3BlZWQgKiAxMDAwO1xuICAgICAgfVxuICAgIH1cbiAgICBuaWMudHlwZSA9IHV0aWwuZ2V0VmFsdWUoc2VjdGlvbiwgJ3R5cGUnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpLWZpJykgPiAtMSA/ICd3aXJlbGVzcycgOiAnd2lyZWQnO1xuICAgIGNvbnN0IG9wZXJzdGF0ZSA9IHV0aWwuZ2V0VmFsdWUoc2VjdGlvbiwgJ3N0YXR1cycpLnRvTG93ZXJDYXNlKCk7XG4gICAgbmljLm9wZXJzdGF0ZSA9IChvcGVyc3RhdGUgPT09ICdhY3RpdmUnID8gJ3VwJyA6IChvcGVyc3RhdGUgPT09ICdpbmFjdGl2ZScgPyAnZG93bicgOiAndW5rbm93bicpKTtcbiAgICBuaWMuZHVwbGV4ID0gdXRpbC5nZXRWYWx1ZShzZWN0aW9uLCAnbWVkaWEnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2hhbGYtZHVwbGV4JykgPiAtMSA/ICdoYWxmJyA6ICdmdWxsJztcbiAgICBpZiAobmljLmlwNiB8fCBuaWMuaXA0IHx8IG5pYy5tYWMpIHtcbiAgICAgIG5pY3MucHVzaChuaWMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuaWNzO1xufVxuXG5mdW5jdGlvbiBnZXREYXJ3aW5OaWNzKCkge1xuICBjb25zdCBjbWQgPSAnL3NiaW4vaWZjb25maWcgLXYnO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IG5zZWN0aW9ucyA9IHNwbGl0U2VjdGlvbnNOaWNzKGxpbmVzKTtcbiAgICByZXR1cm4gKHBhcnNlTGluZXNEYXJ3aW5OaWNzKG5zZWN0aW9ucykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4SWZhY2VDb25uZWN0aW9uTmFtZShpbnRlcmZhY2VOYW1lKSB7XG4gIGNvbnN0IGNtZCA9IGBubWNsaSBkZXZpY2Ugc3RhdHVzIDI+L2Rldi9udWxsIHwgZ3JlcCAke2ludGVyZmFjZU5hbWV9YDtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCByZXN1bHRGb3JtYXQgPSByZXN1bHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTmFtZUxpbmVzID0gcmVzdWx0Rm9ybWF0LnNwbGl0KCcgJykuc2xpY2UoMyk7XG4gICAgY29uc3QgY29ubmVjdGlvbk5hbWUgPSBjb25uZWN0aW9uTmFtZUxpbmVzLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbk5hbWUgIT0gJy0tJyA/IGNvbm5lY3Rpb25OYW1lIDogJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tMaW51eERDSFBJbnRlcmZhY2VzKGZpbGUpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIGxldCBjbWQgPSBgY2F0ICR7ZmlsZX0gMj4gL2Rldi9udWxsIHwgZ3JlcCAnaWZhY2VcXFxcfHNvdXJjZSdgO1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgaW5ldCAnKSA+PSAwICYmIGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdkaGNwJykgPj0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc291cmNlJykpIHtcbiAgICAgICAgbGV0IGZpbGUgPSBsaW5lLnNwbGl0KCcgJylbMV07XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY2hlY2tMaW51eERDSFBJbnRlcmZhY2VzKGZpbGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4REhDUE5pY3MoKSB7XG4gIC8vIGFsdGVybmF0ZSBtZXRob2RzIGdldHRpbmcgaW50ZXJmYWNlcyB1c2luZyBESENQXG4gIGxldCBjbWQgPSAnaXAgYSAyPiAvZGV2L251bGwnO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgbnNlY3Rpb25zID0gc3BsaXRTZWN0aW9uc05pY3MobGluZXMpO1xuICAgIHJlc3VsdCA9IChwYXJzZUxpbnV4REhDUE5pY3MobnNlY3Rpb25zKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IGNoZWNrTGludXhEQ0hQSW50ZXJmYWNlcygnL2V0Yy9uZXR3b3JrL2ludGVyZmFjZXMnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhESENQTmljcyhzZWN0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHNlY3Rpb25zICYmIHNlY3Rpb25zLmxlbmd0aCkge1xuICAgIHNlY3Rpb25zLmZvckVhY2gobGluZXMgPT4ge1xuICAgICAgaWYgKGxpbmVzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignIGluZXQgJykgPj0gMCAmJiBsaW5lLmluZGV4T2YoJyBkeW5hbWljICcpID49IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMyID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBjb25zdCBuaWMgPSBwYXJ0czJbcGFydHMyLmxlbmd0aCAtIDFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmljKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0TGludXhJZmFjZURIQ1BzdGF0dXMoaWZhY2UsIGNvbm5lY3Rpb25OYW1lLCBESENQTmljcykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIGlmIChjb25uZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IGNtZCA9IGBubWNsaSBjb25uZWN0aW9uIHNob3cgXCIke2Nvbm5lY3Rpb25OYW1lfVwiIDI+L2Rldi9udWxsIHwgZ3JlcCBpcHY0Lm1ldGhvZDtgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHJlc3VsdEZvcm1hdCA9IGxpbmVzLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG5cbiAgICAgIGxldCBkaGNTdGF0dXMgPSByZXN1bHRGb3JtYXQuc3BsaXQoJyAnKS5zbGljZSgxKS50b1N0cmluZygpO1xuICAgICAgc3dpdGNoIChkaGNTdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gKERIQ1BOaWNzLmluZGV4T2YoaWZhY2UpID49IDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKERIQ1BOaWNzLmluZGV4T2YoaWZhY2UpID49IDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhcndpbklmYWNlREhDUHN0YXR1cyhpZmFjZSkge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIGNvbnN0IGNtZCA9IGBpcGNvbmZpZyBnZXRwYWNrZXQgXCIke2lmYWNlfVwiIDI+L2Rldi9udWxsIHwgZ3JlcCBsZWFzZV90aW1lO2A7XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGlmIChsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0uc3RhcnRzV2l0aCgnbGVhc2VfdGltZScpKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4SWZhY2VETlNzdWZmaXgoY29ubmVjdGlvbk5hbWUpIHtcbiAgaWYgKGNvbm5lY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgY21kID0gYG5tY2xpIGNvbm5lY3Rpb24gc2hvdyBcIiR7Y29ubmVjdGlvbk5hbWV9XCIgMj4vZGV2L251bGwgfCBncmVwIGlwdjQuZG5zLXNlYXJjaDtgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZXN1bHRGb3JtYXQgPSByZXN1bHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGRuc1N1ZmZpeCA9IHJlc3VsdEZvcm1hdC5zcGxpdCgnICcpLnNsaWNlKDEpLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gZG5zU3VmZml4ID09ICctLScgPyAnTm90IGRlZmluZWQnIDogZG5zU3VmZml4O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGludXhJZmFjZUlFRUU4MDIxeEF1dGgoY29ubmVjdGlvbk5hbWUpIHtcbiAgaWYgKGNvbm5lY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgY21kID0gYG5tY2xpIGNvbm5lY3Rpb24gc2hvdyBcIiR7Y29ubmVjdGlvbk5hbWV9XCIgMj4vZGV2L251bGwgfCBncmVwIDgwMi0xeC5lYXA7YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVzdWx0Rm9ybWF0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICBjb25zdCBhdXRoZW50aWNhdGlvblByb3RvY29sID0gcmVzdWx0Rm9ybWF0LnNwbGl0KCcgJykuc2xpY2UoMSkudG9TdHJpbmcoKTtcblxuXG4gICAgICByZXR1cm4gYXV0aGVudGljYXRpb25Qcm90b2NvbCA9PSAnLS0nID8gJycgOiBhdXRoZW50aWNhdGlvblByb3RvY29sO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnTm90IGRlZmluZWQnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ05vdCBkZWZpbmVkJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMaW51eElmYWNlSUVFRTgwMjF4U3RhdGUoYXV0aGVudGljYXRpb25Qcm90b2NvbCkge1xuICBpZiAoYXV0aGVudGljYXRpb25Qcm90b2NvbCkge1xuICAgIGlmIChhdXRoZW50aWNhdGlvblByb3RvY29sID09ICdOb3QgZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiAnRGlzYWJsZWQnO1xuICAgIH1cbiAgICByZXR1cm4gJ0VuYWJsZWQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFZpcnR1YWxOaWMoaWZhY2UsIGlmYWNlTmFtZSwgbWFjKSB7XG4gIGNvbnN0IHZpcnR1YWxNYWNzID0gWycwMDowMDowMDowMDowMDowMCcsICcwMDowMzpGRicsICcwMDowNTo2OScsICcwMDowQzoyOScsICcwMDowRjo0QicsICcwMDowRjo0QicsICcwMDoxMzowNycsICcwMDoxMzpCRScsICcwMDoxNTo1ZCcsICcwMDoxNjozRScsICcwMDoxQzo0MicsICcwMDoyMTpGNicsICcwMDoyMTpGNicsICcwMDoyNDowQicsICcwMDoyNDowQicsICcwMDo1MDo1NicsICcwMDpBMDpCMScsICcwMDpFMDpDOCcsICcwODowMDoyNycsICcwQTowMDoyNycsICcxODo5MjoyQycsICcxNjpERjo0OScsICczQzpGMzo5MicsICc1NDo1MjowMCcsICdGQzoxNTo5NyddO1xuICBpZiAobWFjKSB7XG4gICAgcmV0dXJuIHZpcnR1YWxNYWNzLmZpbHRlcihpdGVtID0+IHsgcmV0dXJuIG1hYy50b1VwcGVyQ2FzZSgpLnRvVXBwZXJDYXNlKCkuc3RhcnRzV2l0aChpdGVtLnN1YnN0cigwLCBtYWMubGVuZ3RoKSk7IH0pLmxlbmd0aCA+IDAgfHxcbiAgICAgIGlmYWNlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIHZpcnR1YWwgJykgPiAtMSB8fFxuICAgICAgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIHZpcnR1YWwgJykgPiAtMSB8fFxuICAgICAgaWZhY2UudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2ZXRoZXJuZXQgJykgPiAtMSB8fFxuICAgICAgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndmV0aGVybmV0ICcpID4gLTEgfHxcbiAgICAgIGlmYWNlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndmV0aCcpIHx8XG4gICAgICBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2ZXRoJykgfHxcbiAgICAgIGlmYWNlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndmJveG5ldCcpIHx8XG4gICAgICBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2Ym94bmV0Jyk7XG4gIH0gZWxzZSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG5mdW5jdGlvbiBuZXR3b3JrSW50ZXJmYWNlcyhjYWxsYmFjaywgcmVzY2FuLCBkZWZhdWx0U3RyaW5nKSB7XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICBkZWZhdWx0U3RyaW5nID0gY2FsbGJhY2s7XG4gICAgcmVzY2FuID0gdHJ1ZTtcbiAgICBjYWxsYmFjayA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnYm9vbGVhbicpIHtcbiAgICByZXNjYW4gPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgZGVmYXVsdFN0cmluZyA9ICcnO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzY2FuID09PSAndW5kZWZpbmVkJykge1xuICAgIHJlc2NhbiA9IHRydWU7XG4gIH1cbiAgZGVmYXVsdFN0cmluZyA9IGRlZmF1bHRTdHJpbmcgfHwgJyc7XG4gIGRlZmF1bHRTdHJpbmcgPSAnJyArIGRlZmF1bHRTdHJpbmc7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCBpZmFjZXMgPSBvcy5uZXR3b3JrSW50ZXJmYWNlcygpO1xuXG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBsZXQgbmljcyA9IFtdO1xuICAgICAgbGV0IGRuc1N1ZmZpeGVzID0gW107XG4gICAgICBsZXQgbmljczgwMjF4SW5mbyA9IFtdO1xuICAgICAgLy8gc2VwZXJhdGUgaGFuZGxpbmcgaW4gT1NYXG4gICAgICBpZiAoX2RhcndpbiB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGlmICgoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSA9PT0gSlNPTi5zdHJpbmdpZnkoX2lmYWNlcykpICYmICFyZXNjYW4pIHtcbiAgICAgICAgICAvLyBubyBjaGFuZ2VzIC0ganVzdCByZXR1cm4gb2JqZWN0XG4gICAgICAgICAgcmVzdWx0ID0gX25ldHdvcmtJbnRlcmZhY2VzO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEludGVyZmFjZSA9IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG4gICAgICAgICAgX2lmYWNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSk7XG5cbiAgICAgICAgICBuaWNzID0gZ2V0RGFyd2luTmljcygpO1xuXG5cbiAgICAgICAgICBuaWNzLmZvckVhY2gobmljID0+IHtcblxuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBuaWMuaWZhY2UpKSB7XG4gICAgICAgICAgICAgIGlmYWNlc1tuaWMuaWZhY2VdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY0JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgbmljLmlwNHN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NicgfHwgZGV0YWlscy5mYW1pbHkgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgIG5pYy5pcDZzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlmYWNlU2FuaXRpemVkID0gJyc7XG4gICAgICAgICAgICBjb25zdCBzID0gdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnLS0tJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhuaWMuaWZhY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZmFjZVNhbml0aXplZCA9IGlmYWNlU2FuaXRpemVkICsgc1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGlmYWNlOiBuaWMuaWZhY2UsXG4gICAgICAgICAgICAgIGlmYWNlTmFtZTogbmljLmlmYWNlLFxuICAgICAgICAgICAgICBkZWZhdWx0OiBuaWMuaWZhY2UgPT09IGRlZmF1bHRJbnRlcmZhY2UsXG4gICAgICAgICAgICAgIGlwNDogbmljLmlwNCxcbiAgICAgICAgICAgICAgaXA0c3VibmV0OiBuaWMuaXA0c3VibmV0IHx8ICcnLFxuICAgICAgICAgICAgICBpcDY6IG5pYy5pcDYsXG4gICAgICAgICAgICAgIGlwNnN1Ym5ldDogbmljLmlwNnN1Ym5ldCB8fCAnJyxcbiAgICAgICAgICAgICAgbWFjOiBuaWMubWFjLFxuICAgICAgICAgICAgICBpbnRlcm5hbDogbmljLmludGVybmFsLFxuICAgICAgICAgICAgICB2aXJ0dWFsOiBuaWMuaW50ZXJuYWwgPyBmYWxzZSA6IHRlc3RWaXJ0dWFsTmljKG5pYy5pZmFjZSwgbmljLmlmYWNlLCBuaWMubWFjKSxcbiAgICAgICAgICAgICAgb3BlcnN0YXRlOiBuaWMub3BlcnN0YXRlLFxuICAgICAgICAgICAgICB0eXBlOiBuaWMudHlwZSxcbiAgICAgICAgICAgICAgZHVwbGV4OiBuaWMuZHVwbGV4LFxuICAgICAgICAgICAgICBtdHU6IG5pYy5tdHUsXG4gICAgICAgICAgICAgIHNwZWVkOiBuaWMuc3BlZWQsXG4gICAgICAgICAgICAgIGRoY3A6IGdldERhcndpbklmYWNlREhDUHN0YXR1cyhpZmFjZVNhbml0aXplZCksXG4gICAgICAgICAgICAgIGRuc1N1ZmZpeDogJycsXG4gICAgICAgICAgICAgIGllZWU4MDIxeEF1dGg6ICcnLFxuICAgICAgICAgICAgICBpZWVlODAyMXhTdGF0ZTogJycsXG4gICAgICAgICAgICAgIGNhcnJpZXJDaGFuZ2VzOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfbmV0d29ya0ludGVyZmFjZXMgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKGRlZmF1bHRTdHJpbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdkZWZhdWx0JykgPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihpdGVtID0+IGl0ZW0uZGVmYXVsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGlmICgoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSA9PT0gSlNPTi5zdHJpbmdpZnkoX2lmYWNlcykpICYmICFyZXNjYW4pIHtcbiAgICAgICAgICAvLyBubyBjaGFuZ2VzIC0ganVzdCByZXR1cm4gb2JqZWN0XG4gICAgICAgICAgcmVzdWx0ID0gX25ldHdvcmtJbnRlcmZhY2VzO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lmYWNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSk7XG4gICAgICAgICAgX2RoY3BOaWNzID0gZ2V0TGludXhESENQTmljcygpO1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRJbnRlcmZhY2UgPSBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuICAgICAgICAgIGZvciAobGV0IGRldiBpbiBpZmFjZXMpIHtcbiAgICAgICAgICAgIGxldCBpcDQgPSAnJztcbiAgICAgICAgICAgIGxldCBpcDRzdWJuZXQgPSAnJztcbiAgICAgICAgICAgIGxldCBpcDYgPSAnJztcbiAgICAgICAgICAgIGxldCBpcDZzdWJuZXQgPSAnJztcbiAgICAgICAgICAgIGxldCBtYWMgPSAnJztcbiAgICAgICAgICAgIGxldCBkdXBsZXggPSAnJztcbiAgICAgICAgICAgIGxldCBtdHUgPSAnJztcbiAgICAgICAgICAgIGxldCBzcGVlZCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY2FycmllckNoYW5nZXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRoY3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkbnNTdWZmaXggPSAnJztcbiAgICAgICAgICAgIGxldCBpZWVlODAyMXhBdXRoID0gJyc7XG4gICAgICAgICAgICBsZXQgaWVlZTgwMjF4U3RhdGUgPSAnJztcbiAgICAgICAgICAgIGxldCB0eXBlID0gJyc7XG5cbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgZGV2KSkge1xuICAgICAgICAgICAgICBsZXQgaWZhY2VOYW1lID0gZGV2O1xuICAgICAgICAgICAgICBpZmFjZXNbZGV2XS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NCcgfHwgZGV0YWlscy5mYW1pbHkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgIGlwNCA9IGRldGFpbHMuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgIGlwNHN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NicgfHwgZGV0YWlscy5mYW1pbHkgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXA2IHx8IGlwNi5tYXRjaCgvXmZlODA6Oi9pKSkge1xuICAgICAgICAgICAgICAgICAgICBpcDYgPSBkZXRhaWxzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlwNnN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFjID0gZGV0YWlscy5tYWM7XG4gICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTM1ODEgKG5vZGUgOC4xIC0gbm9kZSA4LjIpXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZU1haW5WZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJyksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAobWFjLmluZGV4T2YoJzAwOjAwOjAnKSA+IC0xICYmIChfbGludXggfHwgX2RhcndpbikgJiYgKCFkZXRhaWxzLmludGVybmFsKSAmJiBub2RlTWFpblZlcnNpb24gPj0gOCAmJiBub2RlTWFpblZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhfbWFjKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21hYyA9IGdldE1hY0FkZHJlc3NlcygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbWFjID0gX21hY1tkZXZdIHx8ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBpZmFjZSA9IGRldi5zcGxpdCgnOicpWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBsZXQgaWZhY2VTYW5pdGl6ZWQgPSAnJztcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJy0tLScgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoaWZhY2UpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZmFjZVNhbml0aXplZCA9IGlmYWNlU2FuaXRpemVkICsgc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJhZGRyX2Fzc2lnbl90eXBlOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2FkZHJfYXNzaWduX3R5cGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYWRkcmVzczogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9hZGRyZXNzIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImFkZHJfbGVuOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2FkZHJfbGVuIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJyb2FkY2FzdDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9icm9hZGNhc3QgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2FycmllcjogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9jYXJyaWVyIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNhcnJpZXJfY2hhbmdlczogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9jYXJyaWVyX2NoYW5nZXMgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZGV2X2lkOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2Rldl9pZCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJkZXZfcG9ydDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9kZXZfcG9ydCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJkb3JtYW50OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2Rvcm1hbnQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZHVwbGV4OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2R1cGxleCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJmbGFnczogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9mbGFncyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJncm9fZmx1c2hfdGltZW91dDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9ncm9fZmx1c2hfdGltZW91dCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJpZmFsaWFzOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2lmYWxpYXMgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiaWZpbmRleDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9pZmluZGV4IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImlmbGluazogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9pZmxpbmsgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwibGlua19tb2RlOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2xpbmtfbW9kZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJtdHU6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vbXR1IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcIm5ldGRldl9ncm91cDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9uZXRkZXZfZ3JvdXAgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwib3BlcnN0YXRlOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L29wZXJzdGF0ZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJwcm90b19kb3duOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L3Byb3RvX2Rvd24gMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwic3BlZWQ6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vc3BlZWQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwidHhfcXVldWVfbGVuOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L3R4X3F1ZXVlX2xlbiAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJ0eXBlOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L3R5cGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwid2lyZWxlc3M6IFwiOyBjYXQgL3Byb2MvbmV0L3dpcmVsZXNzIDI+L2Rldi9udWxsIHwgZ3JlcCAke2lmYWNlU2FuaXRpemVkfTsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJ3aXJlbGVzc3NwZWVkOiBcIjsgaXcgZGV2ICR7aWZhY2VTYW5pdGl6ZWR9IGxpbmsgMj4mMSB8IGdyZXAgYml0cmF0ZTsgZWNobztgO1xuXG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uTmFtZSA9IGdldExpbnV4SWZhY2VDb25uZWN0aW9uTmFtZShpZmFjZVNhbml0aXplZCk7XG4gICAgICAgICAgICAgICAgZGhjcCA9IGdldExpbnV4SWZhY2VESENQc3RhdHVzKGlmYWNlU2FuaXRpemVkLCBjb25uZWN0aW9uTmFtZSwgX2RoY3BOaWNzKTtcbiAgICAgICAgICAgICAgICBkbnNTdWZmaXggPSBnZXRMaW51eElmYWNlRE5Tc3VmZml4KGNvbm5lY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhBdXRoID0gZ2V0TGludXhJZmFjZUlFRUU4MDIxeEF1dGgoY29ubmVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGllZWU4MDIxeFN0YXRlID0gZ2V0TGludXhJZmFjZUlFRUU4MDIxeFN0YXRlKGllZWU4MDIxeEF1dGgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZHVwbGV4ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2R1cGxleCcpO1xuICAgICAgICAgICAgICBkdXBsZXggPSBkdXBsZXguc3RhcnRzV2l0aCgnY2F0JykgPyAnJyA6IGR1cGxleDtcbiAgICAgICAgICAgICAgbXR1ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ210dScpLCAxMCk7XG4gICAgICAgICAgICAgIGxldCBteXNwZWVkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NwZWVkJyksIDEwKTtcbiAgICAgICAgICAgICAgc3BlZWQgPSBpc05hTihteXNwZWVkKSA/IG51bGwgOiBteXNwZWVkO1xuICAgICAgICAgICAgICBsZXQgd2lyZWxlc3NzcGVlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd3aXJlbGVzc3NwZWVkJykuc3BsaXQoJ3R4IGJpdHJhdGU6ICcpO1xuICAgICAgICAgICAgICBpZiAoc3BlZWQgPT09IG51bGwgJiYgd2lyZWxlc3NzcGVlZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBteXNwZWVkID0gcGFyc2VGbG9hdCh3aXJlbGVzc3NwZWVkWzFdKTtcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGlzTmFOKG15c3BlZWQpID8gbnVsbCA6IG15c3BlZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FycmllckNoYW5nZXMgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2Fycmllcl9jaGFuZ2VzJyksIDEwKTtcbiAgICAgICAgICAgICAgY29uc3Qgb3BlcnN0YXRlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ29wZXJzdGF0ZScpO1xuICAgICAgICAgICAgICB0eXBlID0gb3BlcnN0YXRlID09PSAndXAnID8gKHV0aWwuZ2V0VmFsdWUobGluZXMsICd3aXJlbGVzcycpLnRyaW0oKSA/ICd3aXJlbGVzcycgOiAnd2lyZWQnKSA6ICd1bmtub3duJztcbiAgICAgICAgICAgICAgaWYgKGlmYWNlU2FuaXRpemVkID09PSAnbG8nIHx8IGlmYWNlU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2JvbmQnKSkgeyB0eXBlID0gJ3ZpcnR1YWwnOyB9XG5cbiAgICAgICAgICAgICAgbGV0IGludGVybmFsID0gKGlmYWNlc1tkZXZdICYmIGlmYWNlc1tkZXZdWzBdKSA/IGlmYWNlc1tkZXZdWzBdLmludGVybmFsIDogZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChkZXYudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdsb29wYmFjaycpID4gLTEgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbG9vcGJhY2snKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWwgPSBpbnRlcm5hbCA/IGZhbHNlIDogdGVzdFZpcnR1YWxOaWMoZGV2LCBpZmFjZU5hbWUsIG1hYyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZmFjZTogaWZhY2VTYW5pdGl6ZWQsXG4gICAgICAgICAgICAgICAgaWZhY2VOYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlmYWNlID09PSBkZWZhdWx0SW50ZXJmYWNlLFxuICAgICAgICAgICAgICAgIGlwNCxcbiAgICAgICAgICAgICAgICBpcDRzdWJuZXQsXG4gICAgICAgICAgICAgICAgaXA2LFxuICAgICAgICAgICAgICAgIGlwNnN1Ym5ldCxcbiAgICAgICAgICAgICAgICBtYWMsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWwsXG4gICAgICAgICAgICAgICAgdmlydHVhbCxcbiAgICAgICAgICAgICAgICBvcGVyc3RhdGUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBkdXBsZXgsXG4gICAgICAgICAgICAgICAgbXR1LFxuICAgICAgICAgICAgICAgIHNwZWVkLFxuICAgICAgICAgICAgICAgIGRoY3AsXG4gICAgICAgICAgICAgICAgZG5zU3VmZml4LFxuICAgICAgICAgICAgICAgIGllZWU4MDIxeEF1dGgsXG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4U3RhdGUsXG4gICAgICAgICAgICAgICAgY2FycmllckNoYW5nZXMsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfbmV0d29ya0ludGVyZmFjZXMgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKGRlZmF1bHRTdHJpbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdkZWZhdWx0JykgPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihpdGVtID0+IGl0ZW0uZGVmYXVsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgaWYgKChKU09OLnN0cmluZ2lmeShpZmFjZXMpID09PSBKU09OLnN0cmluZ2lmeShfaWZhY2VzKSkgJiYgIXJlc2Nhbikge1xuICAgICAgICAgIC8vIG5vIGNoYW5nZXMgLSBqdXN0IHJldHVybiBvYmplY3RcbiAgICAgICAgICByZXN1bHQgPSBfbmV0d29ya0ludGVyZmFjZXM7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaWZhY2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpZmFjZXMpKTtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0SW50ZXJmYWNlID0gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcblxuICAgICAgICAgIGdldFdpbmRvd3NOaWNzKCkudGhlbihmdW5jdGlvbiAobmljcykge1xuICAgICAgICAgICAgbmljcy5mb3JFYWNoKG5pYyA9PiB7XG4gICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhpZmFjZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICBpZmFjZXNba2V5XS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5pbmRleE9mKCdtYWMnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZVsnbWFjJ10gPT09IG5pYy5tYWM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmYWNlc1tuaWMubmFtZV0gPSBbeyBtYWM6IG5pYy5tYWMgfV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmljczgwMjF4SW5mbyA9IGdldFdpbmRvd3NXaXJlZFByb2ZpbGVzSW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIGRuc1N1ZmZpeGVzID0gZ2V0V2luZG93c0ROU3N1ZmZpeGVzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkZXYgaW4gaWZhY2VzKSB7XG5cbiAgICAgICAgICAgICAgbGV0IGlmYWNlU2FuaXRpemVkID0gJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSB1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICctLS0nIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGRldik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmYWNlU2FuaXRpemVkID0gaWZhY2VTYW5pdGl6ZWQgKyBzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBpZmFjZSA9IGRldjtcbiAgICAgICAgICAgICAgbGV0IGlwNCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgaXA0c3VibmV0ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBpcDYgPSAnJztcbiAgICAgICAgICAgICAgbGV0IGlwNnN1Ym5ldCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgbWFjID0gJyc7XG4gICAgICAgICAgICAgIGxldCBkdXBsZXggPSAnJztcbiAgICAgICAgICAgICAgbGV0IG10dSA9ICcnO1xuICAgICAgICAgICAgICBsZXQgc3BlZWQgPSBudWxsO1xuICAgICAgICAgICAgICBsZXQgY2FycmllckNoYW5nZXMgPSAwO1xuICAgICAgICAgICAgICBsZXQgb3BlcnN0YXRlID0gJ2Rvd24nO1xuICAgICAgICAgICAgICBsZXQgZGhjcCA9IGZhbHNlO1xuICAgICAgICAgICAgICBsZXQgZG5zU3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBpZWVlODAyMXhBdXRoID0gJyc7XG4gICAgICAgICAgICAgIGxldCBpZWVlODAyMXhTdGF0ZSA9ICcnO1xuICAgICAgICAgICAgICBsZXQgdHlwZSA9ICcnO1xuXG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgZGV2KSkge1xuICAgICAgICAgICAgICAgIGxldCBpZmFjZU5hbWUgPSBkZXY7XG4gICAgICAgICAgICAgICAgaWZhY2VzW2Rldl0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NCcgfHwgZGV0YWlscy5mYW1pbHkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXA0ID0gZGV0YWlscy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBpcDRzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY2JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlwNiB8fCBpcDYubWF0Y2goL15mZTgwOjovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpcDYgPSBkZXRhaWxzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgaXA2c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtYWMgPSBkZXRhaWxzLm1hYztcbiAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzEzNTgxIChub2RlIDguMSAtIG5vZGUgOC4yKVxuICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZU1haW5WZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJyksIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYWMuaW5kZXhPZignMDA6MDA6MCcpID4gLTEgJiYgKF9saW51eCB8fCBfZGFyd2luKSAmJiAoIWRldGFpbHMuaW50ZXJuYWwpICYmIG5vZGVNYWluVmVyc2lvbiA+PSA4ICYmIG5vZGVNYWluVmVyc2lvbiA8PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoX21hYykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX21hYyA9IGdldE1hY0FkZHJlc3NlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hYyA9IF9tYWNbZGV2XSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgICAgICAgICBkbnNTdWZmaXggPSBnZXRXaW5kb3dzSWZhY2VETlNzdWZmaXgoZG5zU3VmZml4ZXMuaWZhY2VzLCBpZmFjZVNhbml0aXplZCk7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuaWNzLmZvckVhY2goZGV0YWlsID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWwubWFjID09PSBtYWMgJiYgIWZvdW5kRmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWZhY2UgPSBkZXRhaWwuaWZhY2UgfHwgaWZhY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmYWNlTmFtZSA9IGRldGFpbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBkaGNwID0gZGV0YWlsLmRoY3A7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSA9IGRldGFpbC5vcGVyc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHNwZWVkID0gZGV0YWlsLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gZGV0YWlsLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRldi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dsYW4nKSA+PSAwIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dsYW4nKSA+PSAwIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJzgwMi4xMW4nKSA+PSAwIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpcmVsZXNzJykgPj0gMCB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aS1maScpID49IDAgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2lmaScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSAnd2lyZWxlc3MnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IElFRUU4MDIxeCA9IGdldFdpbmRvd3NJRUVFODAyMXgodHlwZSwgaWZhY2VTYW5pdGl6ZWQsIG5pY3M4MDIxeEluZm8pO1xuICAgICAgICAgICAgICAgIGllZWU4MDIxeEF1dGggPSBJRUVFODAyMXgucHJvdG9jb2w7XG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4U3RhdGUgPSBJRUVFODAyMXguc3RhdGU7XG4gICAgICAgICAgICAgICAgbGV0IGludGVybmFsID0gKGlmYWNlc1tkZXZdICYmIGlmYWNlc1tkZXZdWzBdKSA/IGlmYWNlc1tkZXZdWzBdLmludGVybmFsIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGRldi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2xvb3BiYWNrJykgPiAtMSB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdsb29wYmFjaycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbCA9IGludGVybmFsID8gZmFsc2UgOiB0ZXN0VmlydHVhbE5pYyhkZXYsIGlmYWNlTmFtZSwgbWFjKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgICAgICAgIGlmYWNlTmFtZSxcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlmYWNlID09PSBkZWZhdWx0SW50ZXJmYWNlLFxuICAgICAgICAgICAgICAgICAgaXA0LFxuICAgICAgICAgICAgICAgICAgaXA0c3VibmV0LFxuICAgICAgICAgICAgICAgICAgaXA2LFxuICAgICAgICAgICAgICAgICAgaXA2c3VibmV0LFxuICAgICAgICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgICAgICAgaW50ZXJuYWwsXG4gICAgICAgICAgICAgICAgICB2aXJ0dWFsLFxuICAgICAgICAgICAgICAgICAgb3BlcnN0YXRlLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGR1cGxleCxcbiAgICAgICAgICAgICAgICAgIG10dSxcbiAgICAgICAgICAgICAgICAgIHNwZWVkLFxuICAgICAgICAgICAgICAgICAgZGhjcCxcbiAgICAgICAgICAgICAgICAgIGRuc1N1ZmZpeCxcbiAgICAgICAgICAgICAgICAgIGllZWU4MDIxeEF1dGgsXG4gICAgICAgICAgICAgICAgICBpZWVlODAyMXhTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGNhcnJpZXJDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV0d29ya0ludGVyZmFjZXMgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFN0cmluZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RlZmF1bHQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlZmF1bHQpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXMgPSBuZXR3b3JrSW50ZXJmYWNlcztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE5FVCAtIFNwZWVkXG5cbmZ1bmN0aW9uIGNhbGNOZXR3b3JrU3BlZWQoaWZhY2UsIHJ4X2J5dGVzLCB0eF9ieXRlcywgb3BlcnN0YXRlLCByeF9kcm9wcGVkLCByeF9lcnJvcnMsIHR4X2Ryb3BwZWQsIHR4X2Vycm9ycykge1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGlmYWNlLFxuICAgIG9wZXJzdGF0ZSxcbiAgICByeF9ieXRlcyxcbiAgICByeF9kcm9wcGVkLFxuICAgIHJ4X2Vycm9ycyxcbiAgICB0eF9ieXRlcyxcbiAgICB0eF9kcm9wcGVkLFxuICAgIHR4X2Vycm9ycyxcbiAgICByeF9zZWM6IG51bGwsXG4gICAgdHhfc2VjOiBudWxsLFxuICAgIG1zOiAwXG4gIH07XG5cbiAgaWYgKF9uZXR3b3JrW2lmYWNlXSAmJiBfbmV0d29ya1tpZmFjZV0ubXMpIHtcbiAgICByZXN1bHQubXMgPSBEYXRlLm5vdygpIC0gX25ldHdvcmtbaWZhY2VdLm1zO1xuICAgIHJlc3VsdC5yeF9zZWMgPSAocnhfYnl0ZXMgLSBfbmV0d29ya1tpZmFjZV0ucnhfYnl0ZXMpID49IDAgPyAocnhfYnl0ZXMgLSBfbmV0d29ya1tpZmFjZV0ucnhfYnl0ZXMpIC8gKHJlc3VsdC5tcyAvIDEwMDApIDogMDtcbiAgICByZXN1bHQudHhfc2VjID0gKHR4X2J5dGVzIC0gX25ldHdvcmtbaWZhY2VdLnR4X2J5dGVzKSA+PSAwID8gKHR4X2J5dGVzIC0gX25ldHdvcmtbaWZhY2VdLnR4X2J5dGVzKSAvIChyZXN1bHQubXMgLyAxMDAwKSA6IDA7XG4gICAgX25ldHdvcmtbaWZhY2VdLnJ4X2J5dGVzID0gcnhfYnl0ZXM7XG4gICAgX25ldHdvcmtbaWZhY2VdLnR4X2J5dGVzID0gdHhfYnl0ZXM7XG4gICAgX25ldHdvcmtbaWZhY2VdLnJ4X3NlYyA9IHJlc3VsdC5yeF9zZWM7XG4gICAgX25ldHdvcmtbaWZhY2VdLnR4X3NlYyA9IHJlc3VsdC50eF9zZWM7XG4gICAgX25ldHdvcmtbaWZhY2VdLm1zID0gRGF0ZS5ub3coKTtcbiAgICBfbmV0d29ya1tpZmFjZV0ubGFzdF9tcyA9IHJlc3VsdC5tcztcbiAgICBfbmV0d29ya1tpZmFjZV0ub3BlcnN0YXRlID0gb3BlcnN0YXRlO1xuICB9IGVsc2Uge1xuICAgIGlmICghX25ldHdvcmtbaWZhY2VdKSB7IF9uZXR3b3JrW2lmYWNlXSA9IHt9OyB9XG4gICAgX25ldHdvcmtbaWZhY2VdLnJ4X2J5dGVzID0gcnhfYnl0ZXM7XG4gICAgX25ldHdvcmtbaWZhY2VdLnR4X2J5dGVzID0gdHhfYnl0ZXM7XG4gICAgX25ldHdvcmtbaWZhY2VdLnJ4X3NlYyA9IG51bGw7XG4gICAgX25ldHdvcmtbaWZhY2VdLnR4X3NlYyA9IG51bGw7XG4gICAgX25ldHdvcmtbaWZhY2VdLm1zID0gRGF0ZS5ub3coKTtcbiAgICBfbmV0d29ya1tpZmFjZV0ubGFzdF9tcyA9IDA7XG4gICAgX25ldHdvcmtbaWZhY2VdLm9wZXJzdGF0ZSA9IG9wZXJzdGF0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrU3RhdHMoaWZhY2VzLCBjYWxsYmFjaykge1xuXG4gIGxldCBpZmFjZXNBcnJheSA9IFtdO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oaWZhY2VzKSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBpZmFjZXM7XG4gICAgICAgIGlmYWNlc0FycmF5ID0gW2dldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZmFjZXMgIT09ICdzdHJpbmcnICYmIGlmYWNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKFtdKTsgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZmFjZXMgPSBpZmFjZXMgfHwgZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcblxuICAgICAgICBpZmFjZXMuX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICBpZmFjZXMuX19wcm90b19fLnJlcGxhY2UgPSB1dGlsLnN0cmluZ1JlcGxhY2U7XG4gICAgICAgIGlmYWNlcy5fX3Byb3RvX18udHJpbSA9IHV0aWwuc3RyaW5nVHJpbTtcblxuICAgICAgICBpZmFjZXMgPSBpZmFjZXMudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLCsvZywgJ3wnKTtcbiAgICAgICAgaWZhY2VzQXJyYXkgPSBpZmFjZXMuc3BsaXQoJ3wnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICBpZiAoaWZhY2VzQXJyYXkubGVuZ3RoICYmIGlmYWNlc0FycmF5WzBdLnRyaW0oKSA9PT0gJyonKSB7XG4gICAgICAgIGlmYWNlc0FycmF5ID0gW107XG4gICAgICAgIG5ldHdvcmtJbnRlcmZhY2VzKGZhbHNlKS50aGVuKGFsbElGYWNlcyA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaWZhY2Ugb2YgYWxsSUZhY2VzKSB7XG4gICAgICAgICAgICBpZmFjZXNBcnJheS5wdXNoKGlmYWNlLmlmYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV0d29ya1N0YXRzKGlmYWNlc0FycmF5LmpvaW4oJywnKSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpZmFjZSBvZiBpZmFjZXNBcnJheSkge1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2gobmV0d29ya1N0YXRzU2luZ2xlKGlmYWNlLnRyaW0oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrbG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtTdGF0c1NpbmdsZShpZmFjZSkge1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNXaW5kb3dzUGVyZkRhdGEoc2VjdGlvbnMpIHtcbiAgICBsZXQgcGVyZkRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpIGluIHNlY3Rpb25zKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChzZWN0aW9ucywgaSkpIHtcbiAgICAgICAgaWYgKHNlY3Rpb25zW2ldLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzZWN0aW9uc1tpXS50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgIHBlcmZEYXRhLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05hbWUnLCAnOicpLnJlcGxhY2UoL1soKVtcXF0gXSsvZywgJycpLnJlcGxhY2UoLyN8XFwvL2csICdfJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHJ4X2J5dGVzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnl0ZXNSZWNlaXZlZFBlcnNlYycsICc6JyksIDEwKSxcbiAgICAgICAgICAgIHJ4X2Vycm9yczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhY2tldHNSZWNlaXZlZEVycm9ycycsICc6JyksIDEwKSxcbiAgICAgICAgICAgIHJ4X2Ryb3BwZWQ6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWNrZXRzUmVjZWl2ZWREaXNjYXJkZWQnLCAnOicpLCAxMCksXG4gICAgICAgICAgICB0eF9ieXRlczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J5dGVzU2VudFBlcnNlYycsICc6JyksIDEwKSxcbiAgICAgICAgICAgIHR4X2Vycm9yczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhY2tldHNPdXRib3VuZEVycm9ycycsICc6JyksIDEwKSxcbiAgICAgICAgICAgIHR4X2Ryb3BwZWQ6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWNrZXRzT3V0Ym91bmREaXNjYXJkZWQnLCAnOicpLCAxMClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGVyZkRhdGE7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBpZmFjZVNhbml0aXplZCA9ICcnO1xuICAgICAgY29uc3QgcyA9IHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJy0tLScgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoaWZhY2UpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZmFjZVNhbml0aXplZCA9IGlmYWNlU2FuaXRpemVkICsgc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpZmFjZTogaWZhY2VTYW5pdGl6ZWQsXG4gICAgICAgIG9wZXJzdGF0ZTogJ3Vua25vd24nLFxuICAgICAgICByeF9ieXRlczogMCxcbiAgICAgICAgcnhfZHJvcHBlZDogMCxcbiAgICAgICAgcnhfZXJyb3JzOiAwLFxuICAgICAgICB0eF9ieXRlczogMCxcbiAgICAgICAgdHhfZHJvcHBlZDogMCxcbiAgICAgICAgdHhfZXJyb3JzOiAwLFxuICAgICAgICByeF9zZWM6IG51bGwsXG4gICAgICAgIHR4X3NlYzogbnVsbCxcbiAgICAgICAgbXM6IDBcbiAgICAgIH07XG5cbiAgICAgIGxldCBvcGVyc3RhdGUgPSAndW5rbm93bic7XG4gICAgICBsZXQgcnhfYnl0ZXMgPSAwO1xuICAgICAgbGV0IHR4X2J5dGVzID0gMDtcbiAgICAgIGxldCByeF9kcm9wcGVkID0gMDtcbiAgICAgIGxldCByeF9lcnJvcnMgPSAwO1xuICAgICAgbGV0IHR4X2Ryb3BwZWQgPSAwO1xuICAgICAgbGV0IHR4X2Vycm9ycyA9IDA7XG5cbiAgICAgIGxldCBjbWQsIGxpbmVzLCBzdGF0cztcbiAgICAgIGlmICghX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdIHx8IChfbmV0d29ya1tpZmFjZVNhbml0aXplZF0gJiYgIV9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5tcykgfHwgKF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXSAmJiBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ubXMgJiYgRGF0ZS5ub3coKSAtIF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5tcyA+PSA1MDApKSB7XG4gICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYygnL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkKSkge1xuICAgICAgICAgICAgY21kID1cbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL29wZXJzdGF0ZTsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3J4X2J5dGVzOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvdHhfYnl0ZXM7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy9yeF9kcm9wcGVkOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvcnhfZXJyb3JzOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvdHhfZHJvcHBlZDsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3R4X2Vycm9yczsgJztcbiAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgb3BlcnN0YXRlID0gbGluZXNbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIHJ4X2J5dGVzID0gcGFyc2VJbnQobGluZXNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICB0eF9ieXRlcyA9IHBhcnNlSW50KGxpbmVzWzJdLCAxMCk7XG4gICAgICAgICAgICAgICAgcnhfZHJvcHBlZCA9IHBhcnNlSW50KGxpbmVzWzNdLCAxMCk7XG4gICAgICAgICAgICAgICAgcnhfZXJyb3JzID0gcGFyc2VJbnQobGluZXNbNF0sIDEwKTtcbiAgICAgICAgICAgICAgICB0eF9kcm9wcGVkID0gcGFyc2VJbnQobGluZXNbNV0sIDEwKTtcbiAgICAgICAgICAgICAgICB0eF9lcnJvcnMgPSBwYXJzZUludChsaW5lc1s2XSwgMTApO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY05ldHdvcmtTcGVlZChpZmFjZVNhbml0aXplZCwgcnhfYnl0ZXMsIHR4X2J5dGVzLCBvcGVyc3RhdGUsIHJ4X2Ryb3BwZWQsIHJ4X2Vycm9ycywgdHhfZHJvcHBlZCwgdHhfZXJyb3JzKTtcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgY21kID0gJ25ldHN0YXQgLWlibmRJICcgKyBpZmFjZVNhbml0aXplZDsgICAvLyBsZ3RtIFtqcy9zaGVsbC1jb21tYW5kLWNvbnN0cnVjdGVkLWZyb20taW5wdXRdXG4gICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSAmJiBsaW5lWzBdICYmIGxpbmVbN10gJiYgbGluZVsxMF0pIHtcbiAgICAgICAgICAgICAgICAgIHJ4X2J5dGVzID0gcnhfYnl0ZXMgKyBwYXJzZUludChsaW5lWzddKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lWzZdLnRyaW0oKSAhPT0gJy0nKSB7IHJ4X2Ryb3BwZWQgPSByeF9kcm9wcGVkICsgcGFyc2VJbnQobGluZVs2XSk7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lWzVdLnRyaW0oKSAhPT0gJy0nKSB7IHJ4X2Vycm9ycyA9IHJ4X2Vycm9ycyArIHBhcnNlSW50KGxpbmVbNV0pOyB9XG4gICAgICAgICAgICAgICAgICB0eF9ieXRlcyA9IHR4X2J5dGVzICsgcGFyc2VJbnQobGluZVsxMF0pO1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbMTJdLnRyaW0oKSAhPT0gJy0nKSB7IHR4X2Ryb3BwZWQgPSB0eF9kcm9wcGVkICsgcGFyc2VJbnQobGluZVsxMl0pOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobGluZVs5XS50cmltKCkgIT09ICctJykgeyB0eF9lcnJvcnMgPSB0eF9lcnJvcnMgKyBwYXJzZUludChsaW5lWzldKTsgfVxuICAgICAgICAgICAgICAgICAgb3BlcnN0YXRlID0gJ3VwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY05ldHdvcmtTcGVlZChpZmFjZVNhbml0aXplZCwgcnhfYnl0ZXMsIHR4X2J5dGVzLCBvcGVyc3RhdGUsIHJ4X2Ryb3BwZWQsIHJ4X2Vycm9ycywgdHhfZHJvcHBlZCwgdHhfZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIGNtZCA9ICdpZmNvbmZpZyAnICsgaWZhY2VTYW5pdGl6ZWQgKyAnIHwgZ3JlcCBcInN0YXR1c1wiJzsgICAgLy8gbGd0bSBbanMvc2hlbGwtY29tbWFuZC1jb25zdHJ1Y3RlZC1mcm9tLWlucHV0XVxuICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wZXJzdGF0ZSA9IChzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQub3BlcnN0YXRlID0gKHJlc3VsdC5vcGVyc3RhdGUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXN1bHQub3BlcnN0YXRlID0gKHJlc3VsdC5vcGVyc3RhdGUgPT09ICdhY3RpdmUnID8gJ3VwJyA6IChyZXN1bHQub3BlcnN0YXRlID09PSAnaW5hY3RpdmUnID8gJ2Rvd24nIDogJ3Vua25vd24nKSk7XG4gICAgICAgICAgICBjbWQgPSAnbmV0c3RhdCAtYmRJICcgKyBpZmFjZVNhbml0aXplZDsgICAvLyBsZ3RtIFtqcy9zaGVsbC1jb21tYW5kLWNvbnN0cnVjdGVkLWZyb20taW5wdXRdXG4gICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGxlc3MgdGhhbiAyIGxpbmVzLCBubyBpbmZvcm1hdGlvbiBmb3IgdGhpcyBpbnRlcmZhY2Ugd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEgJiYgbGluZXNbMV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgLy8gc2tpcCBoZWFkZXIgbGluZVxuICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzZWNvbmQgbGluZSBiZWNhdXNlIGl0IGlzIHRpZWQgdG8gdGhlIE5JQyBpbnN0ZWFkIG9mIHRoZSBpcHY0IG9yIGlwdjYgYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgc3RhdHMgPSBsaW5lc1sxXS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGF0cy5sZW5ndGggPiAxMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgcnhfYnl0ZXMgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyA1XSk7XG4gICAgICAgICAgICAgICAgICByeF9kcm9wcGVkID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgMTBdKTtcbiAgICAgICAgICAgICAgICAgIHJ4X2Vycm9ycyA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDRdKTtcbiAgICAgICAgICAgICAgICAgIHR4X2J5dGVzID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgOF0pO1xuICAgICAgICAgICAgICAgICAgdHhfZHJvcHBlZCA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDEwXSk7XG4gICAgICAgICAgICAgICAgICB0eF9lcnJvcnMgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyA3XSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjTmV0d29ya1NwZWVkKGlmYWNlU2FuaXRpemVkLCByeF9ieXRlcywgdHhfYnl0ZXMsIHJlc3VsdC5vcGVyc3RhdGUsIHJ4X2Ryb3BwZWQsIHJ4X2Vycm9ycywgdHhfZHJvcHBlZCwgdHhfZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgbGV0IHBlcmZEYXRhID0gW107XG4gICAgICAgICAgbGV0IGlmYWNlTmFtZSA9IGlmYWNlU2FuaXRpemVkO1xuXG4gICAgICAgICAgLy8gUGVyZm9ybWFuY2UgRGF0YVxuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1BlcmZSYXdEYXRhX1RjcGlwX05ldHdvcmtJbnRlcmZhY2UgfCBzZWxlY3QgTmFtZSxCeXRlc1JlY2VpdmVkUGVyc2VjLFBhY2tldHNSZWNlaXZlZEVycm9ycyxQYWNrZXRzUmVjZWl2ZWREaXNjYXJkZWQsQnl0ZXNTZW50UGVyc2VjLFBhY2tldHNPdXRib3VuZEVycm9ycyxQYWNrZXRzT3V0Ym91bmREaXNjYXJkZWQgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHNlY3Rpb25zID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgcGVyZkRhdGEgPSBwYXJzZUxpbmVzV2luZG93c1BlcmZEYXRhKHBzZWN0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5ldHdvcmsgSW50ZXJmYWNlc1xuICAgICAgICAgICAgbmV0d29ya0ludGVyZmFjZXMoZmFsc2UpLnRoZW4oaW50ZXJmYWNlcyA9PiB7XG4gICAgICAgICAgICAgIC8vIGdldCBieXRlcyBzZW50LCByZWNlaXZlZCBmcm9tIHBlcmZEYXRhIGJ5IG5hbWVcbiAgICAgICAgICAgICAgcnhfYnl0ZXMgPSAwO1xuICAgICAgICAgICAgICB0eF9ieXRlcyA9IDA7XG4gICAgICAgICAgICAgIHBlcmZEYXRhLmZvckVhY2goZGV0YWlsID0+IHtcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VzLmZvckVhY2goZGV0ID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICgoZGV0LmlmYWNlLnRvTG93ZXJDYXNlKCkgPT09IGlmYWNlU2FuaXRpemVkLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0Lm1hYy50b0xvd2VyQ2FzZSgpID09PSBpZmFjZVNhbml0aXplZC50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRldC5pcDQudG9Mb3dlckNhc2UoKSA9PT0gaWZhY2VTYW5pdGl6ZWQudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXQuaXA2LnRvTG93ZXJDYXNlKCkgPT09IGlmYWNlU2FuaXRpemVkLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0LmlmYWNlTmFtZS5yZXBsYWNlKC9bKClbXFxdIF0rL2csICcnKS5yZXBsYWNlKC8jfFxcLy9nLCAnXycpLnRvTG93ZXJDYXNlKCkgPT09IGlmYWNlU2FuaXRpemVkLnJlcGxhY2UoL1soKVtcXF0gXSsvZywgJycpLnJlcGxhY2UoJyMnLCAnXycpLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIChkZXQuaWZhY2VOYW1lLnJlcGxhY2UoL1soKVtcXF0gXSsvZywgJycpLnJlcGxhY2UoLyN8XFwvL2csICdfJykudG9Mb3dlckNhc2UoKSA9PT0gZGV0YWlsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmYWNlTmFtZSA9IGRldC5pZmFjZTtcbiAgICAgICAgICAgICAgICAgICAgcnhfYnl0ZXMgPSBkZXRhaWwucnhfYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHJ4X2Ryb3BwZWQgPSBkZXRhaWwucnhfZHJvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgcnhfZXJyb3JzID0gZGV0YWlsLnJ4X2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgdHhfYnl0ZXMgPSBkZXRhaWwudHhfYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHR4X2Ryb3BwZWQgPSBkZXRhaWwudHhfZHJvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgdHhfZXJyb3JzID0gZGV0YWlsLnR4X2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgb3BlcnN0YXRlID0gZGV0Lm9wZXJzdGF0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyeF9ieXRlcyAmJiB0eF9ieXRlcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNOZXR3b3JrU3BlZWQoaWZhY2VOYW1lLCBwYXJzZUludChyeF9ieXRlcyksIHBhcnNlSW50KHR4X2J5dGVzKSwgb3BlcnN0YXRlLCByeF9kcm9wcGVkLCByeF9lcnJvcnMsIHR4X2Ryb3BwZWQsIHR4X2Vycm9ycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yeF9ieXRlcyA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5yeF9ieXRlcztcbiAgICAgICAgcmVzdWx0LnR4X2J5dGVzID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLnR4X2J5dGVzO1xuICAgICAgICByZXN1bHQucnhfc2VjID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLnJ4X3NlYztcbiAgICAgICAgcmVzdWx0LnR4X3NlYyA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS50eF9zZWM7XG4gICAgICAgIHJlc3VsdC5tcyA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5sYXN0X21zO1xuICAgICAgICByZXN1bHQub3BlcnN0YXRlID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLm9wZXJzdGF0ZTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uZXR3b3JrU3RhdHMgPSBuZXR3b3JrU3RhdHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBORVQgLSBjb25uZWN0aW9ucyAoc29ja2V0cylcblxuZnVuY3Rpb24gZ2V0UHJvY2Vzc05hbWUocHJvY2Vzc2VzLCBwaWQpIHtcbiAgbGV0IGNtZCA9ICcnO1xuICBwcm9jZXNzZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBpZCA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCkgfHwgLTE7XG4gICAgaWYgKGlkID09PSBwaWQpIHtcbiAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICBjbWQgPSBwYXJ0cy5qb2luKCcgJykuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gIH0pO1xuICBjbWQgPSBjbWQuc3BsaXQoJyAtJylbMF07XG4gIC8vIHJldHVybiBjbWQ7XG4gIGNvbnN0IGNtZFBhcnRzID0gY21kLnNwbGl0KCcvJyk7XG4gIHJldHVybiBjbWRQYXJ0c1tjbWRQYXJ0cy5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gbmV0d29ya0Nvbm5lY3Rpb25zKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgbGV0IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IG5ldHN0YXQgLXR1bmFwIHwgZ3JlcCBcIkVTVEFCTElTSEVEXFxcXHxTWU5fU0VOVFxcXFx8U1lOX1JFQ1ZcXFxcfEZJTl9XQUlUMVxcXFx8RklOX1dBSVQyXFxcXHxUSU1FX1dBSVRcXFxcfENMT1NFXFxcXHxDTE9TRV9XQUlUXFxcXHxMQVNUX0FDS1xcXFx8TElTVEVOXFxcXHxDTE9TSU5HXFxcXHxVTktOT1dOXCI7IHVuc2V0IExDX0FMTCc7XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IG5ldHN0YXQgLW5hIHwgZ3JlcCBcIkVTVEFCTElTSEVEXFxcXHxTWU5fU0VOVFxcXFx8U1lOX1JFQ1ZcXFxcfEZJTl9XQUlUMVxcXFx8RklOX1dBSVQyXFxcXHxUSU1FX1dBSVRcXFxcfENMT1NFXFxcXHxDTE9TRV9XQUlUXFxcXHxMQVNUX0FDS1xcXFx8TElTVEVOXFxcXHxDTE9TSU5HXFxcXHxVTktOT1dOXCI7IHVuc2V0IExDX0FMTCc7IH1cbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgaWYgKCFlcnJvciAmJiAobGluZXMubGVuZ3RoID4gMSB8fCBsaW5lc1swXSAhPSAnJykpIHtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gNykge1xuICAgICAgICAgICAgICAgIGxldCBsb2NhbGlwID0gbGluZVszXTtcbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsYWRkcmVzcyA9IGxpbmVbM10uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FscG9ydCA9IGxvY2FsYWRkcmVzc1tsb2NhbGFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICBsb2NhbGFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICBsb2NhbGlwID0gbG9jYWxhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBlZXJpcCA9IGxpbmVbNF07XG4gICAgICAgICAgICAgICAgbGV0IHBlZXJwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IHBlZXJhZGRyZXNzID0gbGluZVs0XS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChwZWVyYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBwZWVycG9ydCA9IHBlZXJhZGRyZXNzW3BlZXJhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgcGVlcmFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICBwZWVyaXAgPSBwZWVyYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb25uc3RhdGUgPSBsaW5lWzVdO1xuICAgICAgICAgICAgICAgIGxldCBwcm9jID0gbGluZVs2XS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogbGluZVswXSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbGlwLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFBvcnQ6IGxvY2FscG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcGVlckFkZHJlc3M6IHBlZXJpcCxcbiAgICAgICAgICAgICAgICAgICAgcGVlclBvcnQ6IHBlZXJwb3J0LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY29ubnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBwaWQ6IHByb2NbMF0gJiYgcHJvY1swXSAhPT0gJy0nID8gcGFyc2VJbnQocHJvY1swXSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogcHJvY1sxXSA/IHByb2NbMV0uc3BsaXQoJyAnKVswXS5zcGxpdCgnOicpWzBdIDogJydcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY21kID0gJ3NzIC10dW5hcCB8IGdyZXAgXCJFU1RBQlxcXFx8U1lOLVNFTlRcXFxcfFNZTi1SRUNWXFxcXHxGSU4tV0FJVDFcXFxcfEZJTi1XQUlUMlxcXFx8VElNRS1XQUlUXFxcXHxDTE9TRVxcXFx8Q0xPU0UtV0FJVFxcXFx8TEFTVC1BQ0tcXFxcfExJU1RFTlxcXFx8Q0xPU0lOR1wiJztcbiAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG5cbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gNikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxpcCA9IGxpbmVbNF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbHBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsYWRkcmVzcyA9IGxpbmVbNF0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxwb3J0ID0gbG9jYWxhZGRyZXNzW2xvY2FsYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbGFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxpcCA9IGxvY2FsYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlZXJpcCA9IGxpbmVbNV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZWVycG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVlcmFkZHJlc3MgPSBsaW5lWzVdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVyYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVlcnBvcnQgPSBwZWVyYWRkcmVzc1twZWVyYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyaXAgPSBwZWVyYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5zdGF0ZSA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdFU1RBQicpIHsgY29ubnN0YXRlID0gJ0VTVEFCTElTSEVEJzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnVElNRS1XQUlUJykgeyBjb25uc3RhdGUgPSAnVElNRV9XQUlUJzsgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcGlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2Nlc3MgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDcgJiYgbGluZVs2XS5pbmRleE9mKCd1c2VyczonKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2MgPSBsaW5lWzZdLnJlcGxhY2UoJ3VzZXJzOigoXCInLCAnJykucmVwbGFjZSgvXCIvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyA9IHByb2NbMF0uc3BsaXQoJyAnKVswXS5zcGxpdCgnOicpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGlkID0gcGFyc2VJbnQocHJvY1sxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGxpbmVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvcnQ6IGxvY2FscG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBwZWVyaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyUG9ydDogcGVlcnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY29ubnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgLy8gbGV0IGNtZCA9ICduZXRzdGF0IC1uYXR2IHwgZ3JlcCBcIkVTVEFCTElTSEVEXFxcXHxTWU5fU0VOVFxcXFx8U1lOX1JFQ1ZcXFxcfEZJTl9XQUlUMVxcXFx8RklOX1dBSVQyXFxcXHxUSU1FX1dBSVRcXFxcfENMT1NFXFxcXHxDTE9TRV9XQUlUXFxcXHxMQVNUX0FDS1xcXFx8TElTVEVOXFxcXHxDTE9TSU5HXFxcXHxVTktOT1dOXCInO1xuICAgICAgICBsZXQgY21kID0gJ25ldHN0YXQgLW5hdHYgfCBncmVwIFwidGNwNFxcXFx8dGNwNlxcXFx8dWRwNFxcXFx8dWRwNlwiJztcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gJ0VTVEFCTElTSEVEfFNZTl9TRU5UfFNZTl9SRUNWfEZJTl9XQUlUMXxGSU5fV0FJVDJ8VElNRV9XQUlUfENMT1NFfENMT1NFX1dBSVR8TEFTVF9BQ0t8TElTVEVOfENMT1NJTkd8VU5LTk9XTic7XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXhlYygncHMgLWF4byBwaWQsY29tbWFuZCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycjIsIHN0ZG91dDIpIHtcbiAgICAgICAgICAgICAgbGV0IHByb2Nlc3NlcyA9IHN0ZG91dDIudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIHByb2Nlc3NlcyA9IHByb2Nlc3Nlcy5tYXAoKGxpbmUgPT4geyByZXR1cm4gbGluZS50cmltKCkucmVwbGFjZSgvICsvZywgJyAnKTsgfSkpO1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gOCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsaXAgPSBsaW5lWzNdO1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FscG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsYWRkcmVzcyA9IGxpbmVbM10uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbHBvcnQgPSBsb2NhbGFkZHJlc3NbbG9jYWxhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsaXAgPSBsb2NhbGFkZHJlc3Muam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJpcCA9IGxpbmVbNF07XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcnBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgIGxldCBwZWVyYWRkcmVzcyA9IGxpbmVbNF0uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWVyYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJwb3J0ID0gcGVlcmFkZHJlc3NbcGVlcmFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHBlZXJhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBwZWVyaXAgPSBwZWVyYWRkcmVzcy5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBoYXNTdGF0ZSA9IHN0YXRlcy5pbmRleE9mKGxpbmVbNV0pID49IDA7XG4gICAgICAgICAgICAgICAgICBsZXQgY29ubnN0YXRlID0gaGFzU3RhdGUgPyBsaW5lWzVdIDogJ1VOS05PV04nO1xuICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IHBhcnNlSW50KGxpbmVbOCArIChoYXNTdGF0ZSA/IDAgOiAtMSldLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogbGluZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3J0OiBsb2NhbHBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlckFkZHJlc3M6IHBlZXJpcCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyUG9ydDogcGVlcnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGNvbm5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzOiBnZXRQcm9jZXNzTmFtZShwcm9jZXNzZXMsIHBpZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IGNtZCA9ICduZXRzdGF0IC1uYW8nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoY21kLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcblxuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsaXAgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FscG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsYWRkcmVzcyA9IGxpbmVbMV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbHBvcnQgPSBsb2NhbGFkZHJlc3NbbG9jYWxhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsaXAgPSBsb2NhbGFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbG9jYWxpcCA9IGxvY2FsaXAucmVwbGFjZSgvXFxbL2csICcnKS5yZXBsYWNlKC9cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJpcCA9IGxpbmVbMl07XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcnBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgIGxldCBwZWVyYWRkcmVzcyA9IGxpbmVbMl0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWVyYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJwb3J0ID0gcGVlcmFkZHJlc3NbcGVlcmFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHBlZXJhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBwZWVyaXAgPSBwZWVyYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwZWVyaXAgPSBwZWVyaXAucmVwbGFjZSgvXFxbL2csICcnKS5yZXBsYWNlKC9cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IHV0aWwudG9JbnQobGluZVs0XSk7XG4gICAgICAgICAgICAgICAgICBsZXQgY29ubnN0YXRlID0gbGluZVszXTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdIRVJHRVNURUxMVCcpIHsgY29ubnN0YXRlID0gJ0VTVEFCTElTSEVEJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZS5zdGFydHNXaXRoKCdBQkgnKSkgeyBjb25uc3RhdGUgPSAnTElTVEVOJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ1NDSExJRVNTRU5fV0FSVEVOJykgeyBjb25uc3RhdGUgPSAnQ0xPU0VfV0FJVCc7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdXQVJURU5EJykgeyBjb25uc3RhdGUgPSAnVElNRV9XQUlUJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ1NZTl9HRVNFTkRFVCcpIHsgY29ubnN0YXRlID0gJ1NZTl9TRU5UJzsgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnTElTVEVOSU5HJykgeyBjb25uc3RhdGUgPSAnTElTVEVOJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ1NZTl9SRUNFSVZFRCcpIHsgY29ubnN0YXRlID0gJ1NZTl9SRUNWJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ0ZJTl9XQUlUXzEnKSB7IGNvbm5zdGF0ZSA9ICdGSU5fV0FJVDEnOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnRklOX1dBSVRfMicpIHsgY29ubnN0YXRlID0gJ0ZJTl9XQUlUMic7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lWzBdLnRvTG93ZXJDYXNlKCkgIT09ICd1ZHAnICYmIGNvbm5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGxpbmVbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3J0OiBsb2NhbHBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlckFkZHJlc3M6IHBlZXJpcCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyUG9ydDogcGVlcnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGNvbm5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogJydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBsaW5lWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbGlwLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9ydDogbG9jYWxwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBwZWVyaXAsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlclBvcnQ6IHBlZXJwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBhcnNlSW50KGxpbmVbM10sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm5ldHdvcmtDb25uZWN0aW9ucyA9IG5ldHdvcmtDb25uZWN0aW9ucztcblxuZnVuY3Rpb24gbmV0d29ya0dhdGV3YXlEZWZhdWx0KGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgbGV0IGNtZCA9ICdpcCByb3V0ZSBnZXQgMSc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXMgJiYgbGluZXNbMF0gPyBsaW5lc1swXSA6ICcnO1xuICAgICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCcgdmlhICcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHNbMV0pIHtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3JvdXRlIC1uIGdldCBkZWZhdWx0JztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdnYXRld2F5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICBjbWQgPSAnbmV0c3RhdCAtcm4gfCBhd2sgXFwnL2RlZmF1bHQvIHtwcmludCAkMn1cXCcnO1xuICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaW5lcy5maW5kKGxpbmUgPT4gKC9eKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykkLy50ZXN0KGxpbmUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYygnbmV0c3RhdCAtcicsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KG9zLkVPTCk7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcwLjAuMC4wIDAuMC4wLjAnKSA+IC0xICYmICEoL1thLXpBLVpdLy50ZXN0KGxpbmUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNSAmJiAocGFydHNbcGFydHMubGVuZ3RoIC0gM10pLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgLUNsYXNzTmFtZSBXaW4zMl9JUDRSb3V0ZVRhYmxlIHwgV2hlcmUtT2JqZWN0IHsgJF8uRGVzdGluYXRpb24gLWVxIFxcJzAuMC4wLjBcXCcgLWFuZCAkXy5NYXNrIC1lcSBcXCcwLjAuMC4wXFwnIH0nKVxuICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEgJiYgIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmV4dEhvcCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBleGVjKCdpcGNvbmZpZycsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5yZXBsYWNlKC9cXC4gL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnJlcGxhY2UoLyArL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGlmICgocGFydHNbMF0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdzdGFuZGFyZGdhdGUnKSB8fCBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2dhdGV3YXknKSA+IC0xIHx8IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZW5sYWNlJykgPiAtMSkgJiYgcGFydHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICByZXN1bHQgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uZXR3b3JrR2F0ZXdheURlZmF1bHQgPSBuZXR3b3JrR2F0ZXdheURlZmF1bHQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIG9zaW5mby5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDMuIE9wZXJhdGluZyBTeXN0ZW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2V0IGN1cnJlbnQgdGltZSBhbmQgT1MgdXB0aW1lXG5cbmZ1bmN0aW9uIHRpbWUoKSB7XG4gIGxldCB0ID0gbmV3IERhdGUoKS50b1N0cmluZygpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogRGF0ZS5ub3coKSxcbiAgICB1cHRpbWU6IG9zLnVwdGltZSgpLFxuICAgIHRpbWV6b25lOiAodC5sZW5ndGggPj0gNykgPyB0WzVdIDogJycsXG4gICAgdGltZXpvbmVOYW1lOiBJbnRsID8gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lIDogKHQubGVuZ3RoID49IDcpID8gdC5zbGljZSg2KS5qb2luKCcgJykucmVwbGFjZSgvXFwoL2csICcnKS5yZXBsYWNlKC9cXCkvZywgJycpIDogJydcbiAgfTtcbn1cblxuZXhwb3J0cy50aW1lID0gdGltZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdldCBsb2dvIGZpbGVuYW1lIG9mIE9TIGRpc3RyaWJ1dGlvblxuXG5mdW5jdGlvbiBnZXRMb2dvRmlsZShkaXN0cm8pIHtcbiAgZGlzdHJvID0gZGlzdHJvIHx8ICcnO1xuICBkaXN0cm8gPSBkaXN0cm8udG9Mb3dlckNhc2UoKTtcbiAgbGV0IHJlc3VsdCA9IF9wbGF0Zm9ybTtcbiAgaWYgKF93aW5kb3dzKSB7XG4gICAgcmVzdWx0ID0gJ3dpbmRvd3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtYWMgb3MnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnYXBwbGUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdhcmNoJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2FyY2gnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdjZW50b3MnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnY2VudG9zJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignY29yZW9zJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2NvcmVvcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2RlYmlhbicpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdkZWJpYW4nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdkZWVwaW4nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZGVlcGluJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZWxlbWVudGFyeScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdlbGVtZW50YXJ5JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZmVkb3JhJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2ZlZG9yYSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2dlbnRvbycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdnZW50b28nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtYWdlaWEnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbWFnZWlhJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWFuZHJpdmEnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbWFuZHJpdmEnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtYW5qYXJvJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ21hbmphcm8nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtaW50JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ21pbnQnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdteCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdteCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ29wZW5ic2QnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnb3BlbmJzZCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2ZyZWVic2QnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZnJlZWJzZCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ29wZW5zdXNlJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ29wZW5zdXNlJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncGNsaW51eG9zJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3BjbGludXhvcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3B1cHB5JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3B1cHB5JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncmFzcGJpYW4nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncmFzcGJpYW4nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdyZWFjdG9zJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3JlYWN0b3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdyZWRoYXQnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncmVkaGF0JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignc2xhY2t3YXJlJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3NsYWNrd2FyZSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3N1Z2FyJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3N1Z2FyJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignc3RlYW0nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnc3RlYW0nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdzdXNlJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3N1c2UnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtYXRlJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3VidW50dS1tYXRlJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbHVidW50dScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdsdWJ1bnR1JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigneHVidW50dScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICd4dWJ1bnR1JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigndWJ1bnR1JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3VidW50dSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3NvbGFyaXMnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnc29sYXJpcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3RhaWxzJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3RhaWxzJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZmVyZW4nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZmVyZW5vcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3JvYm9saW51eCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdyb2JvbGludXgnO1xuICB9IGVsc2UgaWYgKF9saW51eCAmJiBkaXN0cm8pIHtcbiAgICByZXN1bHQgPSBkaXN0cm8udG9Mb3dlckNhc2UoKS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGUUROXG5cbmZ1bmN0aW9uIGdldEZRRE4oKSB7XG4gIGxldCBmcWRuID0gb3MuaG9zdG5hbWU7XG4gIGlmIChfbGludXggfHwgX2Rhcndpbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnaG9zdG5hbWUgLWYnKTtcbiAgICAgIGZxZG4gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdChvcy5FT0wpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfVxuICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnaG9zdG5hbWUnKTtcbiAgICAgIGZxZG4gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdChvcy5FT0wpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfVxuICBpZiAoX3dpbmRvd3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2VjaG8gJUNPTVBVVEVSTkFNRSUuJVVTRVJETlNET01BSU4lJywgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgICBmcWRuID0gc3Rkb3V0LnRvU3RyaW5nKCkucmVwbGFjZSgnLiVVU0VSRE5TRE9NQUlOJScsICcnKS5zcGxpdChvcy5FT0wpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnFkbjtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9TIEluZm9ybWF0aW9uXG5cbmZ1bmN0aW9uIG9zSW5mbyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcblxuICAgICAgICBwbGF0Zm9ybTogKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdXaW5kb3dzJyA6IF9wbGF0Zm9ybSksXG4gICAgICAgIGRpc3RybzogJ3Vua25vd24nLFxuICAgICAgICByZWxlYXNlOiAndW5rbm93bicsXG4gICAgICAgIGNvZGVuYW1lOiAnJyxcbiAgICAgICAga2VybmVsOiBvcy5yZWxlYXNlKCksXG4gICAgICAgIGFyY2g6IG9zLmFyY2goKSxcbiAgICAgICAgaG9zdG5hbWU6IG9zLmhvc3RuYW1lKCksXG4gICAgICAgIGZxZG46IGdldEZRRE4oKSxcbiAgICAgICAgY29kZXBhZ2U6ICcnLFxuICAgICAgICBsb2dvZmlsZTogJycsXG4gICAgICAgIHNlcmlhbDogJycsXG4gICAgICAgIGJ1aWxkOiAnJyxcbiAgICAgICAgc2VydmljZXBhY2s6ICcnLFxuICAgICAgICB1ZWZpOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKF9saW51eCkge1xuXG4gICAgICAgIGV4ZWMoJ2NhdCAvZXRjLyotcmVsZWFzZTsgY2F0IC91c3IvbGliL29zLXJlbGVhc2U7IGNhdCAvZXRjL29wZW53cnRfcmVsZWFzZScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgRElTVFJJQl9JRFxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgTkFNRVxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgRElTVFJJQl9SRUxFQVNFXG4gICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBWRVJTSU9OX0lEXG4gICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBESVNUUklCX0NPREVOQU1FXG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IHJlbGVhc2UgPSB7fTtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignPScpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZWxlYXNlW2xpbmUuc3BsaXQoJz0nKVswXS50cmltKCkudG9VcHBlckNhc2UoKV0gPSBsaW5lLnNwbGl0KCc9JylbMV0udHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZWxlYXNlVmVyc2lvbiA9IChyZWxlYXNlLlZFUlNJT04gfHwgJycpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICBsZXQgY29kZW5hbWUgPSAocmVsZWFzZS5ESVNUUklCX0NPREVOQU1FIHx8IHJlbGVhc2UuVkVSU0lPTl9DT0RFTkFNRSB8fCAnJykucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgIGlmIChyZWxlYXNlVmVyc2lvbi5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgY29kZW5hbWUgPSByZWxlYXNlVmVyc2lvbi5zcGxpdCgnKCcpWzFdLnJlcGxhY2UoL1soKV0vZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlbGVhc2VWZXJzaW9uID0gcmVsZWFzZVZlcnNpb24uc3BsaXQoJygnKVswXS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5kaXN0cm8gPSAocmVsZWFzZS5ESVNUUklCX0lEIHx8IHJlbGVhc2UuTkFNRSB8fCAndW5rbm93bicpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICByZXN1bHQubG9nb2ZpbGUgPSBnZXRMb2dvRmlsZShyZXN1bHQuZGlzdHJvKTtcbiAgICAgICAgICByZXN1bHQucmVsZWFzZSA9IChyZWxlYXNlVmVyc2lvbiB8fCByZWxlYXNlLkRJU1RSSUJfUkVMRUFTRSB8fCByZWxlYXNlLlZFUlNJT05fSUQgfHwgJ3Vua25vd24nKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gY29kZW5hbWU7XG4gICAgICAgICAgcmVzdWx0LmNvZGVwYWdlID0gdXRpbC5nZXRDb2RlcGFnZSgpO1xuICAgICAgICAgIHJlc3VsdC5idWlsZCA9IChyZWxlYXNlLkJVSUxEX0lEIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpO1xuICAgICAgICAgIGlzVWVmaUxpbnV4KCkudGhlbih1ZWZpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC51ZWZpID0gdWVmaTtcbiAgICAgICAgICAgIHV1aWQoKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSBkYXRhLm9zO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG5cbiAgICAgICAgZXhlYygnc3lzY3RsIGtlcm4ub3N0eXBlIGtlcm4ub3NyZWxlYXNlIGtlcm4ub3NyZXZpc2lvbiBrZXJuLmhvc3R1dWlkIG1hY2hkZXAuYm9vdG1ldGhvZCBrZXJuLmdlb20uY29uZnhtbCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGNvbnN0IGRpc3RybyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm9zdHlwZScpO1xuICAgICAgICAgIGNvbnN0IGxvZ29maWxlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ub3N0eXBlJyk7XG4gICAgICAgICAgY29uc3QgcmVsZWFzZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm9zcmVsZWFzZScpLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgY29uc3Qgc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4udXVpZCcpO1xuICAgICAgICAgIGNvbnN0IGJvb3RtZXRob2QgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5ib290bWV0aG9kJyk7XG4gICAgICAgICAgY29uc3QgdWVmaUNvbmYgPSBzdGRvdXQudG9TdHJpbmcoKS5pbmRleE9mKCc8dHlwZT5lZmk8L3R5cGU+JykgPj0gMDtcbiAgICAgICAgICBjb25zdCB1ZWZpID0gYm9vdG1ldGhvZCA/IGJvb3RtZXRob2QudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd1ZWZpJykgPj0gMCA6ICh1ZWZpQ29uZiA/IHVlZmlDb25mIDogbnVsbCk7XG4gICAgICAgICAgcmVzdWx0LmRpc3RybyA9IGRpc3RybyB8fCByZXN1bHQuZGlzdHJvO1xuICAgICAgICAgIHJlc3VsdC5sb2dvZmlsZSA9IGxvZ29maWxlIHx8IHJlc3VsdC5sb2dvZmlsZTtcbiAgICAgICAgICByZXN1bHQucmVsZWFzZSA9IHJlbGVhc2UgfHwgcmVzdWx0LnJlbGVhc2U7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHNlcmlhbCB8fCByZXN1bHQuc2VyaWFsO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9ICcnO1xuICAgICAgICAgIHJlc3VsdC5jb2RlcGFnZSA9IHV0aWwuZ2V0Q29kZXBhZ2UoKTtcbiAgICAgICAgICByZXN1bHQudWVmaSA9IHVlZmkgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzd192ZXJzOyBzeXNjdGwga2Vybi5vc3R5cGUga2Vybi5vc3JlbGVhc2Uga2Vybi5vc3JldmlzaW9uIGtlcm4udXVpZCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi51dWlkJyk7XG4gICAgICAgICAgcmVzdWx0LmRpc3RybyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9kdWN0TmFtZScpO1xuICAgICAgICAgIHJlc3VsdC5yZWxlYXNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2R1Y3RWZXJzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LmJ1aWxkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J1aWxkVmVyc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5sb2dvZmlsZSA9IGdldExvZ29GaWxlKHJlc3VsdC5kaXN0cm8pO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9ICdtYWNPUyc7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjQnKSA+IC0xID8gJ01hYyBPUyBYIFRpZ2VyJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjUnKSA+IC0xID8gJ01hYyBPUyBYIExlb3BhcmQnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuNicpID4gLTEgPyAnTWFjIE9TIFggU25vdyBMZW9wYXJkJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjcnKSA+IC0xID8gJ01hYyBPUyBYIExpb24nIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuOCcpID4gLTEgPyAnT1MgWCBNb3VudGFpbiBMaW9uJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjknKSA+IC0xID8gJ09TIFggTWF2ZXJpY2tzJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjEwJykgPiAtMSA/ICdPUyBYIFlvc2VtaXRlJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjExJykgPiAtMSA/ICdPUyBYIEVsIENhcGl0YW4nIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTInKSA+IC0xID8gJ21hY09TIFNpZXJyYScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xMycpID4gLTEgPyAnbWFjT1MgSGlnaCBTaWVycmEnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTQnKSA+IC0xID8gJ21hY09TIE1vamF2ZScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xNScpID4gLTEgPyAnbWFjT1MgQ2F0YWxpbmEnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2Uuc3RhcnRzV2l0aCgnMTEuJykgPyAnbWFjT1MgQmlnIFN1cicgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5zdGFydHNXaXRoKCcxMi4nKSA/ICdtYWNPUyBNb250ZXJleScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5zdGFydHNXaXRoKCcxMy4nKSA/ICdtYWNPUyBWZW50dXJhJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LnVlZmkgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5jb2RlcGFnZSA9IHV0aWwuZ2V0Q29kZXBhZ2UoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIHJlc3VsdC5yZWxlYXNlID0gcmVzdWx0Lmtlcm5lbDtcbiAgICAgICAgZXhlYygndW5hbWUgLW8nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQuZGlzdHJvID0gbGluZXNbMF07XG4gICAgICAgICAgcmVzdWx0LmxvZ29maWxlID0gZ2V0TG9nb0ZpbGUocmVzdWx0LmRpc3Rybyk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHJlc3VsdC5sb2dvZmlsZSA9IGdldExvZ29GaWxlKCk7XG4gICAgICAgIHJlc3VsdC5yZWxlYXNlID0gcmVzdWx0Lmtlcm5lbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfT3BlcmF0aW5nU3lzdGVtIHwgc2VsZWN0IENhcHRpb24sU2VyaWFsTnVtYmVyLEJ1aWxkTnVtYmVyLFNlcnZpY2VQYWNrTWFqb3JWZXJzaW9uLFNlcnZpY2VQYWNrTWlub3JWZXJzaW9uIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJyhHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ29tcHV0ZXJTeXN0ZW0pLkh5cGVydmlzb3JQcmVzZW50JykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdBZGQtVHlwZSAtQXNzZW1ibHlOYW1lIFN5c3RlbS5XaW5kb3dzLkZvcm1zOyBbU3lzdGVtLldpbmRvd3MuRm9ybXMuU3lzdGVtSW5mb3JtYXRpb25dOjpUZXJtaW5hbFNlcnZlclNlc3Npb24nKSk7XG4gICAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGEucmVzdWx0c1swXSA/IGRhdGEucmVzdWx0c1swXS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKSA6IFsnJ107XG4gICAgICAgICAgICByZXN1bHQuZGlzdHJvID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsTnVtYmVyJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuYnVpbGQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnVpbGROdW1iZXInLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJ2aWNlcGFjayA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJ2aWNlUGFja01ham9yVmVyc2lvbicsICc6JykudHJpbSgpICsgJy4nICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcnZpY2VQYWNrTWlub3JWZXJzaW9uJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuY29kZXBhZ2UgPSB1dGlsLmdldENvZGVwYWdlKCk7XG4gICAgICAgICAgICBjb25zdCBoeXBlcnYgPSBkYXRhLnJlc3VsdHNbMV0gPyBkYXRhLnJlc3VsdHNbMV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgICAgICByZXN1bHQuaHlwZXJ2aXNvciA9IGh5cGVydi5pbmRleE9mKCd0cnVlJykgIT09IC0xO1xuICAgICAgICAgICAgY29uc3QgdGVybSA9IGRhdGEucmVzdWx0c1syXSA/IGRhdGEucmVzdWx0c1syXS50b1N0cmluZygpIDogJyc7XG4gICAgICAgICAgICByZXN1bHQucmVtb3RlU2Vzc2lvbiA9ICh0ZXJtLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd0cnVlJykgPj0gMCk7XG4gICAgICAgICAgICBpc1VlZmlXaW5kb3dzKCkudGhlbih1ZWZpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0LnVlZmkgPSB1ZWZpO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMub3NJbmZvID0gb3NJbmZvO1xuXG5mdW5jdGlvbiBpc1VlZmlMaW51eCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBmcy5zdGF0KCcvc3lzL2Zpcm13YXJlL2VmaScsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGVjKCdkbWVzZyB8IGdyZXAgLUUgXCJFRkkgdlwiJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpbmVzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzVWVmaVdpbmRvd3MoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXhlYygnZmluZHN0ciAvQzpcIkRldGVjdGVkIGJvb3QgZW52aXJvbm1lbnRcIiBcIiV3aW5kaXIlXFxcXFBhbnRoZXJcXFxcc2V0dXBhY3QubG9nXCInLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxyJylbMF07XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZWZpJykgPj0gMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ2VjaG8gJWZpcm13YXJlX3R5cGUlJywgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGRvdXQudG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZWZpJykgPj0gMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2ZXJzaW9ucyhhcHBzLCBjYWxsYmFjaykge1xuICBsZXQgdmVyc2lvbk9iamVjdCA9IHtcbiAgICBrZXJuZWw6IG9zLnJlbGVhc2UoKSxcbiAgICBvcGVuc3NsOiAnJyxcbiAgICBzeXN0ZW1PcGVuc3NsOiAnJyxcbiAgICBzeXN0ZW1PcGVuc3NsTGliOiAnJyxcbiAgICBub2RlOiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsXG4gICAgdjg6IHByb2Nlc3MudmVyc2lvbnMudjgsXG4gICAgbnBtOiAnJyxcbiAgICB5YXJuOiAnJyxcbiAgICBwbTI6ICcnLFxuICAgIGd1bHA6ICcnLFxuICAgIGdydW50OiAnJyxcbiAgICBnaXQ6ICcnLFxuICAgIHRzYzogJycsXG4gICAgbXlzcWw6ICcnLFxuICAgIHJlZGlzOiAnJyxcbiAgICBtb25nb2RiOiAnJyxcbiAgICBhcGFjaGU6ICcnLFxuICAgIG5naW54OiAnJyxcbiAgICBwaHA6ICcnLFxuICAgIGRvY2tlcjogJycsXG4gICAgcG9zdGZpeDogJycsXG4gICAgcG9zdGdyZXNxbDogJycsXG4gICAgcGVybDogJycsXG4gICAgcHl0aG9uOiAnJyxcbiAgICBweXRob24zOiAnJyxcbiAgICBwaXA6ICcnLFxuICAgIHBpcDM6ICcnLFxuICAgIGphdmE6ICcnLFxuICAgIGdjYzogJycsXG4gICAgdmlydHVhbGJveDogJycsXG4gICAgYmFzaDogJycsXG4gICAgenNoOiAnJyxcbiAgICBmaXNoOiAnJyxcbiAgICBwb3dlcnNoZWxsOiAnJyxcbiAgICBkb3RuZXQ6ICcnXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tWZXJzaW9uUGFyYW0oYXBwcykge1xuICAgIGlmIChhcHBzID09PSAnKicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb25zOiB2ZXJzaW9uT2JqZWN0LFxuICAgICAgICBjb3VudGVyOiAzMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFwcHMpKSB7XG4gICAgICBhcHBzID0gYXBwcy50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8sKy9nLCAnfCcpLnJlcGxhY2UoLyAvZywgJ3wnKTtcbiAgICAgIGFwcHMgPSBhcHBzLnNwbGl0KCd8Jyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHZlcnNpb25zOiB7fSxcbiAgICAgICAgY291bnRlcjogMFxuICAgICAgfTtcbiAgICAgIGFwcHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGZvciAobGV0IGtleSBpbiB2ZXJzaW9uT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh2ZXJzaW9uT2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gZWwudG9Mb3dlckNhc2UoKSAmJiAhe30uaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQudmVyc2lvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbnNba2V5XSA9IHZlcnNpb25PYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnb3BlbnNzbCcpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9ucy5zeXN0ZW1PcGVuc3NsID0gJyc7XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbnMuc3lzdGVtT3BlbnNzbExpYiA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZlcnNpb25zW2tleV0pIHsgcmVzdWx0LmNvdW50ZXIrKzsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKGFwcHMpICYmICFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGFwcHM7XG4gICAgICAgIGFwcHMgPSAnKic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBzID0gYXBwcyB8fCAnKic7XG4gICAgICAgIGlmICh0eXBlb2YgYXBwcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soe30pOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoe30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhcHBzT2JqID0gY2hlY2tWZXJzaW9uUGFyYW0oYXBwcyk7XG4gICAgICBsZXQgdG90YWxGdW5jdGlvbnMgPSBhcHBzT2JqLmNvdW50ZXI7XG5cbiAgICAgIGxldCBmdW5jdGlvblByb2Nlc3NlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKC0tdG90YWxGdW5jdGlvbnMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhhcHBzT2JqLnZlcnNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoYXBwc09iai52ZXJzaW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAgICAgbGV0IGNtZCA9ICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ29wZW5zc2wnKSkge1xuICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMub3BlbnNzbCA9IHByb2Nlc3MudmVyc2lvbnMub3BlbnNzbDtcbiAgICAgICAgICBleGVjKCdvcGVuc3NsIHZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgb3BlbnNzbF9zdHJpbmcgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICBsZXQgb3BlbnNzbCA9IG9wZW5zc2xfc3RyaW5nLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuc3lzdGVtT3BlbnNzbCA9IG9wZW5zc2wubGVuZ3RoID4gMCA/IG9wZW5zc2xbMV0gOiBvcGVuc3NsWzBdO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnN5c3RlbU9wZW5zc2xMaWIgPSBvcGVuc3NsLmxlbmd0aCA+IDAgPyBvcGVuc3NsWzBdIDogJ29wZW5zc2wnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnbnBtJykpIHtcbiAgICAgICAgICBleGVjKCducG0gLXYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm5wbSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3BtMicpKSB7XG4gICAgICAgICAgY21kID0gJ3BtMic7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICBjbWQgKz0gJy5jbWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjKGAke2NtZH0gLXZgLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgcG0yID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKCFwbTIuc3RhcnRzV2l0aCgnW1BNMl0nKSkge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG0yID0gcG0yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICd5YXJuJykpIHtcbiAgICAgICAgICBleGVjKCd5YXJuIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMueWFybiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2d1bHAnKSkge1xuICAgICAgICAgIGNtZCA9ICdndWxwJztcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNtZCArPSAnLmNtZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMoYCR7Y21kfSAtLXZlcnNpb25gLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBndWxwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmd1bHAgPSAoZ3VscC50b0xvd2VyQ2FzZSgpLnNwbGl0KCd2ZXJzaW9uJylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3RzYycpKSB7XG4gICAgICAgICAgY21kID0gJ3RzYyc7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICBjbWQgKz0gJy5jbWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjKGAke2NtZH0gLS12ZXJzaW9uYCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHNjID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnRzYyA9ICh0c2MudG9Mb3dlckNhc2UoKS5zcGxpdCgndmVyc2lvbicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdncnVudCcpKSB7XG4gICAgICAgICAgY21kID0gJ2dydW50JztcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNtZCArPSAnLmNtZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMoYCR7Y21kfSAtLXZlcnNpb25gLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBncnVudCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5ncnVudCA9IChncnVudC50b0xvd2VyQ2FzZSgpLnNwbGl0KCdjbGkgdicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdnaXQnKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy91c3IvbG9jYWwvQ2VsbGFyL2dpdCcpIHx8IGZzLmV4aXN0c1N5bmMoJy9vcHQvaG9tZWJyZXcvYmluL2dpdCcpO1xuICAgICAgICAgICAgaWYgKHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSB8fCBnaXRIb21lYnJld0V4aXN0cykge1xuICAgICAgICAgICAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ2l0ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgZ2l0ID0gKGdpdC50b0xvd2VyQ2FzZSgpLnNwbGl0KCd2ZXJzaW9uJylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ2l0ID0gKGdpdC5zcGxpdCgnICcpWzBdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygnZ2l0IC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ2l0ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGdpdCA9IChnaXQudG9Mb3dlckNhc2UoKS5zcGxpdCgndmVyc2lvbicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5naXQgPSAoZ2l0LnNwbGl0KCcgJylbMF0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdhcGFjaGUnKSkge1xuICAgICAgICAgIGV4ZWMoJ2FwYWNoZWN0bCAtdiAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXBhY2hlID0gKHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJykuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5hcGFjaGUgPSAoYXBhY2hlLmxlbmd0aCA+IDEgPyBhcGFjaGVbMV0ucmVwbGFjZSgnQXBhY2hlJywgJycpLnJlcGxhY2UoJy8nLCAnJykuc3BsaXQoJygnKVswXS50cmltKCkgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICduZ2lueCcpKSB7XG4gICAgICAgICAgZXhlYygnbmdpbnggLXYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5naW54ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm5naW54ID0gKG5naW54LnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnbXlzcWwnKSkge1xuICAgICAgICAgIGV4ZWMoJ215c3FsIC1WJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IG15c3FsID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBteXNxbCA9IG15c3FsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChteXNxbC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG15c3FsID0gKG15c3FsLnNwbGl0KCcsJylbMF0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG15c3FsLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5teXNxbCA9IChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChteXNxbC5pbmRleE9mKCcgdmVyICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG15c3FsID0gbXlzcWwuc3BsaXQoJyB2ZXIgJylbMV07XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm15c3FsID0gbXlzcWwuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3BocCcpKSB7XG4gICAgICAgICAgZXhlYygncGhwIC12JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGhwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBsZXQgcGFydHMgPSBwaHAuc3BsaXQoJygnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLmluZGV4T2YoJy0nKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBocCA9IHBhcnRzWzBdLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncmVkaXMnKSkge1xuICAgICAgICAgIGV4ZWMoJ3JlZGlzLXNlcnZlciAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCByZWRpcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSByZWRpcy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnJlZGlzID0gdXRpbC5nZXRWYWx1ZShwYXJ0cywgJ3YnLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZG9ja2VyJykpIHtcbiAgICAgICAgICBleGVjKCdkb2NrZXIgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgZG9ja2VyID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGRvY2tlci5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmRvY2tlciA9IHBhcnRzLmxlbmd0aCA+IDIgJiYgcGFydHNbMl0uZW5kc1dpdGgoJywnKSA/IHBhcnRzWzJdLnNsaWNlKDAsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncG9zdGZpeCcpKSB7XG4gICAgICAgICAgZXhlYygncG9zdGNvbmYgLWQgfCBncmVwIG1haWxfdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3RmaXggPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykgfHwgW107XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGZpeCA9IHV0aWwuZ2V0VmFsdWUocG9zdGZpeCwgJ21haWxfdmVyc2lvbicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdtb25nb2RiJykpIHtcbiAgICAgICAgICBleGVjKCdtb25nb2QgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbW9uZ29kYiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5tb25nb2RiID0gKG1vbmdvZGIudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpWzBdIHx8ICcnKS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3Bvc3RncmVzcWwnKSkge1xuICAgICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAgIGV4ZWMoJ2xvY2F0ZSBiaW4vcG9zdGdyZXMnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNxbEJpbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RncmVzcWxCaW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBleGVjKHBvc3RncmVzcWxCaW5bcG9zdGdyZXNxbEJpbi5sZW5ndGggLSAxXSArICcgLVYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNxbCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS5zcGxpdCgnICcpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbCA9IHBvc3RncmVzcWwubGVuZ3RoID8gcG9zdGdyZXNxbFtwb3N0Z3Jlc3FsLmxlbmd0aCAtIDFdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGVjKCdwc3FsIC1WJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNxbCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS5zcGxpdCgnICcpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwgPSBwb3N0Z3Jlc3FsLmxlbmd0aCA/IHBvc3RncmVzcWxbcG9zdGdyZXNxbC5sZW5ndGggLSAxXSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwgPSBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfU2VydmljZSB8IHNlbGVjdCBjYXB0aW9uIHwgZmwnKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VydmljZVNlY3Rpb25zID0gc3Rkb3V0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgc2VydmljZVNlY3Rpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gaXRlbS50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3J2Q2FwdGlvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXB0aW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3J2Q2FwdGlvbi5pbmRleE9mKCdwb3N0Z3Jlc3FsJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3J2Q2FwdGlvbi5zcGxpdCgnIHNlcnZlciAnKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleGVjKCdwb3N0Z3JlcyAtVicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNxbCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS5zcGxpdCgnICcpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsID0gcG9zdGdyZXNxbC5sZW5ndGggPyBwb3N0Z3Jlc3FsW3Bvc3RncmVzcWwubGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwZXJsJykpIHtcbiAgICAgICAgICBleGVjKCdwZXJsIC12JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGVybCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKSB8fCAnJztcbiAgICAgICAgICAgICAgd2hpbGUgKHBlcmwubGVuZ3RoID4gMCAmJiBwZXJsWzBdLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwZXJsLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBlcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGVybCA9IHBlcmxbMF0uc3BsaXQoJygnKS5wb3AoKS5zcGxpdCgnKScpWzBdLnJlcGxhY2UoJ3YnLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3B5dGhvbicpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdzd192ZXJzJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IG9zVmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9kdWN0VmVyc2lvbicsICc6Jyk7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0czEgPSBmcy5leGlzdHNTeW5jKCcvdXNyL2xvY2FsL0NlbGxhci9weXRob24nKTtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzMiA9IGZzLmV4aXN0c1N5bmMoJy9vcHQvaG9tZWJyZXcvYmluL3B5dGhvbicpO1xuICAgICAgICAgICAgaWYgKCh1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkgJiYgdXRpbC5zZW12ZXJDb21wYXJlKCcxMi4wLjEnLCBvc1ZlcnNpb24pIDwgMCkgfHwgZ2l0SG9tZWJyZXdFeGlzdHMxIHx8IGdpdEhvbWVicmV3RXhpc3RzMikge1xuICAgICAgICAgICAgICBjb25zdCBjbWQgPSBnaXRIb21lYnJld0V4aXN0czEgPyAnL3Vzci9sb2NhbC9DZWxsYXIvcHl0aG9uIC1WIDI+JjEnIDogKGdpdEhvbWVicmV3RXhpc3RzMiA/ICcvb3B0L2hvbWVicmV3L2Jpbi9weXRob24gLVYgMj4mMScgOiAncHl0aG9uIC1WIDI+JjEnKTtcbiAgICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5weXRob24gPSBweXRob24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdweXRob24nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ3B5dGhvbiAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnB5dGhvbiA9IHB5dGhvbi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3B5dGhvbicsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncHl0aG9uMycpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzID0gZnMuZXhpc3RzU3luYygnL3Vzci9sb2NhbC9DZWxsYXIvcHl0aG9uMycpIHx8IGZzLmV4aXN0c1N5bmMoJy9vcHQvaG9tZWJyZXcvYmluL3B5dGhvbjMnKTtcbiAgICAgICAgICAgIGlmICh1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkgfHwgZ2l0SG9tZWJyZXdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgZXhlYygncHl0aG9uMyAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBweXRob24gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnB5dGhvbjMgPSBweXRob24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdweXRob24nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ3B5dGhvbjMgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob24gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5weXRob24zID0gcHl0aG9uLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncHl0aG9uJywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwaXAnKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy91c3IvbG9jYWwvQ2VsbGFyL3BpcCcpIHx8IGZzLmV4aXN0c1N5bmMoJy9vcHQvaG9tZWJyZXcvYmluL3BpcCcpO1xuICAgICAgICAgICAgaWYgKHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSB8fCBnaXRIb21lYnJld0V4aXN0cykge1xuICAgICAgICAgICAgICBleGVjKCdwaXAgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGlwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBwaXAuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGlwID0gcGFydHMubGVuZ3RoID49IDIgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ3BpcCAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpcCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBpcC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGlwID0gcGFydHMubGVuZ3RoID49IDIgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3BpcDMnKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy91c3IvbG9jYWwvQ2VsbGFyL3BpcDMnKSB8fCBmcy5leGlzdHNTeW5jKCcvb3B0L2hvbWVicmV3L2Jpbi9waXAzJyk7XG4gICAgICAgICAgICBpZiAodXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpIHx8IGdpdEhvbWVicmV3RXhpc3RzKSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ3BpcDMgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGlwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBwaXAuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGlwMyA9IHBhcnRzLmxlbmd0aCA+PSAyID8gcGFydHNbMV0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdwaXAzIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGlwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcGlwLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5waXAzID0gcGFydHMubGVuZ3RoID49IDIgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2phdmEnKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhbnkgSlZNIGlzIGluc3RhbGxlZCBidXQgYXZvaWQgZGlhbG9nIGJveCB0aGF0IEphdmEgbmVlZHMgdG8gYmUgaW5zdGFsbGVkXG4gICAgICAgICAgICBleGVjKCcvdXNyL2xpYmV4ZWMvamF2YV9ob21lIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yICYmIHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbm8gamF2YSBydW50aW1lJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gbm93IHRoaXMgY2FuIGJlIGRvbmUgc2F2ZWx5XG4gICAgICAgICAgICAgICAgZXhlYygnamF2YSAtdmVyc2lvbiAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgamF2YSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqYXZhLnNwbGl0KCdcIicpO1xuICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmphdmEgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJ0c1sxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ2phdmEgLXZlcnNpb24gMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqYXZhID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gamF2YS5zcGxpdCgnXCInKTtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmphdmEgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJ0c1sxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdnY2MnKSkge1xuICAgICAgICAgIGlmICgoX2RhcndpbiAmJiB1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkpIHx8ICFfZGFyd2luKSB7XG4gICAgICAgICAgICBleGVjKCdnY2MgLWR1bXB2ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ2NjID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnRyaW0oKSB8fCAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXBwc09iai52ZXJzaW9ucy5nY2MuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4ZWMoJ2djYyAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnY2MgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2NjLmluZGV4T2YoJ2djYycpID4gLTEgJiYgZ2NjLmluZGV4T2YoJyknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBnY2Muc3BsaXQoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmdjYyA9IHBhcnRzWzFdLnRyaW0oKSB8fCBhcHBzT2JqLnZlcnNpb25zLmdjYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICd2aXJ0dWFsYm94JykpIHtcbiAgICAgICAgICBleGVjKHV0aWwuZ2V0VmJveG1hbmFnZSgpICsgJyAtdiAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmJveCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB2Ym94LnNwbGl0KCdyJyk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMudmlydHVhbGJveCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnYmFzaCcpKSB7XG4gICAgICAgICAgZXhlYygnYmFzaCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyB2ZXJzaW9uICcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuYmFzaCA9IHBhcnRzWzFdLnNwbGl0KCcgJylbMF0uc3BsaXQoJygnKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnenNoJykpIHtcbiAgICAgICAgICBleGVjKCd6c2ggLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCd6c2ggJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy56c2ggPSBwYXJ0c1sxXS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdmaXNoJykpIHtcbiAgICAgICAgICBleGVjKCdmaXNoIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnIHZlcnNpb24gJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5maXNoID0gcGFydHNbMV0uc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncG93ZXJzaGVsbCcpKSB7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJyRQU1ZlcnNpb25UYWJsZScpLnRoZW4oc3Rkb3V0ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnJlcGxhY2UoLyArL2csICc6JykpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvd2Vyc2hlbGwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHN2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2RvdG5ldCcpKSB7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ2djaSBcIkhLTE06XFxcXFNPRlRXQVJFXFxcXE1pY3Jvc29mdFxcXFxORVQgRnJhbWV3b3JrIFNldHVwXFxcXE5EUFwiIC1yZWN1cnNlIHwgZ3AgLW5hbWUgVmVyc2lvbixSZWxlYXNlIC1FQSAwIHwgd2hlcmUgeyAkXy5QU0NoaWxkTmFtZSAtbWF0Y2ggXCJeKD8hUylcXFxccHtMfVwifSB8IHNlbGVjdCBQU0NoaWxkTmFtZSwgVmVyc2lvbiwgUmVsZWFzZScpLnRoZW4oc3Rkb3V0ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBkb3RuZXQgPSAnJztcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGRvdG5ldCA9IGRvdG5ldCB8fCAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjbGllbnQnKSAmJiBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMV0udHJpbSgpIDogKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZnVsbCcpICYmIHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1sxXS50cmltKCkgOiAnJykpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5kb3RuZXQgPSBkb3RuZXQudHJpbSgpO1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhhcHBzT2JqLnZlcnNpb25zKTsgfVxuICAgICAgICByZXNvbHZlKGFwcHNPYmoudmVyc2lvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy52ZXJzaW9ucyA9IHZlcnNpb25zO1xuXG5mdW5jdGlvbiBzaGVsbChjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICByZXNvbHZlKCdjbWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgZXhlYygnZWNobyAkU0hFTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5zaGVsbCA9IHNoZWxsO1xuXG5mdW5jdGlvbiBnZXRVbmlxdWVNYWNBZHJlc3NlcygpIHtcbiAgbGV0IG1hY3MgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBpZmFjZXMgPSBvcy5uZXR3b3JrSW50ZXJmYWNlcygpO1xuICAgIGZvciAobGV0IGRldiBpbiBpZmFjZXMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgZGV2KSkge1xuICAgICAgICBpZmFjZXNbZGV2XS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5tYWMgJiYgZGV0YWlscy5tYWMgIT09ICcwMDowMDowMDowMDowMDowMCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hYyA9IGRldGFpbHMubWFjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobWFjcy5pbmRleE9mKG1hYykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIG1hY3MucHVzaChtYWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hY3MgPSBtYWNzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhIDwgYikgeyByZXR1cm4gLTE7IH1cbiAgICAgIGlmIChhID4gYikgeyByZXR1cm4gMTsgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBtYWNzLnB1c2goJzAwOjAwOjAwOjAwOjAwOjAwJyk7XG4gIH1cbiAgcmV0dXJuIG1hY3M7XG59XG5cbmZ1bmN0aW9uIHV1aWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG9zOiAnJyxcbiAgICAgICAgaGFyZHdhcmU6ICcnLFxuICAgICAgICBtYWNzOiBnZXRVbmlxdWVNYWNBZHJlc3NlcygpXG4gICAgICB9O1xuICAgICAgbGV0IHBhcnRzO1xuXG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzeXN0ZW1fcHJvZmlsZXIgU1BIYXJkd2FyZURhdGFUeXBlIC1qc29uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBqc29uT2JqID0gSlNPTi5wYXJzZShzdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGlmIChqc29uT2JqLlNQSGFyZHdhcmVEYXRhVHlwZSAmJiBqc29uT2JqLlNQSGFyZHdhcmVEYXRhVHlwZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BIYXJkd2FyZSA9IGpzb25PYmouU1BIYXJkd2FyZURhdGFUeXBlWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vcyA9IHNwSGFyZHdhcmUucGxhdGZvcm1fVVVJRC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5oYXJkd2FyZSA9IHNwSGFyZHdhcmUuc2VyaWFsX251bWJlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcIm9zOiBcIjsgY2F0IC92YXIvbGliL2RidXMvbWFjaGluZS1pZCAyPiAvZGV2L251bGw7IGVjaG87XG5lY2hvIC1uIFwib3M6IFwiOyBjYXQgL2V0Yy9tYWNoaW5lLWlkIDI+IC9kZXYvbnVsbDsgZWNobztcbmVjaG8gLW4gXCJoYXJkd2FyZTogXCI7IGNhdCAvc3lzL2NsYXNzL2RtaS9pZC9wcm9kdWN0X3V1aWQgMj4gL2Rldi9udWxsOyBlY2hvO2A7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5vcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdvcycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmVzdWx0LmhhcmR3YXJlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2hhcmR3YXJlJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5oYXJkd2FyZSkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBmcy5yZWFkRmlsZVN5bmMoJy9wcm9jL2NwdWluZm8nLCB7IGVuY29kaW5nOiAndXRmOCcgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsJyk7XG4gICAgICAgICAgICByZXN1bHQuaGFyZHdhcmUgPSBzZXJpYWwgfHwgJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ3N5c2N0bCAtaSBrZXJuLmhvc3RpZCBrZXJuLmhvc3R1dWlkJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQub3MgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5ob3N0aWQnLCAnOicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmVzdWx0LmhhcmR3YXJlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4uaG9zdHV1aWQnLCAnOicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5vcy5pbmRleE9mKCd1bmtub3duJykgPj0gMCkgeyByZXN1bHQub3MgPSAnJzsgfVxuICAgICAgICAgIGlmIChyZXN1bHQuaGFyZHdhcmUuaW5kZXhPZigndW5rbm93bicpID49IDApIHsgcmVzdWx0LmhhcmR3YXJlID0gJyc7IH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IHN5c2RpciA9ICcld2luZGlyJVxcXFxTeXN0ZW0zMic7XG4gICAgICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdpYTMyJyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzcy5lbnYsICdQUk9DRVNTT1JfQVJDSElURVc2NDMyJykpIHtcbiAgICAgICAgICBzeXNkaXIgPSAnJXdpbmRpciVcXFxcc3lzbmF0aXZlXFxcXGNtZC5leGUgL2MgJXdpbmRpciVcXFxcU3lzdGVtMzInO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NvbXB1dGVyU3lzdGVtUHJvZHVjdCB8IHNlbGVjdCBVVUlEIHwgZmwnKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgIHJlc3VsdC5oYXJkd2FyZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd1dWlkJywgJzonKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGV4ZWMoYCR7c3lzZGlyfVxcXFxyZWcgcXVlcnkgXCJIS0VZX0xPQ0FMX01BQ0hJTkVcXFxcU09GVFdBUkVcXFxcTWljcm9zb2Z0XFxcXENyeXB0b2dyYXBoeVwiIC92IE1hY2hpbmVHdWlkYCwgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxccicpWzBdLnNwbGl0KCdSRUdfU1onKTtcbiAgICAgICAgICAgIHJlc3VsdC5vcyA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS5yZXBsYWNlKC9cXHIrfFxcbit8XFxzKy9pZywgJycpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMudXVpZCA9IHV1aWQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHByaW50ZXJzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTUuIHByaW50ZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmNvbnN0IHdpblByaW50ZXJTdGF0dXMgPSB7XG4gIDE6ICdPdGhlcicsXG4gIDI6ICdVbmtub3duJyxcbiAgMzogJ0lkbGUnLFxuICA0OiAnUHJpbnRpbmcnLFxuICA1OiAnV2FybXVwJyxcbiAgNjogJ1N0b3BwZWQgUHJpbnRpbmcnLFxuICA3OiAnT2ZmbGluZScsXG59O1xuXG5mdW5jdGlvbiBwYXJzZUxpbnV4Q3Vwc0hlYWRlcihsaW5lcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKGxpbmVzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgIGlmIChsaW5lc1swXS5pbmRleE9mKCcgQ1VQUyB2JykgPiAwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnNwbGl0KCcgQ1VQUyB2Jyk7XG4gICAgICByZXN1bHQuY3Vwc1ZlcnNpb24gPSBwYXJ0c1sxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eEN1cHNQcmludGVyKGxpbmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBwcmludGVySWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJpbnRlcklkJywgJyAnKTtcbiAgcmVzdWx0LmlkID0gcHJpbnRlcklkID8gcGFyc2VJbnQocHJpbnRlcklkLCAxMCkgOiBudWxsO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbmZvJywgJyAnKTtcbiAgcmVzdWx0Lm1vZGVsID0gbGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1swXSA/IGxpbmVzWzBdLnNwbGl0KCcgJylbMF0gOiAnJztcbiAgcmVzdWx0LnVyaSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXZpY2VVUkknLCAnICcpO1xuICByZXN1bHQudXVpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdVVUlEJywgJyAnKTtcbiAgcmVzdWx0LnN0YXR1cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGF0ZScsICcgJyk7XG4gIHJlc3VsdC5sb2NhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb2NhdGlvbicsICcgJykudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdsb2NhbCcpO1xuICByZXN1bHQuZGVmYXVsdCA9IG51bGw7XG4gIHJlc3VsdC5zaGFyZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2hhcmVkJywgJyAnKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3llcycpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhMcHN0YXRQcmludGVyKGxpbmVzLCBpZCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgcmVzdWx0LmlkID0gaWQ7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Rlc2NyaXB0aW9uJywgJzonLCB0cnVlKTtcbiAgcmVzdWx0Lm1vZGVsID0gbGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1swXSA/IGxpbmVzWzBdLnNwbGl0KCcgJylbMF0gOiAnJztcbiAgcmVzdWx0LnVyaSA9IG51bGw7XG4gIHJlc3VsdC51dWlkID0gbnVsbDtcbiAgcmVzdWx0LnN0YXR1cyA9IGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbMF0gPyAobGluZXNbMF0uaW5kZXhPZignIGlkbGUnKSA+IDAgPyAnaWRsZScgOiAobGluZXNbMF0uaW5kZXhPZignIHByaW50aW5nJykgPiAwID8gJ3ByaW50aW5nJyA6ICd1bmtub3duJykpIDogbnVsbDtcbiAgcmVzdWx0LmxvY2FsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvY2F0aW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2xvY2FsJyk7XG4gIHJlc3VsdC5kZWZhdWx0ID0gbnVsbDtcbiAgcmVzdWx0LnNoYXJlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaGFyZWQnLCAnICcpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgneWVzJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXJ3aW5QcmludGVycyhwcmludGVyT2JqZWN0LCBpZCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgdXJpUGFydHMgPSBwcmludGVyT2JqZWN0LnVyaS5zcGxpdCgnLycpO1xuICByZXN1bHQuaWQgPSBpZDtcbiAgcmVzdWx0Lm5hbWUgPSBwcmludGVyT2JqZWN0Ll9uYW1lO1xuICByZXN1bHQubW9kZWwgPSB1cmlQYXJ0cy5sZW5ndGggPyB1cmlQYXJ0c1t1cmlQYXJ0cy5sZW5ndGggLSAxXSA6ICcnO1xuICByZXN1bHQudXJpID0gcHJpbnRlck9iamVjdC51cmk7XG4gIHJlc3VsdC51dWlkID0gbnVsbDtcbiAgcmVzdWx0LnN0YXR1cyA9IHByaW50ZXJPYmplY3Quc3RhdHVzO1xuICByZXN1bHQubG9jYWwgPSBwcmludGVyT2JqZWN0LnByaW50c2VydmVyID09PSAnbG9jYWwnO1xuICByZXN1bHQuZGVmYXVsdCA9IHByaW50ZXJPYmplY3QuZGVmYXVsdCA9PT0gJ3llcyc7XG4gIHJlc3VsdC5zaGFyZWQgPSBwcmludGVyT2JqZWN0LnNoYXJlZCA9PT0gJ3llcyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzUHJpbnRlcnMobGluZXMsIGlkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBzdGF0dXMgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJpbnRlclN0YXR1cycsICc6JyksIDEwKTtcblxuICByZXN1bHQuaWQgPSBpZDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6Jyk7XG4gIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEcml2ZXJOYW1lJywgJzonKTtcbiAgcmVzdWx0LnVyaSA9IG51bGw7XG4gIHJlc3VsdC51dWlkID0gbnVsbDtcbiAgcmVzdWx0LnN0YXR1cyA9IHdpblByaW50ZXJTdGF0dXNbc3RhdHVzXSA/IHdpblByaW50ZXJTdGF0dXNbc3RhdHVzXSA6IG51bGw7XG4gIHJlc3VsdC5sb2NhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb2NhbCcsICc6JykudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnO1xuICByZXN1bHQuZGVmYXVsdCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZWZhdWx0JywgJzonKS50b1VwcGVyQ2FzZSgpID09PSAnVFJVRSc7XG4gIHJlc3VsdC5zaGFyZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2hhcmVkJywgJzonKS50b1VwcGVyQ2FzZSgpID09PSAnVFJVRSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcHJpbnRlcihjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGxldCBjbWQgPSAnY2F0IC9ldGMvY3Vwcy9wcmludGVycy5jb25mIDI+L2Rldi9udWxsJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgLy8gcHJpbnRlcnMuY29uZlxuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJzxQcmludGVyICcpO1xuICAgICAgICAgICAgY29uc3QgcHJpbnRlckhlYWRlciA9IHBhcnNlTGludXhDdXBzSGVhZGVyKHBhcnRzWzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpbnRlcnMgPSBwYXJzZUxpbnV4Q3Vwc1ByaW50ZXIocGFydHNbaV0uc3BsaXQoJ1xcbicpKTtcbiAgICAgICAgICAgICAgaWYgKHByaW50ZXJzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcmludGVycy5lbmdpbmUgPSAnQ1VQUyc7XG4gICAgICAgICAgICAgICAgcHJpbnRlcnMuZW5naW5lVmVyc2lvbiA9IHByaW50ZXJIZWFkZXIuY3Vwc1ZlcnNpb247XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJpbnRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgICAgIGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IGxwc3RhdCAtbHAgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCc7XG4gICAgICAgICAgICAgIC8vIGxwc3RhdFxuICAgICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9ICgnXFxuJyArIHN0ZG91dC50b1N0cmluZygpKS5zcGxpdCgnXFxucHJpbnRlciAnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmludGVycyA9IHBhcnNlTGludXhMcHN0YXRQcmludGVyKHBhcnRzW2ldLnNwbGl0KCdcXG4nKSwgaSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmludGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIFNQUHJpbnRlcnNEYXRhVHlwZSAtanNvbic7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dE9iaiA9IEpTT04ucGFyc2Uoc3Rkb3V0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQUHJpbnRlcnNEYXRhVHlwZSAmJiBvdXRPYmouU1BQcmludGVyc0RhdGFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0T2JqLlNQUHJpbnRlcnNEYXRhVHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbnRlciA9IHBhcnNlRGFyd2luUHJpbnRlcnMob3V0T2JqLlNQUHJpbnRlcnNEYXRhVHlwZVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9QcmludGVyIHwgc2VsZWN0IFByaW50ZXJTdGF0dXMsTmFtZSxEcml2ZXJOYW1lLExvY2FsLERlZmF1bHQsU2hhcmVkIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBwcmludGVyID0gcGFyc2VXaW5kb3dzUHJpbnRlcnMocGFydHNbaV0uc3BsaXQoJ1xcbicpLCBpKTtcbiAgICAgICAgICAgICAgaWYgKHByaW50ZXIubmFtZSB8fCBwcmludGVyLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJpbnRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5wcmludGVyID0gcHJpbnRlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gcHJvY2Vzc2VzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTAuIFByb2Nlc3Nlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmNvbnN0IF9wcm9jZXNzZXNfY3B1ID0ge1xuICBhbGw6IDAsXG4gIGFsbF91dGltZTogMCxcbiAgYWxsX3N0aW1lOiAwLFxuICBsaXN0OiB7fSxcbiAgbXM6IDAsXG4gIHJlc3VsdDoge31cbn07XG5jb25zdCBfc2VydmljZXNfY3B1ID0ge1xuICBhbGw6IDAsXG4gIGFsbF91dGltZTogMCxcbiAgYWxsX3N0aW1lOiAwLFxuICBsaXN0OiB7fSxcbiAgbXM6IDAsXG4gIHJlc3VsdDoge31cbn07XG5jb25zdCBfcHJvY2Vzc19jcHUgPSB7XG4gIGFsbDogMCxcbiAgYWxsX3V0aW1lOiAwLFxuICBhbGxfc3RpbWU6IDAsXG4gIGxpc3Q6IHt9LFxuICBtczogMCxcbiAgcmVzdWx0OiB7fVxufTtcblxuY29uc3QgX3dpblN0YXR1c1ZhbHVlcyA9IHtcbiAgJzAnOiAndW5rbm93bicsXG4gICcxJzogJ290aGVyJyxcbiAgJzInOiAncmVhZHknLFxuICAnMyc6ICdydW5uaW5nJyxcbiAgJzQnOiAnYmxvY2tlZCcsXG4gICc1JzogJ3N1c3BlbmRlZCBibG9ja2VkJyxcbiAgJzYnOiAnc3VzcGVuZGVkIHJlYWR5JyxcbiAgJzcnOiAndGVybWluYXRlZCcsXG4gICc4JzogJ3N0b3BwZWQnLFxuICAnOSc6ICdncm93aW5nJyxcbn07XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXgodGltZSkge1xuICBsZXQgcmVzdWx0ID0gdGltZTtcbiAgbGV0IHBhcnRzID0gdGltZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDUpIHtcbiAgICByZXN1bHQgPSBwYXJ0c1s0XSArICctJyArICgnMCcgKyAoJ0pBTkZFQk1BUkFQUk1BWUpVTkpVTEFVR1NFUE9DVE5PVkRFQycuaW5kZXhPZihwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpKSAvIDMgKyAxKSkuc2xpY2UoLTIpICsgJy0nICsgKCcwJyArIHBhcnRzWzJdKS5zbGljZSgtMikgKyAnICcgKyBwYXJ0c1szXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUVsYXBzZWRUaW1lKGV0aW1lKSB7XG4gIGxldCBjdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgY3VycmVudCA9IG5ldyBEYXRlKGN1cnJlbnQuZ2V0VGltZSgpIC0gY3VycmVudC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuXG4gIGNvbnN0IGVsYXBzZWQgPSBldGltZS5zcGxpdCgnLScpO1xuXG4gIGNvbnN0IHRpbWVJbmRleCA9IGVsYXBzZWQubGVuZ3RoIC0gMTtcbiAgY29uc3QgZGF5cyA9IHRpbWVJbmRleCA+IDAgPyBwYXJzZUludChlbGFwc2VkW3RpbWVJbmRleCAtIDFdKSA6IDA7XG5cbiAgY29uc3QgdGltZVN0ciA9IGVsYXBzZWRbdGltZUluZGV4XS5zcGxpdCgnOicpO1xuICBjb25zdCBob3VycyA9IHRpbWVTdHIubGVuZ3RoID09PSAzID8gcGFyc2VJbnQodGltZVN0clswXSB8fCAwKSA6IDA7XG4gIGNvbnN0IG1pbnMgPSBwYXJzZUludCh0aW1lU3RyW3RpbWVTdHIubGVuZ3RoID09PSAzID8gMSA6IDBdIHx8IDApO1xuICBjb25zdCBzZWNzID0gcGFyc2VJbnQodGltZVN0clt0aW1lU3RyLmxlbmd0aCA9PT0gMyA/IDIgOiAxXSB8fCAwKTtcbiAgY29uc3QgbXMgPSAoKCgoKGRheXMgKiAyNCArIGhvdXJzKSAqIDYwKSArIG1pbnMpICogNjAgKyBzZWNzKSAqIDEwMDApO1xuXG4gIGxldCByZXMgPSBuZXcgRGF0ZShjdXJyZW50LmdldFRpbWUoKSk7XG4gIGxldCByZXN1bHQgPSByZXMudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApICsgJyAnICsgcmVzLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDExLCAxOSk7XG4gIHRyeSB7XG4gICAgcmVzID0gbmV3IERhdGUoY3VycmVudC5nZXRUaW1lKCkgLSBtcyk7XG4gICAgcmVzdWx0ID0gcmVzLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKSArICcgJyArIHJlcy50b0lTT1N0cmluZygpLnN1YnN0cmluZygxMSwgMTkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBTIC0gc2VydmljZXNcbi8vIHBhc3MgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggc2VydmljZXMgdG8gY2hlY2sgKG15c3FsLCBhcGFjaGUsIHBvc3RncmVzcWwsIC4uLilcbi8vIHRoaXMgZnVuY3Rpb24gZ2l2ZXMgYW4gYXJyYXkgYmFjaywgaWYgdGhlIHNlcnZpY2VzIGFyZSBydW5uaW5nLlxuXG5mdW5jdGlvbiBzZXJ2aWNlcyhzcnYsIGNhbGxiYWNrKSB7XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oc3J2KSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHNydjtcbiAgICBzcnYgPSAnJztcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhbXSk7IH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3J2KSB7XG4gICAgICAgIGxldCBzcnZTdHJpbmcgPSAnJztcbiAgICAgICAgc3J2U3RyaW5nLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgc3J2U3RyaW5nLl9fcHJvdG9fXy5yZXBsYWNlID0gdXRpbC5zdHJpbmdSZXBsYWNlO1xuICAgICAgICBzcnZTdHJpbmcuX19wcm90b19fLnRyaW0gPSB1dGlsLnN0cmluZ1RyaW07XG5cbiAgICAgICAgY29uc3QgcyA9IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhzcnYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcnZTdHJpbmcgPSBzcnZTdHJpbmcgKyBzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNydlN0cmluZyA9IHNydlN0cmluZy50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8sIC9nLCAnfCcpLnJlcGxhY2UoLywrL2csICd8Jyk7XG4gICAgICAgIGlmIChzcnZTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgICAgc3J2U3RyaW5nID0gJyonO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSAmJiBzcnZTdHJpbmcgIT09ICcqJykge1xuICAgICAgICAgIHNydlN0cmluZyA9ICctLS0tLS0nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcnZzID0gc3J2U3RyaW5nLnNwbGl0KCd8Jyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGRhdGFTcnYgPSBbXTtcblxuICAgICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2Rhcndpbikge1xuICAgICAgICAgIGlmICgoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpICYmIHNydlN0cmluZyA9PT0gJyonKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB0bXBzcnYgPSBleGVjU3luYygnc3lzdGVtY3RsIC0tYWxsIC0tdHlwZT1zZXJ2aWNlIC0tbm8tbGVnZW5kIDI+IC9kZXYvbnVsbCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBzcnZzID0gW107XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0bXBzcnYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcy5zcGxpdCgnLnNlcnZpY2UnKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiBzLmluZGV4T2YoJyBub3QtZm91bmQgJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBzcnZzLnB1c2gobmFtZS50cmltKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcnZTdHJpbmcgPSBzcnZzLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzcnZTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBzcnYgPSBleGVjU3luYygnc2VydmljZSAtLXN0YXR1cy1hbGwgMj4gL2Rldi9udWxsJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRtcHNydikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzLnNwbGl0KCddJyk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNydlN0cmluZyArPSAoc3J2U3RyaW5nICE9PSAnJyA/ICd8JyA6ICcnKSArIHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3J2cyA9IHNydlN0cmluZy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNydlN0ciA9IGV4ZWNTeW5jKCdscyAvZXRjL2luaXQuZC8gLW0gMj4gL2Rldi9udWxsJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICBzcnZTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgIGlmIChzcnZTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wc3J2ID0gc3J2U3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0bXBzcnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcy50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNydlN0cmluZyArPSAoc3J2U3RyaW5nICE9PSAnJyA/ICd8JyA6ICcnKSArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNydnMgPSBzcnZTdHJpbmcuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgICAgICAgICAgICBzcnZTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgIHNydnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChfZGFyd2luKSAmJiBzcnZTdHJpbmcgPT09ICcqJykgeyAvLyBzZXJ2aWNlIGVudW1lcmF0aW9uIG5vdCB5ZXQgc3Vwb3J0ZWQgb24gbWFjIE9TXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgYXJncyA9IChfZGFyd2luKSA/IFsnLWNheG8nLCAncGNwdSxwbWVtLHBpZCxjb21tYW5kJ10gOiBbJy1heG8nLCAncGNwdSxwbWVtLHBpZCxjb21tYW5kJ107XG4gICAgICAgICAgaWYgKHNydlN0cmluZyAhPT0gJycgJiYgc3J2cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwcycsIGFyZ3MpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnJlcGxhY2UoLyArL2csICcgJykucmVwbGFjZSgvLCsvZywgJy4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgc3J2cy5mb3JFYWNoKGZ1bmN0aW9uIChzcnYpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBwcztcbiAgICAgICAgICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHBzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzcnYpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyAnICsgc3J2ICsgJzonKSAhPT0gLTEpIHx8IChlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLycgKyBzcnYpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgcGlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpZCA9IHAudHJpbSgpLnNwbGl0KCcgJylbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwaWRzLnB1c2gocGFyc2VJbnQocGlkLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydixcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZzogcHMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGlkczogcGlkcyxcbiAgICAgICAgICAgICAgICAgICAgY3B1OiBwYXJzZUZsb2F0KChwcy5yZWR1Y2UoZnVuY3Rpb24gKHB2LCBjdikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdiArIHBhcnNlRmxvYXQoY3YudHJpbSgpLnNwbGl0KCcgJylbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKSkudG9GaXhlZCgyKSksXG4gICAgICAgICAgICAgICAgICAgIG1lbTogcGFyc2VGbG9hdCgocHMucmVkdWNlKGZ1bmN0aW9uIChwdiwgY3YpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHYgKyBwYXJzZUZsb2F0KGN2LnRyaW0oKS5zcGxpdCgnICcpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCkpLnRvRml4ZWQoMikpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgICAgICAgICAvLyBjYWxjIHByb2Nlc3NfY3B1IC0gcHMgaXMgbm90IGFjY3VyYXRlIGluIGxpbnV4IVxuICAgICAgICAgICAgICAgICAgbGV0IGNtZCA9ICdjYXQgL3Byb2Mvc3RhdCB8IGdyZXAgXCJjcHUgXCInO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiBpbiByZXN1bHRbaV0ucGlkcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNtZCArPSAoJztjYXQgL3Byb2MvJyArIHJlc3VsdFtpXS5waWRzW2pdICsgJy9zdGF0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyX3Byb2Nlc3NlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBsaW5lIChhbGwgLSAvcHJvYy9zdGF0KVxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsID0gcGFyc2VQcm9jU3RhdChjdXJyX3Byb2Nlc3Nlcy5zaGlmdCgpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0X25ldyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UHJvY2VzcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyX3Byb2Nlc3Nlcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvY2VzcyA9IGNhbGNQcm9jU3RhdExpbnV4KGVsZW1lbnQsIGFsbCwgX3NlcnZpY2VzX2NwdSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0UHJvY2Vzcy5waWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0UG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIGluIHJlc3VsdFtpXS5waWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlc3VsdFtpXS5waWRzW2pdKSA9PT0gcGFyc2VJbnQocmVzdWx0UHJvY2Vzcy5waWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0UG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLmNwdSArPSByZXN1bHRQcm9jZXNzLmNwdXUgKyByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdF9uZXdbcmVzdWx0UHJvY2Vzcy5waWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjcHV1OiByZXN1bHRQcm9jZXNzLmNwdXUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IHJlc3VsdFByb2Nlc3MuY3B1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHJlc3VsdFByb2Nlc3MudXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0aW1lOiByZXN1bHRQcm9jZXNzLnN0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXRpbWU6IHJlc3VsdFByb2Nlc3MuY3V0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjc3RpbWU6IHJlc3VsdFByb2Nlc3MuY3N0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgb2xkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBfc2VydmljZXNfY3B1LmFsbCA9IGFsbDtcbiAgICAgICAgICAgICAgICAgICAgX3NlcnZpY2VzX2NwdS5saXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgbGlzdF9uZXcpO1xuICAgICAgICAgICAgICAgICAgICBfc2VydmljZXNfY3B1Lm1zID0gRGF0ZS5ub3coKSAtIF9zZXJ2aWNlc19jcHUubXM7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJ2aWNlc19jcHUucmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbJy1vJywgJ2NvbW0nXTtcbiAgICAgICAgICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwcycsIGFyZ3MpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQucmVwbGFjZSgvICsvZywgJyAnKS5yZXBsYWNlKC8sKy9nLCAnLicpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgc3J2cy5mb3JFYWNoKGZ1bmN0aW9uIChzcnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcHMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmluZGV4T2Yoc3J2KSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2LFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZzogcHMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNydnMuZm9yRWFjaChmdW5jdGlvbiAoc3J2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2LFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHdpbmNvbW1hbmQgPSAnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1NlcnZpY2UnO1xuICAgICAgICAgICAgaWYgKHNydnNbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICB3aW5jb21tYW5kICs9ICcgLUZpbHRlciBcIic7XG4gICAgICAgICAgICAgIHNydnMuZm9yRWFjaCgoc3J2KSA9PiB7XG4gICAgICAgICAgICAgICAgd2luY29tbWFuZCArPSBgTmFtZT0nJHtzcnZ9JyBvciBgO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2luY29tbWFuZCA9IGAke3dpbmNvbW1hbmQuc2xpY2UoMCwgLTQpfVwiYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmNvbW1hbmQgKz0gJyB8IHNlbGVjdCBOYW1lLENhcHRpb24sU3RhcnRlZCxTdGFydE1vZGUsUHJvY2Vzc0lkIHwgZmwnO1xuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKHdpbmNvbW1hbmQpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBzZXJ2aWNlU2VjdGlvbnMgPSBzdGRvdXQuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlU2VjdGlvbnMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBlbGVtZW50LnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcnZOYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05hbWUnLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcnZDYXB0aW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydGVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXJ0ZWQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRNb2RlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXJ0TW9kZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvY2Vzc0lkJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNydlN0cmluZyA9PT0gJyonIHx8IHNydnMuaW5kZXhPZihzcnZOYW1lKSA+PSAwIHx8IHNydnMuaW5kZXhPZihzcnZDYXB0aW9uKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IChzdGFydGVkLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6IHN0YXJ0TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZHM6IFtwaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVNydi5wdXNoKHNydk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFTcnYucHVzaChzcnZDYXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3J2U3RyaW5nICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBzcnZzTWlzc2luZyA9IHNydnMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhU3J2LmluZGV4T2YoZSkgPT09IC0xO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBzcnZzTWlzc2luZy5mb3JFYWNoKGZ1bmN0aW9uIChzcnZOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnZOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcnZzLmZvckVhY2goZnVuY3Rpb24gKHNydk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhbXSk7IH1cbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnNlcnZpY2VzID0gc2VydmljZXM7XG5cbmZ1bmN0aW9uIHBhcnNlUHJvY1N0YXQobGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgbGV0IHVzZXIgPSAocGFydHMubGVuZ3RoID49IDIgPyBwYXJzZUludChwYXJ0c1sxXSkgOiAwKTtcbiAgbGV0IG5pY2UgPSAocGFydHMubGVuZ3RoID49IDMgPyBwYXJzZUludChwYXJ0c1syXSkgOiAwKTtcbiAgbGV0IHN5c3RlbSA9IChwYXJ0cy5sZW5ndGggPj0gNCA/IHBhcnNlSW50KHBhcnRzWzNdKSA6IDApO1xuICBsZXQgaWRsZSA9IChwYXJ0cy5sZW5ndGggPj0gNSA/IHBhcnNlSW50KHBhcnRzWzRdKSA6IDApO1xuICBsZXQgaW93YWl0ID0gKHBhcnRzLmxlbmd0aCA+PSA2ID8gcGFyc2VJbnQocGFydHNbNV0pIDogMCk7XG4gIGxldCBpcnEgPSAocGFydHMubGVuZ3RoID49IDcgPyBwYXJzZUludChwYXJ0c1s2XSkgOiAwKTtcbiAgbGV0IHNvZnRpcnEgPSAocGFydHMubGVuZ3RoID49IDggPyBwYXJzZUludChwYXJ0c1s3XSkgOiAwKTtcbiAgbGV0IHN0ZWFsID0gKHBhcnRzLmxlbmd0aCA+PSA5ID8gcGFyc2VJbnQocGFydHNbOF0pIDogMCk7XG4gIGxldCBndWVzdCA9IChwYXJ0cy5sZW5ndGggPj0gMTAgPyBwYXJzZUludChwYXJ0c1s5XSkgOiAwKTtcbiAgbGV0IGd1ZXN0X25pY2UgPSAocGFydHMubGVuZ3RoID49IDExID8gcGFyc2VJbnQocGFydHNbMTBdKSA6IDApO1xuICByZXR1cm4gdXNlciArIG5pY2UgKyBzeXN0ZW0gKyBpZGxlICsgaW93YWl0ICsgaXJxICsgc29mdGlycSArIHN0ZWFsICsgZ3Vlc3QgKyBndWVzdF9uaWNlO1xufVxuXG5mdW5jdGlvbiBjYWxjUHJvY1N0YXRMaW51eChsaW5lLCBhbGwsIF9jcHVfb2xkKSB7XG4gIGxldCBzdGF0cGFydHMgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyknKTtcbiAgaWYgKHN0YXRwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgIGxldCBwYXJ0cyA9IHN0YXRwYXJ0c1sxXS5zcGxpdCgnICcpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMTYpIHtcbiAgICAgIGxldCBwaWQgPSBwYXJzZUludChzdGF0cGFydHNbMF0uc3BsaXQoJyAnKVswXSk7XG4gICAgICBsZXQgdXRpbWUgPSBwYXJzZUludChwYXJ0c1sxMl0pO1xuICAgICAgbGV0IHN0aW1lID0gcGFyc2VJbnQocGFydHNbMTNdKTtcbiAgICAgIGxldCBjdXRpbWUgPSBwYXJzZUludChwYXJ0c1sxNF0pO1xuICAgICAgbGV0IGNzdGltZSA9IHBhcnNlSW50KHBhcnRzWzE1XSk7XG5cbiAgICAgIC8vIGNhbGNcbiAgICAgIGxldCBjcHV1ID0gMDtcbiAgICAgIGxldCBjcHVzID0gMDtcbiAgICAgIGlmIChfY3B1X29sZC5hbGwgPiAwICYmIF9jcHVfb2xkLmxpc3RbcGlkXSkge1xuICAgICAgICBjcHV1ID0gKHV0aW1lICsgY3V0aW1lIC0gX2NwdV9vbGQubGlzdFtwaWRdLnV0aW1lIC0gX2NwdV9vbGQubGlzdFtwaWRdLmN1dGltZSkgLyAoYWxsIC0gX2NwdV9vbGQuYWxsKSAqIDEwMDsgLy8gdXNlclxuICAgICAgICBjcHVzID0gKHN0aW1lICsgY3N0aW1lIC0gX2NwdV9vbGQubGlzdFtwaWRdLnN0aW1lIC0gX2NwdV9vbGQubGlzdFtwaWRdLmNzdGltZSkgLyAoYWxsIC0gX2NwdV9vbGQuYWxsKSAqIDEwMDsgLy8gc3lzdGVtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcHV1ID0gKHV0aW1lICsgY3V0aW1lKSAvIChhbGwpICogMTAwOyAvLyB1c2VyXG4gICAgICAgIGNwdXMgPSAoc3RpbWUgKyBjc3RpbWUpIC8gKGFsbCkgKiAxMDA7IC8vIHN5c3RlbVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgIHV0aW1lOiB1dGltZSxcbiAgICAgICAgc3RpbWU6IHN0aW1lLFxuICAgICAgICBjdXRpbWU6IGN1dGltZSxcbiAgICAgICAgY3N0aW1lOiBjc3RpbWUsXG4gICAgICAgIGNwdXU6IGNwdXUsXG4gICAgICAgIGNwdXM6IGNwdXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpZDogMCxcbiAgICAgICAgdXRpbWU6IDAsXG4gICAgICAgIHN0aW1lOiAwLFxuICAgICAgICBjdXRpbWU6IDAsXG4gICAgICAgIGNzdGltZTogMCxcbiAgICAgICAgY3B1dTogMCxcbiAgICAgICAgY3B1czogMFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpZDogMCxcbiAgICAgIHV0aW1lOiAwLFxuICAgICAgc3RpbWU6IDAsXG4gICAgICBjdXRpbWU6IDAsXG4gICAgICBjc3RpbWU6IDAsXG4gICAgICBjcHV1OiAwLFxuICAgICAgY3B1czogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY1Byb2NTdGF0V2luKHByb2NTdGF0LCBhbGwsIF9jcHVfb2xkKSB7XG4gIC8vIGNhbGNcbiAgbGV0IGNwdXUgPSAwO1xuICBsZXQgY3B1cyA9IDA7XG4gIGlmIChfY3B1X29sZC5hbGwgPiAwICYmIF9jcHVfb2xkLmxpc3RbcHJvY1N0YXQucGlkXSkge1xuICAgIGNwdXUgPSAocHJvY1N0YXQudXRpbWUgLSBfY3B1X29sZC5saXN0W3Byb2NTdGF0LnBpZF0udXRpbWUpIC8gKGFsbCAtIF9jcHVfb2xkLmFsbCkgKiAxMDA7IC8vIHVzZXJcbiAgICBjcHVzID0gKHByb2NTdGF0LnN0aW1lIC0gX2NwdV9vbGQubGlzdFtwcm9jU3RhdC5waWRdLnN0aW1lKSAvIChhbGwgLSBfY3B1X29sZC5hbGwpICogMTAwOyAvLyBzeXN0ZW1cbiAgfSBlbHNlIHtcbiAgICBjcHV1ID0gKHByb2NTdGF0LnV0aW1lKSAvIChhbGwpICogMTAwOyAvLyB1c2VyXG4gICAgY3B1cyA9IChwcm9jU3RhdC5zdGltZSkgLyAoYWxsKSAqIDEwMDsgLy8gc3lzdGVtXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwaWQ6IHByb2NTdGF0LnBpZCxcbiAgICB1dGltZTogcHJvY1N0YXQudXRpbWUsXG4gICAgc3RpbWU6IHByb2NTdGF0LnN0aW1lLFxuICAgIGNwdXU6IGNwdXUgPiAwID8gY3B1dSA6IDAsXG4gICAgY3B1czogY3B1cyA+IDAgPyBjcHVzIDogMFxuICB9O1xufVxuXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHJ1bm5pbmcgcHJvY2Vzc2VzXG5cbmZ1bmN0aW9uIHByb2Nlc3NlcyhjYWxsYmFjaykge1xuXG4gIGxldCBwYXJzZWRoZWFkID0gW107XG5cbiAgZnVuY3Rpb24gZ2V0TmFtZShjb21tYW5kKSB7XG4gICAgY29tbWFuZCA9IGNvbW1hbmQgfHwgJyc7XG4gICAgbGV0IHJlc3VsdCA9IGNvbW1hbmQuc3BsaXQoJyAnKVswXTtcbiAgICBpZiAocmVzdWx0LnN1YnN0cigtMSkgPT09ICc6Jykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc3Vic3RyKDAsIDEpICE9PSAnWycpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHJlc3VsdC5zcGxpdCgnLycpO1xuICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBwYXJ0c1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgb2Zmc2V0MiA9IDA7XG5cbiAgICBmdW5jdGlvbiBjaGVja0NvbHVtbihpKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQyO1xuICAgICAgaWYgKHBhcnNlZGhlYWRbaV0pIHtcbiAgICAgICAgb2Zmc2V0MiA9IGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbaV0udG8gKyBvZmZzZXQsIDEwMDAwKS5pbmRleE9mKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQyID0gMTAwMDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tDb2x1bW4oMCk7XG4gICAgY29uc3QgcGlkID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFswXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzBdLnRvICsgb2Zmc2V0MikpO1xuICAgIGNoZWNrQ29sdW1uKDEpO1xuICAgIGNvbnN0IHBwaWQgPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzFdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMV0udG8gKyBvZmZzZXQyKSk7XG4gICAgY2hlY2tDb2x1bW4oMik7XG4gICAgY29uc3QgY3B1ID0gcGFyc2VGbG9hdChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzJdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMl0udG8gKyBvZmZzZXQyKS5yZXBsYWNlKC8sL2csICcuJykpO1xuICAgIGNoZWNrQ29sdW1uKDMpO1xuICAgIGNvbnN0IG1lbSA9IHBhcnNlRmxvYXQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFszXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzNdLnRvICsgb2Zmc2V0MikucmVwbGFjZSgvLC9nLCAnLicpKTtcbiAgICBjaGVja0NvbHVtbig0KTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbNF0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs0XS50byArIG9mZnNldDIpKTtcbiAgICBjaGVja0NvbHVtbig1KTtcbiAgICBjb25zdCB2c3ogPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzVdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbNV0udG8gKyBvZmZzZXQyKSk7XG4gICAgY2hlY2tDb2x1bW4oNik7XG4gICAgY29uc3QgcnNzID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs2XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzZdLnRvICsgb2Zmc2V0MikpO1xuICAgIGNoZWNrQ29sdW1uKDcpO1xuICAgIGNvbnN0IG5pY2UgPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzddLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbN10udG8gKyBvZmZzZXQyKSkgfHwgMDtcbiAgICBjaGVja0NvbHVtbig4KTtcbiAgICBjb25zdCBzdGFydGVkID0gIV9zdW5vcyA/IHBhcnNlRWxhcHNlZFRpbWUobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs4XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzhdLnRvICsgb2Zmc2V0MikudHJpbSgpKSA6IHBhcnNlVGltZVVuaXgobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs4XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzhdLnRvICsgb2Zmc2V0MikudHJpbSgpKTtcbiAgICBjaGVja0NvbHVtbig5KTtcbiAgICBsZXQgc3RhdGUgPSBsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzldLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbOV0udG8gKyBvZmZzZXQyKS50cmltKCk7XG4gICAgc3RhdGUgPSAoc3RhdGVbMF0gPT09ICdSJyA/ICdydW5uaW5nJyA6IChzdGF0ZVswXSA9PT0gJ1MnID8gJ3NsZWVwaW5nJyA6IChzdGF0ZVswXSA9PT0gJ1QnID8gJ3N0b3BwZWQnIDogKHN0YXRlWzBdID09PSAnVycgPyAncGFnaW5nJyA6IChzdGF0ZVswXSA9PT0gJ1gnID8gJ2RlYWQnIDogKHN0YXRlWzBdID09PSAnWicgPyAnem9tYmllJyA6ICgoc3RhdGVbMF0gPT09ICdEJyB8fCBzdGF0ZVswXSA9PT0gJ1UnKSA/ICdibG9ja2VkJyA6ICd1bmtub3duJykpKSkpKSk7XG4gICAgY2hlY2tDb2x1bW4oMTApO1xuICAgIGxldCB0dHkgPSBsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzEwXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzEwXS50byArIG9mZnNldDIpLnRyaW0oKTtcbiAgICBpZiAodHR5ID09PSAnPycgfHwgdHR5ID09PSAnPz8nKSB7IHR0eSA9ICcnOyB9XG4gICAgY2hlY2tDb2x1bW4oMTEpO1xuICAgIGNvbnN0IHVzZXIgPSBsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzExXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzExXS50byArIG9mZnNldDIpLnRyaW0oKTtcbiAgICBjaGVja0NvbHVtbigxMik7XG4gICAgbGV0IGNtZFBhdGggPSAnJztcbiAgICBsZXQgY29tbWFuZCA9ICcnO1xuICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICBsZXQgZnVsbGNvbW1hbmQgPSBsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzEyXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzEyXS50byArIG9mZnNldDIpLnRyaW0oKTtcbiAgICBpZiAoZnVsbGNvbW1hbmQuc3Vic3RyKGZ1bGxjb21tYW5kLmxlbmd0aCAtIDEpID09PSAnXScpIHsgZnVsbGNvbW1hbmQgPSBmdWxsY29tbWFuZC5zbGljZSgwLCAtMSk7IH1cbiAgICBpZiAoZnVsbGNvbW1hbmQuc3Vic3RyKDAsIDEpID09PSAnWycpIHsgY29tbWFuZCA9IGZ1bGxjb21tYW5kLnN1YnN0cmluZygxKTsgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcDEgPSBmdWxsY29tbWFuZC5pbmRleE9mKCcoJyk7XG4gICAgICBjb25zdCBwMiA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJyknKTtcbiAgICAgIGNvbnN0IHAzID0gZnVsbGNvbW1hbmQuaW5kZXhPZignLycpO1xuICAgICAgY29uc3QgcDQgPSBmdWxsY29tbWFuZC5pbmRleE9mKCc6Jyk7XG4gICAgICBpZiAocDEgPCBwMiAmJiBwMSA8IHAzICYmIHAzIDwgcDIpIHtcbiAgICAgICAgY29tbWFuZCA9IGZ1bGxjb21tYW5kLnNwbGl0KCcgJylbMF07XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kLnJlcGxhY2UoLzovZywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHA0ID4gMCAmJiAocDMgPT09IC0xIHx8IHAzID4gMykpIHtcbiAgICAgICAgICBjb21tYW5kID0gZnVsbGNvbW1hbmQuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICBjb21tYW5kID0gY29tbWFuZC5yZXBsYWNlKC86L2csICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cnkgdG8gZmlndXJlIG91dCB3aGVyZSBwYXJhbWV0ZXIgc3RhcnRzXG4gICAgICAgICAgbGV0IGZpcnN0UGFyYW1Qb3MgPSBmdWxsY29tbWFuZC5pbmRleE9mKCcgLScpO1xuICAgICAgICAgIGxldCBmaXJzdFBhcmFtUGF0aFBvcyA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJyAvJyk7XG4gICAgICAgICAgZmlyc3RQYXJhbVBvcyA9IChmaXJzdFBhcmFtUG9zID49IDAgPyBmaXJzdFBhcmFtUG9zIDogMTAwMDApO1xuICAgICAgICAgIGZpcnN0UGFyYW1QYXRoUG9zID0gKGZpcnN0UGFyYW1QYXRoUG9zID49IDAgPyBmaXJzdFBhcmFtUGF0aFBvcyA6IDEwMDAwKTtcbiAgICAgICAgICBjb25zdCBmaXJzdFBvcyA9IE1hdGgubWluKGZpcnN0UGFyYW1Qb3MsIGZpcnN0UGFyYW1QYXRoUG9zKTtcbiAgICAgICAgICBsZXQgdG1wQ29tbWFuZCA9IGZ1bGxjb21tYW5kLnN1YnN0cigwLCBmaXJzdFBvcyk7XG4gICAgICAgICAgY29uc3QgdG1wUGFyYW1zID0gZnVsbGNvbW1hbmQuc3Vic3RyKGZpcnN0UG9zKTtcbiAgICAgICAgICBjb25zdCBsYXN0U2xhc2hQb3MgPSB0bXBDb21tYW5kLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgaWYgKGxhc3RTbGFzaFBvcyA+PSAwKSB7XG4gICAgICAgICAgICBjbWRQYXRoID0gdG1wQ29tbWFuZC5zdWJzdHIoMCwgbGFzdFNsYXNoUG9zKTtcbiAgICAgICAgICAgIHRtcENvbW1hbmQgPSB0bXBDb21tYW5kLnN1YnN0cihsYXN0U2xhc2hQb3MgKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlyc3RQb3MgPT09IDEwMDAwICYmIHRtcENvbW1hbmQuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdG1wQ29tbWFuZC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKGNtZFBhdGgsIHBhcnRzWzBdKSkpIHtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHBhcmFtcyA9IChwYXJ0cy5qb2luKCcgJykgKyAnICcgKyB0bXBQYXJhbXMpLnRyaW0oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSB0bXBDb21tYW5kLnRyaW0oKTtcbiAgICAgICAgICAgICAgcGFyYW1zID0gdG1wUGFyYW1zLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbWFuZCA9IHRtcENvbW1hbmQudHJpbSgpO1xuICAgICAgICAgICAgcGFyYW1zID0gdG1wUGFyYW1zLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgcGlkOiBwaWQsXG4gICAgICBwYXJlbnRQaWQ6IHBwaWQsXG4gICAgICBuYW1lOiBfbGludXggPyBnZXROYW1lKGNvbW1hbmQpIDogY29tbWFuZCxcbiAgICAgIGNwdTogY3B1LFxuICAgICAgY3B1dTogMCxcbiAgICAgIGNwdXM6IDAsXG4gICAgICBtZW06IG1lbSxcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgIG1lbVZzejogdnN6LFxuICAgICAgbWVtUnNzOiByc3MsXG4gICAgICBuaWNlOiBuaWNlLFxuICAgICAgc3RhcnRlZDogc3RhcnRlZCxcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHR0eTogdHR5LFxuICAgICAgdXNlcjogdXNlcixcbiAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIHBhdGg6IGNtZFBhdGhcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvY2Vzc2VzKGxpbmVzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgaGVhZCA9IGxpbmVzWzBdO1xuICAgICAgcGFyc2VkaGVhZCA9IHV0aWwucGFyc2VIZWFkKGhlYWQsIDgpO1xuICAgICAgbGluZXMuc2hpZnQoKTtcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlTGluZShsaW5lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlUHJvY2Vzc2VzMihsaW5lcykge1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWUodGltZSkge1xuICAgICAgY29uc3QgbW9udGggPSAoJzAnICsgKHRpbWUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgIGNvbnN0IHllYXIgPSB0aW1lLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGRheSA9ICgnMCcgKyB0aW1lLmdldERhdGUoKS50b1N0cmluZygpKS5zbGljZSgtMik7XG4gICAgICBjb25zdCBob3VycyA9ICgnMCcgKyB0aW1lLmdldEhvdXJzKCkudG9TdHJpbmcoKSkuc2xpY2UoLTIpO1xuICAgICAgY29uc3QgbWlucyA9ICgnMCcgKyB0aW1lLmdldE1pbnV0ZXMoKS50b1N0cmluZygpKS5zbGljZSgtMik7XG4gICAgICBjb25zdCBzZWNzID0gKCcwJyArIHRpbWUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcblxuICAgICAgcmV0dXJuICh5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXkgKyAnICcgKyBob3VycyArICc6JyArIG1pbnMgKyAnOicgKyBzZWNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVsYXBzZWQoZXRpbWUpIHtcbiAgICAgIGxldCBzdGFydGVkID0gJyc7XG4gICAgICBpZiAoZXRpbWUuaW5kZXhPZignZCcpID49IDApIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZF9wYXJ0cyA9IGV0aW1lLnNwbGl0KCdkJyk7XG4gICAgICAgIHN0YXJ0ZWQgPSBmb3JtYXREYXRlVGltZShuZXcgRGF0ZShEYXRlLm5vdygpIC0gKGVsYXBzZWRfcGFydHNbMF0gKiAyNCArIGVsYXBzZWRfcGFydHNbMV0gKiAxKSAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICB9IGVsc2UgaWYgKGV0aW1lLmluZGV4T2YoJ2gnKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRfcGFydHMgPSBldGltZS5zcGxpdCgnaCcpO1xuICAgICAgICBzdGFydGVkID0gZm9ybWF0RGF0ZVRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIChlbGFwc2VkX3BhcnRzWzBdICogNjAgKyBlbGFwc2VkX3BhcnRzWzFdICogMSkgKiA2MCAqIDEwMDApKTtcbiAgICAgIH0gZWxzZSBpZiAoZXRpbWUuaW5kZXhPZignOicpID49IDApIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZF9wYXJ0cyA9IGV0aW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHN0YXJ0ZWQgPSBmb3JtYXREYXRlVGltZShuZXcgRGF0ZShEYXRlLm5vdygpIC0gKGVsYXBzZWRfcGFydHMubGVuZ3RoID4gMSA/IChlbGFwc2VkX3BhcnRzWzBdICogNjAgKyBlbGFwc2VkX3BhcnRzWzFdKSAqIDEwMDAgOiBlbGFwc2VkX3BhcnRzWzBdICogMTAwMCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydGVkO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnICcpLnJlcGxhY2UoLywrL2csICcuJyk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gcGFydHMuc2xpY2UoOSkuam9pbignICcpO1xuICAgICAgICBjb25zdCBwbWVtID0gcGFyc2VGbG9hdCgoMS4wICogcGFyc2VJbnQocGFydHNbM10pICogMTAyNCAvIG9zLnRvdGFsbWVtKCkpLnRvRml4ZWQoMSkpO1xuICAgICAgICBjb25zdCBzdGFydGVkID0gcGFyc2VFbGFwc2VkKHBhcnRzWzVdKTtcblxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgcGlkOiBwYXJzZUludChwYXJ0c1swXSksXG4gICAgICAgICAgcGFyZW50UGlkOiBwYXJzZUludChwYXJ0c1sxXSksXG4gICAgICAgICAgbmFtZTogZ2V0TmFtZShjb21tYW5kKSxcbiAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgY3B1dTogMCxcbiAgICAgICAgICBjcHVzOiAwLFxuICAgICAgICAgIG1lbTogcG1lbSxcbiAgICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgICBtZW1Wc3o6IHBhcnNlSW50KHBhcnRzWzJdKSxcbiAgICAgICAgICBtZW1Sc3M6IHBhcnNlSW50KHBhcnRzWzNdKSxcbiAgICAgICAgICBuaWNlOiBwYXJzZUludChwYXJ0c1s0XSksXG4gICAgICAgICAgc3RhcnRlZDogc3RhcnRlZCxcbiAgICAgICAgICBzdGF0ZTogKHBhcnRzWzZdID09PSAnUicgPyAncnVubmluZycgOiAocGFydHNbNl0gPT09ICdTJyA/ICdzbGVlcGluZycgOiAocGFydHNbNl0gPT09ICdUJyA/ICdzdG9wcGVkJyA6IChwYXJ0c1s2XSA9PT0gJ1cnID8gJ3BhZ2luZycgOiAocGFydHNbNl0gPT09ICdYJyA/ICdkZWFkJyA6IChwYXJ0c1s2XSA9PT0gJ1onID8gJ3pvbWJpZScgOiAoKHBhcnRzWzZdID09PSAnRCcgfHwgcGFydHNbNl0gPT09ICdVJykgPyAnYmxvY2tlZCcgOiAndW5rbm93bicpKSkpKSkpLFxuICAgICAgICAgIHR0eTogcGFydHNbN10sXG4gICAgICAgICAgdXNlcjogcGFydHNbOF0sXG4gICAgICAgICAgY29tbWFuZDogY29tbWFuZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBhbGw6IDAsXG4gICAgICAgIHJ1bm5pbmc6IDAsXG4gICAgICAgIGJsb2NrZWQ6IDAsXG4gICAgICAgIHNsZWVwaW5nOiAwLFxuICAgICAgICB1bmtub3duOiAwLFxuICAgICAgICBsaXN0OiBbXVxuICAgICAgfTtcblxuICAgICAgbGV0IGNtZCA9ICcnO1xuXG4gICAgICBpZiAoKF9wcm9jZXNzZXNfY3B1Lm1zICYmIERhdGUubm93KCkgLSBfcHJvY2Vzc2VzX2NwdS5tcyA+PSA1MDApIHx8IF9wcm9jZXNzZXNfY3B1Lm1zID09PSAwKSB7XG4gICAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luIHx8IF9zdW5vcykge1xuICAgICAgICAgIGlmIChfbGludXgpIHsgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgcHMgLWF4byBwaWQ6MTEscHBpZDoxMSxwY3B1OjYscG1lbTo2LHByaTo1LHZzejoxMSxyc3M6MTEsbmk6NSxldGltZTozMCxzdGF0ZTo1LHR0eToxNSx1c2VyOjIwLGNvbW1hbmQ7IHVuc2V0IExDX0FMTCc7IH1cbiAgICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgeyBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBwcyAtYXhvIHBpZCxwcGlkLHBjcHUscG1lbSxwcmksdnN6LHJzcyxuaSxldGltZSxzdGF0ZSx0dHksdXNlcixjb21tYW5kOyB1bnNldCBMQ19BTEwnOyB9XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHsgY21kID0gJ3BzIC1heG8gcGlkLHBwaWQscGNwdSxwbWVtLHByaSx2c3o9dGVtcF90aXRsZV8xLHJzcz10ZW1wX3RpdGxlXzIsbmljZSxldGltZT10ZW1wX3RpdGxlXzMsc3RhdGUsdHR5LHVzZXIsY29tbWFuZCAtcic7IH1cbiAgICAgICAgICBpZiAoX3N1bm9zKSB7IGNtZCA9ICdwcyAtQW8gcGlkLHBwaWQscGNwdSxwbWVtLHByaSx2c3oscnNzLG5pY2Usc3RpbWUscyx0dHksdXNlcixjb21tJzsgfVxuICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yICYmIHN0ZG91dC50b1N0cmluZygpLnRyaW0oKSkge1xuICAgICAgICAgICAgICByZXN1bHQubGlzdCA9IChwYXJzZVByb2Nlc3NlcyhzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykpKS5zbGljZSgpO1xuICAgICAgICAgICAgICByZXN1bHQuYWxsID0gcmVzdWx0Lmxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICByZXN1bHQucnVubmluZyA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAncnVubmluZyc7XG4gICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVzdWx0LmJsb2NrZWQgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ2Jsb2NrZWQnO1xuICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlc3VsdC5zbGVlcGluZyA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAnc2xlZXBpbmcnO1xuICAgICAgICAgICAgICB9KS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgcHJvY2Vzc19jcHUgLSBwcyBpcyBub3QgYWNjdXJhdGUgaW4gbGludXghXG4gICAgICAgICAgICAgICAgY21kID0gJ2NhdCAvcHJvYy9zdGF0IHwgZ3JlcCBcImNwdSBcIic7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3QuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY21kICs9ICgnO2NhdCAvcHJvYy8nICsgZWxlbWVudC5waWQgKyAnL3N0YXQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGN1cnJfcHJvY2Vzc2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBmaXJzdCBsaW5lIChhbGwgLSAvcHJvYy9zdGF0KVxuICAgICAgICAgICAgICAgICAgbGV0IGFsbCA9IHBhcnNlUHJvY1N0YXQoY3Vycl9wcm9jZXNzZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgIGxldCBsaXN0X25ldyA9IHt9O1xuICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFByb2Nlc3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGN1cnJfcHJvY2Vzc2VzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvY2VzcyA9IGNhbGNQcm9jU3RhdExpbnV4KGVsZW1lbnQsIGFsbCwgX3Byb2Nlc3Nlc19jcHUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRQcm9jZXNzLnBpZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcGNwdSBpbiBvdXRlciBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0UG9zID0gcmVzdWx0Lmxpc3QubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBpZDsgfSkuaW5kZXhPZihyZXN1bHRQcm9jZXNzLnBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1ID0gcmVzdWx0UHJvY2Vzcy5jcHV1ICsgcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1dSA9IHJlc3VsdFByb2Nlc3MuY3B1dTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdXMgPSByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgbGlzdF9uZXdbcmVzdWx0UHJvY2Vzcy5waWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B1dTogcmVzdWx0UHJvY2Vzcy5jcHV1LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3B1czogcmVzdWx0UHJvY2Vzcy5jcHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHJlc3VsdFByb2Nlc3MudXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGltZTogcmVzdWx0UHJvY2Vzcy5zdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dGltZTogcmVzdWx0UHJvY2Vzcy5jdXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3RpbWU6IHJlc3VsdFByb2Nlc3MuY3N0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LmFsbCA9IGFsbDtcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1Lmxpc3QgPSBPYmplY3QuYXNzaWduKHt9LCBsaXN0X25ldyk7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5tcyA9IERhdGUubm93KCkgLSBfcHJvY2Vzc2VzX2NwdS5tcztcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LnJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbWQgPSAncHMgLW8gcGlkLHBwaWQsdnN6LHJzcyxuaWNlLGV0aW1lLHN0YXQsdHR5LHVzZXIsY29tbSc7XG4gICAgICAgICAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSAncHMgLW8gcGlkLHBwaWQsdnN6LHJzcyxuaWNlLGV0aW1lLHMsdHR5LHVzZXIsY29tbSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICBsaW5lcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgICByZXN1bHQubGlzdCA9IHBhcnNlUHJvY2Vzc2VzMihsaW5lcykuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbGwgPSByZXN1bHQubGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucnVubmluZyA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ3J1bm5pbmcnO1xuICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmJsb2NrZWQgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdibG9ja2VkJztcbiAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5zbGVlcGluZyA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ3NsZWVwaW5nJztcbiAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChfd2luZG93cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Qcm9jZXNzIHwgc2VsZWN0LU9iamVjdCBQcm9jZXNzSWQsUGFyZW50UHJvY2Vzc0lkLEV4ZWN1dGlvblN0YXRlLENhcHRpb24sQ29tbWFuZExpbmUsRXhlY3V0YWJsZVBhdGgsVXNlck1vZGVUaW1lLEtlcm5lbE1vZGVUaW1lLFdvcmtpbmdTZXRTaXplLFByaW9yaXR5LFBhZ2VGaWxlVXNhZ2UsIEB7bj1cIkNyZWF0aW9uRGF0ZVwiO2U9eyRfLkNyZWF0aW9uRGF0ZS5Ub1N0cmluZyhcInl5eXktTU0tZGQgSEg6bW06c3NcIil9fSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb2Nlc3NTZWN0aW9ucyA9IHN0ZG91dC5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICAgIGxldCBwcm9jcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBwcm9jU3RhdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdF9uZXcgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgYWxsY3B1dSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGFsbGNwdXMgPSAwO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NTZWN0aW9ucy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGVsZW1lbnQudHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9jZXNzSWQnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRQaWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFyZW50UHJvY2Vzc0lkJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzVmFsdWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRXhlY3V0aW9uU3RhdGUnLCAnOicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmRMaW5lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbW1hbmRMaW5lJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGFkZGl0aW9uYWwgY29tbWFuZCBsaW5lIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxDb21tYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENvbW1hbmQgJiYgbGluZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZExpbmUgKz0gJyAnICsgbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDb21tYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnY29tbWFuZGxpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbW1hbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kUGF0aCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdFeGVjdXRhYmxlUGF0aCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1dGltZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdVc2VyTW9kZVRpbWUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGltZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdLZXJuZWxNb2RlVGltZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lbXcgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnV29ya2luZ1NldFNpemUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbGNwdXUgPSBhbGxjcHV1ICsgdXRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGFsbGNwdXMgPSBhbGxjcHVzICsgc3RpbWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbGwrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0dXNWYWx1ZSkgeyByZXN1bHQudW5rbm93bisrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNWYWx1ZSA9PT0gJzMnKSB7IHJlc3VsdC5ydW5uaW5nKys7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c1ZhbHVlID09PSAnNCcgfHwgc3RhdHVzVmFsdWUgPT09ICc1JykgeyByZXN1bHQuYmxvY2tlZCsrOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY1N0YXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHV0aW1lOiB1dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGltZTogc3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1czogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2NzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFBpZDogcGFyZW50UGlkLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1czogMCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW06IG1lbXcgLyBvcy50b3RhbG1lbSgpICogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJpb3JpdHknLCAnOicsIHRydWUpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgbWVtVnN6OiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFnZUZpbGVVc2FnZScsICc6JywgdHJ1ZSksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1Sc3M6IE1hdGguZmxvb3IocGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1dvcmtpbmdTZXRTaXplJywgJzonLCB0cnVlKSwgMTApIC8gMTAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3JlYXRpb25EYXRlJywgJzonLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogKCFzdGF0dXNWYWx1ZSA/IF93aW5TdGF0dXNWYWx1ZXNbMF0gOiBfd2luU3RhdHVzVmFsdWVzW3N0YXR1c1ZhbHVlXSksXG4gICAgICAgICAgICAgICAgICAgICAgdHR5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICB1c2VyOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kTGluZSB8fCBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGNvbW1hbmRQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogJydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2xlZXBpbmcgPSByZXN1bHQuYWxsIC0gcmVzdWx0LnJ1bm5pbmcgLSByZXN1bHQuYmxvY2tlZCAtIHJlc3VsdC51bmtub3duO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0ID0gcHJvY3M7XG4gICAgICAgICAgICAgICAgcHJvY1N0YXRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRQcm9jZXNzID0gY2FsY1Byb2NTdGF0V2luKGVsZW1lbnQsIGFsbGNwdXUgKyBhbGxjcHVzLCBfcHJvY2Vzc2VzX2NwdSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBjcHUgaW4gb3V0ZXIgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGxldCBsaXN0UG9zID0gcmVzdWx0Lmxpc3QubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBpZDsgfSkuaW5kZXhPZihyZXN1bHRQcm9jZXNzLnBpZCk7XG4gICAgICAgICAgICAgICAgICBpZiAobGlzdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdSA9IHJlc3VsdFByb2Nlc3MuY3B1dSArIHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1dSA9IHJlc3VsdFByb2Nlc3MuY3B1dTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1cyA9IHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBsaXN0X25ld1tyZXN1bHRQcm9jZXNzLnBpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNwdXU6IHJlc3VsdFByb2Nlc3MuY3B1dSxcbiAgICAgICAgICAgICAgICAgICAgY3B1czogcmVzdWx0UHJvY2Vzcy5jcHVzLFxuICAgICAgICAgICAgICAgICAgICB1dGltZTogcmVzdWx0UHJvY2Vzcy51dGltZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHJlc3VsdFByb2Nlc3Muc3RpbWVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUuYWxsID0gYWxsY3B1dSArIGFsbGNwdXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUuYWxsX3V0aW1lID0gYWxsY3B1dTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5hbGxfc3RpbWUgPSBhbGxjcHVzO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1Lmxpc3QgPSBPYmplY3QuYXNzaWduKHt9LCBsaXN0X25ldyk7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUubXMgPSBEYXRlLm5vdygpIC0gX3Byb2Nlc3Nlc19jcHUubXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUucmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soX3Byb2Nlc3Nlc19jcHUucmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKF9wcm9jZXNzZXNfY3B1LnJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnByb2Nlc3NlcyA9IHByb2Nlc3NlcztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBTIC0gcHJvY2VzcyBsb2FkXG4vLyBnZXQgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgYSBjZXJ0YWluIHByb2Nlc3Ncbi8vIChQSUQsIENQVS1Vc2FnZSAlLCBNZW0tVXNhZ2UgJSlcblxuZnVuY3Rpb24gcHJvY2Vzc0xvYWQocHJvYywgY2FsbGJhY2spIHtcblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihwcm9jKSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb2M7XG4gICAgcHJvYyA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIHByb2MgPSBwcm9jIHx8ICcnO1xuXG4gICAgICBpZiAodHlwZW9mIHByb2MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhbXSk7IH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgfVxuXG4gICAgICBsZXQgcHJvY2Vzc2VzU3RyaW5nID0gJyc7XG4gICAgICBwcm9jZXNzZXNTdHJpbmcuX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgcHJvY2Vzc2VzU3RyaW5nLl9fcHJvdG9fXy5yZXBsYWNlID0gdXRpbC5zdHJpbmdSZXBsYWNlO1xuICAgICAgcHJvY2Vzc2VzU3RyaW5nLl9fcHJvdG9fXy50cmltID0gdXRpbC5zdHJpbmdUcmltO1xuXG4gICAgICBjb25zdCBzID0gdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKHByb2MpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9jZXNzZXNTdHJpbmcgPSBwcm9jZXNzZXNTdHJpbmcgKyBzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3Nlc1N0cmluZyA9IHByb2Nlc3Nlc1N0cmluZy50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8sIC9nLCAnfCcpLnJlcGxhY2UoLywrL2csICd8Jyk7XG4gICAgICBpZiAocHJvY2Vzc2VzU3RyaW5nID09PSAnJykge1xuICAgICAgICBwcm9jZXNzZXNTdHJpbmcgPSAnKic7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgJiYgcHJvY2Vzc2VzU3RyaW5nICE9PSAnKicpIHtcbiAgICAgICAgcHJvY2Vzc2VzU3RyaW5nID0gJy0tLS0tLSc7XG4gICAgICB9XG4gICAgICBsZXQgcHJvY2Vzc2VzID0gcHJvY2Vzc2VzU3RyaW5nLnNwbGl0KCd8Jyk7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgIGNvbnN0IHByb2NTYW5pdGl6ZWQgPSB1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICcnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKHByb2MpO1xuXG4gICAgICAvLyBmcm9tIGhlcmUgbmV3XG4gICAgICAvLyBsZXQgcmVzdWx0ID0ge1xuICAgICAgLy8gICAncHJvYyc6IHByb2NTYW5pdGl6ZWQsXG4gICAgICAvLyAgICdwaWQnOiBudWxsLFxuICAgICAgLy8gICAnY3B1JzogMCxcbiAgICAgIC8vICAgJ21lbSc6IDBcbiAgICAgIC8vIH07XG4gICAgICBpZiAocHJvY1Nhbml0aXplZCAmJiBwcm9jZXNzZXMubGVuZ3RoICYmIHByb2Nlc3Nlc1swXSAhPT0gJy0tLS0tLScpIHtcbiAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1Byb2Nlc3MgfCBzZWxlY3QgUHJvY2Vzc0lkLENhcHRpb24sVXNlck1vZGVUaW1lLEtlcm5lbE1vZGVUaW1lLFdvcmtpbmdTZXRTaXplIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2Vzc1NlY3Rpb25zID0gc3Rkb3V0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgbGV0IHByb2NTdGF0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0X25ldyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBhbGxjcHV1ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsY3B1cyA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBwcm9jZXNzZXNcbiAgICAgICAgICAgICAgICBwcm9jZXNzU2VjdGlvbnMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBlbGVtZW50LnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvY2Vzc0lkJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHV0aW1lID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VzZXJNb2RlVGltZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0aW1lID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0tlcm5lbE1vZGVUaW1lJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVtID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1dvcmtpbmdTZXRTaXplJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBhbGxjcHV1ID0gYWxsY3B1dSArIHV0aW1lO1xuICAgICAgICAgICAgICAgICAgICBhbGxjcHVzID0gYWxsY3B1cyArIHN0aW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2NTdGF0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHV0aW1lOiB1dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGltZTogc3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1czogMCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByb2MudG9Mb3dlckNhc2UoKSkgPj0gMCAmJiAhaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG5hbWUgPSBwcm9jO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nlc1N0cmluZyA9PT0gJyonIHx8IGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucHJvYy50b0xvd2VyQ2FzZSgpID09PSBwbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGlkcy5wdXNoKHBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubWVtICs9IG1lbSAvIG9zLnRvdGFsbWVtKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvYzogcG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwaWRzOiBbcGlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZW06IG1lbSAvIG9zLnRvdGFsbWVtKCkgKiAxMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIG1pc3NpbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nlc1N0cmluZyAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgcHJvY2Vzc2VzTWlzc2luZyA9IHByb2Nlc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2NTdGF0cy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YobmFtZSkgPj0gMDsgfSkubGVuZ3RoID09PSAwO1xuXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3Nlc01pc3NpbmcuZm9yRWFjaChmdW5jdGlvbiAocHJvY05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHByb2M6IHByb2NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBwaWRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHByb2Mgc3RhdHMgZm9yIGVhY2ggcHJvY1xuICAgICAgICAgICAgICAgIHByb2NTdGF0cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UHJvY2VzcyA9IGNhbGNQcm9jU3RhdFdpbihlbGVtZW50LCBhbGxjcHV1ICsgYWxsY3B1cywgX3Byb2Nlc3NfY3B1KTtcblxuICAgICAgICAgICAgICAgICAgbGV0IGxpc3RQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbal0ucGlkID09PSByZXN1bHRQcm9jZXNzLnBpZCB8fCByZXN1bHRbal0ucGlkcy5pbmRleE9mKHJlc3VsdFByb2Nlc3MucGlkKSA+PSAwKSB7IGxpc3RQb3MgPSBqOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobGlzdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5jcHUgKz0gcmVzdWx0UHJvY2Vzcy5jcHV1ICsgcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBzYXZlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGxpc3RfbmV3W3Jlc3VsdFByb2Nlc3MucGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3B1dTogcmVzdWx0UHJvY2Vzcy5jcHV1LFxuICAgICAgICAgICAgICAgICAgICBjcHVzOiByZXN1bHRQcm9jZXNzLmNwdXMsXG4gICAgICAgICAgICAgICAgICAgIHV0aW1lOiByZXN1bHRQcm9jZXNzLnV0aW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGltZTogcmVzdWx0UHJvY2Vzcy5zdGltZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUuYWxsID0gYWxsY3B1dSArIGFsbGNwdXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LmFsbF91dGltZSA9IGFsbGNwdXU7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LmFsbF9zdGltZSA9IGFsbGNwdXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1Lmxpc3QgPSBPYmplY3QuYXNzaWduKHt9LCBsaXN0X25ldyk7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1Lm1zID0gRGF0ZS5ub3coKSAtIF9wcm9jZXNzX2NwdS5tcztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUucmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2RhcndpbiB8fCBfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFsnLWF4bycsICdwaWQscHBpZCxwY3B1LHBtZW0sY29tbSddO1xuICAgICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BzJywgcGFyYW1zKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgICAgbGV0IHByb2NTdGF0cyA9IFtdO1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nlc1N0cmluZyA9PT0gJyonKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdncmVwJykgIT09IC0xKSB7IHJldHVybiBmYWxzZTsgfSAvLyByZW1vdmUgdGhpcz8/XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQgfHwgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKGl0ZW0udG9Mb3dlckNhc2UoKSkgPj0gMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBsaW5lLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgICAgcHJvY1N0YXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhWzRdLnN1YnN0cmluZyhkYXRhWzRdLmxhc3RJbmRleE9mKCcvJykgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgcGlkOiBwYXJzZUludChkYXRhWzBdKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBwcGlkOiBwYXJzZUludChkYXRhWzFdKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBjcHU6IHBhcnNlRmxvYXQoZGF0YVsyXS5yZXBsYWNlKCcsJywgJy4nKSksXG4gICAgICAgICAgICAgICAgICAgIG1lbTogcGFyc2VGbG9hdChkYXRhWzNdLnJlcGxhY2UoJywnLCAnLicpKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBwcm9jU3RhdHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGxldCBsaXN0UG9zID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHJlc3VsdFtqXS5wcm9jLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFBvcyA9IGo7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9jKSB7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByb2MudG9Mb3dlckNhc2UoKSkgPj0gMCAmJiAhaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9jO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzc2VzU3RyaW5nID09PSAnKicpIHx8IGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RQb3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZDogaXRlbS5waWQsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkczogW2l0ZW0ucGlkXSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IGl0ZW0uY3B1LFxuICAgICAgICAgICAgICAgICAgICAgIG1lbTogaXRlbS5tZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcGlkIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10ucGlkID0gaXRlbS5waWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLnBpZHMucHVzaChpdGVtLnBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5jcHUgKz0gaXRlbS5jcHU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5tZW0gKz0gaXRlbS5tZW07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VzU3RyaW5nICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgbWlzc2luZyBwcm9jZXNzZXNcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2Vzc2VzTWlzc2luZyA9IHByb2Nlc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jU3RhdHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5hbWUpID49IDA7IH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZXNNaXNzaW5nLmZvckVhY2goZnVuY3Rpb24gKHByb2NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2M6IHByb2NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBwaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBpZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgcHJvY2Vzc19jcHUgLSBwcyBpcyBub3QgYWNjdXJhdGUgaW4gbGludXghXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0uY3B1ID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgY21kID0gJ2NhdCAvcHJvYy9zdGF0IHwgZ3JlcCBcImNwdSBcIic7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gcmVzdWx0W2ldLnBpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kICs9ICgnO2NhdCAvcHJvYy8nICsgcmVzdWx0W2ldLnBpZHNbal0gKyAnL3N0YXQnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBjdXJyX3Byb2Nlc3NlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgbGluZSAoYWxsIC0gL3Byb2Mvc3RhdClcbiAgICAgICAgICAgICAgICAgIGxldCBhbGwgPSBwYXJzZVByb2NTdGF0KGN1cnJfcHJvY2Vzc2VzLnNoaWZ0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICBsZXQgbGlzdF9uZXcgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRQcm9jZXNzID0ge307XG4gICAgICAgICAgICAgICAgICBjdXJyX3Byb2Nlc3Nlcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb2Nlc3MgPSBjYWxjUHJvY1N0YXRMaW51eChlbGVtZW50LCBhbGwsIF9wcm9jZXNzX2NwdSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFByb2Nlc3MucGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHJlc3VsdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdEl0ZW1JZCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLnBpZHMuaW5kZXhPZihyZXN1bHRQcm9jZXNzLnBpZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtSWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwY3B1IGluIG91dGVyIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJdGVtSWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdEl0ZW1JZF0uY3B1ICs9IHJlc3VsdFByb2Nlc3MuY3B1dSArIHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0X25ld1tyZXN1bHRQcm9jZXNzLnBpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHV1OiByZXN1bHRQcm9jZXNzLmNwdXUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHVzOiByZXN1bHRQcm9jZXNzLmNwdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGltZTogcmVzdWx0UHJvY2Vzcy51dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0aW1lOiByZXN1bHRQcm9jZXNzLnN0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0aW1lOiByZXN1bHRQcm9jZXNzLmN1dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdGltZTogcmVzdWx0UHJvY2Vzcy5jc3RpbWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jcHUgPSBNYXRoLnJvdW5kKGl0ZW0uY3B1ICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUuYWxsID0gYWxsO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1Lmxpc3QgPSBPYmplY3QuYXNzaWduKHt9LCBsaXN0X25ldyk7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUubXMgPSBEYXRlLm5vdygpIC0gX3Byb2Nlc3NfY3B1Lm1zO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LnJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucHJvY2Vzc0xvYWQgPSBwcm9jZXNzTG9hZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gc3lzdGVtLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMi4gU3lzdGVtIChIYXJkd2FyZSwgQklPUywgQmFzZSBCb2FyZClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCBleGVjUHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIHN5c3RlbShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICBtb2RlbDogJ0NvbXB1dGVyJyxcbiAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIHNlcmlhbDogJy0nLFxuICAgICAgICB1dWlkOiAnLScsXG4gICAgICAgIHNrdTogJy0nLFxuICAgICAgICB2aXJ0dWFsOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IHN5c3RlbSAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInKTtcbiAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdCBuYW1lJyk7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsIG51bWJlcicpO1xuICAgICAgICAgIHJlc3VsdC51dWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3V1aWQnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJlc3VsdC5za3UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2t1IG51bWJlcicpO1xuICAgICAgICAgIC8vIE5vbi1Sb290IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwicHJvZHVjdF9uYW1lOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X25hbWUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwicHJvZHVjdF9zZXJpYWw6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3Rfc2VyaWFsIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInByb2R1Y3RfdXVpZDogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF91dWlkIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInByb2R1Y3RfdmVyc2lvbjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF92ZXJzaW9uIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInN5c192ZW5kb3I6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3N5c192ZW5kb3IgMj4vZGV2L251bGw7IGVjaG87YDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHJlc3VsdC5tYW51ZmFjdHVyZXIgPT09ICcnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N5c192ZW5kb3InKSA6IHJlc3VsdC5tYW51ZmFjdHVyZXI7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSByZXN1bHQubW9kZWwgPT09ICcnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3RfbmFtZScpIDogcmVzdWx0Lm1vZGVsO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSByZXN1bHQudmVyc2lvbiA9PT0gJycgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdF92ZXJzaW9uJykgOiByZXN1bHQudmVyc2lvbjtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSByZXN1bHQuc2VyaWFsID09PSAnJyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0X3NlcmlhbCcpIDogcmVzdWx0LnNlcmlhbDtcbiAgICAgICAgICAgIHJlc3VsdC51dWlkID0gcmVzdWx0LnV1aWQgPT09ICcnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3RfdXVpZCcpLnRvTG93ZXJDYXNlKCkgOiByZXN1bHQudXVpZDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQuc2VyaWFsIHx8IHJlc3VsdC5zZXJpYWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnNlcmlhbCA9ICctJzsgfVxuICAgICAgICAgIGlmICghcmVzdWx0Lm1hbnVmYWN0dXJlciB8fCByZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnJzsgfVxuICAgICAgICAgIGlmICghcmVzdWx0Lm1vZGVsIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQubW9kZWwgPSAnQ29tcHV0ZXInOyB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQudmVyc2lvbiB8fCByZXN1bHQudmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQudmVyc2lvbiA9ICcnOyB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQuc2t1IHx8IHJlc3VsdC5za3UudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnNrdSA9ICctJzsgfVxuXG4gICAgICAgICAgLy8gZGV0ZWN0IHZpcnR1YWwgKDEpXG4gICAgICAgICAgaWYgKHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpID09PSAndmlydHVhbGJveCcgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkgPT09ICdrdm0nIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpID09PSAndmlydHVhbCBtYWNoaW5lJyB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKSA9PT0gJ2JvY2hzJyB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2bXdhcmUnKSB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdkcm9wbGV0JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgY2FzZSAndmlydHVhbGJveCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWxCb3gnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd2bXdhcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdrdm0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib2Nocyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ2JvY2hzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2bXdhcmUnKSB8fCByZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkgPT09ICd4ZW4nKSB7XG4gICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICBjYXNlICd2bXdhcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd4ZW4nOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdYZW4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC52aXJ0dWFsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBkaXNrc0J5SWQgPSBleGVjU3luYygnbHMgLTEgL2Rldi9kaXNrL2J5LWlkLyAyPi9kZXYvbnVsbCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGlmIChkaXNrc0J5SWQuaW5kZXhPZignX1FFTVVfJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnUUVNVSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRpc2tzQnlJZC5pbmRleE9mKCdfVkJPWF8nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsQm94JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQudmlydHVhbCAmJiAob3MucmVsZWFzZSgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbWljcm9zb2Z0JykgPj0gMCB8fCBvcy5yZWxlYXNlKCkudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnd3NsMicpKSkge1xuICAgICAgICAgICAgY29uc3Qga2VybmVsVmVyc2lvbiA9IHBhcnNlRmxvYXQob3MucmVsZWFzZSgpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICdNaWNyb3NvZnQnO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gJ1dTTCc7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IGtlcm5lbFZlcnNpb24gPCA0LjE5ID8gJzEnIDogJzInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2NJbmZvID0gZXhlY1N5bmMoJ2RtaWRlY29kZSAtdCA0Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2NMaW5lcyA9IHByb2NJbmZvLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCBwcm9jTWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShwcm9jTGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHByb2NNYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZpcnR1YWxib3gnOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWxCb3gnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndm13YXJlJzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAna3ZtJzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9jaHMnOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ2JvY2hzJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZXRlY3QgZG9ja2VyXG4gICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoJy8uZG9ja2VyZW52JykgfHwgZnMuZXhpc3RzU3luYygnLy5kb2NrZXJpbml0JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9ICdEb2NrZXIgQ29udGFpbmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdkbWVzZyAyPi9kZXYvbnVsbCB8IGdyZXAgLWlFIFwidmlydHVhbHxoeXBlcnZpc29yXCIgfCBncmVwIC1pRSBcInZtd2FyZXxxZW11fGt2bXx4ZW5cIiB8IGdyZXAgLXZpRSBcIk5lc3RlZCBWaXJ0dWFsaXphdGlvbnwvdmlydHVhbC9cIicpO1xuICAgICAgICAgICAgLy8gZGV0ZWN0IHZpcnR1YWwgbWFjaGluZXNcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubW9kZWwgPT09ICdDb21wdXRlcicpIHsgcmVzdWx0Lm1vZGVsID0gJ1ZpcnR1YWwgbWFjaGluZSc7IH1cbiAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2bXdhcmUnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdxZW11JykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1FFTVUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3hlbicpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdYZW4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2t2bScpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3VsdC5tYW51ZmFjdHVyZXIgPT09ICcnICYmIHJlc3VsdC5tb2RlbCA9PT0gJ0NvbXB1dGVyJyAmJiByZXN1bHQudmVyc2lvbiA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIFJhc3BiZXJyeSBQaVxuICAgICAgICAgICAgZnMucmVhZEZpbGUoJy9wcm9jL2NwdWluZm8nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdoYXJkd2FyZScsICc6JywgdHJ1ZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdyZXZpc2lvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWw6JywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgdmFsdWVzOiBodHRwczovL2VsaW51eC5vcmcvUlBpX0hhcmR3YXJlSGlzdG9yeVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJhc3BiZXJyeXBpLm9yZy9kb2N1bWVudGF0aW9uL2hhcmR3YXJlL3Jhc3BiZXJyeXBpL3JldmlzaW9uLWNvZGVzL1JFQURNRS5tZFxuICAgICAgICAgICAgICAgIGlmICgocmVzdWx0Lm1vZGVsID09PSAnQkNNMjgzNScgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjcwOCcgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjcwOScgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjcxMCcgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjcxMScgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjgzNicgfHwgcmVzdWx0Lm1vZGVsID09PSAnQkNNMjgzNycpICYmIG1vZGVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmFzcGJlcnJ5JykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgclBJUmV2aXNpb24gPSB1dGlsLmRlY29kZVBpQ3B1aW5mbyhsaW5lcyk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSByUElSZXZpc2lvbi5tb2RlbDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gclBJUmV2aXNpb24ucmV2aXNpb25Db2RlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICdSYXNwYmVycnkgUGkgRm91bmRhdGlvbic7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucmFzcGJlcnJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHJQSVJldmlzaW9uLm1hbnVmYWN0dXJlcixcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yOiByUElSZXZpc2lvbi5wcm9jZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHJQSVJldmlzaW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldmlzaW9uOiByUElSZXZpc2lvbi5yZXZpc2lvblxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ2lvcmVnIC1jIElPUGxhdGZvcm1FeHBlcnREZXZpY2UgLWQgMicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkucmVwbGFjZSgvWzw+XCJdL2csICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwnLCAnPScsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lvcGxhdGZvcm1zZXJpYWxudW1iZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnV1aWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaW9wbGF0Zm9ybXV1aWQnLCAnPScsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXN1bHQuc2t1ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkLWlkJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Db21wdXRlclN5c3RlbVByb2R1Y3QgfCBzZWxlY3QgTmFtZSxWZW5kb3IsVmVyc2lvbixJZGVudGlmeWluZ051bWJlcixVVUlEIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVuZG9yJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpZGVudGlmeWluZ251bWJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC51dWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3V1aWQnLCAnOicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIC8vIGRldGVjdCB2aXJ0dWFsICgxKVxuICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAobW9kZWwgPT09ICd2aXJ0dWFsYm94JyB8fCBtb2RlbCA9PT0gJ2t2bScgfHwgbW9kZWwgPT09ICd2aXJ0dWFsIG1hY2hpbmUnIHx8IG1vZGVsID09PSAnYm9jaHMnIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ3FlbXUnKSB8fCBtb2RlbC5zdGFydHNXaXRoKCdwYXJhbGxlbHMnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgndmlydHVhbGJveCcpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsQm94JzsgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCd2bXdhcmUnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdrdm0nKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdib2NocycpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdib2Nocyc7IH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncWVtdScpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3BhcmFsbGVscycpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdQYXJhbGxlbHMnOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgbWFudWZhY3R1cmVyID0gcmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAobWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpIHx8IG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCdxZW11JykgfHwgbWFudWZhY3R1cmVyID09PSAneGVuJyB8fCBtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgncGFyYWxsZWxzJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCd2bXdhcmUnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgneGVuJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1hlbic7IH1cbiAgICAgICAgICAgICAgICBpZiAobWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3FlbXUnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgncGFyYWxsZWxzJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1BhcmFsbGVscyc7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBNU19TeXN0ZW1pbmZvcm1hdGlvbiAtTmFtZXNwYWNlIFwicm9vdC93bWlcIiB8IHNlbGVjdCBzeXN0ZW1za3UgfCBmbCAnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5za3UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3lzdGVtc2t1JywgJzonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudmlydHVhbCkge1xuICAgICAgICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfYmlvcyB8IHNlbGVjdCBWZXJzaW9uLCBTZXJpYWxOdW1iZXIsIFNNQklPU0JJT1NWZXJzaW9uJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1ZSVFVBTCcpID49IDAgfHwgbGluZXMuaW5kZXhPZignQSBNIEkgJykgPj0gMCB8fCBsaW5lcy5pbmRleE9mKCdWaXJ0dWFsQm94JykgPj0gMCB8fCBsaW5lcy5pbmRleE9mKCdWTVdhcmUnKSA+PSAwIHx8IGxpbmVzLmluZGV4T2YoJ1hlbicpID49IDAgfHwgbGluZXMuaW5kZXhPZignUGFyYWxsZWxzJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1ZpcnR1YWxCb3gnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWxCb3gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1ZNd2FyZScpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdYZW4nKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1hlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignVlJUVUFMJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdIeXBlci1WJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdBIE0gSScpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbCBQQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignUGFyYWxsZWxzJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdQYXJhbGxlbHMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnN5c3RlbSA9IHN5c3RlbTtcblxuZnVuY3Rpb24gYmlvcyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICB2ZXJzaW9uOiAnJyxcbiAgICAgICAgcmVsZWFzZURhdGU6ICcnLFxuICAgICAgICByZXZpc2lvbjogJycsXG4gICAgICB9O1xuICAgICAgbGV0IGNtZCA9ICcnO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAgICAgY21kID0gJ2NhdCAvcHJvYy9jcHVpbmZvIHwgZ3JlcCBTZXJpYWwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCBiaW9zIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQudmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ZlbmRvcicpO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ZlcnNpb24nKTtcbiAgICAgICAgICBsZXQgZGF0ZXRpbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmVsZWFzZSBEYXRlJyk7XG4gICAgICAgICAgcmVzdWx0LnJlbGVhc2VEYXRlID0gdXRpbC5wYXJzZURhdGVUaW1lKGRhdGV0aW1lKS5kYXRlO1xuICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCSU9TIFJldmlzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWxOdW1iZXInKTtcbiAgICAgICAgICBsZXQgbGFuZ3VhZ2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3VycmVudGx5IEluc3RhbGxlZCBMYW5ndWFnZScpLnNwbGl0KCd8JylbMF07XG4gICAgICAgICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICByZXN1bHQubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAmJiBzdGRvdXQudG9TdHJpbmcoKS5pbmRleE9mKCdDaGFyYWN0ZXJpc3RpY3M6JykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyBpcyBzdXBwb3J0ZWQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGxpbmUuc3BsaXQoJyBpcyBzdXBwb3J0ZWQnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm9uLVJvb3QgdmFsdWVzXG4gICAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJiaW9zX2RhdGU6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2Jpb3NfZGF0ZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJiaW9zX3ZlbmRvcjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYmlvc192ZW5kb3IgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYmlvc192ZXJzaW9uOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9iaW9zX3ZlcnNpb24gMj4vZGV2L251bGw7IGVjaG87YDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9ICFyZXN1bHQudmVuZG9yID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Jpb3NfdmVuZG9yJykgOiByZXN1bHQudmVuZG9yO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSAhcmVzdWx0LnZlcnNpb24gPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYmlvc192ZXJzaW9uJykgOiByZXN1bHQudmVyc2lvbjtcbiAgICAgICAgICAgIGRhdGV0aW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Jpb3NfZGF0ZScpO1xuICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VEYXRlID0gIXJlc3VsdC5yZWxlYXNlRGF0ZSA/IHV0aWwucGFyc2VEYXRlVGltZShkYXRldGltZSkuZGF0ZSA6IHJlc3VsdC5yZWxlYXNlRGF0ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgcmVzdWx0LnZlbmRvciA9ICdBcHBsZSBJbmMuJztcbiAgICAgICAgZXhlYyhcbiAgICAgICAgICAnc3lzdGVtX3Byb2ZpbGVyIFNQSGFyZHdhcmVEYXRhVHlwZSAtanNvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBoYXJkd2FyZURhdGEgPSBKU09OLnBhcnNlKHN0ZG91dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgaWYgKGhhcmR3YXJlRGF0YSAmJiBoYXJkd2FyZURhdGEuU1BIYXJkd2FyZURhdGFUeXBlICYmIGhhcmR3YXJlRGF0YS5TUEhhcmR3YXJlRGF0YVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvb3RSb21WZXJzaW9uID0gaGFyZHdhcmVEYXRhLlNQSGFyZHdhcmVEYXRhVHlwZVswXS5ib290X3JvbV92ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGJvb3RSb21WZXJzaW9uID0gYm9vdFJvbVZlcnNpb24gPyBib290Um9tVmVyc2lvbi5zcGxpdCgnKCcpWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBib290Um9tVmVyc2lvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIHJlc3VsdC52ZW5kb3IgPSAnU3VuIE1pY3Jvc3lzdGVtcyc7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX2Jpb3MgfCBzZWxlY3QgRGVzY3JpcHRpb24sVmVyc2lvbixNYW51ZmFjdHVyZXIsQHtuPVwiUmVsZWFzZURhdGVcIjtlPXskXy5SZWxlYXNlRGF0ZS5Ub1N0cmluZyhcInl5eXktTU0tZGRcIil9fSxCdWlsZE51bWJlcixTZXJpYWxOdW1iZXIgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkZXNjcmlwdGlvbicsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi5pbmRleE9mKCcgVmVyc2lvbiAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gUGhvZW5peCBST00gQklPUyBQTFVTIFZlcnNpb24gMS4xMCBBMDRcbiAgICAgICAgICAgICAgICByZXN1bHQudmVuZG9yID0gZGVzY3JpcHRpb24uc3BsaXQoJyBWZXJzaW9uICcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IGRlc2NyaXB0aW9uLnNwbGl0KCcgVmVyc2lvbiAnKVsxXS50cmltKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24uaW5kZXhPZignIFZlcjogJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uIEJJT1MgRGF0ZTogMDYvMjcvMTYgMTc6NTA6MTYgVmVyOiAxLjQuNVxuICAgICAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IGRlc2NyaXB0aW9uLnNwbGl0KCcgVmVyOiAnKVsxXS50cmltKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnOicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5yZWxlYXNlRGF0ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdyZWxlYXNlZGF0ZScsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdidWlsZG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsbnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmJpb3MgPSBiaW9zO1xuXG5mdW5jdGlvbiBiYXNlYm9hcmQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICB2ZXJzaW9uOiAnJyxcbiAgICAgICAgc2VyaWFsOiAnLScsXG4gICAgICAgIGFzc2V0VGFnOiAnLScsXG4gICAgICAgIG1lbU1heDogbnVsbCxcbiAgICAgICAgbWVtU2xvdHM6IG51bGxcbiAgICAgIH07XG4gICAgICBsZXQgY21kID0gJyc7XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgICAgICBjbWQgPSAnY2F0IC9wcm9jL2NwdWluZm8gfCBncmVwIFNlcmlhbCc7XG4gICAgICAgICAgLy8gJ0JDTTI3MDknLCAnQkNNMjgzNScsICdCQ00yNzA4JyAtLT5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgMiAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICB3b3JrbG9hZC5wdXNoKGV4ZWNQcm9taXNlKGNtZCkpO1xuICAgICAgICB3b3JrbG9hZC5wdXNoKGV4ZWNQcm9taXNlKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCBtZW1vcnkgMj4vZGV2L251bGwnKSk7XG4gICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhLnJlc3VsdHNbMF0gPyBkYXRhLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5zcGxpdCgnXFxuJykgOiBbJyddO1xuICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWFudWZhY3R1cmVyJyk7XG4gICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2R1Y3QgTmFtZScpO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ZlcnNpb24nKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbCBOdW1iZXInKTtcbiAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQXNzZXQgVGFnJyk7XG4gICAgICAgICAgLy8gTm9uLVJvb3QgdmFsdWVzXG4gICAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJib2FyZF9hc3NldF90YWc6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2JvYXJkX2Fzc2V0X3RhZyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJib2FyZF9uYW1lOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9ib2FyZF9uYW1lIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJvYXJkX3NlcmlhbDogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYm9hcmRfc2VyaWFsIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJvYXJkX3ZlbmRvcjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYm9hcmRfdmVuZG9yIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJvYXJkX3ZlcnNpb246IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2JvYXJkX3ZlcnNpb24gMj4vZGV2L251bGw7IGVjaG87YDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICFyZXN1bHQubWFudWZhY3R1cmVyID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkX3ZlbmRvcicpIDogcmVzdWx0Lm1hbnVmYWN0dXJlcjtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9ICFyZXN1bHQubW9kZWwgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmRfbmFtZScpIDogcmVzdWx0Lm1vZGVsO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSAhcmVzdWx0LnZlcnNpb24gPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmRfdmVyc2lvbicpIDogcmVzdWx0LnZlcnNpb247XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gIXJlc3VsdC5zZXJpYWwgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmRfc2VyaWFsJykgOiByZXN1bHQuc2VyaWFsO1xuICAgICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gIXJlc3VsdC5hc3NldFRhZyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZF9hc3NldF90YWcnKSA6IHJlc3VsdC5hc3NldFRhZztcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5zZXJpYWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnNlcmlhbCA9ICctJzsgfVxuICAgICAgICAgIGlmIChyZXN1bHQuYXNzZXRUYWcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LmFzc2V0VGFnID0gJy0nOyB9XG5cbiAgICAgICAgICAvLyBtZW1cbiAgICAgICAgICBsaW5lcyA9IGRhdGEucmVzdWx0c1sxXSA/IGRhdGEucmVzdWx0c1sxXS50b1N0cmluZygpLnNwbGl0KCdcXG4nKSA6IFsnJ107XG4gICAgICAgICAgcmVzdWx0Lm1lbU1heCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01heGltdW0gQ2FwYWNpdHknKSkgKiAxMDI0ICogMTAyNCAqIDEwMjQgfHwgbnVsbDtcbiAgICAgICAgICByZXN1bHQubWVtU2xvdHMgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdOdW1iZXIgT2YgRGV2aWNlcycpKSB8fCBudWxsO1xuXG4gICAgICAgICAgLy8gcmFzcGJlcnJ5XG4gICAgICAgICAgbGV0IGxpbmVzUnBpID0gJyc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmVzUnBpID0gZnMucmVhZEZpbGVTeW5jKCcvcHJvYy9jcHVpbmZvJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGhhcmR3YXJlID0gdXRpbC5nZXRWYWx1ZShsaW5lc1JwaSwgJ2hhcmR3YXJlJyk7XG4gICAgICAgICAgaWYgKGhhcmR3YXJlLnN0YXJ0c1dpdGgoJ0JDTScpKSB7XG4gICAgICAgICAgICBjb25zdCBycGkgPSB1dGlsLmRlY29kZVBpQ3B1aW5mbyhsaW5lc1JwaSk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gcnBpLm1hbnVmYWN0dXJlcjtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9ICdSYXNwYmVycnkgUGknO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHJwaS5zZXJpYWw7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHJwaS50eXBlICsgJyAtICcgKyBycGkucmV2aXNpb247XG4gICAgICAgICAgICByZXN1bHQubWVtTWF4ID0gb3MudG90YWxtZW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1TbG90cyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgd29ya2xvYWQucHVzaChleGVjUHJvbWlzZSgnaW9yZWcgLWMgSU9QbGF0Zm9ybUV4cGVydERldmljZSAtZCAyJykpO1xuICAgICAgICB3b3JrbG9hZC5wdXNoKGV4ZWNQcm9taXNlKCdzeXN0ZW1fcHJvZmlsZXIgU1BNZW1vcnlEYXRhVHlwZScpKTtcbiAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGEucmVzdWx0c1swXSA/IGRhdGEucmVzdWx0c1swXS50b1N0cmluZygpLnJlcGxhY2UoL1s8PlwiXS9nLCAnJykuc3BsaXQoJ1xcbicpIDogWycnXTtcbiAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lvcGxhdGZvcm1zZXJpYWxudW1iZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZC1pZCcsICc9JywgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBtZW1cbiAgICAgICAgICBsZXQgZGV2aWNlcyA9IGRhdGEucmVzdWx0c1sxXSA/IGRhdGEucmVzdWx0c1sxXS50b1N0cmluZygpLnNwbGl0KCcgICAgICAgIEJBTksgJykgOiBbJyddO1xuICAgICAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRhdGEucmVzdWx0c1sxXSA/IGRhdGEucmVzdWx0c1sxXS50b1N0cmluZygpLnNwbGl0KCcgICAgICAgIERJTU0nKSA6IFsnJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICByZXN1bHQubWVtU2xvdHMgPSBkZXZpY2VzLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChvcy5hcmNoKCkgPT09ICdhcm02NCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1TbG90cyA9IDA7XG4gICAgICAgICAgICByZXN1bHQubWVtTWF4ID0gb3MudG90YWxtZW0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgY29uc3Qgd2luMTBwbHVzID0gcGFyc2VJbnQob3MucmVsZWFzZSgpKSA+PSAxMDtcbiAgICAgICAgICBjb25zdCBtYXhDYXBhY2l0eUF0dHJpYnV0ZSA9IHdpbjEwcGx1cyA/ICdNYXhDYXBhY2l0eUV4JyA6ICdNYXhDYXBhY2l0eSc7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9iYXNlYm9hcmQgfCBzZWxlY3QgTW9kZWwsTWFudWZhY3R1cmVyLFByb2R1Y3QsVmVyc2lvbixTZXJpYWxOdW1iZXIsUGFydE51bWJlcixTS1UgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbChgR2V0LUNpbUluc3RhbmNlIFdpbjMyX3BoeXNpY2FsbWVtb3J5YXJyYXkgfCBzZWxlY3QgJHttYXhDYXBhY2l0eUF0dHJpYnV0ZX0sIE1lbW9yeURldmljZXMgfCBmbGApKTtcbiAgICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gZGF0YS5yZXN1bHRzWzBdID8gZGF0YS5yZXN1bHRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpIDogWycnXTtcblxuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsJywgJzonKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm1vZGVsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0JywgJzonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnOicpO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWxudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3BhcnRudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuYXNzZXRUYWcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NrdScsICc6Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1lbXBoeXNpY2FsXG4gICAgICAgICAgICBsaW5lcyA9IGRhdGEucmVzdWx0c1sxXSA/IGRhdGEucmVzdWx0c1sxXS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKSA6IFsnJ107XG4gICAgICAgICAgICByZXN1bHQubWVtTWF4ID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCBtYXhDYXBhY2l0eUF0dHJpYnV0ZSwgJzonKSkgKiAod2luMTBwbHVzID8gMTAyNCA6IDEpIHx8IG51bGw7XG4gICAgICAgICAgICByZXN1bHQubWVtU2xvdHMgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNZW1vcnlEZXZpY2VzJywgJzonKSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmJhc2Vib2FyZCA9IGJhc2Vib2FyZDtcblxuZnVuY3Rpb24gY2hhc3NpcyhjYWxsYmFjaykge1xuICBjb25zdCBjaGFzc2lzVHlwZXMgPSBbJ090aGVyJyxcbiAgICAnVW5rbm93bicsXG4gICAgJ0Rlc2t0b3AnLFxuICAgICdMb3cgUHJvZmlsZSBEZXNrdG9wJyxcbiAgICAnUGl6emEgQm94JyxcbiAgICAnTWluaSBUb3dlcicsXG4gICAgJ1Rvd2VyJyxcbiAgICAnUG9ydGFibGUnLFxuICAgICdMYXB0b3AnLFxuICAgICdOb3RlYm9vaycsXG4gICAgJ0hhbmQgSGVsZCcsXG4gICAgJ0RvY2tpbmcgU3RhdGlvbicsXG4gICAgJ0FsbCBpbiBPbmUnLFxuICAgICdTdWIgTm90ZWJvb2snLFxuICAgICdTcGFjZS1TYXZpbmcnLFxuICAgICdMdW5jaCBCb3gnLFxuICAgICdNYWluIFN5c3RlbSBDaGFzc2lzJyxcbiAgICAnRXhwYW5zaW9uIENoYXNzaXMnLFxuICAgICdTdWJDaGFzc2lzJyxcbiAgICAnQnVzIEV4cGFuc2lvbiBDaGFzc2lzJyxcbiAgICAnUGVyaXBoZXJhbCBDaGFzc2lzJyxcbiAgICAnU3RvcmFnZSBDaGFzc2lzJyxcbiAgICAnUmFjayBNb3VudCBDaGFzc2lzJyxcbiAgICAnU2VhbGVkLUNhc2UgUEMnLFxuICAgICdNdWx0aS1TeXN0ZW0gQ2hhc3NpcycsXG4gICAgJ0NvbXBhY3QgUENJJyxcbiAgICAnQWR2YW5jZWQgVENBJyxcbiAgICAnQmxhZGUnLFxuICAgICdCbGFkZSBFbmNsb3N1cmUnLFxuICAgICdUYWJsZXQnLFxuICAgICdDb252ZXJ0aWJsZScsXG4gICAgJ0RldGFjaGFibGUnLFxuICAgICdJb1QgR2F0ZXdheSAnLFxuICAgICdFbWJlZGRlZCBQQycsXG4gICAgJ01pbmkgUEMnLFxuICAgICdTdGljayBQQycsXG4gIF07XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHZlcnNpb246ICcnLFxuICAgICAgICBzZXJpYWw6ICctJyxcbiAgICAgICAgYXNzZXRUYWc6ICctJyxcbiAgICAgICAgc2t1OiAnJyxcbiAgICAgIH07XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJjaGFzc2lzX2Fzc2V0X3RhZzogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvY2hhc3Npc19hc3NldF90YWcgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2hhc3Npc19zZXJpYWw6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2NoYXNzaXNfc2VyaWFsIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNoYXNzaXNfdHlwZTogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvY2hhc3Npc190eXBlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNoYXNzaXNfdmVuZG9yOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9jaGFzc2lzX3ZlbmRvciAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjaGFzc2lzX3ZlcnNpb246IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2NoYXNzaXNfdmVyc2lvbiAyPi9kZXYvbnVsbDsgZWNobztgO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFzc2lzX3ZlbmRvcicpO1xuICAgICAgICAgIGNvbnN0IGN0eXBlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYXNzaXNfdHlwZScpLnJlcGxhY2UoL1xcRC9nLCAnJykpO1xuICAgICAgICAgIHJlc3VsdC50eXBlID0gKGN0eXBlICYmICFpc05hTihjdHlwZSkgJiYgY3R5cGUgPCBjaGFzc2lzVHlwZXMubGVuZ3RoKSA/IGNoYXNzaXNUeXBlc1tjdHlwZSAtIDFdIDogJyc7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhc3Npc192ZXJzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFzc2lzX3NlcmlhbCcpO1xuICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFzc2lzX2Fzc2V0X3RhZycpO1xuICAgICAgICAgIGlmIChyZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnLSc7IH1cbiAgICAgICAgICBpZiAocmVzdWx0LnZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnZlcnNpb24gPSAnLSc7IH1cbiAgICAgICAgICBpZiAocmVzdWx0LnNlcmlhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuc2VyaWFsID0gJy0nOyB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5hc3NldFRhZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuYXNzZXRUYWcgPSAnLSc7IH1cblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ2lvcmVnIC1jIElPUGxhdGZvcm1FeHBlcnREZXZpY2UgLWQgMicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkucmVwbGFjZSgvWzw+XCJdL2csICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwnLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lvcGxhdGZvcm1zZXJpYWxudW1iZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkLWlkJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1N5c3RlbUVuY2xvc3VyZSB8IHNlbGVjdCBNb2RlbCxNYW51ZmFjdHVyZXIsQ2hhc3Npc1R5cGVzLFZlcnNpb24sU2VyaWFsTnVtYmVyLFBhcnROdW1iZXIsU0tVIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcblxuICAgICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCcsICc6Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IGN0eXBlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NoYXNzaXNUeXBlcycsICc6JykucmVwbGFjZSgvXFxEL2csICcnKSk7XG4gICAgICAgICAgICAgIHJlc3VsdC50eXBlID0gKGN0eXBlICYmICFpc05hTihjdHlwZSkgJiYgY3R5cGUgPCBjaGFzc2lzVHlwZXMubGVuZ3RoKSA/IGNoYXNzaXNUeXBlc1tjdHlwZSAtIDFdIDogJyc7XG4gICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwYXJ0bnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNrdSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdza3UnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQubWFudWZhY3R1cmVyID0gJy0nOyB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQudmVyc2lvbiA9ICctJzsgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnNlcmlhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuc2VyaWFsID0gJy0nOyB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuYXNzZXRUYWcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LmFzc2V0VGFnID0gJy0nOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jaGFzc2lzID0gY2hhc3NpcztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gdXNiLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTYuIHVzYlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBnZXRMaW51eFVzYlR5cGUodHlwZSwgbmFtZSkge1xuICBsZXQgcmVzdWx0ID0gdHlwZTtcbiAgY29uc3Qgc3RyID0gKG5hbWUgKyAnICcgKyB0eXBlKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoc3RyLmluZGV4T2YoJ2NhbWVyYScpID49IDApIHsgcmVzdWx0ID0gJ0NhbWVyYSc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2h1YicpID49IDApIHsgcmVzdWx0ID0gJ0h1Yic7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2tleWJyZCcpID49IDApIHsgcmVzdWx0ID0gJ0tleWJvYXJkJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZigna2V5Ym9hcmQnKSA+PSAwKSB7IHJlc3VsdCA9ICdLZXlib2FyZCc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ21vdXNlJykgPj0gMCkgeyByZXN1bHQgPSAnTW91c2UnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdzdG9yYScpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdtaWMnKSA+PSAwKSB7IHJlc3VsdCA9ICdNaWNyb3Bob25lJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignaGVhZHNldCcpID49IDApIHsgcmVzdWx0ID0gJ0F1ZGlvJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignYXVkaW8nKSA+PSAwKSB7IHJlc3VsdCA9ICdBdWRpbyc7IH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4VXNiKHVzYikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgbGluZXMgPSB1c2Iuc3BsaXQoJ1xcbicpO1xuICBpZiAobGluZXMgJiYgbGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLmluZGV4T2YoJ0RldmljZScpID49IDApIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gICAgcmVzdWx0LmJ1cyA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gICAgaWYgKHBhcnRzWzJdKSB7XG4gICAgICByZXN1bHQuZGV2aWNlSWQgPSBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuZGV2aWNlSWQgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQuYnVzID0gbnVsbDtcbiAgICByZXN1bHQuZGV2aWNlSWQgPSBudWxsO1xuICB9XG4gIGNvbnN0IGlkVmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lkVmVuZG9yJywgJyAnLCB0cnVlKS50cmltKCk7XG4gIGxldCB2ZW5kb3JQYXJ0cyA9IGlkVmVuZG9yLnNwbGl0KCcgJyk7XG4gIHZlbmRvclBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHZlbmRvciA9IHZlbmRvclBhcnRzLmpvaW4oJyAnKTtcblxuICBjb25zdCBpZFByb2R1Y3QgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaWRQcm9kdWN0JywgJyAnLCB0cnVlKS50cmltKCk7XG4gIGxldCBwcm9kdWN0UGFydHMgPSBpZFByb2R1Y3Quc3BsaXQoJyAnKTtcbiAgcHJvZHVjdFBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHByb2R1Y3QgPSBwcm9kdWN0UGFydHMuam9pbignICcpO1xuXG4gIGNvbnN0IGludGVyZmFjZUNsYXNzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JJbnRlcmZhY2VDbGFzcycsICcgJywgdHJ1ZSkudHJpbSgpO1xuICBsZXQgaW50ZXJmYWNlQ2xhc3NQYXJ0cyA9IGludGVyZmFjZUNsYXNzLnNwbGl0KCcgJyk7XG4gIGludGVyZmFjZUNsYXNzUGFydHMuc2hpZnQoKTtcbiAgY29uc3QgdXNiVHlwZSA9IGludGVyZmFjZUNsYXNzUGFydHMuam9pbignICcpO1xuXG4gIGNvbnN0IGlNYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaU1hbnVmYWN0dXJlcicsICcgJywgdHJ1ZSkudHJpbSgpO1xuICBsZXQgaU1hbnVmYWN0dXJlclBhcnRzID0gaU1hbnVmYWN0dXJlci5zcGxpdCgnICcpO1xuICBpTWFudWZhY3R1cmVyUGFydHMuc2hpZnQoKTtcbiAgY29uc3QgbWFudWZhY3R1cmVyID0gaU1hbnVmYWN0dXJlclBhcnRzLmpvaW4oJyAnKTtcblxuICByZXN1bHQuaWQgPSAoaWRWZW5kb3Iuc3RhcnRzV2l0aCgnMHgnKSA/IGlkVmVuZG9yLnNwbGl0KCcgJylbMF0uc3Vic3RyKDIsIDEwKSA6ICcnKSArICc6JyArIChpZFByb2R1Y3Quc3RhcnRzV2l0aCgnMHgnKSA/IGlkUHJvZHVjdC5zcGxpdCgnICcpWzBdLnN1YnN0cigyLCAxMCkgOiAnJyk7XG4gIHJlc3VsdC5uYW1lID0gcHJvZHVjdDtcbiAgcmVzdWx0LnR5cGUgPSBnZXRMaW51eFVzYlR5cGUodXNiVHlwZSwgcHJvZHVjdCk7XG4gIHJlc3VsdC5yZW1vdmFibGUgPSBudWxsO1xuICByZXN1bHQudmVuZG9yID0gdmVuZG9yO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gbWFudWZhY3R1cmVyO1xuICByZXN1bHQubWF4UG93ZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWF4UG93ZXInLCAnICcsIHRydWUpO1xuICByZXN1bHQuc2VyaWFsTnVtYmVyID0gbnVsbDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXREYXJ3aW5Vc2JUeXBlKG5hbWUpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAobmFtZS5pbmRleE9mKCdjYW1lcmEnKSA+PSAwKSB7IHJlc3VsdCA9ICdDYW1lcmEnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigndG91Y2ggYmFyJykgPj0gMCkgeyByZXN1bHQgPSAnVG91Y2ggQmFyJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ2NvbnRyb2xsZXInKSA+PSAwKSB7IHJlc3VsdCA9ICdDb250cm9sbGVyJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ2hlYWRzZXQnKSA+PSAwKSB7IHJlc3VsdCA9ICdBdWRpbyc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdrZXlib2FyZCcpID49IDApIHsgcmVzdWx0ID0gJ0tleWJvYXJkJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3RyYWNrcGFkJykgPj0gMCkgeyByZXN1bHQgPSAnVHJhY2twYWQnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignc2Vuc29yJykgPj0gMCkgeyByZXN1bHQgPSAnU2Vuc29yJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ2J0aHVzYicpID49IDApIHsgcmVzdWx0ID0gJ0JsdWV0b290aCc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdidGgnKSA+PSAwKSB7IHJlc3VsdCA9ICdCbHVldG9vdGgnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigncmZjb21tJykgPj0gMCkgeyByZXN1bHQgPSAnQmx1ZXRvb3RoJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3VzYmh1YicpID49IDApIHsgcmVzdWx0ID0gJ0h1Yic7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCcgaHViJykgPj0gMCkgeyByZXN1bHQgPSAnSHViJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ21vdXNlJykgPj0gMCkgeyByZXN1bHQgPSAnTW91c2UnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignbWljJykgPj0gMCkgeyByZXN1bHQgPSAnTWljcm9waG9uZSc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdyZW1vdmFibGUnKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlRGFyd2luVXNiKHVzYiwgaWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHJlc3VsdC5pZCA9IGlkO1xuXG4gIHVzYiA9IHVzYi5yZXBsYWNlKC8gXFx8L2csICcnKTtcbiAgdXNiID0gdXNiLnRyaW0oKTtcbiAgbGV0IGxpbmVzID0gdXNiLnNwbGl0KCdcXG4nKTtcbiAgbGluZXMuc2hpZnQoKTtcbiAgdHJ5IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgvPS9nLCAnOicpO1xuICAgICAgaWYgKGxpbmVzW2ldICE9PSAneycgJiYgbGluZXNbaV0gIT09ICd9JyAmJiBsaW5lc1tpICsgMV0gJiYgbGluZXNbaSArIDFdLnRyaW0oKSAhPT0gJ30nKSB7XG4gICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0gKyAnLCc7XG4gICAgICB9XG4gICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UoJzogWWVzLCcsICc6IFwiWWVzXCIsJyk7XG4gICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UoJzogTm8sJywgJzogXCJOb1wiLCcpO1xuICAgIH1cbiAgICBjb25zdCB1c2JPYmogPSBKU09OLnBhcnNlKGxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICBjb25zdCByZW1vdmFibGVEcml2ZSA9IHVzYk9ialsnQnVpbHQtSW4nXS50b0xvd2VyQ2FzZSgpICE9PSAneWVzJyAmJiB1c2JPYmpbJ25vbi1yZW1vdmFibGUnXS50b0xvd2VyQ2FzZSgpID09PSAnbm8nO1xuXG4gICAgcmVzdWx0LmJ1cyA9IG51bGw7XG4gICAgcmVzdWx0LmRldmljZUlkID0gbnVsbDtcbiAgICByZXN1bHQuaWQgPSB1c2JPYmpbJ1VTQiBBZGRyZXNzJ10gfHwgbnVsbDtcbiAgICByZXN1bHQubmFtZSA9IHVzYk9ialsna1VTQlByb2R1Y3RTdHJpbmcnXSB8fCB1c2JPYmpbJ1VTQiBQcm9kdWN0IE5hbWUnXSB8fCBudWxsO1xuICAgIHJlc3VsdC50eXBlID0gZ2V0RGFyd2luVXNiVHlwZSgodXNiT2JqWydrVVNCUHJvZHVjdFN0cmluZyddIHx8IHVzYk9ialsnVVNCIFByb2R1Y3QgTmFtZSddIHx8ICcnKS50b0xvd2VyQ2FzZSgpICsgKHJlbW92YWJsZURyaXZlID8gJyByZW1vdmFibGUnIDogJycpKTtcbiAgICByZXN1bHQucmVtb3ZhYmxlID0gdXNiT2JqWydub24tcmVtb3ZhYmxlJ10udG9Mb3dlckNhc2UoKSA9PT0gJ25vJztcbiAgICByZXN1bHQudmVuZG9yID0gdXNiT2JqWydrVVNCVmVuZG9yU3RyaW5nJ10gfHwgdXNiT2JqWydVU0IgVmVuZG9yIE5hbWUnXSB8fCBudWxsO1xuICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1c2JPYmpbJ2tVU0JWZW5kb3JTdHJpbmcnXSB8fCB1c2JPYmpbJ1VTQiBWZW5kb3IgTmFtZSddIHx8IG51bGw7XG4gICAgcmVzdWx0Lm1heFBvd2VyID0gbnVsbDtcbiAgICByZXN1bHQuc2VyaWFsTnVtYmVyID0gdXNiT2JqWydrVVNCU2VyaWFsTnVtYmVyU3RyaW5nJ10gfHwgbnVsbDtcblxuICAgIGlmIChyZXN1bHQubmFtZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c1VzYlR5cGVDcmVhdGlvbihjcmVhdGlvbmNsYXNzLCBuYW1lKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKG5hbWUuaW5kZXhPZignc3RvcmFnZScpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignc3BlaWNoZXInKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ3VzYmh1YicpID49IDApIHsgcmVzdWx0ID0gJ0h1Yic7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCdzdG9yYWdlJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCd1c2Jjb250cm9sbGVyJykgPj0gMCkgeyByZXN1bHQgPSAnQ29udHJvbGxlcic7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCdrZXlib2FyZCcpID49IDApIHsgcmVzdWx0ID0gJ0tleWJvYXJkJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ3BvaW50aW5nJykgPj0gMCkgeyByZXN1bHQgPSAnTW91c2UnOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZignZGlzaycpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luZG93c1VzYihsaW5lcywgaWQpIHtcbiAgY29uc3QgdXNiVHlwZSA9IGdldFdpbmRvd3NVc2JUeXBlQ3JlYXRpb24odXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NyZWF0aW9uQ2xhc3NOYW1lJywgJzonKS50b0xvd2VyQ2FzZSgpLCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6JykudG9Mb3dlckNhc2UoKSk7XG5cbiAgaWYgKHVzYlR5cGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQuYnVzID0gbnVsbDtcbiAgICByZXN1bHQuZGV2aWNlSWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZGV2aWNlaWQnLCAnOicpO1xuICAgIHJlc3VsdC5pZCA9IGlkO1xuICAgIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpO1xuICAgIHJlc3VsdC50eXBlID0gdXNiVHlwZTtcbiAgICByZXN1bHQucmVtb3ZhYmxlID0gbnVsbDtcbiAgICByZXN1bHQudmVuZG9yID0gbnVsbDtcbiAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgcmVzdWx0Lm1heFBvd2VyID0gbnVsbDtcbiAgICByZXN1bHQuc2VyaWFsTnVtYmVyID0gbnVsbDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNiKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGNvbnN0IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IGxzdXNiIC12IDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnO1xuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0ICogMTI4IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSAoJ1xcblxcbicgKyBzdGRvdXQudG9TdHJpbmcoKSkuc3BsaXQoJ1xcblxcbkJ1cyAnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdXNiID0gcGFyc2VMaW51eFVzYihwYXJ0c1tpXSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVzYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnaW9yZWcgLXAgSU9VU0IgLWMgQXBwbGVVU0JSb290SHViRGV2aWNlIC13MCAtbCc7XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgKiAxMjggfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IChzdGRvdXQudG9TdHJpbmcoKSkuc3BsaXQoJyArLW8gJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYiA9IHBhcnNlRGFyd2luVXNiKHBhcnRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKHVzYikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVzYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgQ0lNX0xvZ2ljYWxEZXZpY2UgfCB3aGVyZSB7ICRfLkRlc2NyaXB0aW9uIC1tYXRjaCBcIlVTQlwifSB8IHNlbGVjdCBOYW1lLENyZWF0aW9uQ2xhc3NOYW1lLERldmljZUlkLE1hbnVmYWN0dXJlciB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdXNiID0gcGFyc2VXaW5kb3dzVXNiKHBhcnRzW2ldLnNwbGl0KCdcXG4nKSwgaSk7XG4gICAgICAgICAgICAgIGlmICh1c2IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1c2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MgfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy51c2IgPSB1c2I7XG5cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gdXNlcnMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxMS4gVXNlcnMvU2Vzc2lvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gcGFyc2VVc2Vyc0xpbnV4KGxpbmVzLCBwaGFzZSkge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGxldCByZXN1bHRfd2hvID0gW107XG4gIGxldCByZXN1bHRfdyA9IHt9O1xuICBsZXQgd19maXJzdCA9IHRydWU7XG4gIGxldCB3X2hlYWRlciA9IFtdO1xuICBsZXQgd19wb3MgPSBbXTtcbiAgbGV0IHdob19saW5lID0ge307XG5cbiAgbGV0IGlzX3dob3BhcnQgPSB0cnVlO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKGxpbmUgPT09ICctLS0nKSB7XG4gICAgICBpc193aG9wYXJ0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG5cbiAgICAgIC8vIHdobyBwYXJ0XG4gICAgICBpZiAoaXNfd2hvcGFydCkge1xuICAgICAgICByZXN1bHRfd2hvLnB1c2goe1xuICAgICAgICAgIHVzZXI6IGxbMF0sXG4gICAgICAgICAgdHR5OiBsWzFdLFxuICAgICAgICAgIGRhdGU6IGxbMl0sXG4gICAgICAgICAgdGltZTogbFszXSxcbiAgICAgICAgICBpcDogKGwgJiYgbC5sZW5ndGggPiA0KSA/IGxbNF0ucmVwbGFjZSgvXFwoL2csICcnKS5yZXBsYWNlKC9cXCkvZywgJycpIDogJydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3IHBhcnRcbiAgICAgICAgaWYgKHdfZmlyc3QpIHsgICAgLy8gaGVhZGVyXG4gICAgICAgICAgd19oZWFkZXIgPSBsO1xuICAgICAgICAgIHdfaGVhZGVyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHdfcG9zLnB1c2gobGluZS5pbmRleE9mKGl0ZW0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3X2ZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3BsaXQgYnkgd19wb3NcbiAgICAgICAgICByZXN1bHRfdy51c2VyID0gbGluZS5zdWJzdHJpbmcod19wb3NbMF0sIHdfcG9zWzFdIC0gMSkudHJpbSgpO1xuICAgICAgICAgIHJlc3VsdF93LnR0eSA9IGxpbmUuc3Vic3RyaW5nKHdfcG9zWzFdLCB3X3Bvc1syXSAtIDEpLnRyaW0oKTtcbiAgICAgICAgICByZXN1bHRfdy5pcCA9IGxpbmUuc3Vic3RyaW5nKHdfcG9zWzJdLCB3X3Bvc1szXSAtIDEpLnJlcGxhY2UoL1xcKC9nLCAnJykucmVwbGFjZSgvXFwpL2csICcnKS50cmltKCk7XG4gICAgICAgICAgcmVzdWx0X3cuY29tbWFuZCA9IGxpbmUuc3Vic3RyaW5nKHdfcG9zWzddLCAxMDAwKS50cmltKCk7XG4gICAgICAgICAgLy8gZmluZCBjb3JyZXNwb25kaW5nICd3aG8nIGxpbmVcbiAgICAgICAgICB3aG9fbGluZSA9IHJlc3VsdF93aG8uZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAob2JqLnVzZXIuc3Vic3RyaW5nKDAsIDgpLnRyaW0oKSA9PT0gcmVzdWx0X3cudXNlciAmJiBvYmoudHR5ID09PSByZXN1bHRfdy50dHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh3aG9fbGluZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgdXNlcjogd2hvX2xpbmVbMF0udXNlcixcbiAgICAgICAgICAgICAgdHR5OiB3aG9fbGluZVswXS50dHksXG4gICAgICAgICAgICAgIGRhdGU6IHdob19saW5lWzBdLmRhdGUsXG4gICAgICAgICAgICAgIHRpbWU6IHdob19saW5lWzBdLnRpbWUsXG4gICAgICAgICAgICAgIGlwOiB3aG9fbGluZVswXS5pcCxcbiAgICAgICAgICAgICAgY29tbWFuZDogcmVzdWx0X3cuY29tbWFuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDAgJiYgcGhhc2UgPT09IDIpIHtcbiAgICByZXR1cm4gcmVzdWx0X3dobztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVXNlcnNEYXJ3aW4obGluZXMpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBsZXQgcmVzdWx0X3dobyA9IFtdO1xuICBsZXQgcmVzdWx0X3cgPSB7fTtcbiAgbGV0IHdob19saW5lID0ge307XG5cbiAgbGV0IGlzX3dob3BhcnQgPSB0cnVlO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKGxpbmUgPT09ICctLS0nKSB7XG4gICAgICBpc193aG9wYXJ0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG5cbiAgICAgIC8vIHdobyBwYXJ0XG4gICAgICBpZiAoaXNfd2hvcGFydCkge1xuICAgICAgICByZXN1bHRfd2hvLnB1c2goe1xuICAgICAgICAgIHVzZXI6IGxbMF0sXG4gICAgICAgICAgdHR5OiBsWzFdLFxuICAgICAgICAgIGRhdGU6ICgnJyArIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSkgKyAnLScgKyAoJzAnICsgKCdKQU5GRUJNQVJBUFJNQVlKVU5KVUxBVUdTRVBPQ1ROT1ZERUMnLmluZGV4T2YobFsyXS50b1VwcGVyQ2FzZSgpKSAvIDMgKyAxKSkuc2xpY2UoLTIpICsgJy0nICsgKCcwJyArIGxbM10pLnNsaWNlKC0yKSxcbiAgICAgICAgICB0aW1lOiBsWzRdLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHcgcGFydFxuICAgICAgICAvLyBzcGxpdCBieSB3X3Bvc1xuICAgICAgICByZXN1bHRfdy51c2VyID0gbFswXTtcbiAgICAgICAgcmVzdWx0X3cudHR5ID0gbFsxXTtcbiAgICAgICAgcmVzdWx0X3cuaXAgPSAobFsyXSAhPT0gJy0nKSA/IGxbMl0gOiAnJztcbiAgICAgICAgcmVzdWx0X3cuY29tbWFuZCA9IGwuc2xpY2UoNSwgMTAwMCkuam9pbignICcpO1xuICAgICAgICAvLyBmaW5kIGNvcnJlc3BvbmRpbmcgJ3dobycgbGluZVxuICAgICAgICB3aG9fbGluZSA9IHJlc3VsdF93aG8uZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gKG9iai51c2VyID09PSByZXN1bHRfdy51c2VyICYmIChvYmoudHR5LnN1YnN0cmluZygzLCAxMDAwKSA9PT0gcmVzdWx0X3cudHR5IHx8IG9iai50dHkgPT09IHJlc3VsdF93LnR0eSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHdob19saW5lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHVzZXI6IHdob19saW5lWzBdLnVzZXIsXG4gICAgICAgICAgICB0dHk6IHdob19saW5lWzBdLnR0eSxcbiAgICAgICAgICAgIGRhdGU6IHdob19saW5lWzBdLmRhdGUsXG4gICAgICAgICAgICB0aW1lOiB3aG9fbGluZVswXS50aW1lLFxuICAgICAgICAgICAgaXA6IHJlc3VsdF93LmlwLFxuICAgICAgICAgICAgY29tbWFuZDogcmVzdWx0X3cuY29tbWFuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlcnMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgLy8gbGludXhcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgZXhlYygnd2hvIC0taXBzOyBlY2hvIFwiLS0tXCI7IHcgfCB0YWlsIC1uICsyJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAvLyBsaW5lcyAvIHNwbGl0XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZVVzZXJzTGludXgobGluZXMsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZXhlYygnd2hvOyBlY2hvIFwiLS0tXCI7IHcgfCB0YWlsIC1uICsyJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBsaW5lcyAvIHNwbGl0XG4gICAgICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVXNlcnNMaW51eChsaW5lcywgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnd2hvOyBlY2hvIFwiLS0tXCI7IHcgLWloJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAvLyBsaW5lcyAvIHNwbGl0XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZVVzZXJzRGFyd2luKGxpbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBleGVjKCd3aG87IGVjaG8gXCItLS1cIjsgdyAtaCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgLy8gbGluZXMgLyBzcGxpdFxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VVc2Vyc0RhcndpbihsaW5lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnd2hvOyBlY2hvIFwiLS0tXCI7IHcgLWloJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAvLyBsaW5lcyAvIHNwbGl0XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZVVzZXJzRGFyd2luKGxpbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGNtZCA9ICdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfTG9nb25TZXNzaW9uIHwgc2VsZWN0IExvZ29uSWQsQHtuPVwiU3RhcnRUaW1lXCI7ZT17JF8uU3RhcnRUaW1lLlRvU3RyaW5nKFwieXl5eS1NTS1kZCBISDptbTpzc1wiKX19IHwgZmwnICsgJzsgZWNobyBcXCcjLSMtIy0jXFwnOyc7XG4gICAgICAgICAgY21kICs9ICdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfTG9nZ2VkT25Vc2VyIHwgc2VsZWN0IGFudGVjZWRlbnQsZGVwZW5kZW50IHwgZmwgJyArICc7IGVjaG8gXFwnIy0jLSMtI1xcJzsnO1xuICAgICAgICAgIGNtZCArPSAnJHByb2Nlc3MgPSAoR2V0LUNpbUluc3RhbmNlIFdpbjMyX1Byb2Nlc3MgLUZpbHRlciBcIm5hbWUgPSBcXCdleHBsb3Jlci5leGVcXCdcIik7IEludm9rZS1DaW1NZXRob2QgLUlucHV0T2JqZWN0ICRwcm9jZXNzWzBdIC1NZXRob2ROYW1lIEdldE93bmVyIHwgc2VsZWN0IHVzZXIsIGRvbWFpbiB8IGZsOyBnZXQtcHJvY2VzcyAtbmFtZSBleHBsb3JlciB8IHNlbGVjdC1vYmplY3Qgc2Vzc2lvbmlkIHwgZmw7IGVjaG8gXFwnIy0jLSMtI1xcJzsnO1xuICAgICAgICAgIGNtZCArPSAncXVlcnkgdXNlcic7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKGNtZCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJyMtIy0jLSMnKTtcbiAgICAgICAgICAgICAgbGV0IHNlc3Npb25zID0gcGFyc2VXaW5TZXNzaW9ucygoZGF0YVswXSB8fCAnJykuc3BsaXQoL1xcblxccypcXG4vKSk7XG4gICAgICAgICAgICAgIGxldCBsb2dnZWRvbnMgPSBwYXJzZVdpbkxvZ2dlZE9uKChkYXRhWzFdIHx8ICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pKTtcbiAgICAgICAgICAgICAgbGV0IHF1ZXJ5VXNlciA9IHBhcnNlV2luVXNlcnNRdWVyeSgoZGF0YVszXSB8fCAnJykuc3BsaXQoJ1xcclxcbicpKTtcbiAgICAgICAgICAgICAgbGV0IHVzZXJzID0gcGFyc2VXaW5Vc2VycygoZGF0YVsyXSB8fCAnJykuc3BsaXQoL1xcblxccypcXG4vKSwgcXVlcnlVc2VyKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gbG9nZ2Vkb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobG9nZ2Vkb25zLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlZG9uc1tpZF0uZGF0ZVRpbWUgPSB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlc3Npb25zLCBpZCkgPyBzZXNzaW9uc1tpZF0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXNlcnMuZm9yRWFjaCh1c2VyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0ZVRpbWUgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBsb2dnZWRvbnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZ2dlZG9ucywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dnZWRvbnNbaWRdLnVzZXIgPT09IHVzZXIudXNlciAmJiAoIWRhdGVUaW1lIHx8IGRhdGVUaW1lIDwgbG9nZ2Vkb25zW2lkXS5kYXRlVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRlVGltZSA9IGxvZ2dlZG9uc1tpZF0uZGF0ZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyLnVzZXIsXG4gICAgICAgICAgICAgICAgICB0dHk6IHVzZXIudHR5LFxuICAgICAgICAgICAgICAgICAgZGF0ZTogYCR7ZGF0ZVRpbWUuc3Vic3RyaW5nKDAsIDEwKX1gLFxuICAgICAgICAgICAgICAgICAgdGltZTogYCR7ZGF0ZVRpbWUuc3Vic3RyaW5nKDExLCAxOSl9YCxcbiAgICAgICAgICAgICAgICAgIGlwOiAnJyxcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luU2Vzc2lvbnMoc2Vzc2lvblBhcnRzKSB7XG4gIGNvbnN0IHNlc3Npb25zID0ge307XG4gIHNlc3Npb25QYXJ0cy5mb3JFYWNoKHNlc3Npb24gPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gc2Vzc2lvbi5zcGxpdCgnXFxyXFxuJyk7XG4gICAgY29uc3QgaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9nb25JZCcpO1xuICAgIGNvbnN0IHN0YXJ0dGltZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzdGFydHRpbWUnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHNlc3Npb25zW2lkXSA9IHN0YXJ0dGltZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2Vzc2lvbnM7XG59XG5cbmZ1bmN0aW9uIGZ1enp5TWF0Y2gobmFtZTEsIG5hbWUyKSB7XG4gIG5hbWUxID0gbmFtZTEudG9Mb3dlckNhc2UoKTtcbiAgbmFtZTIgPSBuYW1lMi50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZXEgPSAwO1xuICBsZXQgbGVuID0gbmFtZTEubGVuZ3RoO1xuICBpZiAobmFtZTIubGVuZ3RoID4gbGVuKSB7IGxlbiA9IG5hbWUyLmxlbmd0aDsgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjMSA9IG5hbWUxW2ldIHx8ICcnO1xuICAgIGNvbnN0IGMyID0gbmFtZTJbaV0gfHwgJyc7XG4gICAgaWYgKGMxID09PSBjMikgeyBlcSsrOyB9XG4gIH1cbiAgcmV0dXJuIChsZW4gPiAxMCA/IGVxIC8gbGVuID4gMC45IDogKGxlbiA+IDAgPyBlcSAvIGxlbiA+IDAuOCA6IGZhbHNlKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luVXNlcnModXNlclBhcnRzLCB1c2VyUXVlcnkpIHtcbiAgY29uc3QgdXNlcnMgPSBbXTtcbiAgdXNlclBhcnRzLmZvckVhY2godXNlciA9PiB7XG4gICAgY29uc3QgbGluZXMgPSB1c2VyLnNwbGl0KCdcXHJcXG4nKTtcblxuICAgIGNvbnN0IGRvbWFpbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkb21haW4nLCAnOicsIHRydWUpO1xuICAgIGNvbnN0IHVzZXJuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3VzZXInLCAnOicsIHRydWUpO1xuICAgIGNvbnN0IHNlc3Npb25pZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXNzaW9uaWQnLCAnOicsIHRydWUpO1xuXG4gICAgaWYgKHVzZXJuYW1lKSB7XG4gICAgICBjb25zdCBxdXNlciA9IHVzZXJRdWVyeS5maWx0ZXIoaXRlbSA9PiBmdXp6eU1hdGNoKGl0ZW0udXNlciwgdXNlcm5hbWUpKTtcbiAgICAgIHVzZXJzLnB1c2goe1xuICAgICAgICBkb21haW4sXG4gICAgICAgIHVzZXI6IHVzZXJuYW1lLFxuICAgICAgICB0dHk6IHF1c2VyICYmIHF1c2VyWzBdICYmIHF1c2VyWzBdLnR0eSA/IHF1c2VyWzBdLnR0eSA6IHNlc3Npb25pZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVzZXJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpbkxvZ2dlZE9uKGxvZ2dlZG9uUGFydHMpIHtcbiAgY29uc3QgbG9nZ2Vkb25zID0ge307XG4gIGxvZ2dlZG9uUGFydHMuZm9yRWFjaChsb2dnZWRvbiA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBsb2dnZWRvbi5zcGxpdCgnXFxyXFxuJyk7XG5cbiAgICBjb25zdCBhbnRlY2VuZGVudCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdhbnRlY2VkZW50JywgJzonLCB0cnVlKTtcbiAgICBsZXQgcGFydHMgPSBhbnRlY2VuZGVudC5zcGxpdCgnPScpO1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMV0uc3BsaXQoJywnKVswXS5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpIDogJyc7XG4gICAgY29uc3QgZG9tYWluID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdLnJlcGxhY2UoL1wiL2csICcnKS5yZXBsYWNlKC9cXCkvZywgJycpLnRyaW0oKSA6ICcnO1xuICAgIGNvbnN0IGRlcGVuZGVudCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkZXBlbmRlbnQnLCAnOicsIHRydWUpO1xuICAgIHBhcnRzID0gZGVwZW5kZW50LnNwbGl0KCc9Jyk7XG4gICAgY29uc3QgaWQgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0ucmVwbGFjZSgvXCIvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykudHJpbSgpIDogJyc7XG4gICAgaWYgKGlkKSB7XG4gICAgICBsb2dnZWRvbnNbaWRdID0ge1xuICAgICAgICBkb21haW4sXG4gICAgICAgIHVzZXI6IG5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxvZ2dlZG9ucztcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5Vc2Vyc1F1ZXJ5KGxpbmVzKSB7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaGVhZGVyID0gbGluZXNbMF07XG4gIGNvbnN0IGhlYWRlckRlbGltaXRlciA9IFtdO1xuICBpZiAoaGVhZGVyKSB7XG4gICAgY29uc3Qgc3RhcnQgPSAoaGVhZGVyWzBdID09PSAnICcpID8gMSA6IDA7XG4gICAgaGVhZGVyRGVsaW1pdGVyLnB1c2goc3RhcnQgLSAxKTtcbiAgICBsZXQgbmV4dFNwYWNlID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGVhZGVyW2ldID09PSAnICcgJiYgKChoZWFkZXJbaSAtIDFdID09PSAnICcpIHx8IChoZWFkZXJbaSAtIDFdID09PSAnLicpKSkge1xuICAgICAgICBuZXh0U3BhY2UgPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5leHRTcGFjZSkge1xuICAgICAgICAgIGhlYWRlckRlbGltaXRlci5wdXNoKG5leHRTcGFjZSk7XG4gICAgICAgICAgbmV4dFNwYWNlID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGluZXNbaV0udHJpbSgpKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBsaW5lc1tpXS5zdWJzdHJpbmcoaGVhZGVyRGVsaW1pdGVyWzBdICsgMSwgaGVhZGVyRGVsaW1pdGVyWzFdKS50cmltKCkgfHwgJyc7XG4gICAgICAgIGNvbnN0IHR0eSA9IGxpbmVzW2ldLnN1YnN0cmluZyhoZWFkZXJEZWxpbWl0ZXJbMV0gKyAxLCBoZWFkZXJEZWxpbWl0ZXJbMl0gLSAyKS50cmltKCkgfHwgJyc7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICAgIHR0eTogdHR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy51c2VycyA9IHVzZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyB1dGlscy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDAuIGhlbHBlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuXG5sZXQgX2NvcmVzID0gMDtcbmxldCB3bWljUGF0aCA9ICcnO1xubGV0IGNvZGVwYWdlID0gJyc7XG5sZXQgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBudWxsO1xuXG5jb25zdCBXSU5ESVIgPSBwcm9jZXNzLmVudi5XSU5ESVIgfHwgJ0M6XFxcXFdpbmRvd3MnO1xuXG4vLyBwb3dlclNoZWxsXG5sZXQgX3BzQ2hpbGQ7XG5sZXQgX3BzUmVzdWx0ID0gJyc7XG5sZXQgX3BzQ21kcyA9IFtdO1xubGV0IF9wc1BlcnNpc3RlbnQgPSBmYWxzZTtcbmNvbnN0IF9wc1RvVVRGOCA9ICckT3V0cHV0RW5jb2RpbmcgPSBbU3lzdGVtLkNvbnNvbGVdOjpPdXRwdXRFbmNvZGluZyA9IFtTeXN0ZW0uQ29uc29sZV06OklucHV0RW5jb2RpbmcgPSBbU3lzdGVtLlRleHQuRW5jb2RpbmddOjpVVEY4IDsgJztcbmNvbnN0IF9wc0NtZFN0YXJ0ID0gJy0tIyMjU1RBUlQjIyMtLSc7XG5jb25zdCBfcHNFcnJvciA9ICctLUVSUk9SLS0nO1xuY29uc3QgX3BzQ21kU2VwZXJhdG9yID0gJy0tIyMjRU5EQ01EIyMjLS0nO1xuY29uc3QgX3BzSWRTZXBlcmF0b3IgPSAnLS0jI0lEIyMtLSc7XG5cbmNvbnN0IGV4ZWNPcHRzV2luID0ge1xuICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAsXG4gIGVuY29kaW5nOiAnVVRGLTgnLFxuICBlbnY6IHV0aWwuX2V4dGVuZCh7fSwgcHJvY2Vzcy5lbnYsIHsgTEFORzogJ2VuX1VTLlVURi04JyB9KVxufTtcblxuZnVuY3Rpb24gdG9JbnQodmFsdWUpIHtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmNvbnN0IHN0cmluZ1JlcGxhY2UgPSBuZXcgU3RyaW5nKCkucmVwbGFjZTtcbmNvbnN0IHN0cmluZ1RvTG93ZXIgPSBuZXcgU3RyaW5nKCkudG9Mb3dlckNhc2U7XG5jb25zdCBzdHJpbmdUb1N0cmluZyA9IG5ldyBTdHJpbmcoKS50b1N0cmluZztcbmNvbnN0IHN0cmluZ1N1YnN0ciA9IG5ldyBTdHJpbmcoKS5zdWJzdHI7XG5jb25zdCBzdHJpbmdUcmltID0gbmV3IFN0cmluZygpLnRyaW07XG5jb25zdCBzdHJpbmdTdGFydFdpdGggPSBuZXcgU3RyaW5nKCkuc3RhcnRzV2l0aDtcbmNvbnN0IG1hdGhNaW4gPSBNYXRoLm1pbjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgbGV0IGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gdW5pcXVlKG9iaikge1xuICBsZXQgdW5pcXVlcyA9IFtdO1xuICBsZXQgc3RyaW5naWZ5ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmpbaV0pO1xuICAgIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShrZXlzW2pdKTtcbiAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmpbaV1ba2V5c1tqXV0pO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoc3RyaW5naWZ5LCBzdHIpKSB7XG4gICAgICB1bmlxdWVzLnB1c2gob2JqW2ldKTtcbiAgICAgIHN0cmluZ2lmeVtzdHJdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZXM7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeUtleShhcnJheSwga2V5cykge1xuICByZXR1cm4gYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGxldCB4ID0gJyc7XG4gICAgbGV0IHkgPSAnJztcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgeCA9IHggKyBhW2tleV07IHkgPSB5ICsgYltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29yZXMoKSB7XG4gIGlmIChfY29yZXMgPT09IDApIHtcbiAgICBfY29yZXMgPSBvcy5jcHVzKCkubGVuZ3RoO1xuICB9XG4gIHJldHVybiBfY29yZXM7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKGxpbmVzLCBwcm9wZXJ0eSwgc2VwYXJhdG9yLCB0cmltbWVkLCBsaW5lTWF0Y2gpIHtcbiAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICc6JztcbiAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICB0cmltbWVkID0gdHJpbW1lZCB8fCBmYWxzZTtcbiAgbGluZU1hdGNoID0gbGluZU1hdGNoIHx8IGZhbHNlO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICBsZXQgbGluZUxvd2VyID0gbGluZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcdC9nLCAnJyk7XG4gICAgaWYgKHRyaW1tZWQpIHtcbiAgICAgIGxpbmVMb3dlciA9IGxpbmVMb3dlci50cmltKCk7XG4gICAgfVxuICAgIGlmIChsaW5lTG93ZXIuc3RhcnRzV2l0aChwcm9wZXJ0eSkgJiYgKGxpbmVNYXRjaCA/IChsaW5lTG93ZXIubWF0Y2gocHJvcGVydHkgKyBzZXBhcmF0b3IpKSB8fCAobGluZUxvd2VyLm1hdGNoKHByb3BlcnR5ICsgJyAnICsgc2VwYXJhdG9yKSkgOiB0cnVlKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB0cmltbWVkID8gbGluZS50cmltKCkuc3BsaXQoc2VwYXJhdG9yKSA6IGxpbmUuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICByZXN1bHQgPSBwYXJ0cy5qb2luKHNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUVzY2FwZVNlcXVlbmNlKHN0ciwgYmFzZSkge1xuICBiYXNlID0gYmFzZSB8fCAxNjtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxceChbMC05QS1GYS1mXXsyfSkvZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGFyZ3VtZW50c1sxXSwgYmFzZSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0U3BsaXQoc3RyKSB7XG4gIGxldCBzZXBlcmF0b3IgPSAnJztcbiAgbGV0IHBhcnQgPSAwO1xuICBzdHIuc3BsaXQoJycpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnQgPj0gJzAnICYmIGVsZW1lbnQgPD0gJzknKSB7XG4gICAgICBpZiAocGFydCA9PT0gMSkgeyBwYXJ0Kys7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcnQgPT09IDApIHsgcGFydCsrOyB9XG4gICAgICBpZiAocGFydCA9PT0gMSkge1xuICAgICAgICBzZXBlcmF0b3IgKz0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VwZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWUodCwgcG1EZXNpZ25hdG9yKSB7XG4gIHBtRGVzaWduYXRvciA9IHBtRGVzaWduYXRvciB8fCAnJztcbiAgdCA9IHQudG9VcHBlckNhc2UoKTtcbiAgbGV0IGhvdXIgPSAwO1xuICBsZXQgbWluID0gMDtcbiAgbGV0IHNwbGl0dGVyID0gZGV0ZWN0U3BsaXQodCk7XG4gIGxldCBwYXJ0cyA9IHQuc3BsaXQoc3BsaXR0ZXIpO1xuICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICBpZiAocGFydHNbMl0pIHtcbiAgICAgIHBhcnRzWzFdICs9IHBhcnRzWzJdO1xuICAgIH1cbiAgICBsZXQgaXNQTSA9IChwYXJ0c1sxXSAmJiAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwbScpID4gLTEpIHx8IChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3AubS4nKSA+IC0xKSB8fCAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwLiBtLicpID4gLTEpIHx8IChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ24nKSA+IC0xKSB8fCAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaCcpID4gLTEpIHx8IChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ8O2cycpID4gLTEpIHx8IChwbURlc2lnbmF0b3IgJiYgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHBtRGVzaWduYXRvcikgPiAtMSkpO1xuICAgIGhvdXIgPSBwYXJzZUludChwYXJ0c1swXSwgMTApO1xuICAgIG1pbiA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgaG91ciA9IGlzUE0gJiYgaG91ciA8IDEyID8gaG91ciArIDEyIDogaG91cjtcbiAgICByZXR1cm4gKCcwJyArIGhvdXIpLnN1YnN0cigtMikgKyAnOicgKyAoJzAnICsgbWluKS5zdWJzdHIoLTIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWUoZHQsIGN1bHR1cmUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRhdGU6ICcnLFxuICAgIHRpbWU6ICcnXG4gIH07XG4gIGN1bHR1cmUgPSBjdWx0dXJlIHx8IHt9O1xuICBsZXQgZGF0ZUZvcm1hdCA9IChjdWx0dXJlLmRhdGVGb3JtYXQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBwbURlc2lnbmF0b3IgPSAoY3VsdHVyZS5wbURlc2lnbmF0b3IgfHwgJycpO1xuXG4gIGNvbnN0IHBhcnRzID0gZHQuc3BsaXQoJyAnKTtcbiAgaWYgKHBhcnRzWzBdKSB7XG4gICAgaWYgKHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAvLyBEYXRlZm9ybWF0OiBtbS9kZC95eXl5IG9yIGRkL21tL3l5eXkgb3IgZGQvbW0veXkgb3IgeXl5eS9tbS9kZFxuICAgICAgY29uc3QgZHRwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG4gICAgICBpZiAoZHRwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgaWYgKGR0cGFydHNbMF0ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gRGF0ZWZvcm1hdDogeXl5eS9tbS9kZFxuICAgICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1swXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMl0pLnN1YnN0cigtMik7XG4gICAgICAgIH0gZWxzZSBpZiAoZHRwYXJ0c1syXS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBpZiAoKGRhdGVGb3JtYXQuaW5kZXhPZignL2QvJykgPiAtMSB8fCBkYXRlRm9ybWF0LmluZGV4T2YoJy9kZC8nKSA+IC0xKSkge1xuICAgICAgICAgICAgLy8gRGF0ZWZvcm1hdDogbW0vZGQveXlcbiAgICAgICAgICAgIHJlc3VsdC5kYXRlID0gJzIwJyArIGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBkZC9tbS95eVxuICAgICAgICAgICAgcmVzdWx0LmRhdGUgPSAnMjAnICsgZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IG1tL2RkL3l5eXkgb3IgZGQvbW0veXl5eVxuICAgICAgICAgIGNvbnN0IGlzRU4gPSAoKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncG0nKSA+IC0xKSB8fCAoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwLm0uJykgPiAtMSkgfHwgKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncC4gbS4nKSA+IC0xKSB8fCAoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhbScpID4gLTEpIHx8IChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2EubS4nKSA+IC0xKSB8fCAoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhLiBtLicpID4gLTEpKTtcbiAgICAgICAgICBpZiAoKGlzRU4gfHwgZGF0ZUZvcm1hdC5pbmRleE9mKCcvZC8nKSA+IC0xIHx8IGRhdGVGb3JtYXQuaW5kZXhPZignL2RkLycpID4gLTEpICYmIGRhdGVGb3JtYXQuaW5kZXhPZignZGQvJykgIT09IDApIHtcbiAgICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IG1tL2RkL3l5eXlcbiAgICAgICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IGRkL21tL3l5eXlcbiAgICAgICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1swXS5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgY29uc3QgZHRwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7XG4gICAgICBpZiAoZHRwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgaWYgKGRhdGVGb3JtYXQuaW5kZXhPZignLmQuJykgPiAtMSB8fCBkYXRlRm9ybWF0LmluZGV4T2YoJy5kZC4nKSA+IC0xKSB7XG4gICAgICAgICAgLy8gRGF0ZWZvcm1hdDogbW0uZGQueXl5eVxuICAgICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGF0ZWZvcm1hdDogZGQubW0ueXl5eVxuICAgICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRzWzBdLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICAvLyBEYXRlZm9ybWF0OiB5eXl5LW1tLWRkXG4gICAgICBjb25zdCBkdHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy0nKTtcbiAgICAgIGlmIChkdHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMF0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzJdKS5zdWJzdHIoLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGFydHNbMV0pIHtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICAgIGxldCB0aW1lID0gcGFydHMuam9pbignICcpO1xuICAgIHJlc3VsdC50aW1lID0gcGFyc2VUaW1lKHRpbWUsIHBtRGVzaWduYXRvcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkKGhlYWQsIHJpZ2h0cykge1xuICBsZXQgc3BhY2UgPSAocmlnaHRzID4gMCk7XG4gIGxldCBjb3VudCA9IDE7XG4gIGxldCBmcm9tID0gMDtcbiAgbGV0IHRvID0gMDtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY291bnQgPD0gcmlnaHRzKSB7XG4gICAgICBpZiAoL1xccy8udGVzdChoZWFkW2ldKSAmJiAhc3BhY2UpIHtcbiAgICAgICAgdG8gPSBpIC0gMTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgdG86IHRvICsgMSxcbiAgICAgICAgICBjYXA6IGhlYWQuc3Vic3RyaW5nKGZyb20sIHRvICsgMSlcbiAgICAgICAgfSk7XG4gICAgICAgIGZyb20gPSB0byArIDI7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBzcGFjZSA9IGhlYWRbaV0gPT09ICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEvXFxzLy50ZXN0KGhlYWRbaV0pICYmIHNwYWNlKSB7XG4gICAgICAgIHRvID0gaSAtIDE7XG4gICAgICAgIGlmIChmcm9tIDwgdG8pIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgY2FwOiBoZWFkLnN1YnN0cmluZyhmcm9tLCB0bylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tID0gdG8gKyAxO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgc3BhY2UgPSBoZWFkW2ldID09PSAnICc7XG4gICAgfVxuICB9XG4gIHRvID0gNTAwMDtcbiAgcmVzdWx0LnB1c2goe1xuICAgIGZyb206IGZyb20sXG4gICAgdG86IHRvLFxuICAgIGNhcDogaGVhZC5zdWJzdHJpbmcoZnJvbSwgdG8pXG4gIH0pO1xuICBsZXQgbGVuID0gcmVzdWx0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChyZXN1bHRbaV0uY2FwLnJlcGxhY2UoL1xccy9nLCAnJykubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgcmVzdWx0W2ldLnRvID0gcmVzdWx0W2kgKyAxXS50bztcbiAgICAgICAgcmVzdWx0W2ldLmNhcCA9IHJlc3VsdFtpXS5jYXAgKyByZXN1bHRbaSArIDFdLmNhcDtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgIGxlbiA9IGxlbiAtIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRPYmplY3RCeUtleShhcnJheSwga2V5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRXbWljKCkge1xuICBpZiAob3MudHlwZSgpID09PSAnV2luZG93c19OVCcgJiYgIXdtaWNQYXRoKSB7XG4gICAgd21pY1BhdGggPSBXSU5ESVIgKyAnXFxcXHN5c3RlbTMyXFxcXHdiZW1cXFxcd21pYy5leGUnO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyh3bWljUGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdtaWNQYXRoQXJyYXkgPSBleGVjU3luYygnV0hFUkUgV01JQycsIGV4ZWNPcHRzV2luKS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgaWYgKHdtaWNQYXRoQXJyYXkgJiYgd21pY1BhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB3bWljUGF0aCA9IHdtaWNQYXRoQXJyYXlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd21pY1BhdGggPSAnd21pYyc7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd21pY1BhdGggPSAnd21pYyc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB3bWljUGF0aDtcbn1cblxuZnVuY3Rpb24gd21pYyhjb21tYW5kKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG93ZXJTaGVsbChnZXRXbWljKCkgKyAnICcgKyBjb21tYW5kKS50aGVuKHN0ZG91dCA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShzdGRvdXQsICcnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc29sdmUoJycsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VmJveG1hbmFnZSgpIHtcbiAgcmV0dXJuIF93aW5kb3dzID8gYFwiJHtwcm9jZXNzLmVudi5WQk9YX0lOU1RBTExfUEFUSCB8fCBwcm9jZXNzLmVudi5WQk9YX01TSV9JTlNUQUxMX1BBVEh9XFxcXFZCb3hNYW5hZ2UuZXhlXCJgIDogJ3Zib3htYW5hZ2UnO1xufVxuXG5mdW5jdGlvbiBwb3dlclNoZWxsUHJvY2VlZFJlc3VsdHMoZGF0YSkge1xuICBsZXQgaWQgPSAnJztcbiAgbGV0IHBhcnRzO1xuICBsZXQgcmVzID0gJyc7XG4gIC8vIHN0YXJ0SURcbiAgaWYgKGRhdGEuaW5kZXhPZihfcHNDbWRTdGFydCkgPj0gMCkge1xuICAgIHBhcnRzID0gZGF0YS5zcGxpdChfcHNDbWRTdGFydCk7XG4gICAgY29uc3QgcGFydHMyID0gcGFydHNbMV0uc3BsaXQoX3BzSWRTZXBlcmF0b3IpO1xuICAgIGlkID0gcGFydHMyWzBdO1xuICAgIGlmIChwYXJ0czIubGVuZ3RoID4gMSkge1xuICAgICAgZGF0YSA9IHBhcnRzMi5zbGljZSgxKS5qb2luKF9wc0lkU2VwZXJhdG9yKTtcbiAgICB9XG4gIH1cbiAgLy8gcmVzdWx0O1xuICBpZiAoZGF0YS5pbmRleE9mKF9wc0NtZFNlcGVyYXRvcikgPj0gMCkge1xuICAgIHBhcnRzID0gZGF0YS5zcGxpdChfcHNDbWRTZXBlcmF0b3IpO1xuICAgIHJlcyA9IHBhcnRzWzBdO1xuICB9XG4gIGxldCByZW1vdmUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBfcHNDbWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKF9wc0NtZHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICByZW1vdmUgPSBpO1xuICAgICAgX3BzQ21kc1tpXS5jYWxsYmFjayhyZXMpO1xuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlID49IDApIHtcbiAgICBfcHNDbWRzLnNwbGljZShyZW1vdmUsIDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvd2VyU2hlbGxTdGFydCgpIHtcbiAgaWYgKCFfcHNDaGlsZCkge1xuICAgIF9wc0NoaWxkID0gc3Bhd24oJ3Bvd2Vyc2hlbGwuZXhlJywgWyctTm9Mb2dvJywgJy1JbnB1dEZvcm1hdCcsICdUZXh0JywgJy1Ob0V4aXQnLCAnLUNvbW1hbmQnLCAnLSddLCB7XG4gICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCxcbiAgICAgIGVuY29kaW5nOiAnVVRGLTgnLFxuICAgICAgZW52OiB1dGlsLl9leHRlbmQoe30sIHByb2Nlc3MuZW52LCB7IExBTkc6ICdlbl9VUy5VVEYtOCcgfSlcbiAgICB9KTtcbiAgICBpZiAoX3BzQ2hpbGQgJiYgX3BzQ2hpbGQucGlkKSB7XG4gICAgICBfcHNQZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgICAgIF9wc0NoaWxkLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9wc1Jlc3VsdCA9IF9wc1Jlc3VsdCArIGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgaWYgKGRhdGEuaW5kZXhPZihfcHNDbWRTZXBlcmF0b3IpID49IDApIHtcbiAgICAgICAgICBwb3dlclNoZWxsUHJvY2VlZFJlc3VsdHMoX3BzUmVzdWx0KTtcbiAgICAgICAgICBfcHNSZXN1bHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfcHNDaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvd2VyU2hlbGxQcm9jZWVkUmVzdWx0cyhfcHNSZXN1bHQgKyBfcHNFcnJvcik7XG4gICAgICB9KTtcbiAgICAgIF9wc0NoaWxkLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG93ZXJTaGVsbFByb2NlZWRSZXN1bHRzKF9wc1Jlc3VsdCArIF9wc0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgX3BzQ2hpbGQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfcHNDaGlsZC5raWxsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG93ZXJTaGVsbFJlbGVhc2UoKSB7XG4gIHRyeSB7XG4gICAgaWYgKF9wc0NoaWxkKSB7XG4gICAgICBfcHNDaGlsZC5zdGRpbi53cml0ZSgnZXhpdCcgKyBvcy5FT0wpO1xuICAgICAgX3BzQ2hpbGQuc3RkaW4uZW5kKCk7XG4gICAgICBfcHNQZXJzaXN0ZW50ID0gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKF9wc0NoaWxkKSB7IF9wc0NoaWxkLmtpbGwoKTsgfVxuICB9XG4gIF9wc0NoaWxkID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG93ZXJTaGVsbChjbWQpIHtcblxuICBpZiAoX3BzUGVyc2lzdGVudCkge1xuICAgIGNvbnN0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhkYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBfcHNDbWRzLnB1c2goe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNtZCxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICBzdGFydDogbmV3IERhdGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoX3BzQ2hpbGQgJiYgX3BzQ2hpbGQucGlkKSB7XG4gICAgICAgICAgICBfcHNDaGlsZC5zdGRpbi53cml0ZShfcHNUb1VURjggKyAnZWNobyAnICsgX3BzQ21kU3RhcnQgKyBpZCArIF9wc0lkU2VwZXJhdG9yICsgJzsgJyArIG9zLkVPTCArIGNtZCArIG9zLkVPTCArICdlY2hvICcgKyBfcHNDbWRTZXBlcmF0b3IgKyBvcy5FT0wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc29sdmUoJycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bigncG93ZXJzaGVsbC5leGUnLCBbJy1Ob0xvZ28nLCAnLUlucHV0Rm9ybWF0JywgJ1RleHQnLCAnLU5vRXhpdCcsICctRXhlY3V0aW9uUG9saWN5JywgJ1VucmVzdHJpY3RlZCcsICctQ29tbWFuZCcsICctJ10sIHtcbiAgICAgICAgICAgIHN0ZGlvOiAncGlwZScsXG4gICAgICAgICAgICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgICAgICAgICAgIG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICdVVEYtOCcsXG4gICAgICAgICAgICBlbnY6IHV0aWwuX2V4dGVuZCh7fSwgcHJvY2Vzcy5lbnYsIHsgTEFORzogJ2VuX1VTLlVURi04JyB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkICYmICFjaGlsZC5waWQpIHtcbiAgICAgICAgICAgIGNoaWxkLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5waWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjaGlsZC5raWxsKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjaGlsZC5raWxsKCk7XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGlsZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGRpbi53cml0ZShfcHNUb1VURjggKyBjbWQgKyBvcy5FT0wpO1xuICAgICAgICAgICAgICBjaGlsZC5zdGRpbi53cml0ZSgnZXhpdCcgKyBvcy5FT0wpO1xuICAgICAgICAgICAgICBjaGlsZC5zdGRpbi5lbmQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4ZWNTYWZlKGNtZCwgYXJncywgb3B0aW9ucykge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzcGF3bihjbWQsIGFyZ3MsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChjaGlsZCAmJiAhY2hpbGQucGlkKSB7XG4gICAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5waWQpIHtcbiAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGlsZC5raWxsKCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDb2RlcGFnZSgpIHtcbiAgaWYgKF93aW5kb3dzKSB7XG4gICAgaWYgKCFjb2RlcGFnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2NoY3AnLCBleGVjT3B0c1dpbik7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvZGVwYWdlID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnJlcGxhY2UoJy4nLCAnJykudHJpbSgpIDogJyc7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29kZXBhZ2UgPSAnNDM3JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVwYWdlO1xuICB9XG4gIGlmIChfbGludXggfHwgX2RhcndpbiB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgaWYgKCFjb2RlcGFnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2VjaG8gJExBTkcnKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3BsaXQoJy4nKTtcbiAgICAgICAgY29kZXBhZ2UgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0udHJpbSgpIDogJyc7XG4gICAgICAgIGlmICghY29kZXBhZ2UpIHtcbiAgICAgICAgICBjb2RlcGFnZSA9ICdVVEYtOCc7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb2RlcGFnZSA9ICdVVEYtOCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlcGFnZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbWFydE1vblRvb2xzSW5zdGFsbGVkKCkge1xuICBpZiAoX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQ7XG4gIH1cbiAgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBmYWxzZTtcbiAgaWYgKF93aW5kb3dzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhdGhBcnJheSA9IGV4ZWNTeW5jKCdXSEVSRSBzbWFydGN0bCAyPm51bCcsIGV4ZWNPcHRzV2luKS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgIGlmIChwYXRoQXJyYXkgJiYgcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgICBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IHBhdGhBcnJheVswXS5pbmRleE9mKCc6XFxcXCcpID49IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChfbGludXggfHwgX2RhcndpbiB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgY29uc3QgcGF0aEFycmF5ID0gZXhlY1N5bmMoJ3doaWNoIHNtYXJ0Y3RsIDI+L2Rldi9udWxsJywgZXhlY09wdHNXaW4pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gcGF0aEFycmF5Lmxlbmd0aCA+IDA7XG4gIH1cbiAgcmV0dXJuIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkO1xufVxuXG5mdW5jdGlvbiBpc1Jhc3BiZXJyeSgpIHtcbiAgY29uc3QgUElfTU9ERUxfTk8gPSBbXG4gICAgJ0JDTTI3MDgnLFxuICAgICdCQ00yNzA5JyxcbiAgICAnQkNNMjcxMCcsXG4gICAgJ0JDTTI3MTEnLFxuICAgICdCQ00yODM1JyxcbiAgICAnQkNNMjgzNicsXG4gICAgJ0JDTTI4MzcnLFxuICAgICdCQ00yODM3QjAnXG4gIF07XG4gIGxldCBjcHVpbmZvID0gW107XG4gIHRyeSB7XG4gICAgY3B1aW5mbyA9IGZzLnJlYWRGaWxlU3luYygnL3Byb2MvY3B1aW5mbycsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXJkd2FyZSA9IGdldFZhbHVlKGNwdWluZm8sICdoYXJkd2FyZScpO1xuICByZXR1cm4gKGhhcmR3YXJlICYmIFBJX01PREVMX05PLmluZGV4T2YoaGFyZHdhcmUpID4gLTEpO1xufVxuXG5mdW5jdGlvbiBpc1Jhc3BiaWFuKCkge1xuICBsZXQgb3NyZWxlYXNlID0gW107XG4gIHRyeSB7XG4gICAgb3NyZWxlYXNlID0gZnMucmVhZEZpbGVTeW5jKCcvZXRjL29zLXJlbGVhc2UnLCB7IGVuY29kaW5nOiAndXRmOCcgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaWQgPSBnZXRWYWx1ZShvc3JlbGVhc2UsICdpZCcsICc9Jyk7XG4gIHJldHVybiAoaWQgJiYgaWQuaW5kZXhPZigncmFzcGJpYW4nKSA+IC0xKTtcbn1cblxuZnVuY3Rpb24gZXhlY1dpbihjbWQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IGV4ZWNPcHRzV2luO1xuICB9XG4gIGxldCBuZXdDbWQgPSAnY2hjcCA2NTAwMSA+IG51bCAmJiBjbWQgL0MgJyArIGNtZCArICcgJiYgY2hjcCAnICsgY29kZXBhZ2UgKyAnID4gbnVsJztcbiAgZXhlYyhuZXdDbWQsIG9wdHMsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgY2FsbGJhY2soZXJyb3IsIHN0ZG91dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkYXJ3aW5YY29kZUV4aXN0cygpIHtcbiAgY29uc3QgY21kTGluZVRvb2xzRXhpc3RzID0gZnMuZXhpc3RzU3luYygnL0xpYnJhcnkvRGV2ZWxvcGVyL0NvbW1hbmRMaW5lVG9vbHMvdXNyL2Jpbi8nKTtcbiAgY29uc3QgeGNvZGVBcHBFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvQXBwbGljYXRpb25zL1hjb2RlLmFwcC9Db250ZW50cy9EZXZlbG9wZXIvVG9vbHMnKTtcbiAgY29uc3QgeGNvZGVFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvTGlicmFyeS9EZXZlbG9wZXIvWGNvZGUvJyk7XG4gIHJldHVybiAoY21kTGluZVRvb2xzRXhpc3RzIHx8IHhjb2RlRXhpc3RzIHx8IHhjb2RlQXBwRXhpc3RzKTtcbn1cblxuZnVuY3Rpb24gbmFub1NlY29uZHMoKSB7XG4gIGNvbnN0IHRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGltZSkgfHwgdGltZS5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gK3RpbWVbMF0gKiAxZTkgKyArdGltZVsxXTtcbn1cblxuZnVuY3Rpb24gY291bnRVbmlxdWVMaW5lcyhsaW5lcywgc3RhcnRpbmdXaXRoKSB7XG4gIHN0YXJ0aW5nV2l0aCA9IHN0YXJ0aW5nV2l0aCB8fCAnJztcbiAgY29uc3QgdW5pcXVlTGluZXMgPSBbXTtcbiAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAobGluZS5zdGFydHNXaXRoKHN0YXJ0aW5nV2l0aCkpIHtcbiAgICAgIGlmICh1bmlxdWVMaW5lcy5pbmRleE9mKGxpbmUpID09PSAtMSkge1xuICAgICAgICB1bmlxdWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1bmlxdWVMaW5lcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGNvdW50TGluZXMobGluZXMsIHN0YXJ0aW5nV2l0aCkge1xuICBzdGFydGluZ1dpdGggPSBzdGFydGluZ1dpdGggfHwgJyc7XG4gIGNvbnN0IHVuaXF1ZUxpbmVzID0gW107XG4gIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChzdGFydGluZ1dpdGgpKSB7XG4gICAgICB1bmlxdWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1bmlxdWVMaW5lcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplU2hlbGxTdHJpbmcoc3RyLCBzdHJpY3QpIHtcbiAgaWYgKHR5cGVvZiBzdHJpY3QgPT09ICd1bmRlZmluZWQnKSB7IHN0cmljdCA9IGZhbHNlOyB9XG4gIGNvbnN0IHMgPSBzdHIgfHwgJyc7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgIGlmICghKHNbaV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgc1tpXSA9PT0gJz4nIHx8XG4gICAgICBzW2ldID09PSAnPCcgfHxcbiAgICAgIHNbaV0gPT09ICcqJyB8fFxuICAgICAgc1tpXSA9PT0gJz8nIHx8XG4gICAgICBzW2ldID09PSAnWycgfHxcbiAgICAgIHNbaV0gPT09ICddJyB8fFxuICAgICAgc1tpXSA9PT0gJ3wnIHx8XG4gICAgICBzW2ldID09PSAny5onIHx8XG4gICAgICBzW2ldID09PSAnJCcgfHxcbiAgICAgIHNbaV0gPT09ICc7JyB8fFxuICAgICAgc1tpXSA9PT0gJyYnIHx8XG4gICAgICBzW2ldID09PSAnKCcgfHxcbiAgICAgIHNbaV0gPT09ICcpJyB8fFxuICAgICAgc1tpXSA9PT0gJ10nIHx8XG4gICAgICBzW2ldID09PSAnIycgfHxcbiAgICAgIHNbaV0gPT09ICdcXFxcJyB8fFxuICAgICAgc1tpXSA9PT0gJ1xcdCcgfHxcbiAgICAgIHNbaV0gPT09ICdcXG4nIHx8XG4gICAgICBzW2ldID09PSAnXFwnJyB8fFxuICAgICAgc1tpXSA9PT0gJ2AnIHx8XG4gICAgICBzW2ldID09PSAnXCInIHx8XG4gICAgICBzW2ldLmxlbmd0aCA+IDEgfHxcbiAgICAgIChzdHJpY3QgJiYgc1tpXSA9PT0gJ0AnKSB8fFxuICAgICAgKHN0cmljdCAmJiBzW2ldID09PSAnICcpIHx8XG4gICAgICAoc3RyaWN0ICYmIHNbaV0gPT0gJ3snKSB8fFxuICAgICAgKHN0cmljdCAmJiBzW2ldID09ICcpJykpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyBzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1Byb3RvdHlwZVBvbGx1dGVkKCkge1xuICBjb25zdCBzID0gJzEyMzQ1Njc4OTBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJztcbiAgbGV0IG5vdFBvbGx1dGVkID0gdHJ1ZTtcbiAgbGV0IHN0ID0gJyc7XG5cbiAgc3QuX19wcm90b19fLnJlcGxhY2UgPSBzdHJpbmdSZXBsYWNlO1xuICBzdC5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSBzdHJpbmdUb0xvd2VyO1xuICBzdC5fX3Byb3RvX18udG9TdHJpbmcgPSBzdHJpbmdUb1N0cmluZztcbiAgc3QuX19wcm90b19fLnN1YnN0ciA9IHN0cmluZ1N1YnN0cjtcblxuICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkIHx8IChzLmxlbmd0aCAhPT0gNjIpO1xuICBjb25zdCBtcyA9IERhdGUubm93KCk7XG4gIGlmICh0eXBlb2YgbXMgPT09ICdudW1iZXInICYmIG1zID4gMTYwMDAwMDAwMDAwMCkge1xuICAgIGNvbnN0IGwgPSBtcyAlIDEwMCArIDE1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDYxLjk5OTk5OTk5ICsgMTtcbiAgICAgIGNvbnN0IHJzID0gcGFyc2VJbnQoTWF0aC5mbG9vcihyKS50b1N0cmluZygpLCAxMCk7XG4gICAgICBjb25zdCByczIgPSBwYXJzZUludChyLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXSwgMTApO1xuICAgICAgY29uc3QgcSA9IE1hdGgucmFuZG9tKCkgKiA2MS45OTk5OTk5OSArIDE7XG4gICAgICBjb25zdCBxcyA9IHBhcnNlSW50KE1hdGguZmxvb3IocSkudG9TdHJpbmcoKSwgMTApO1xuICAgICAgY29uc3QgcXMyID0gcGFyc2VJbnQocS50b1N0cmluZygpLnNwbGl0KCcuJylbMF0sIDEwKTtcbiAgICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgKHIgIT09IHEpO1xuICAgICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBycyA9PT0gcnMyICYmIHFzID09PSBxczI7XG4gICAgICBzdCArPSBzW3JzIC0gMV07XG4gICAgfVxuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgc3QubGVuZ3RoID09PSBsO1xuICAgIC8vIHN0cmluZyBtYW5pcHVsYXRpb25cbiAgICBsZXQgcCA9IE1hdGgucmFuZG9tKCkgKiBsICogMC45OTk5OTk5OTk5O1xuICAgIGxldCBzdG0gPSBzdC5zdWJzdHIoMCwgcCkgKyAnICcgKyBzdC5zdWJzdHIocCwgMjAwMCk7XG4gICAgc3RtLl9fcHJvdG9fXy5yZXBsYWNlID0gc3RyaW5nUmVwbGFjZTtcbiAgICBsZXQgc3RvID0gc3RtLnJlcGxhY2UoLyAvZywgJycpO1xuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgc3QgPT09IHN0bztcbiAgICBwID0gTWF0aC5yYW5kb20oKSAqIGwgKiAwLjk5OTk5OTk5OTk7XG4gICAgc3RtID0gc3Quc3Vic3RyKDAsIHApICsgJ3snICsgc3Quc3Vic3RyKHAsIDIwMDApO1xuICAgIHN0byA9IHN0bS5yZXBsYWNlKC97L2csICcnKTtcbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHN0ID09PSBzdG87XG4gICAgcCA9IE1hdGgucmFuZG9tKCkgKiBsICogMC45OTk5OTk5OTk5O1xuICAgIHN0bSA9IHN0LnN1YnN0cigwLCBwKSArICcqJyArIHN0LnN1YnN0cihwLCAyMDAwKTtcbiAgICBzdG8gPSBzdG0ucmVwbGFjZSgvXFwqL2csICcnKTtcbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHN0ID09PSBzdG87XG4gICAgcCA9IE1hdGgucmFuZG9tKCkgKiBsICogMC45OTk5OTk5OTk5O1xuICAgIHN0bSA9IHN0LnN1YnN0cigwLCBwKSArICckJyArIHN0LnN1YnN0cihwLCAyMDAwKTtcbiAgICBzdG8gPSBzdG0ucmVwbGFjZSgvXFwkL2csICcnKTtcbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHN0ID09PSBzdG87XG5cbiAgICAvLyBsb3dlclxuICAgIGNvbnN0IHN0bCA9IHN0LnRvTG93ZXJDYXNlKCk7XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiAoc3RsLmxlbmd0aCA9PT0gbCkgJiYgc3RsW2wgLSAxXSAmJiAhKHN0bFtsXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHMxID0gc3RbaV07XG4gICAgICBzMS5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSBzdHJpbmdUb0xvd2VyO1xuICAgICAgY29uc3QgczIgPSBzdGwgPyBzdGxbaV0gOiAnJztcbiAgICAgIGNvbnN0IHMxbCA9IHMxLnRvTG93ZXJDYXNlKCk7XG4gICAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHMxbFswXSA9PT0gczIgJiYgczFsWzBdICYmICEoczFsWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFub3RQb2xsdXRlZDtcbn1cblxuZnVuY3Rpb24gaGV4MmJpbihoZXgpIHtcbiAgcmV0dXJuICgnMDAwMDAwMDAnICsgKHBhcnNlSW50KGhleCwgMTYpKS50b1N0cmluZygyKSkuc3Vic3RyKC04KTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZXNJblBhdGgoc291cmNlKSB7XG4gIGNvbnN0IGxzdGF0U3luYyA9IGZzLmxzdGF0U3luYztcbiAgY29uc3QgcmVhZGRpclN5bmMgPSBmcy5yZWFkZGlyU3luYztcbiAgY29uc3Qgam9pbiA9IHBhdGguam9pbjtcblxuICBmdW5jdGlvbiBpc0RpcmVjdG9yeShzb3VyY2UpIHtcbiAgICByZXR1cm4gbHN0YXRTeW5jKHNvdXJjZSkuaXNEaXJlY3RvcnkoKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZpbGUoc291cmNlKSB7IHJldHVybiBsc3RhdFN5bmMoc291cmNlKS5pc0ZpbGUoKTsgfVxuXG4gIGZ1bmN0aW9uIGdldERpcmVjdG9yaWVzKHNvdXJjZSkge1xuICAgIHJldHVybiByZWFkZGlyU3luYyhzb3VyY2UpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gam9pbihzb3VyY2UsIG5hbWUpOyB9KS5maWx0ZXIoaXNEaXJlY3RvcnkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZpbGVzKHNvdXJjZSkge1xuICAgIHJldHVybiByZWFkZGlyU3luYyhzb3VyY2UpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gam9pbihzb3VyY2UsIG5hbWUpOyB9KS5maWx0ZXIoaXNGaWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpbGVzUmVjdXJzaXZlbHkoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkaXJzID0gZ2V0RGlyZWN0b3JpZXMoc291cmNlKTtcbiAgICAgIGxldCBmaWxlcyA9IGRpcnNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBnZXRGaWxlc1JlY3Vyc2l2ZWx5KGRpcik7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICByZXR1cm4gZmlsZXMuY29uY2F0KGdldEZpbGVzKHNvdXJjZSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2UpKSB7XG4gICAgcmV0dXJuIGdldEZpbGVzUmVjdXJzaXZlbHkoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlUGlDcHVpbmZvKGxpbmVzKSB7XG5cbiAgLy8gaHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkub3JnL2RvY3VtZW50YXRpb24vaGFyZHdhcmUvcmFzcGJlcnJ5cGkvcmV2aXNpb24tY29kZXMvUkVBRE1FLm1kXG5cbiAgY29uc3Qgb2xkUmV2aXNpb25Db2RlcyA9IHtcbiAgICAnMDAwMic6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMS4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwMyc6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMS4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwNCc6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDUnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1Fpc2RhJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwNic6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwNyc6IHtcbiAgICAgIHR5cGU6ICdBJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwOCc6IHtcbiAgICAgIHR5cGU6ICdBJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDknOiB7XG4gICAgICB0eXBlOiAnQScsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1Fpc2RhJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwZCc6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwZSc6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMGYnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTAnOiB7XG4gICAgICB0eXBlOiAnQisnLFxuICAgICAgcmV2aXNpb246ICcxLjInLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxMSc6IHtcbiAgICAgIHR5cGU6ICdDTTEnLFxuICAgICAgcmV2aXNpb246ICcxLjAnLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxMic6IHtcbiAgICAgIHR5cGU6ICdBKycsXG4gICAgICByZXZpc2lvbjogJzEuMScsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDEzJzoge1xuICAgICAgdHlwZTogJ0IrJyxcbiAgICAgIHJldmlzaW9uOiAnMS4yJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnRW1iZXN0JyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxNCc6IHtcbiAgICAgIHR5cGU6ICdDTTEnLFxuICAgICAgcmV2aXNpb246ICcxLjAnLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFbWJlc3QnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDE1Jzoge1xuICAgICAgdHlwZTogJ0ErJyxcbiAgICAgIHJldmlzaW9uOiAnMS4xJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnNTEyTUJcdEVtYmVzdCcsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcm9jZXNzb3JMaXN0ID0gW1xuICAgICdCQ00yODM1JyxcbiAgICAnQkNNMjgzNicsXG4gICAgJ0JDTTI4MzcnLFxuICAgICdCQ00yNzExJyxcbiAgXTtcbiAgY29uc3QgbWFudWZhY3R1cmVyTGlzdCA9IFtcbiAgICAnU29ueSBVSycsXG4gICAgJ0Vnb21hbicsXG4gICAgJ0VtYmVzdCcsXG4gICAgJ1NvbnkgSmFwYW4nLFxuICAgICdFbWJlc3QnLFxuICAgICdTdGFkaXVtJ1xuICBdO1xuICBjb25zdCB0eXBlTGlzdCA9IHtcbiAgICAnMDAnOiAnQScsXG4gICAgJzAxJzogJ0InLFxuICAgICcwMic6ICdBKycsXG4gICAgJzAzJzogJ0IrJyxcbiAgICAnMDQnOiAnMkInLFxuICAgICcwNSc6ICdBbHBoYSAoZWFybHkgcHJvdG90eXBlKScsXG4gICAgJzA2JzogJ0NNMScsXG4gICAgJzA4JzogJzNCJyxcbiAgICAnMDknOiAnWmVybycsXG4gICAgJzBhJzogJ0NNMycsXG4gICAgJzBjJzogJ1plcm8gVycsXG4gICAgJzBkJzogJzNCKycsXG4gICAgJzBlJzogJzNBKycsXG4gICAgJzBmJzogJ0ludGVybmFsIHVzZSBvbmx5JyxcbiAgICAnMTAnOiAnQ00zKycsXG4gICAgJzExJzogJzRCJyxcbiAgICAnMTInOiAnWmVybyAyIFcnLFxuICAgICcxMyc6ICc0MDAnLFxuICAgICcxNCc6ICdDTTQnXG4gIH07XG5cbiAgY29uc3QgcmV2aXNpb25Db2RlID0gZ2V0VmFsdWUobGluZXMsICdyZXZpc2lvbicsICc6JywgdHJ1ZSk7XG4gIGNvbnN0IG1vZGVsID0gZ2V0VmFsdWUobGluZXMsICdtb2RlbDonLCAnOicsIHRydWUpO1xuICBjb25zdCBzZXJpYWwgPSBnZXRWYWx1ZShsaW5lcywgJ3NlcmlhbCcsICc6JywgdHJ1ZSk7XG5cbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChvbGRSZXZpc2lvbkNvZGVzLCByZXZpc2lvbkNvZGUpKSB7XG4gICAgLy8gb2xkIHJldmlzaW9uIGNvZGVzXG4gICAgcmVzdWx0ID0ge1xuICAgICAgbW9kZWwsXG4gICAgICBzZXJpYWwsXG4gICAgICByZXZpc2lvbkNvZGUsXG4gICAgICBtZW1vcnk6IG9sZFJldmlzaW9uQ29kZXNbcmV2aXNpb25Db2RlXS5tZW1vcnksXG4gICAgICBtYW51ZmFjdHVyZXI6IG9sZFJldmlzaW9uQ29kZXNbcmV2aXNpb25Db2RlXS5tYW51ZmFjdHVyZXIsXG4gICAgICBwcm9jZXNzb3I6IG9sZFJldmlzaW9uQ29kZXNbcmV2aXNpb25Db2RlXS5wcm9jZXNzb3IsXG4gICAgICB0eXBlOiBvbGRSZXZpc2lvbkNvZGVzW3JldmlzaW9uQ29kZV0udHlwZSxcbiAgICAgIHJldmlzaW9uOiBvbGRSZXZpc2lvbkNvZGVzW3JldmlzaW9uQ29kZV0ucmV2aXNpb24sXG4gICAgfTtcblxuICB9IGVsc2Uge1xuICAgIC8vIG5ldyByZXZpc2lvbiBjb2RlXG4gICAgY29uc3QgcmV2aXNpb24gPSAoJzAwMDAwMDAwJyArIGdldFZhbHVlKGxpbmVzLCAncmV2aXNpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCkpLnN1YnN0cigtOCk7XG4gICAgY29uc3QgbWVtU2l6ZUNvZGUgPSBwYXJzZUludChoZXgyYmluKHJldmlzaW9uLnN1YnN0cigyLCAxKSkuc3Vic3RyKDUsIDMpLCAyKSB8fCAwO1xuICAgIGNvbnN0IG1hbnVmYWN0dXJlciA9IG1hbnVmYWN0dXJlckxpc3RbcGFyc2VJbnQocmV2aXNpb24uc3Vic3RyKDMsIDEpLCAxMCldO1xuICAgIGNvbnN0IHByb2Nlc3NvciA9IHByb2Nlc3Nvckxpc3RbcGFyc2VJbnQocmV2aXNpb24uc3Vic3RyKDQsIDEpLCAxMCldO1xuICAgIGNvbnN0IHR5cGVDb2RlID0gcmV2aXNpb24uc3Vic3RyKDUsIDIpO1xuXG5cbiAgICByZXN1bHQgPSB7XG4gICAgICBtb2RlbCxcbiAgICAgIHNlcmlhbCxcbiAgICAgIHJldmlzaW9uQ29kZSxcbiAgICAgIG1lbW9yeTogMjU2ICogTWF0aC5wb3coMiwgbWVtU2l6ZUNvZGUpLFxuICAgICAgbWFudWZhY3R1cmVyLFxuICAgICAgcHJvY2Vzc29yLFxuICAgICAgdHlwZToge30uaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlTGlzdCwgdHlwZUNvZGUpID8gdHlwZUxpc3RbdHlwZUNvZGVdIDogJycsXG4gICAgICByZXZpc2lvbjogJzEuJyArIHJldmlzaW9uLnN1YnN0cig3LCAxKSxcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHByb21pc2VBbGwocHJvbWlzZXMpIHtcbiAgY29uc3QgcmVzb2x2aW5nUHJvbWlzZXMgPSBwcm9taXNlcy5tYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGxldCBwYXlsb2FkID0gbmV3IEFycmF5KDIpO1xuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcGF5bG9hZFswXSA9IHJlc3VsdDtcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBwYXlsb2FkWzFdID0gZXJyb3I7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBUaGUgd3JhcHBlZCBQcm9taXNlIHJldHVybnMgYW4gYXJyYXk6IDAgPSByZXN1bHQsIDEgPSBlcnJvciAuLi4gd2UgcmVzb2x2ZSBhbGxcbiAgICAgICAgICByZXNvbHZlKHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgLy8gRXhlY3V0ZSBhbGwgd3JhcHBlZCBQcm9taXNlc1xuICByZXR1cm4gUHJvbWlzZS5hbGwocmVzb2x2aW5nUHJvbWlzZXMpXG4gICAgLnRoZW4oZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkWzFdKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gocGF5bG9hZFsxXSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG51bGwpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChwYXlsb2FkWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkobm9kZVN0eWxlRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbm9kZVN0eWxlRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeVNhdmUobm9kZVN0eWxlRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIG5vZGVTdHlsZUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsaW51eFZlcnNpb24oKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKF9saW51eCkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBleGVjU3luYygndW5hbWUgLXYnKS50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwbGlzdFBhcnNlcih4bWxTdHIpIHtcbiAgY29uc3QgdGFncyA9IFsnYXJyYXknLCAnZGljdCcsICdrZXknLCAnc3RyaW5nJywgJ2ludGVnZXInLCAnZGF0ZScsICdyZWFsJywgJ2RhdGEnLCAnYm9vbGVhbicsICdhcnJheUVtcHR5J107XG4gIGNvbnN0IHN0YXJ0U3RyID0gJzxwbGlzdCB2ZXJzaW9uJztcblxuICBsZXQgcG9zID0geG1sU3RyLmluZGV4T2Yoc3RhcnRTdHIpO1xuICBsZXQgbGVuID0geG1sU3RyLmxlbmd0aDtcbiAgd2hpbGUgKHhtbFN0cltwb3NdICE9PSAnPicgJiYgcG9zIDwgbGVuKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBsZXQgZGVwdGggPSAwO1xuICBsZXQgaW5UYWdTdGFydCA9IGZhbHNlO1xuICBsZXQgaW5UYWdDb250ZW50ID0gZmFsc2U7XG4gIGxldCBpblRhZ0VuZCA9IGZhbHNlO1xuICBsZXQgbWV0YURhdGEgPSBbeyB0YWdTdGFydDogJycsIHRhZ0VuZDogJycsIHRhZ0NvbnRlbnQ6ICcnLCBrZXk6ICcnLCBkYXRhOiBudWxsIH1dO1xuICBsZXQgYyA9ICcnO1xuICBsZXQgY24gPSB4bWxTdHJbcG9zXTtcblxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgYyA9IGNuO1xuICAgIGlmIChwb3MgKyAxIDwgbGVuKSB7IGNuID0geG1sU3RyW3BvcyArIDFdOyB9XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgaW5UYWdDb250ZW50ID0gZmFsc2U7XG4gICAgICBpZiAoY24gPT09ICcvJykgeyBpblRhZ0VuZCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCkge1xuICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCA9ICcnO1xuICAgICAgICBpZiAoIW1ldGFEYXRhW2RlcHRoXS5kYXRhKSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAnYXJyYXknID8gW10gOiB7fTsgfVxuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBtZXRhRGF0YS5wdXNoKHsgdGFnU3RhcnQ6ICcnLCB0YWdFbmQ6ICcnLCB0YWdDb250ZW50OiAnJywga2V5OiBudWxsLCBkYXRhOiBudWxsIH0pO1xuICAgICAgICBpblRhZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaW5UYWdDb250ZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaW5UYWdTdGFydCkgeyBpblRhZ1N0YXJ0ID0gdHJ1ZTsgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAndHJ1ZS8nKSB7IGluVGFnU3RhcnQgPSBmYWxzZTsgaW5UYWdFbmQgPSB0cnVlOyBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPSAnJzsgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcvYm9vbGVhbic7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ2ZhbHNlLycpIHsgaW5UYWdTdGFydCA9IGZhbHNlOyBpblRhZ0VuZCA9IHRydWU7IG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9ICcnOyBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJy9ib29sZWFuJzsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBmYWxzZTsgfVxuICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ2FycmF5LycpIHsgaW5UYWdTdGFydCA9IGZhbHNlOyBpblRhZ0VuZCA9IHRydWU7IG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9ICcnOyBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJy9hcnJheUVtcHR5JzsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBbXTsgfVxuICAgICAgaWYgKGluVGFnQ29udGVudCkgeyBpblRhZ0NvbnRlbnQgPSBmYWxzZTsgfVxuICAgICAgaWYgKGluVGFnU3RhcnQpIHtcbiAgICAgICAgaW5UYWdTdGFydCA9IGZhbHNlO1xuICAgICAgICBpblRhZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAnZGljdCcpIHtcbiAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5UYWdFbmQpIHtcbiAgICAgICAgaW5UYWdFbmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgJiYgdGFncy5pbmRleE9mKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQuc3Vic3RyKDEpKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvZGljdCcgfHwgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9hcnJheScpIHtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDEgJiYgbWV0YURhdGFbZGVwdGggLSAyXS50YWdTdGFydCA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICBtZXRhRGF0YVtkZXB0aCAtIDJdLmRhdGEucHVzaChtZXRhRGF0YVtkZXB0aCAtIDFdLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlcHRoID4gMSAmJiBtZXRhRGF0YVtkZXB0aCAtIDJdLnRhZ1N0YXJ0ID09PSAnZGljdCcpIHtcbiAgICAgICAgICAgICAgbWV0YURhdGFbZGVwdGggLSAyXS5kYXRhW21ldGFEYXRhW2RlcHRoIC0gMV0ua2V5XSA9IG1ldGFEYXRhW2RlcHRoIC0gMV0uZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICBtZXRhRGF0YS5wb3AoKTtcbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPSAnJztcbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9rZXknICYmIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB7XG4gICAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS5rZXkgPSBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL3JlYWwnICYmIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gcGFyc2VGbG9hdChtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkgfHwgMDsgfVxuICAgICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9pbnRlZ2VyJyAmJiBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IHBhcnNlSW50KG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB8fCAwOyB9XG4gICAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL3N0cmluZycgJiYgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCB8fCAnJzsgfVxuICAgICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9ib29sZWFuJykgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50IHx8IGZhbHNlOyB9XG4gICAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2FycmF5RW1wdHknKSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgfHwgW107IH1cbiAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBtZXRhRGF0YVtkZXB0aCAtIDFdLnRhZ1N0YXJ0ID09PSAnYXJyYXknKSB7IG1ldGFEYXRhW2RlcHRoIC0gMV0uZGF0YS5wdXNoKG1ldGFEYXRhW2RlcHRoXS5kYXRhKTsgfVxuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAwICYmIG1ldGFEYXRhW2RlcHRoIC0gMV0udGFnU3RhcnQgPT09ICdkaWN0JykgeyBtZXRhRGF0YVtkZXB0aCAtIDFdLmRhdGFbbWV0YURhdGFbZGVwdGhdLmtleV0gPSBtZXRhRGF0YVtkZXB0aF0uZGF0YTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9ICcnO1xuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJyc7XG4gICAgICAgIGluVGFnU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaW5UYWdDb250ZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpblRhZ1N0YXJ0KSB7IG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCArPSBjOyB9XG4gICAgICBpZiAoaW5UYWdFbmQpIHsgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCArPSBjOyB9XG4gICAgICBpZiAoaW5UYWdDb250ZW50KSB7IG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50ICs9IGM7IH1cbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgcmV0dXJuIG1ldGFEYXRhWzBdLmRhdGE7XG59XG5cbmZ1bmN0aW9uIHN0cklzTnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmICFpc05hTihzdHIpICYmICFpc05hTihwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwbGlzdFJlYWRlcihvdXRwdXQpIHtcbiAgY29uc3QgbGluZXMgPSBvdXRwdXQuc3BsaXQoJ1xcbicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmluZGV4T2YoJyA9ICcpID49IDApIHtcbiAgICAgIGNvbnN0IGxpbmVQYXJ0cyA9IGxpbmVzW2ldLnNwbGl0KCcgPSAnKTtcbiAgICAgIGxpbmVQYXJ0c1swXSA9IGxpbmVQYXJ0c1swXS50cmltKCk7XG4gICAgICBpZiAoIWxpbmVQYXJ0c1swXS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgIGxpbmVQYXJ0c1swXSA9ICdcIicgKyBsaW5lUGFydHNbMF0gKyAnXCInO1xuICAgICAgfVxuICAgICAgbGluZVBhcnRzWzFdID0gbGluZVBhcnRzWzFdLnRyaW0oKTtcbiAgICAgIGlmIChsaW5lUGFydHNbMV0uaW5kZXhPZignXCInKSA9PT0gLTEgJiYgbGluZVBhcnRzWzFdLmVuZHNXaXRoKCc7JykpIHtcbiAgICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBsaW5lUGFydHNbMV0uc3Vic3RyaW5nKDAsIGxpbmVQYXJ0c1sxXS5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKCFzdHJJc051bWVyaWModmFsdWVTdHJpbmcpKSB7XG4gICAgICAgICAgbGluZVBhcnRzWzFdID0gYFwiJHt2YWx1ZVN0cmluZ31cIjtgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGluZVBhcnRzWzFdLmluZGV4T2YoJ1wiJykgPj0gMCAmJiBsaW5lUGFydHNbMV0uZW5kc1dpdGgoJzsnKSkge1xuICAgICAgICBjb25zdCB2YWx1ZVN0cmluZyA9IGxpbmVQYXJ0c1sxXS5zdWJzdHJpbmcoMCwgbGluZVBhcnRzWzFdLmxlbmd0aCAtIDEpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgaWYgKHN0cklzTnVtZXJpYyh2YWx1ZVN0cmluZykpIHtcbiAgICAgICAgICBsaW5lUGFydHNbMV0gPSBgJHt2YWx1ZVN0cmluZ307YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGluZXNbaV0gPSBsaW5lUGFydHMuam9pbignIDogJyk7XG4gICAgfVxuICAgIGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgvXFwoL2csICdbJykucmVwbGFjZSgvXFwpL2csICddJykucmVwbGFjZSgvOy9nLCAnLCcpLnRyaW0oKTtcbiAgICBpZiAobGluZXNbaV0uc3RhcnRzV2l0aCgnfScpICYmIGxpbmVzW2kgLSAxXSAmJiBsaW5lc1tpIC0gMV0uZW5kc1dpdGgoJywnKSkge1xuICAgICAgbGluZXNbaSAtIDFdID0gbGluZXNbaSAtIDFdLnN1YnN0cmluZygwLCBsaW5lc1tpIC0gMV0ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCA9IGxpbmVzLmpvaW4oJycpO1xuICBsZXQgb2JqID0ge307XG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbm9vcCgpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHNlbXZlckNvbXBhcmUodjEsIHYyKSB7XG4gIGxldCByZXMgPSAwO1xuICBjb25zdCBwYXJ0czEgPSB2MS5zcGxpdCgnLicpO1xuICBjb25zdCBwYXJ0czIgPSB2Mi5zcGxpdCgnLicpO1xuICBpZiAocGFydHMxWzBdIDwgcGFydHMyWzBdKSB7IHJlcyA9IDE7IH1cbiAgZWxzZSBpZiAocGFydHMxWzBdID4gcGFydHMyWzBdKSB7IHJlcyA9IC0xOyB9XG4gIGVsc2UgaWYgKHBhcnRzMVswXSA9PT0gcGFydHMyWzBdICYmIHBhcnRzMS5sZW5ndGggPj0gMiAmJiBwYXJ0czIubGVuZ3RoID49IDIpIHtcbiAgICBpZiAocGFydHMxWzFdIDwgcGFydHMyWzFdKSB7IHJlcyA9IDE7IH1cbiAgICBlbHNlIGlmIChwYXJ0czFbMV0gPiBwYXJ0czJbMV0pIHsgcmVzID0gLTE7IH1cbiAgICBlbHNlIGlmIChwYXJ0czFbMV0gPT09IHBhcnRzMlsxXSkge1xuICAgICAgaWYgKHBhcnRzMS5sZW5ndGggPj0gMyAmJiBwYXJ0czIubGVuZ3RoID49IDMpIHtcbiAgICAgICAgaWYgKHBhcnRzMVsyXSA8IHBhcnRzMlsyXSkgeyByZXMgPSAxOyB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRzMVsyXSA+IHBhcnRzMlsyXSkgeyByZXMgPSAtMTsgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0czIubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG5leHBvcnRzLnRvSW50ID0gdG9JbnQ7XG5leHBvcnRzLmV4ZWNPcHRzV2luID0gZXhlY09wdHNXaW47XG5leHBvcnRzLmdldENvZGVwYWdlID0gZ2V0Q29kZXBhZ2U7XG5leHBvcnRzLmV4ZWNXaW4gPSBleGVjV2luO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMudW5pcXVlID0gdW5pcXVlO1xuZXhwb3J0cy5zb3J0QnlLZXkgPSBzb3J0QnlLZXk7XG5leHBvcnRzLmNvcmVzID0gY29yZXM7XG5leHBvcnRzLmdldFZhbHVlID0gZ2V0VmFsdWU7XG5leHBvcnRzLmRlY29kZUVzY2FwZVNlcXVlbmNlID0gZGVjb2RlRXNjYXBlU2VxdWVuY2U7XG5leHBvcnRzLnBhcnNlRGF0ZVRpbWUgPSBwYXJzZURhdGVUaW1lO1xuZXhwb3J0cy5wYXJzZUhlYWQgPSBwYXJzZUhlYWQ7XG5leHBvcnRzLmZpbmRPYmplY3RCeUtleSA9IGZpbmRPYmplY3RCeUtleTtcbmV4cG9ydHMuZ2V0V21pYyA9IGdldFdtaWM7XG5leHBvcnRzLndtaWMgPSB3bWljO1xuZXhwb3J0cy5kYXJ3aW5YY29kZUV4aXN0cyA9IGRhcndpblhjb2RlRXhpc3RzO1xuZXhwb3J0cy5nZXRWYm94bWFuYWdlID0gZ2V0VmJveG1hbmFnZTtcbmV4cG9ydHMucG93ZXJTaGVsbCA9IHBvd2VyU2hlbGw7XG5leHBvcnRzLnBvd2VyU2hlbGxTdGFydCA9IHBvd2VyU2hlbGxTdGFydDtcbmV4cG9ydHMucG93ZXJTaGVsbFJlbGVhc2UgPSBwb3dlclNoZWxsUmVsZWFzZTtcbmV4cG9ydHMuZXhlY1NhZmUgPSBleGVjU2FmZTtcbmV4cG9ydHMubmFub1NlY29uZHMgPSBuYW5vU2Vjb25kcztcbmV4cG9ydHMuY291bnRVbmlxdWVMaW5lcyA9IGNvdW50VW5pcXVlTGluZXM7XG5leHBvcnRzLmNvdW50TGluZXMgPSBjb3VudExpbmVzO1xuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuaXNSYXNwYmVycnkgPSBpc1Jhc3BiZXJyeTtcbmV4cG9ydHMuaXNSYXNwYmlhbiA9IGlzUmFzcGJpYW47XG5leHBvcnRzLnNhbml0aXplU2hlbGxTdHJpbmcgPSBzYW5pdGl6ZVNoZWxsU3RyaW5nO1xuZXhwb3J0cy5pc1Byb3RvdHlwZVBvbGx1dGVkID0gaXNQcm90b3R5cGVQb2xsdXRlZDtcbmV4cG9ydHMuZGVjb2RlUGlDcHVpbmZvID0gZGVjb2RlUGlDcHVpbmZvO1xuZXhwb3J0cy5wcm9taXNlQWxsID0gcHJvbWlzZUFsbDtcbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xuZXhwb3J0cy5wcm9taXNpZnlTYXZlID0gcHJvbWlzaWZ5U2F2ZTtcbmV4cG9ydHMuc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IHNtYXJ0TW9uVG9vbHNJbnN0YWxsZWQ7XG5leHBvcnRzLmxpbnV4VmVyc2lvbiA9IGxpbnV4VmVyc2lvbjtcbmV4cG9ydHMucGxpc3RQYXJzZXIgPSBwbGlzdFBhcnNlcjtcbmV4cG9ydHMucGxpc3RSZWFkZXIgPSBwbGlzdFJlYWRlcjtcbmV4cG9ydHMuc3RyaW5nUmVwbGFjZSA9IHN0cmluZ1JlcGxhY2U7XG5leHBvcnRzLnN0cmluZ1RvTG93ZXIgPSBzdHJpbmdUb0xvd2VyO1xuZXhwb3J0cy5zdHJpbmdUb1N0cmluZyA9IHN0cmluZ1RvU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdTdWJzdHIgPSBzdHJpbmdTdWJzdHI7XG5leHBvcnRzLnN0cmluZ1RyaW0gPSBzdHJpbmdUcmltO1xuZXhwb3J0cy5zdHJpbmdTdGFydFdpdGggPSBzdHJpbmdTdGFydFdpdGg7XG5leHBvcnRzLm1hdGhNaW4gPSBtYXRoTWluO1xuZXhwb3J0cy5XSU5ESVIgPSBXSU5ESVI7XG5leHBvcnRzLmdldEZpbGVzSW5QYXRoID0gZ2V0RmlsZXNJblBhdGg7XG5leHBvcnRzLnNlbXZlckNvbXBhcmUgPSBzZW12ZXJDb21wYXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyB2aXJ0dWFsYm94LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTQuIERvY2tlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIHZib3hJbmZvKGNhbGxiYWNrKSB7XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBleGVjKHV0aWwuZ2V0VmJveG1hbmFnZSgpICsgJyBsaXN0IHZtcyAtLWxvbmcnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IChvcy5FT0wgKyBzdGRvdXQudG9TdHJpbmcoKSkuc3BsaXQob3MuRU9MICsgJ05hbWU6Jyk7XG4gICAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSAoJ05hbWU6JyArIHBhcnQpLnNwbGl0KG9zLkVPTCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGF0ZScpO1xuICAgICAgICAgICAgY29uc3QgcnVubmluZyA9IHN0YXRlLnN0YXJ0c1dpdGgoJ3J1bm5pbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdTaW5jZVN0cmluZyA9IHJ1bm5pbmcgPyBzdGF0ZS5yZXBsYWNlKCdydW5uaW5nIChzaW5jZSAnLCAnJykucmVwbGFjZSgnKScsICcnKS50cmltKCkgOiAnJztcbiAgICAgICAgICAgIGxldCBydW5uaW5nU2luY2UgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5jZURhdGVPYmogPSBuZXcgRGF0ZShydW5uaW5nU2luY2VTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHNpbmNlRGF0ZU9iai5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdTaW5jZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBEYXRlLnBhcnNlKHNpbmNlRGF0ZU9iaikpIC8gMTAwMCkgKyBvZmZzZXQgKiA2MDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0b3BwZWRTaW5jZVN0cmluZyA9ICFydW5uaW5nID8gc3RhdGUucmVwbGFjZSgncG93ZXJlZCBvZmYgKHNpbmNlJywgJycpLnJlcGxhY2UoJyknLCAnJykudHJpbSgpIDogJyc7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZFNpbmNlID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmNlRGF0ZU9iaiA9IG5ldyBEYXRlKHN0b3BwZWRTaW5jZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2luY2VEYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgc3RvcHBlZFNpbmNlID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIERhdGUucGFyc2Uoc2luY2VEYXRlT2JqKSkgLyAxMDAwKSArIG9mZnNldCAqIDYwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VVSUQnKSxcbiAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05hbWUnKSxcbiAgICAgICAgICAgICAgcnVubmluZyxcbiAgICAgICAgICAgICAgc3RhcnRlZDogcnVubmluZ1NpbmNlU3RyaW5nLFxuICAgICAgICAgICAgICBydW5uaW5nU2luY2UsXG4gICAgICAgICAgICAgIHN0b3BwZWQ6IHN0b3BwZWRTaW5jZVN0cmluZyxcbiAgICAgICAgICAgICAgc3RvcHBlZFNpbmNlLFxuICAgICAgICAgICAgICBndWVzdE9TOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR3Vlc3QgT1MnKSxcbiAgICAgICAgICAgICAgaGFyZHdhcmVVVUlEOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSGFyZHdhcmUgVVVJRCcpLFxuICAgICAgICAgICAgICBtZW1vcnk6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNZW1vcnkgc2l6ZScsICcgICAgICcpLCAxMCksXG4gICAgICAgICAgICAgIHZyYW06IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdWUkFNIHNpemUnKSwgMTApLFxuICAgICAgICAgICAgICBjcHVzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTnVtYmVyIG9mIENQVXMnKSwgMTApLFxuICAgICAgICAgICAgICBjcHVFeGVwQ2FwOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ1BVIGV4ZWMgY2FwJyksXG4gICAgICAgICAgICAgIGNwdVByb2ZpbGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDUFVQcm9maWxlJyksXG4gICAgICAgICAgICAgIGNoaXBzZXQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDaGlwc2V0JyksXG4gICAgICAgICAgICAgIGZpcm13YXJlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRmlybXdhcmUnKSxcbiAgICAgICAgICAgICAgcGFnZUZ1c2lvbjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhZ2UgRnVzaW9uJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgY29uZmlnRmlsZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZyBmaWxlJyksXG4gICAgICAgICAgICAgIHNuYXBzaG90Rm9sZGVyOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU25hcHNob3QgZm9sZGVyJyksXG4gICAgICAgICAgICAgIGxvZ0ZvbGRlcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvZyBmb2xkZXInKSxcbiAgICAgICAgICAgICAgaHBldDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0hQRVQnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBwYWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQQUUnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBsb25nTW9kZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvbmcgTW9kZScpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIHRyaXBsZUZhdWx0UmVzZXQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUcmlwbGUgRmF1bHQgUmVzZXQnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBhcGljOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQVBJQycpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIHgyQXBpYzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1gyQVBJQycpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGFjcGk6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBQ1BJJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgaW9BcGljOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSU9BUElDJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgYmlvc0FwaWNNb2RlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQklPUyBBUElDIG1vZGUnKSxcbiAgICAgICAgICAgICAgYm9vdE1lbnVNb2RlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQm9vdCBtZW51IG1vZGUnKSxcbiAgICAgICAgICAgICAgYm9vdERldmljZTE6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCb290IERldmljZSAxJyksXG4gICAgICAgICAgICAgIGJvb3REZXZpY2UyOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQm9vdCBEZXZpY2UgMicpLFxuICAgICAgICAgICAgICBib290RGV2aWNlMzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Jvb3QgRGV2aWNlIDMnKSxcbiAgICAgICAgICAgICAgYm9vdERldmljZTQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCb290IERldmljZSA0JyksXG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUaW1lIG9mZnNldCcpLFxuICAgICAgICAgICAgICBydGM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSVEMnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnZib3hJbmZvID0gdmJveEluZm87XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHdpZmkuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA5LiB3aWZpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcblxuZnVuY3Rpb24gd2lmaURCRnJvbVF1YWxpdHkocXVhbGl0eSkge1xuICByZXR1cm4gKHBhcnNlRmxvYXQocXVhbGl0eSkgLyAyIC0gMTAwKTtcbn1cblxuZnVuY3Rpb24gd2lmaVF1YWxpdHlGcm9tREIoZGIpIHtcbiAgY29uc3QgcmVzdWx0ID0gMiAqIChwYXJzZUZsb2F0KGRiKSArIDEwMCk7XG4gIHJldHVybiByZXN1bHQgPD0gMTAwID8gcmVzdWx0IDogMTAwO1xufVxuXG5jb25zdCBfd2lmaV9mcmVxdWVuY2llcyA9IHtcbiAgMTogMjQxMixcbiAgMjogMjQxNyxcbiAgMzogMjQyMixcbiAgNDogMjQyNyxcbiAgNTogMjQzMixcbiAgNjogMjQzNyxcbiAgNzogMjQ0MixcbiAgODogMjQ0NyxcbiAgOTogMjQ1MixcbiAgMTA6IDI0NTcsXG4gIDExOiAyNDYyLFxuICAxMjogMjQ2NyxcbiAgMTM6IDI0NzIsXG4gIDE0OiAyNDg0LFxuICAzMjogNTE2MCxcbiAgMzQ6IDUxNzAsXG4gIDM2OiA1MTgwLFxuICAzODogNTE5MCxcbiAgNDA6IDUyMDAsXG4gIDQyOiA1MjEwLFxuICA0NDogNTIyMCxcbiAgNDY6IDUyMzAsXG4gIDQ4OiA1MjQwLFxuICA1MDogNTI1MCxcbiAgNTI6IDUyNjAsXG4gIDU0OiA1MjcwLFxuICA1NjogNTI4MCxcbiAgNTg6IDUyOTAsXG4gIDYwOiA1MzAwLFxuICA2MjogNTMxMCxcbiAgNjQ6IDUzMjAsXG4gIDY4OiA1MzQwLFxuICA5NjogNTQ4MCxcbiAgMTAwOiA1NTAwLFxuICAxMDI6IDU1MTAsXG4gIDEwNDogNTUyMCxcbiAgMTA2OiA1NTMwLFxuICAxMDg6IDU1NDAsXG4gIDExMDogNTU1MCxcbiAgMTEyOiA1NTYwLFxuICAxMTQ6IDU1NzAsXG4gIDExNjogNTU4MCxcbiAgMTE4OiA1NTkwLFxuICAxMjA6IDU2MDAsXG4gIDEyMjogNTYxMCxcbiAgMTI0OiA1NjIwLFxuICAxMjY6IDU2MzAsXG4gIDEyODogNTY0MCxcbiAgMTMyOiA1NjYwLFxuICAxMzQ6IDU2NzAsXG4gIDEzNjogNTY4MCxcbiAgMTM4OiA1NjkwLFxuICAxNDA6IDU3MDAsXG4gIDE0MjogNTcxMCxcbiAgMTQ0OiA1NzIwLFxuICAxNDk6IDU3NDUsXG4gIDE1MTogNTc1NSxcbiAgMTUzOiA1NzY1LFxuICAxNTU6IDU3NzUsXG4gIDE1NzogNTc4NSxcbiAgMTU5OiA1Nzk1LFxuICAxNjE6IDU4MDUsXG4gIDE2NTogNTgyNSxcbiAgMTY5OiA1ODQ1LFxuICAxNzM6IDU4NjUsXG4gIDE4MzogNDkxNSxcbiAgMTg0OiA0OTIwLFxuICAxODU6IDQ5MjUsXG4gIDE4NzogNDkzNSxcbiAgMTg4OiA0OTQwLFxuICAxODk6IDQ5NDUsXG4gIDE5MjogNDk2MCxcbiAgMTk2OiA0OTgwXG59O1xuXG5mdW5jdGlvbiB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwoY2hhbm5lbCkge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChfd2lmaV9mcmVxdWVuY2llcywgY2hhbm5lbCkgPyBfd2lmaV9mcmVxdWVuY2llc1tjaGFubmVsXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdpZmlDaGFubmVsRnJvbUZyZXF1ZW5jcyhmcmVxdWVuY3kpIHtcbiAgbGV0IGNoYW5uZWwgPSAwO1xuICBmb3IgKGxldCBrZXkgaW4gX3dpZmlfZnJlcXVlbmNpZXMpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChfd2lmaV9mcmVxdWVuY2llcywga2V5KSkge1xuICAgICAgaWYgKF93aWZpX2ZyZXF1ZW5jaWVzW2tleV0gPT09IGZyZXF1ZW5jeSkgeyBjaGFubmVsID0gdXRpbC50b0ludChrZXkpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFubmVsO1xufVxuXG5mdW5jdGlvbiBpZmFjZUxpc3RMaW51eCgpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNtZCA9ICdpdyBkZXYgMj4vZGV2L251bGwnO1xuICB0cnkge1xuICAgIGNvbnN0IGFsbCA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpLmpvaW4oJ1xcbicpO1xuICAgIGNvbnN0IHBhcnRzID0gYWxsLnNwbGl0KCdcXG5JbnRlcmZhY2UgJyk7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICBwYXJ0cy5mb3JFYWNoKGlmYWNlRGV0YWlscyA9PiB7XG4gICAgICBjb25zdCBsaW5lcyA9IGlmYWNlRGV0YWlscy5zcGxpdCgnXFxuJyk7XG4gICAgICBjb25zdCBpZmFjZSA9IGxpbmVzWzBdO1xuICAgICAgY29uc3QgaWQgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdpZmluZGV4JywgJyAnKSk7XG4gICAgICBjb25zdCBtYWMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYWRkcicsICcgJyk7XG4gICAgICBjb25zdCBjaGFubmVsID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhbm5lbCcsICcgJykpO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgaWZhY2UsXG4gICAgICAgIG1hYyxcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGwgPSBleGVjU3luYygnbm1jbGkgLXQgLWYgZ2VuZXJhbCx3aWZpLXByb3BlcnRpZXMsd2lyZWQtcHJvcGVydGllcyxpbnRlcmZhY2UtZmxhZ3MsY2FwYWJpbGl0aWVzLG5zcCBkZXZpY2Ugc2hvdyAyPi9kZXYvbnVsbCcpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBwYXJ0cyA9IGFsbC5zcGxpdCgnXFxuR0VORVJBTC5ERVZJQ0U6Jyk7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICBwYXJ0cy5mb3JFYWNoKGlmYWNlRGV0YWlscyA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gaWZhY2VEZXRhaWxzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5ERVZJQ0UnKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLlRZUEUnKTtcbiAgICAgICAgY29uc3QgaWQgPSBpKys7IC8vIC8vIHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLlBBVEgnKTtcbiAgICAgICAgY29uc3QgbWFjID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuSFdBRERSJyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSAnJztcbiAgICAgICAgaWYgKHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3dpZmknKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgIG1hYyxcbiAgICAgICAgICAgIGNoYW5uZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm1pRGV2aWNlTGludXgoaWZhY2UpIHtcbiAgY29uc3QgY21kID0gYG5tY2xpIC10IC1mIGdlbmVyYWwsd2lmaS1wcm9wZXJ0aWVzLGNhcGFiaWxpdGllcyxpcDQsaXA2IGRldmljZSBzaG93ICR7aWZhY2V9IDI+L2Rldi9udWxsYDtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3Qgc3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLkNPTk5FQ1RJT04nKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWZhY2UsXG4gICAgICB0eXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5UWVBFJyksXG4gICAgICB2ZW5kb3I6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLlZFTkRPUicpLFxuICAgICAgcHJvZHVjdDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuUFJPRFVDVCcpLFxuICAgICAgbWFjOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5IV0FERFInKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgc3NpZDogc3NpZCAhPT0gJy0tJyA/IHNzaWQgOiBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiBubWlDb25uZWN0aW9uTGludXgoc3NpZCkge1xuICBjb25zdCBjbWQgPSBgbm1jbGkgLXQgLS1zaG93LXNlY3JldHMgY29ubmVjdGlvbiBzaG93ICR7c3NpZH0gMj4vZGV2L251bGxgO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBic3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICc4MDItMTEtd2lyZWxlc3Muc2Vlbi1ic3NpZHMnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzc2lkOiBzc2lkICE9PSAnLS0nID8gc3NpZCA6IG51bGwsXG4gICAgICB1dWlkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY29ubmVjdGlvbi51dWlkJyksXG4gICAgICB0eXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY29ubmVjdGlvbi50eXBlJyksXG4gICAgICBhdXRvY29ubmVjdDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Nvbm5lY3Rpb24uYXV0b2Nvbm5lY3QnKSA9PT0gJ3llcycsXG4gICAgICBzZWN1cml0eTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJzgwMi0xMS13aXJlbGVzcy1zZWN1cml0eS5rZXktbWdtdCcpLFxuICAgICAgYnNzaWQ6IGJzc2lkICE9PSAnLS0nID8gYnNzaWQgOiBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cGFDb25uZWN0aW9uTGludXgoaWZhY2UpIHtcbiAgY29uc3QgY21kID0gYHdwYV9jbGkgLWkgJHtpZmFjZX0gc3RhdHVzIDI+JjFgO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBmcmVxID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnZnJlcScsICc9JykpO1xuICAgIHJldHVybiB7XG4gICAgICBzc2lkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3NpZCcsICc9JyksXG4gICAgICB1dWlkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAndXVpZCcsICc9JyksXG4gICAgICBzZWN1cml0eTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tleV9tZ210JywgJz0nKSxcbiAgICAgIGZyZXEsXG4gICAgICBjaGFubmVsOiB3aWZpQ2hhbm5lbEZyb21GcmVxdWVuY3MoZnJlcSksXG4gICAgICBic3NpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Jzc2lkJywgJz0nKS50b0xvd2VyQ2FzZSgpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaWZpTmV0d29ya0xpc3RObWkoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjbWQgPSAnbm1jbGkgLXQgLW0gbXVsdGlsaW5lIC0tZmllbGRzIGFjdGl2ZSxzc2lkLGJzc2lkLG1vZGUsY2hhbixmcmVxLHNpZ25hbCxzZWN1cml0eSx3cGEtZmxhZ3MscnNuLWZsYWdzIGRldmljZSB3aWZpIGxpc3QgMj4vZGV2L251bGwnO1xuICB0cnkge1xuICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9KTtcbiAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdBQ1RJVkU6Jyk7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgcGFydCA9ICdBQ1RJVkU6JyArIHBhcnQ7XG4gICAgICBjb25zdCBsaW5lcyA9IHBhcnQuc3BsaXQob3MuRU9MKTtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ0hBTicpO1xuICAgICAgY29uc3QgZnJlcXVlbmN5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0ZSRVEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21oeicsICcnKS50cmltKCk7XG4gICAgICBjb25zdCBzZWN1cml0eSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTRUNVUklUWScpLnJlcGxhY2UoJygnLCAnJykucmVwbGFjZSgnKScsICcnKTtcbiAgICAgIGNvbnN0IHdwYUZsYWdzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1dQQS1GTEFHUycpLnJlcGxhY2UoJygnLCAnJykucmVwbGFjZSgnKScsICcnKTtcbiAgICAgIGNvbnN0IHJzbkZsYWdzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JTTi1GTEFHUycpLnJlcGxhY2UoJygnLCAnJykucmVwbGFjZSgnKScsICcnKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgc3NpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NTSUQnKSxcbiAgICAgICAgYnNzaWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU1NJRCcpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIG1vZGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNT0RFJyksXG4gICAgICAgIGNoYW5uZWw6IGNoYW5uZWwgPyBwYXJzZUludChjaGFubmVsLCAxMCkgOiBudWxsLFxuICAgICAgICBmcmVxdWVuY3k6IGZyZXF1ZW5jeSA/IHBhcnNlSW50KGZyZXF1ZW5jeSwgMTApIDogbnVsbCxcbiAgICAgICAgc2lnbmFsTGV2ZWw6IHdpZmlEQkZyb21RdWFsaXR5KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTSUdOQUwnKSksXG4gICAgICAgIHF1YWxpdHk6IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NJR05BTCcpKSxcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5ICYmIHNlY3VyaXR5ICE9PSAnbm9uZScgPyBzZWN1cml0eS5zcGxpdCgnICcpIDogW10sXG4gICAgICAgIHdwYUZsYWdzOiB3cGFGbGFncyAmJiB3cGFGbGFncyAhPT0gJ25vbmUnID8gd3BhRmxhZ3Muc3BsaXQoJyAnKSA6IFtdLFxuICAgICAgICByc25GbGFnczogcnNuRmxhZ3MgJiYgcnNuRmxhZ3MgIT09ICdub25lJyA/IHJzbkZsYWdzLnNwbGl0KCcgJykgOiBbXVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaWZpTmV0d29ya0xpc3RJdyhpZmFjZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgdHJ5IHtcbiAgICBsZXQgaXdsaXN0UGFydHMgPSBleGVjU3luYyhgZXhwb3J0IExDX0FMTD1DOyBpd2xpc3QgJHtpZmFjZX0gc2NhbiAyPiYxOyB1bnNldCBMQ19BTExgKS50b1N0cmluZygpLnNwbGl0KCcgICAgICAgIENlbGwgJyk7XG4gICAgaWYgKGl3bGlzdFBhcnRzWzBdLmluZGV4T2YoJ3Jlc291cmNlIGJ1c3knKSA+PSAwKSB7IHJldHVybiAtMTsgfVxuICAgIGlmIChpd2xpc3RQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBpd2xpc3RQYXJ0cy5zaGlmdCgpO1xuICAgICAgaXdsaXN0UGFydHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBlbGVtZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFubmVsJywgJzonLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChsaW5lcyAmJiBsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0uaW5kZXhPZignQWRkcmVzczonKSA+PSAwID8gbGluZXNbMF0uc3BsaXQoJ0FkZHJlc3M6JylbMV0udHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJyk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZScsICc6JywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdmcmVxdWVuY3knLCAnOicsIHRydWUpO1xuICAgICAgICBjb25zdCBxdWFsaXR5U3RyaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1F1YWxpdHknLCAnPScsIHRydWUpO1xuICAgICAgICBjb25zdCBkYlBhcnRzID0gcXVhbGl0eVN0cmluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCdzaWduYWwgbGV2ZWw9Jyk7XG4gICAgICAgIGNvbnN0IGRiID0gZGJQYXJ0cy5sZW5ndGggPiAxID8gdXRpbC50b0ludChkYlBhcnRzWzFdKSA6IDA7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSBkYiA/IHdpZmlRdWFsaXR5RnJvbURCKGRiKSA6IDA7XG4gICAgICAgIGNvbnN0IHNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZXNzaWQnLCAnOicsIHRydWUpO1xuXG4gICAgICAgIC8vIHNlY3VyaXR5IGFuZCB3cGEtZmxhZ3NcbiAgICAgICAgY29uc3QgaXNXcGEgPSBlbGVtZW50LmluZGV4T2YoJyBXUEEgJykgPj0gMDtcbiAgICAgICAgY29uc3QgaXNXcGEyID0gZWxlbWVudC5pbmRleE9mKCdXUEEyICcpID49IDA7XG4gICAgICAgIGNvbnN0IHNlY3VyaXR5ID0gW107XG4gICAgICAgIGlmIChpc1dwYSkgeyBzZWN1cml0eS5wdXNoKCdXUEEnKTsgfVxuICAgICAgICBpZiAoaXNXcGEyKSB7IHNlY3VyaXR5LnB1c2goJ1dQQTInKTsgfVxuICAgICAgICBjb25zdCB3cGFGbGFncyA9IFtdO1xuICAgICAgICBsZXQgd3BhRmxhZyA9ICcnO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgY29uc3QgbCA9IGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGwuaW5kZXhPZignZ3JvdXAgY2lwaGVyJykgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHdwYUZsYWcpIHtcbiAgICAgICAgICAgICAgd3BhRmxhZ3MucHVzaCh3cGFGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgd3BhRmxhZyA9IHBhcnRzWzFdLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobC5pbmRleE9mKCdwYWlyd2lzZSBjaXBoZXInKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGwuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1sxXS5pbmRleE9mKCd0a2lwJykpIHsgd3BhRmxhZyA9ICh3cGFGbGFnID8gJ1RLSVAvJyArIHdwYUZsYWcgOiAnVEtJUCcpOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzFdLmluZGV4T2YoJ2NjbXAnKSkgeyB3cGFGbGFnID0gKHdwYUZsYWcgPyAnQ0NNUC8nICsgd3BhRmxhZyA6ICdDQ01QJyk7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMV0uaW5kZXhPZigncHJvcHJpZXRhcnknKSkgeyB3cGFGbGFnID0gKHdwYUZsYWcgPyAnUFJPUC8nICsgd3BhRmxhZyA6ICdQUk9QJyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGwuaW5kZXhPZignYXV0aGVudGljYXRpb24gc3VpdGVzJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBpZiAocGFydHNbMV0uaW5kZXhPZignODAyLjF4JykpIHsgd3BhRmxhZyA9ICh3cGFGbGFnID8gJzgwMi4xeC8nICsgd3BhRmxhZyA6ICc4MDIuMXgnKTsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1sxXS5pbmRleE9mKCdwc2snKSkgeyB3cGFGbGFnID0gKHdwYUZsYWcgPyAnUFNLLycgKyB3cGFGbGFnIDogJ1BTSycpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHdwYUZsYWcpIHtcbiAgICAgICAgICB3cGFGbGFncy5wdXNoKHdwYUZsYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIHNzaWQsXG4gICAgICAgICAgYnNzaWQ6IGFkZHJlc3MsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBjaGFubmVsOiBjaGFubmVsID8gdXRpbC50b0ludChjaGFubmVsKSA6IG51bGwsXG4gICAgICAgICAgZnJlcXVlbmN5OiBmcmVxdWVuY3kgPyB1dGlsLnRvSW50KGZyZXF1ZW5jeS5yZXBsYWNlKCcuJywgJycpKSA6IG51bGwsXG4gICAgICAgICAgc2lnbmFsTGV2ZWw6IGRiLFxuICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgc2VjdXJpdHksXG4gICAgICAgICAgd3BhRmxhZ3MsXG4gICAgICAgICAgcnNuRmxhZ3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VXaWZpRGFyd2luKHdpZmlPYmopIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmICh3aWZpT2JqKSB7XG4gICAgd2lmaU9iai5mb3JFYWNoKGZ1bmN0aW9uICh3aWZpSXRlbSkge1xuICAgICAgY29uc3Qgc2lnbmFsTGV2ZWwgPSB3aWZpSXRlbS5SU1NJO1xuICAgICAgbGV0IHNlY3VyaXR5ID0gW107XG4gICAgICBsZXQgd3BhRmxhZ3MgPSBbXTtcbiAgICAgIGlmICh3aWZpSXRlbS5XUEFfSUUpIHtcbiAgICAgICAgc2VjdXJpdHkucHVzaCgnV1BBJyk7XG4gICAgICAgIGlmICh3aWZpSXRlbS5XUEFfSUUuSUVfS0VZX1dQQV9VQ0lQSEVSUykge1xuICAgICAgICAgIHdpZmlJdGVtLldQQV9JRS5JRV9LRVlfV1BBX1VDSVBIRVJTLmZvckVhY2goZnVuY3Rpb24gKGNpcGhlcnMpIHtcbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSAwICYmIHdwYUZsYWdzLmluZGV4T2YoJ3Vua25vd24vVEtJUCcpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCd1bmtub3duL1RLSVAnKTsgfVxuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDIgJiYgd3BhRmxhZ3MuaW5kZXhPZignUFNLL1RLSVAnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgnUFNLL1RLSVAnKTsgfVxuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDQgJiYgd3BhRmxhZ3MuaW5kZXhPZignUFNLL0FFUycpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCdQU0svQUVTJyk7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHdpZmlJdGVtLlJTTl9JRSkge1xuICAgICAgICBzZWN1cml0eS5wdXNoKCdXUEEyJyk7XG4gICAgICAgIGlmICh3aWZpSXRlbS5SU05fSUUuSUVfS0VZX1JTTl9VQ0lQSEVSUykge1xuICAgICAgICAgIHdpZmlJdGVtLlJTTl9JRS5JRV9LRVlfUlNOX1VDSVBIRVJTLmZvckVhY2goZnVuY3Rpb24gKGNpcGhlcnMpIHtcbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSAwICYmIHdwYUZsYWdzLmluZGV4T2YoJ3Vua25vd24vVEtJUCcpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCd1bmtub3duL1RLSVAnKTsgfVxuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDIgJiYgd3BhRmxhZ3MuaW5kZXhPZignVEtJUC9US0lQJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ1RLSVAvVEtJUCcpOyB9XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gNCAmJiB3cGFGbGFncy5pbmRleE9mKCdQU0svQUVTJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ1BTSy9BRVMnKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHNzaWQ6IHdpZmlJdGVtLlNTSURfU1RSLFxuICAgICAgICBic3NpZDogd2lmaUl0ZW0uQlNTSUQsXG4gICAgICAgIG1vZGU6ICcnLFxuICAgICAgICBjaGFubmVsOiB3aWZpSXRlbS5DSEFOTkVMLFxuICAgICAgICBmcmVxdWVuY3k6IHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbCh3aWZpSXRlbS5DSEFOTkVMKSxcbiAgICAgICAgc2lnbmFsTGV2ZWw6IHNpZ25hbExldmVsID8gcGFyc2VJbnQoc2lnbmFsTGV2ZWwsIDEwKSA6IG51bGwsXG4gICAgICAgIHF1YWxpdHk6IHdpZmlRdWFsaXR5RnJvbURCKHNpZ25hbExldmVsKSxcbiAgICAgICAgc2VjdXJpdHksXG4gICAgICAgIHdwYUZsYWdzLFxuICAgICAgICByc25GbGFnczogW11cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWZpTmV0d29ya3MoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIHJlc3VsdCA9IGdldFdpZmlOZXR3b3JrTGlzdE5taSgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpd2NvbmZpZ1BhcnRzID0gZXhlY1N5bmMoJ2V4cG9ydCBMQ19BTEw9QzsgaXdjb25maWcgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxcbicpO1xuICAgICAgICAgICAgbGV0IGlmYWNlID0gJyc7XG4gICAgICAgICAgICBpd2NvbmZpZ1BhcnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LmluZGV4T2YoJ25vIHdpcmVsZXNzJykgPT09IC0xICYmIGVsZW1lbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGlmYWNlID0gZWxlbWVudC5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpZmFjZSkge1xuICAgICAgICAgICAgICBjb25zdCByZXMgPSBnZXRXaWZpTmV0d29ya0xpc3RJdyhpZmFjZSk7XG4gICAgICAgICAgICAgIGlmIChyZXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IGFnYWluIGFmdGVyIDQgc2Vjc1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKGlmYWNlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBnZXRXaWZpTmV0d29ya0xpc3RJdyhpZmFjZSk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzICE9IC0xKSB7IHJlc3VsdCA9IHJlczsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgNDAwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJy9TeXN0ZW0vTGlicmFyeS9Qcml2YXRlRnJhbWV3b3Jrcy9BcHBsZTgwMjExLmZyYW1ld29yay9WZXJzaW9ucy9DdXJyZW50L1Jlc291cmNlcy9haXJwb3J0IC1zIC14JztcbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogNDAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICByZXN1bHQgPSBwYXJzZVdpZmlEYXJ3aW4odXRpbC5wbGlzdFBhcnNlcihvdXRwdXQpKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBjbWQgPSAnbmV0c2ggd2xhbiBzaG93IG5ldHdvcmtzIG1vZGU9QnNzaWQnO1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoY21kKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICBjb25zdCBzc2lkUGFydHMgPSBzdGRvdXQudG9TdHJpbmcoJ3V0ZjgnKS5zcGxpdChvcy5FT0wgKyBvcy5FT0wgKyAnU1NJRCAnKTtcbiAgICAgICAgICBzc2lkUGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgIHNzaWRQYXJ0cy5mb3JFYWNoKHNzaWRQYXJ0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNzaWRMaW5lcyA9IHNzaWRQYXJ0LnNwbGl0KG9zLkVPTCk7XG4gICAgICAgICAgICBpZiAoc3NpZExpbmVzICYmIHNzaWRMaW5lcy5sZW5ndGggPj0gOCAmJiBzc2lkTGluZXNbMF0uaW5kZXhPZignOicpID49IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgYnNzaWRzUGFydHMgPSBzc2lkUGFydC5zcGxpdCgnIEJTU0lEJyk7XG4gICAgICAgICAgICAgIGJzc2lkc1BhcnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgYnNzaWRzUGFydHMuZm9yRWFjaCgoYnNzaWRQYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnNzaWRMaW5lcyA9IGJzc2lkUGFydC5zcGxpdChvcy5FT0wpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJzc2lkTGluZSA9IGJzc2lkTGluZXNbMF0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBic3NpZExpbmUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBic3NpZCA9IGJzc2lkTGluZS5qb2luKCc6JykudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGJzc2lkTGluZXNbM10uc3BsaXQoJzonKS5wb3AoKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVhbGl0eSA9IGJzc2lkTGluZXNbMV0uc3BsaXQoJzonKS5wb3AoKS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzc2lkOiBzc2lkTGluZXNbMF0uc3BsaXQoJzonKS5wb3AoKS50cmltKCksXG4gICAgICAgICAgICAgICAgICBic3NpZCxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCA/IHBhcnNlSW50KGNoYW5uZWwsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbChjaGFubmVsKSxcbiAgICAgICAgICAgICAgICAgIHNpZ25hbExldmVsOiB3aWZpREJGcm9tUXVhbGl0eShxdWFsaXR5KSxcbiAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHkgPyBwYXJzZUludChxdWFsaXR5LCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IFtzc2lkTGluZXNbMl0uc3BsaXQoJzonKS5wb3AoKS50cmltKCldLFxuICAgICAgICAgICAgICAgICAgd3BhRmxhZ3M6IFtzc2lkTGluZXNbM10uc3BsaXQoJzonKS5wb3AoKS50cmltKCldLFxuICAgICAgICAgICAgICAgICAgcnNuRmxhZ3M6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLndpZmlOZXR3b3JrcyA9IHdpZmlOZXR3b3JrcztcblxuZnVuY3Rpb24gZ2V0VmVuZG9yKG1vZGVsKSB7XG4gIG1vZGVsID0gbW9kZWwudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAobW9kZWwuaW5kZXhPZignaW50ZWwnKSA+PSAwKSB7IHJlc3VsdCA9ICdJbnRlbCc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZigncmVhbHRlaycpID49IDApIHsgcmVzdWx0ID0gJ1JlYWx0ZWsnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ3F1YWxjb20nKSA+PSAwKSB7IHJlc3VsdCA9ICdRdWFsY29tJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdicm9hZGNvbScpID49IDApIHsgcmVzdWx0ID0gJ0Jyb2FkY29tJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdjYXZpdW0nKSA+PSAwKSB7IHJlc3VsdCA9ICdDYXZpdW0nOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2Npc2NvJykgPj0gMCkgeyByZXN1bHQgPSAnQ2lzY28nOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ21hcnZlbCcpID49IDApIHsgcmVzdWx0ID0gJ01hcnZlbCc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignenl4ZWwnKSA+PSAwKSB7IHJlc3VsdCA9ICdaeXhlbCc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignbWVsYW5veCcpID49IDApIHsgcmVzdWx0ID0gJ01lbGFub3gnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2QtbGluaycpID49IDApIHsgcmVzdWx0ID0gJ0QtTGluayc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZigndHAtbGluaycpID49IDApIHsgcmVzdWx0ID0gJ1RQLUxpbmsnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2FzdXMnKSA+PSAwKSB7IHJlc3VsdCA9ICdBc3VzJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdsaW5rc3lzJykgPj0gMCkgeyByZXN1bHQgPSAnTGlua3N5cyc7IH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd2lmaUNvbm5lY3Rpb25zKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBjb25zdCBpZmFjZXMgPSBpZmFjZUxpc3RMaW51eCgpO1xuICAgICAgICBjb25zdCBuZXR3b3JrTGlzdCA9IGdldFdpZmlOZXR3b3JrTGlzdE5taSgpO1xuICAgICAgICBpZmFjZXMuZm9yRWFjaChpZmFjZURldGFpbCA9PiB7XG4gICAgICAgICAgY29uc3Qgbm1pRGV0YWlscyA9IG5taURldmljZUxpbnV4KGlmYWNlRGV0YWlsLmlmYWNlKTtcbiAgICAgICAgICBjb25zdCB3cGFEZXRhaWxzID0gd3BhQ29ubmVjdGlvbkxpbnV4KGlmYWNlRGV0YWlsLmlmYWNlKTtcbiAgICAgICAgICBjb25zdCBzc2lkID0gbm1pRGV0YWlscy5zc2lkIHx8IHdwYURldGFpbHMuc3NpZDtcbiAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya0xpc3QuZmlsdGVyKG53ID0+IG53LnNzaWQgPT09IHNzaWQpO1xuICAgICAgICAgIGNvbnN0IG5taUNvbm5lY3Rpb24gPSBubWlDb25uZWN0aW9uTGludXgoc3NpZCk7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldHdvcmsgJiYgbmV0d29yay5sZW5ndGggJiYgbmV0d29ya1swXS5jaGFubmVsID8gbmV0d29ya1swXS5jaGFubmVsIDogKHdwYURldGFpbHMuY2hhbm5lbCA/IHdwYURldGFpbHMuY2hhbm5lbCA6IG51bGwpO1xuICAgICAgICAgIGNvbnN0IGJzc2lkID0gbmV0d29yayAmJiBuZXR3b3JrLmxlbmd0aCAmJiBuZXR3b3JrWzBdLmJzc2lkID8gbmV0d29ya1swXS5ic3NpZCA6ICh3cGFEZXRhaWxzLmJzc2lkID8gd3BhRGV0YWlscy5ic3NpZCA6IG51bGwpO1xuICAgICAgICAgIGlmIChzc2lkICYmIGJzc2lkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBpZmFjZURldGFpbC5pZCxcbiAgICAgICAgICAgICAgaWZhY2U6IGlmYWNlRGV0YWlsLmlmYWNlLFxuICAgICAgICAgICAgICBtb2RlbDogbm1pRGV0YWlscy5wcm9kdWN0LFxuICAgICAgICAgICAgICBzc2lkLFxuICAgICAgICAgICAgICBic3NpZDogbmV0d29yayAmJiBuZXR3b3JrLmxlbmd0aCAmJiBuZXR3b3JrWzBdLmJzc2lkID8gbmV0d29ya1swXS5ic3NpZCA6ICh3cGFEZXRhaWxzLmJzc2lkID8gd3BhRGV0YWlscy5ic3NpZCA6IG51bGwpLFxuICAgICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgICBmcmVxdWVuY3k6IGNoYW5uZWwgPyB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwoY2hhbm5lbCkgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBubWlDb25uZWN0aW9uLnR5cGUgPyBubWlDb25uZWN0aW9uLnR5cGUgOiAnODAyLjExJyxcbiAgICAgICAgICAgICAgc2VjdXJpdHk6IG5taUNvbm5lY3Rpb24uc2VjdXJpdHkgPyBubWlDb25uZWN0aW9uLnNlY3VyaXR5IDogKHdwYURldGFpbHMuc2VjdXJpdHkgPyB3cGFEZXRhaWxzLnNlY3VyaXR5IDogbnVsbCksXG4gICAgICAgICAgICAgIHNpZ25hbExldmVsOiBuZXR3b3JrICYmIG5ldHdvcmsubGVuZ3RoICYmIG5ldHdvcmtbMF0uc2lnbmFsTGV2ZWwgPyBuZXR3b3JrWzBdLnNpZ25hbExldmVsIDogbnVsbCxcbiAgICAgICAgICAgICAgdHhSYXRlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciBTUE5ldHdvcmtEYXRhVHlwZSc7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IHBhcnRzMSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG5cXG4gICAgV2ktRmk6XFxuXFxuJyk7XG4gICAgICAgICAgaWYgKHBhcnRzMS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnRzMVsxXS5zcGxpdCgnXFxuXFxuJylbMF0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaWZhY2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNEIERldmljZSBOYW1lJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2hhcmR3YXJlJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgIGNtZCA9ICcvU3lzdGVtL0xpYnJhcnkvUHJpdmF0ZUZyYW1ld29ya3MvQXBwbGU4MDIxMS5mcmFtZXdvcmsvVmVyc2lvbnMvQ3VycmVudC9SZXNvdXJjZXMvYWlycG9ydCAtSSc7XG4gICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMyID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdzc2lkJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBic3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnYnNzaWQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyaXR5ID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdsaW5rIGF1dGgnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4UmF0ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnbGFzdFR4UmF0ZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnY2hhbm5lbCcsICc6JywgdHJ1ZSkuc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gJzgwMi4xMSc7XG4gICAgICAgICAgICAgICAgY29uc3QgcnNzaSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lczIsICdhZ3JDdGxSU1NJJywgJzonLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9pc2UgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnYWdyQ3RsTm9pc2UnLCAnOicsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxMZXZlbCA9IHJzc2kgLSBub2lzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3NpZCB8fCBic3NpZCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogJ1dpLUZpJyxcbiAgICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBzc2lkLFxuICAgICAgICAgICAgICAgICAgICBic3NpZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdXRpbC50b0ludChjaGFubmVsKSxcbiAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBjaGFubmVsID8gd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKGNoYW5uZWwpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbExldmVsLFxuICAgICAgICAgICAgICAgICAgICB0eFJhdGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBjbWQgPSAnbmV0c2ggd2xhbiBzaG93IGludGVyZmFjZXMnO1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoY21kKS50aGVuKGZ1bmN0aW9uIChzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBhbGxMaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhbGxMaW5lc1tpXSA9IGFsbExpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBhbGxMaW5lcy5qb2luKCdcXHJcXG4nKS5zcGxpdCgnOlxcclxcblxcclxcbicpO1xuICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgICAgY29uc3QgaWZhY2UgPSBsaW5lc1swXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzBdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbGluZXNbMV0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1sxXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IGxpbmVzWzJdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMl0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3Qgc3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTU0lEJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgY29uc3QgYnNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNTSUQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICBjb25zdCBzaWduYWxMZXZlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaWduYWwnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JhZGlvIHR5cGUnLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUeXBlIGRlIHJhZGlvJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRnVua3R5cCcsICc6JywgdHJ1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYXV0aGVudGljYXRpb24nLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBdXRoZW50aWZpY2F0aW9uJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQXV0aGVudGlmaXppZXJ1bmcnLCAnOicsIHRydWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2hhbm5lbCcsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhbmFsJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnS2FuYWwnLCAnOicsIHRydWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IHR4UmF0ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUcmFuc21pdCByYXRlIChtYnBzKScsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RyYW5zbWlzc2lvbiAobWJpdC9zKScsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0VtcGZhbmdzcmF0ZSAoTUJpdC9zKScsICc6JywgdHJ1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgaWYgKG1vZGVsICYmIGlkICYmIHNzaWQgJiYgYnNzaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICBzc2lkLFxuICAgICAgICAgICAgICAgICAgYnNzaWQsXG4gICAgICAgICAgICAgICAgICBjaGFubmVsOiB1dGlsLnRvSW50KGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBjaGFubmVsID8gd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKGNoYW5uZWwpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICBzZWN1cml0eSxcbiAgICAgICAgICAgICAgICAgIHNpZ25hbExldmVsLFxuICAgICAgICAgICAgICAgICAgdHhSYXRlOiB1dGlsLnRvSW50KHR4UmF0ZSkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLndpZmlDb25uZWN0aW9ucyA9IHdpZmlDb25uZWN0aW9ucztcblxuZnVuY3Rpb24gd2lmaUludGVyZmFjZXMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGNvbnN0IGlmYWNlcyA9IGlmYWNlTGlzdExpbnV4KCk7XG4gICAgICAgIGlmYWNlcy5mb3JFYWNoKGlmYWNlRGV0YWlsID0+IHtcbiAgICAgICAgICBjb25zdCBubWlEZXRhaWxzID0gbm1pRGV2aWNlTGludXgoaWZhY2VEZXRhaWwuaWZhY2UpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpZmFjZURldGFpbC5pZCxcbiAgICAgICAgICAgIGlmYWNlOiBpZmFjZURldGFpbC5pZmFjZSxcbiAgICAgICAgICAgIG1vZGVsOiBubWlEZXRhaWxzLnByb2R1Y3QgPyBubWlEZXRhaWxzLnByb2R1Y3QgOiBudWxsLFxuICAgICAgICAgICAgdmVuZG9yOiBubWlEZXRhaWxzLnZlbmRvciA/IG5taURldGFpbHMudmVuZG9yIDogbnVsbCxcbiAgICAgICAgICAgIG1hYzogaWZhY2VEZXRhaWwubWFjLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgU1BOZXR3b3JrRGF0YVR5cGUnO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0czEgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxuICAgIFdpLUZpOlxcblxcbicpO1xuICAgICAgICAgIGlmIChwYXJ0czEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0czFbMV0uc3BsaXQoJ1xcblxcbicpWzBdLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGlmYWNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTRCBEZXZpY2UgTmFtZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBtYWMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTUFDIEFkZHJlc3MnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaGFyZHdhcmUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBpZDogJ1dpLUZpJyxcbiAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICAgICAgICBtYWNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBjbWQgPSAnbmV0c2ggd2xhbiBzaG93IGludGVyZmFjZXMnO1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoY21kKS50aGVuKGZ1bmN0aW9uIChzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBhbGxMaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhbGxMaW5lc1tpXSA9IGFsbExpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBhbGxMaW5lcy5qb2luKCdcXHJcXG4nKS5zcGxpdCgnOlxcclxcblxcclxcbicpO1xuICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgICAgY29uc3QgaWZhY2UgPSBsaW5lc1swXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzBdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbGluZXNbMV0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1sxXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IGxpbmVzWzJdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMl0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3QgbWFjUGFydHMgPSBsaW5lc1szXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzNdLnNwbGl0KCc6JykgOiBbXTtcbiAgICAgICAgICAgICAgbWFjUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbWFjID0gbWFjUGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgdmVuZG9yID0gZ2V0VmVuZG9yKG1vZGVsKTtcbiAgICAgICAgICAgICAgaWYgKGlmYWNlICYmIG1vZGVsICYmIGlkICYmIG1hYykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgIHZlbmRvcixcbiAgICAgICAgICAgICAgICAgIG1hYyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy53aWZpSW50ZXJmYWNlcyA9IHdpZmlJbnRlcmZhY2VzO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJzeXN0ZW1pbmZvcm1hdGlvblwiLFxuICBcInZlcnNpb25cIjogXCI1LjE3LjEyXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBZHZhbmNlZCwgbGlnaHR3ZWlnaHQgc3lzdGVtIGFuZCBPUyBpbmZvcm1hdGlvbiBsaWJyYXJ5XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImF1dGhvclwiOiBcIlNlYmFzdGlhbiBIaWxkZWJyYW5kdCA8aGlsZGVicmFuZHRAcGx1cy1pbm5vdmF0aW9ucy5jb20+IChodHRwczovL3BsdXMtaW5ub3ZhdGlvbnMuY29tKVwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9zeXN0ZW1pbmZvcm1hdGlvbi5pb1wiLFxuICBcIm1haW5cIjogXCIuL2xpYi9pbmRleC5qc1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJzeXN0ZW1pbmZvcm1hdGlvblwiOiBcImxpYi9jbGkuanNcIlxuICB9LFxuICBcInR5cGVzXCI6IFwiLi9saWIvaW5kZXguZC50c1wiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwidGVzdFwiOiBcIm5vZGUgLi90ZXN0L3Rlc3QuanNcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImxpYi9cIlxuICBdLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcInN5c3RlbSBpbmZvcm1hdGlvblwiLFxuICAgIFwic3lzaW5mb1wiLFxuICAgIFwibW9uaXRvclwiLFxuICAgIFwibW9uaXRvcmluZ1wiLFxuICAgIFwib3NcIixcbiAgICBcImxpbnV4XCIsXG4gICAgXCJvc3hcIixcbiAgICBcIndpbmRvd3NcIixcbiAgICBcImZyZWVic2RcIixcbiAgICBcIm9wZW5ic2RcIixcbiAgICBcIm5ldGJzZFwiLFxuICAgIFwiY3B1XCIsXG4gICAgXCJjcHVsb2FkXCIsXG4gICAgXCJwaHlzaWNhbCBjb3Jlc1wiLFxuICAgIFwibG9naWNhbCBjb3Jlc1wiLFxuICAgIFwicHJvY2Vzc29yXCIsXG4gICAgXCJjb3Jlc1wiLFxuICAgIFwidGhyZWFkc1wiLFxuICAgIFwic29ja2V0IHR5cGVcIixcbiAgICBcIm1lbW9yeVwiLFxuICAgIFwiZmlsZSBzeXN0ZW1cIixcbiAgICBcImZzc3RhdHNcIixcbiAgICBcImRpc2tpb1wiLFxuICAgIFwiYmxvY2sgZGV2aWNlc1wiLFxuICAgIFwibmV0c3RhdHNcIixcbiAgICBcIm5ldHdvcmtcIixcbiAgICBcIm5ldHdvcmsgaW50ZXJmYWNlc1wiLFxuICAgIFwibmV0d29yayBjb25uZWN0aW9uc1wiLFxuICAgIFwibmV0d29yayBzdGF0c1wiLFxuICAgIFwiaWZhY2VcIixcbiAgICBcInByaW50ZXJcIixcbiAgICBcInByb2Nlc3Nlc1wiLFxuICAgIFwidXNlcnNcIixcbiAgICBcImludGVybmV0XCIsXG4gICAgXCJiYXR0ZXJ5XCIsXG4gICAgXCJkb2NrZXJcIixcbiAgICBcImRvY2tlciBzdGF0c1wiLFxuICAgIFwiZG9ja2VyIHByb2Nlc3Nlc1wiLFxuICAgIFwiZ3JhcGhpY3NcIixcbiAgICBcImdyYXBoaWMgY2FyZFwiLFxuICAgIFwiZ3JhcGhpYyBjb250cm9sbGVyXCIsXG4gICAgXCJncHVcIixcbiAgICBcImRpc3BsYXlcIixcbiAgICBcInNtYXJ0XCIsXG4gICAgXCJkaXNrIGxheW91dFwiLFxuICAgIFwidXNiXCIsXG4gICAgXCJhdWRpb1wiLFxuICAgIFwiYmx1ZXRvb3RoXCIsXG4gICAgXCJ3aWZpXCIsXG4gICAgXCJ3aWZpbmV0d29ya3NcIixcbiAgICBcInZpcnR1YWwgYm94XCIsXG4gICAgXCJ2aXJ0dWFsYm94XCIsXG4gICAgXCJ2bVwiLFxuICAgIFwiYmFja2VuZFwiLFxuICAgIFwiaGFyZHdhcmVcIixcbiAgICBcIkJJT1NcIixcbiAgICBcImNoYXNzaXNcIlxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NlYmhpbGRlYnJhbmR0L3N5c3RlbWluZm9ybWF0aW9uLmdpdFwiXG4gIH0sXG4gIFwiZnVuZGluZ1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiQnV5IG1lIGEgY29mZmVlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3d3dy5idXltZWFjb2ZmZWUuY29tL3N5c3RlbWluZm9cIlxuICB9LFxuICBcIm9zXCI6IFtcbiAgICBcImRhcndpblwiLFxuICAgIFwibGludXhcIixcbiAgICBcIndpbjMyXCIsXG4gICAgXCJmcmVlYnNkXCIsXG4gICAgXCJvcGVuYnNkXCIsXG4gICAgXCJuZXRic2RcIixcbiAgICBcInN1bm9zXCIsXG4gICAgXCJhbmRyb2lkXCJcbiAgXSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTguMC4wXCJcbiAgfVxufVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoXCIuLi9wcm90b3R5cGUvaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJsZW5ndGhcIikpIHJldHVybiBmYWxzZTtcblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZS5jYWxsICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0XHRpZiAodHlwZW9mIHZhbHVlLmFwcGx5ICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gIWlzUHJvdG90eXBlKHZhbHVlKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgICAgICAgPSByZXF1aXJlKFwiLi4vdmFsdWUvaXNcIilcbiAgLCBpc09iamVjdCAgICAgID0gcmVxdWlyZShcIi4uL29iamVjdC9pc1wiKVxuICAsIHN0cmluZ0NvZXJjZSAgPSByZXF1aXJlKFwiLi4vc3RyaW5nL2NvZXJjZVwiKVxuICAsIHRvU2hvcnRTdHJpbmcgPSByZXF1aXJlKFwiLi90by1zaG9ydC1zdHJpbmdcIik7XG5cbnZhciByZXNvbHZlTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB2YWx1ZSkge1xuXHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKFwiJXZcIiwgdG9TaG9ydFN0cmluZyh2YWx1ZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRNZXNzYWdlLCBpbnB1dE9wdGlvbnMpIHtcblx0aWYgKCFpc09iamVjdChpbnB1dE9wdGlvbnMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlc29sdmVNZXNzYWdlKGRlZmF1bHRNZXNzYWdlLCB2YWx1ZSkpO1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSB7XG5cdFx0aWYgKFwiZGVmYXVsdFwiIGluIGlucHV0T3B0aW9ucykgcmV0dXJuIGlucHV0T3B0aW9uc1tcImRlZmF1bHRcIl07XG5cdFx0aWYgKGlucHV0T3B0aW9ucy5pc09wdGlvbmFsKSByZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3JNZXNzYWdlID0gc3RyaW5nQ29lcmNlKGlucHV0T3B0aW9ucy5lcnJvck1lc3NhZ2UpO1xuXHRpZiAoIWlzVmFsdWUoZXJyb3JNZXNzYWdlKSkgZXJyb3JNZXNzYWdlID0gZGVmYXVsdE1lc3NhZ2U7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IocmVzb2x2ZU1lc3NhZ2UoZXJyb3JNZXNzYWdlLCB2YWx1ZSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHRyeSB7IHJldHVybiBTdHJpbmcodmFsdWUpOyB9XG5cdFx0Y2F0Y2ggKGVycm9yMikgeyByZXR1cm4gbnVsbDsgfVxuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKFwiLi9zYWZlLXRvLXN0cmluZ1wiKTtcblxudmFyIHJlTmV3TGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHZhciBzdHJpbmcgPSBzYWZlVG9TdHJpbmcodmFsdWUpO1xuXHRpZiAoc3RyaW5nID09PSBudWxsKSByZXR1cm4gXCI8Tm9uLWNvZXJjaWJsZSB0byBzdHJpbmcgdmFsdWU+XCI7XG5cdC8vIFRyaW0gaWYgdG9vIGxvbmdcblx0aWYgKHN0cmluZy5sZW5ndGggPiAxMDApIHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCA5OSkgKyBcIuKAplwiO1xuXHQvLyBSZXBsYWNlIGV2ZW50dWFsIG5ldyBsaW5lc1xuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZU5ld0xpbmUsIGZ1bmN0aW9uIChjaGFyKSB7XG5cdFx0c3dpdGNoIChjaGFyKSB7XG5cdFx0XHRjYXNlIFwiXFxuXCI6XG5cdFx0XHRcdHJldHVybiBcIlxcXFxuXCI7XG5cdFx0XHRjYXNlIFwiXFxyXCI6XG5cdFx0XHRcdHJldHVybiBcIlxcXFxyXCI7XG5cdFx0XHRjYXNlIFwiXFx1MjAyOFwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcdTIwMjhcIjtcblx0XHRcdGNhc2UgXCJcXHUyMDI5XCI6XG5cdFx0XHRcdHJldHVybiBcIlxcXFx1MjAyOVwiO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyXCIpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBzdHJpbmc7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4uL3ZhbHVlL2lzXCIpO1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBwb3NzaWJsZVR5cGVzID0geyBcIm9iamVjdFwiOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIFwidW5kZWZpbmVkXCI6IHRydWUgLyogZG9jdW1lbnQuYWxsICovIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwocG9zc2libGVUeXBlcywgdHlwZW9mIHZhbHVlKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHJlc29sdmVFeGNlcHRpb24gPSByZXF1aXJlKFwiLi4vbGliL3Jlc29sdmUtZXhjZXB0aW9uXCIpXG4gICwgaXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0aWYgKGlzKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gcmVzb2x2ZUV4Y2VwdGlvbih2YWx1ZSwgXCIldiBpcyBub3QgYSBwbGFpbiBmdW5jdGlvblwiLCBhcmd1bWVudHNbMV0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9pc1wiKTtcblxudmFyIGNsYXNzUmUgPSAvXlxccypjbGFzc1tcXHN7L31dLywgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoY2xhc3NSZS50ZXN0KGZ1bmN0aW9uVG9TdHJpbmcuY2FsbCh2YWx1ZSkpKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiB0cnVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdGlmICghdmFsdWUuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgID0gcmVxdWlyZShcIi4uL3ZhbHVlL2lzXCIpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gbnVsbDtcblx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdC8vIFJlamVjdCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGNvZXJjaW9uXG5cdFx0dmFyIHZhbHVlVG9TdHJpbmcgPSB2YWx1ZS50b1N0cmluZztcblx0XHRpZiAodHlwZW9mIHZhbHVlVG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG5cdFx0aWYgKHZhbHVlVG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nKSByZXR1cm4gbnVsbDtcblx0XHQvLyBOb3RlOiBJdCBjYW4gYmUgb2JqZWN0IGNvbWluZyBmcm9tIG90aGVyIHJlYWxtLCBzdGlsbCBhcyB0aGVyZSdzIG5vIEVTMyBhbmQgQ1NQIGNvbXBsaWFudFxuXHRcdC8vIHdheSB0byByZXNvbHZlIGl0cyByZWFsbSdzIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgaXQncyBsZWZ0IGFzIG5vdCBhZGRyZXNzZWQgZWRnZSBjYXNlXG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gXCJcIiArIHZhbHVlOyAvLyBFbnN1cmUgaW1wbGljaXQgY29lcmNpb25cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVzb2x2ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuLi9saWIvcmVzb2x2ZS1leGNlcHRpb25cIilcbiAgLCBpcyAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHRpZiAoaXModmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiByZXNvbHZlRXhjZXB0aW9uKHZhbHVlLCBcIkNhbm5vdCB1c2UgJXZcIiwgYXJndW1lbnRzWzFdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVMzIHNhZmVcbnZhciBfdW5kZWZpbmVkID0gdm9pZCAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IF91bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBkdXBsZXhpZnkgPSByZXF1aXJlKCdkdXBsZXhpZnknKVxudmFyIFdTID0gcmVxdWlyZSgnd3MnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U3RyZWFtXG5cbmZ1bmN0aW9uIGJ1aWxkUHJveHkgKG9wdGlvbnMsIHNvY2tldFdyaXRlLCBzb2NrZXRFbmQpIHtcbiAgdmFyIHByb3h5ID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgb2JqZWN0TW9kZTogb3B0aW9ucy5vYmplY3RNb2RlXG4gIH0pXG5cbiAgcHJveHkuX3dyaXRlID0gc29ja2V0V3JpdGVcbiAgcHJveHkuX2ZsdXNoID0gc29ja2V0RW5kXG5cbiAgcmV0dXJuIHByb3h5XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFN0cmVhbSh0YXJnZXQsIHByb3RvY29scywgb3B0aW9ucykge1xuICB2YXIgc3RyZWFtLCBzb2NrZXRcblxuICB2YXIgaXNCcm93c2VyID0gcHJvY2Vzcy50aXRsZSA9PT0gJ2Jyb3dzZXInXG4gIHZhciBpc05hdGl2ZSA9ICEhZ2xvYmFsLldlYlNvY2tldFxuICB2YXIgc29ja2V0V3JpdGUgPSBpc0Jyb3dzZXIgPyBzb2NrZXRXcml0ZUJyb3dzZXIgOiBzb2NrZXRXcml0ZU5vZGVcblxuICBpZiAocHJvdG9jb2xzICYmICFBcnJheS5pc0FycmF5KHByb3RvY29scykgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBwcm90b2NvbHMpIHtcbiAgICAvLyBhY2NlcHQgdGhlIFwib3B0aW9uc1wiIE9iamVjdCBhcyB0aGUgMm5kIGFyZ3VtZW50XG4gICAgb3B0aW9ucyA9IHByb3RvY29sc1xuICAgIHByb3RvY29scyA9IG51bGxcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm90b2NvbCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnByb3RvY29sKSkge1xuICAgICAgcHJvdG9jb2xzID0gb3B0aW9ucy5wcm90b2NvbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIGlmIChvcHRpb25zLm9iamVjdE1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMub2JqZWN0TW9kZSA9ICEob3B0aW9ucy5iaW5hcnkgPT09IHRydWUgfHwgb3B0aW9ucy5iaW5hcnkgPT09IHVuZGVmaW5lZClcbiAgfVxuXG4gIHZhciBwcm94eSA9IGJ1aWxkUHJveHkob3B0aW9ucywgc29ja2V0V3JpdGUsIHNvY2tldEVuZClcblxuICBpZiAoIW9wdGlvbnMub2JqZWN0TW9kZSkge1xuICAgIHByb3h5Ll93cml0ZXYgPSB3cml0ZXZcbiAgfVxuXG4gIC8vIGJyb3dzZXIgb25seTogc2V0cyB0aGUgbWF4aW11bSBzb2NrZXQgYnVmZmVyIHNpemUgYmVmb3JlIHRocm90dGxpbmdcbiAgdmFyIGJ1ZmZlclNpemUgPSBvcHRpb25zLmJyb3dzZXJCdWZmZXJTaXplIHx8IDEwMjQgKiA1MTJcblxuICAvLyBicm93c2VyIG9ubHk6IGhvdyBsb25nIHRvIHdhaXQgd2hlbiB0aHJvdHRsaW5nXG4gIHZhciBidWZmZXJUaW1lb3V0ID0gb3B0aW9ucy5icm93c2VyQnVmZmVyVGltZW91dCB8fCAxMDAwXG5cbiAgLy8gdXNlIGV4aXN0aW5nIFdlYlNvY2tldCBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGluXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgIHNvY2tldCA9IHRhcmdldFxuICAvLyBvdGhlcndpc2UgbWFrZSBhIG5ldyBvbmVcbiAgfSBlbHNlIHtcbiAgICAvLyBzcGVjaWFsIGNvbnN0cnVjdG9yIHRyZWF0bWVudCBmb3IgbmF0aXZlIHdlYnNvY2tldHMgaW4gYnJvd3NlcnMsIHNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi93ZWJzb2NrZXQtc3RyZWFtL2lzc3Vlcy84MlxuICAgIGlmIChpc05hdGl2ZSAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgIHNvY2tldCA9IG5ldyBXUyh0YXJnZXQsIHByb3RvY29scylcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0ID0gbmV3IFdTKHRhcmdldCwgcHJvdG9jb2xzLCBvcHRpb25zKVxuICAgIH1cblxuICAgIHNvY2tldC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICB9XG5cbiAgLy8gd2FzIGFscmVhZHkgb3BlbiB3aGVuIHBhc3NlZCBpblxuICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgc3RyZWFtID0gcHJveHlcbiAgfSBlbHNlIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBzdHJlYW0gPSBwcm94eVxuICAgIHN0cmVhbS5jb3JrKClcbiAgICBzb2NrZXQub25vcGVuID0gb25vcGVuQnJvd3NlclxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuICAgIHNvY2tldC5vbm9wZW4gPSBvbm9wZW5cbiAgfVxuXG4gIHN0cmVhbS5zb2NrZXQgPSBzb2NrZXRcblxuICBzb2NrZXQub25jbG9zZSA9IG9uY2xvc2VcbiAgc29ja2V0Lm9uZXJyb3IgPSBvbmVycm9yXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBvbm1lc3NhZ2VcblxuICBwcm94eS5vbignY2xvc2UnLCBkZXN0cm95KVxuXG4gIHZhciBjb2VyY2VUb0J1ZmZlciA9ICFvcHRpb25zLm9iamVjdE1vZGVcblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZU5vZGUoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIC8vIGF2b2lkIGVycm9ycywgdGhpcyBuZXZlciBoYXBwZW5zIHVubGVzc1xuICAgIC8vIGRlc3Ryb3koKSBpcyBjYWxsZWRcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IHNvY2tldC5PUEVOKSB7XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAndXRmOCcpXG4gICAgfVxuICAgIHNvY2tldC5zZW5kKGNodW5rLCBuZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0V3JpdGVCcm93c2VyKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICBpZiAoc29ja2V0LmJ1ZmZlcmVkQW1vdW50ID4gYnVmZmVyU2l6ZSkge1xuICAgICAgc2V0VGltZW91dChzb2NrZXRXcml0ZUJyb3dzZXIsIGJ1ZmZlclRpbWVvdXQsIGNodW5rLCBlbmMsIG5leHQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29lcmNlVG9CdWZmZXIgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ3V0ZjgnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzb2NrZXQuc2VuZChjaHVuaylcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgcmV0dXJuIG5leHQoZXJyKVxuICAgIH1cblxuICAgIG5leHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0RW5kKGRvbmUpIHtcbiAgICBzb2NrZXQuY2xvc2UoKVxuICAgIGRvbmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuKCkge1xuICAgIHN0cmVhbS5zZXRSZWFkYWJsZShwcm94eSlcbiAgICBzdHJlYW0uc2V0V3JpdGFibGUocHJveHkpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuQnJvd3NlciAoKSB7XG4gICAgc3RyZWFtLnVuY29yaygpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBzdHJlYW0uZW5kKClcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubWVzc2FnZShldmVudCkge1xuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIGVsc2UgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JylcbiAgICBwcm94eS5wdXNoKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHNvY2tldC5jbG9zZSgpXG4gIH1cblxuICAvLyB0aGlzIGlzIHRvIGJlIGVuYWJsZWQgb25seSBpZiBvYmplY3RNb2RlIGlzIGZhbHNlXG4gIGZ1bmN0aW9uIHdyaXRldiAoY2h1bmtzLCBjYikge1xuICAgIHZhciBidWZmZXJzID0gbmV3IEFycmF5KGNodW5rcy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmtzW2ldLmNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXJzW2ldID0gQnVmZmVyLmZyb20oY2h1bmtzW2ldLCAndXRmOCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzW2ldID0gY2h1bmtzW2ldLmNodW5rXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fd3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSwgJ2JpbmFyeScsIGNiKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuIiwiXG52YXIgd3MgPSBudWxsXG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IFdlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IE1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IHdpbmRvdy5XZWJTb2NrZXQgfHwgd2luZG93Lk1veldlYlNvY2tldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdzXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iXX0="}