{"version":3,"file":"assemblyscript.js","mappings":"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,2HC7WA,SAAYxe,GACV,+CACA,mDACA,yCACA,6DACA,qGACA,iHACA,iHACA,mHACA,qHACA,uCACA,uHACA,iMACA,iFACA,2FACA,+DACA,yEACA,2EACA,yIACA,uGACA,6EACA,6DACA,2FACA,uEACA,mDACA,+EACA,mGACA,uKACA,6FACA,2JACA,uFACA,iGACA,qHACA,qGACA,+DACA,iEACA,iGACA,uFACA,yDACA,uGACA,qHACA,yEACA,yLACA,2GACA,+KACA,uIACA,uIACA,+GACA,iGACA,yHACA,2EACA,qIACA,oEACA,oDACA,oCACA,8FACA,kEACA,8CACA,gHACA,oHACA,8HACA,0GACA,8GACA,4EACA,oFACA,oGACA,0GACA,oHACA,wFACA,gFACA,kIACA,kIACA,4FACA,oHACA,oFACA,kFACA,wKACA,sLACA,kIACA,oDACA,wCACA,oJACA,gDACA,kGACA,wGACA,0CACA,kEACA,0DACA,gDACA,gEACA,sIACA,4IACA,0DACA,4DACA,wEACA,sDACA,4FACA,4FACA,oHACA,wDACA,sDACA,8HACA,gKACA,oKACA,sFACA,wEACA,sKACA,sJACA,8IACA,wFACA,0IACA,sJACA,0DACA,kDACA,gFACA,gGACA,gGACA,wDACA,kFACA,sFACA,0GACA,oHACA,8GACA,sHACA,wMACA,oFACA,8HACA,0NACA,sFACA,0IACA,gMACA,0LACA,wGACA,oIACA,kIACA,0HACA,wGACA,oIACA,wFACA,4KACA,sHACA,gFACA,oKACA,gLACA,4FACA,0MACA,wKACA,0FACA,8FACA,kQACA,8DACA,kGACA,gKACA,oIACA,kJACA,0GACA,kKACA,4DACA,oJACA,oJACA,0GACA,0EACA,4FACA,oFACA,sNACA,8FACA,0QACA,kLACA,sLACA,gHACA,sFACA,8IACA,sDACA,0HACA,wEACA,8CACA,4FACA,gIACA,iLACA,+MAnLF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAuL1B,kCAAuCwvD,GACrC,OAAQA,GACN,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,uBACjB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K,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,EAA+B,CACnC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,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AAK,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,IAAK,IAAK,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,IAAK,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,I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","sources":["webpack://assemblyscript/webpack/universalModuleDefinition","webpack://assemblyscript/./src/ast.ts","webpack://assemblyscript/./src/builtins.ts","webpack://assemblyscript/./src/common.ts","webpack://assemblyscript/./src/compiler.ts","webpack://assemblyscript/./src/definitions.ts","webpack://assemblyscript/./src/diagnosticMessages.generated.ts","webpack://assemblyscript/./src/diagnostics.ts","webpack://assemblyscript/./src/extra/ast.ts","webpack://assemblyscript/./src/flow.ts","webpack://assemblyscript/./src/glue/js/index.ts","webpack://assemblyscript/./src/index.ts","webpack://assemblyscript/./src/module.ts","webpack://assemblyscript/./src/parser.ts","webpack://assemblyscript/./src/passes/findusedlocals.ts","webpack://assemblyscript/./src/passes/pass.ts","webpack://assemblyscript/./src/passes/rtrace.ts","webpack://assemblyscript/./src/passes/shadowstack.ts","webpack://assemblyscript/./src/program.ts","webpack://assemblyscript/./src/resolver.ts","webpack://assemblyscript/./src/tokenizer.ts","webpack://assemblyscript/./src/types.ts","webpack://assemblyscript/./src/util/binary.ts","webpack://assemblyscript/./src/util/collections.ts","webpack://assemblyscript/./src/util/index.ts","webpack://assemblyscript/./src/util/math.ts","webpack://assemblyscript/./src/util/path.ts","webpack://assemblyscript/./src/util/terminal.ts","webpack://assemblyscript/./src/util/text.ts","webpack://assemblyscript/./src/util/vector.ts","webpack://assemblyscript/./std/assembly/shared/feature.ts","webpack://assemblyscript/./std/assembly/shared/runtime.ts","webpack://assemblyscript/./std/assembly/shared/target.ts","webpack://assemblyscript/./std/assembly/shared/typeinfo.ts","webpack://assemblyscript/external umd \"binaryen\"","webpack://assemblyscript/./node_modules/long/umd/index.js","webpack://assemblyscript/./src/glue/binaryen.js","webpack://assemblyscript/./src/glue/js/collections.js","webpack://assemblyscript/./src/glue/js/float.js","webpack://assemblyscript/./src/glue/js/i64.js","webpack://assemblyscript/./std/portable/index.js","webpack://assemblyscript/webpack/bootstrap","webpack://assemblyscript/webpack/runtime/global","webpack://assemblyscript/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__725__) {\nreturn ","/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode,\n  isTrivialAlphanum\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport enum NodeKind {\n\n  SOURCE,\n\n  // types\n  NAMEDTYPE,\n  FUNCTIONTYPE,\n  TYPENAME,\n  TYPEPARAMETER,\n  PARAMETER,\n\n  // expressions\n  IDENTIFIER,\n  ASSERTION,\n  BINARY,\n  CALL,\n  CLASS,\n  COMMA,\n  ELEMENTACCESS,\n  FALSE,\n  FUNCTION,\n  INSTANCEOF,\n  LITERAL,\n  NEW,\n  NULL,\n  OMITTED,\n  PARENTHESIZED,\n  PROPERTYACCESS,\n  TERNARY,\n  SUPER,\n  THIS,\n  TRUE,\n  CONSTRUCTOR,\n  UNARYPOSTFIX,\n  UNARYPREFIX,\n  COMPILED,\n\n  // statements\n  BLOCK,\n  BREAK,\n  CONTINUE,\n  DO,\n  EMPTY,\n  EXPORT,\n  EXPORTDEFAULT,\n  EXPORTIMPORT,\n  EXPRESSION,\n  FOR,\n  FOROF,\n  IF,\n  IMPORT,\n  RETURN,\n  SWITCH,\n  THROW,\n  TRY,\n  VARIABLE,\n  VOID,\n  WHILE,\n\n  // declaration statements\n  CLASSDECLARATION,\n  ENUMDECLARATION,\n  ENUMVALUEDECLARATION,\n  FIELDDECLARATION,\n  FUNCTIONDECLARATION,\n  IMPORTDECLARATION,\n  INTERFACEDECLARATION,\n  METHODDECLARATION,\n  NAMESPACEDECLARATION,\n  TYPEDECLARATION,\n  VARIABLEDECLARATION,\n\n  // special\n  DECORATOR,\n  EXPORTMEMBER,\n  SWITCHCASE,\n  INDEXSIGNATURE,\n  COMMENT\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    statement: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(statement, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    statement: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, statement, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    statement: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, statement, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    statements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.LITERAL\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.LITERAL) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.FLOAT:\n        case LiteralKind.INTEGER: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.LITERAL: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.FLOAT:\n          case LiteralKind.INTEGER:\n          case LiteralKind.STRING: return true;\n        }\n        break;\n      }\n      case NodeKind.NULL:\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.CALL) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PROPERTYACCESS) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.THIS);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.SUPER);\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FUNCTIONTYPE) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPENAME, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMEDTYPE, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    var typeArguments = this.typeArguments;\n    return typeArguments !== null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONTYPE, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEPARAMETER, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport enum ParameterKind {\n  /** No specific flags. */\n  DEFAULT,\n  /** Is an optional parameter. */\n  OPTIONAL,\n  /** Is a rest parameter. */\n  REST\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARAMETER, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  CUSTOM,\n  GLOBAL,\n  OPERATOR,\n  OPERATOR_BINARY,\n  OPERATOR_PREFIX,\n  OPERATOR_POSTFIX,\n  UNMANAGED,\n  FINAL,\n  INLINE,\n  EXTERNAL,\n  BUILTIN,\n  LAZY,\n  UNSAFE\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.IDENTIFIER) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.BUILTIN;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.EXTERNAL;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.FINAL;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.GLOBAL;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.INLINE;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.LAZY;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.OPERATOR;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.UNMANAGED;\n          if (nameStr == \"unsafe\") return DecoratorKind.UNSAFE;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.IDENTIFIER) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OPERATOR_BINARY;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OPERATOR_PREFIX;\n              if (propStr == \"postfix\") return DecoratorKind.OPERATOR_POSTFIX;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.CUSTOM;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DECORATOR, range);\n  }\n}\n\n/** Comment kinds. */\nexport enum CommentKind {\n  /** Line comment. */\n  LINE,\n  /** Triple-slash line comment. */\n  TRIPLE,\n  /** Block comment. */\n  BLOCK\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMENT, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IDENTIFIER, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport enum LiteralKind {\n  FLOAT,\n  INTEGER,\n  STRING,\n  TEMPLATE,\n  REGEXP,\n  ARRAY,\n  OBJECT\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.LITERAL, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.ARRAY, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  PREFIX,\n  /** An as assertion, i.e. `expr as T`. */\n  AS,\n  /** A non-null assertion, i.e. `!expr`. */\n  NONNULL,\n  /** A const assertion, i.e. `expr as const`. */\n  CONST\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ASSERTION, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BINARY, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CALL, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.CLASS, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMA, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.CONSTRUCTOR;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ELEMENTACCESS, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.FLOAT, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.FUNCTION, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INSTANCEOF, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.INTEGER, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NEW, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.NULL;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.OBJECT, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.OMITTED, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARENTHESIZED, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PROPERTYACCESS, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.REGEXP, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TERNARY, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.STRING, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.SUPER;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.TEMPLATE, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.THIS;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.TRUE;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.FALSE;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPOSTFIX, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPREFIX, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMPILED, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport enum SourceKind {\n  /** User-provided file. */\n  USER = 0,\n  /** User-provided entry file. */\n  USER_ENTRY = 1,\n  /** Library-provided file. */\n  LIBRARY = 2,\n  /** Library-provided entry file. */\n  LIBRARY_ENTRY = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.SOURCE, new Range(0, text.length));\n    var internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    var pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    var kind = this.sourceKind;\n    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    var lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    var l = 0;\n    var r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INDEXSIGNATURE, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BLOCK, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BREAK, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CONTINUE, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DO, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EMPTY, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTIMPORT, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTMEMBER, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORT, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTDEFAULT, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.EXPRESSION, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOR, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOROF, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  NONE,\n  /** Parenthesized parameter list. */\n  ARROW_PARENTHESIZED,\n  /** Single parameter without parenthesis. */\n  ARROW_SINGLE\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IF, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORT, range);\n    var normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = normalizedPath;\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.INTERFACEDECLARATION;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);\n    this.kind = NodeKind.METHODDECLARATION;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.RETURN, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCHCASE, range);\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCH, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.THROW, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TRY, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLE, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VOID, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.WHILE, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  var pos = path.lastIndexOf(\".\");\n  var len = path.length;\n  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot\n    let cur = pos;\n    while (++cur < len) {\n      if (!isTrivialAlphanum(path.charCodeAt(cur))) {\n        assert(false); // not a valid external path\n        return path;\n      }\n    }\n    return path.substring(0, pos);\n  }\n  assert(false); // not an external path\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NAMEDTYPE) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next !== null || name.identifier.text.length > 0);\n  }\n  return false;\n}\n","/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  RefIsOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Field,\n  Global,\n  DecoratorFlags,\n  ClassPrototype,\n  Class\n} from \"./program\";\n\nimport {\n  findUsedLocals,\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n\n  // std/bindings/wasi.ts\n  export const wasiAbort = \"~lib/wasi/index/abort\";\n  export const wasiTrace = \"~lib/wasi/index/trace\";\n  export const wasiSeed = \"~lib/wasi/index/seed\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFloatValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isBooleanValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isSignedIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.extends(compiler.program.arrayPrototype)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isArrayLike\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFunction ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isNullableReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.SWALLOW\n  );\n  return module.i32(element !== null ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isManaged ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  var signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return module.i32(signatureReference.parameterTypes.length);\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var type = ctx.typeArguments![0];\n  var classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let classMembers = classReference.members;\n    if (classMembers !== null && classMembers.has(fieldName)) {\n      let member = assert(classMembers.get(fieldName));\n      if (member.kind == ElementKind.FIELD) {\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var resultType = evaluateConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  var value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return compiler.ensureStaticString(value);\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return module.i32(signatureReference.id);\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {\n    return module.i32(classReference.id);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ClzI64\n            : UnaryOp.ClzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.CtzI64\n            : UnaryOp.CtzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.PopcntI64\n            : UnaryOp.PopcntI32,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotlI64\n            : BinaryOp.RotlI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotrI64\n            : BinaryOp.RotrI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.ISIZE: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n        let isWasm64 = options.isWasm64;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,\n          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                isWasm64 ? module.i64(63) : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.USIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.GtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64: { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64: { op = BinaryOp.GtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtI64\n          : BinaryOp.GtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtU64\n          : BinaryOp.GtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.LtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtI64\n          : BinaryOp.LtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtU64\n          : BinaryOp.LtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let arg0 = compiler.compileExpression(operands[0],\n          compiler.options.isWasm64\n            ? Type.f64\n            : Type.f32,\n          Constraints.CONV_IMPLICIT\n        );\n        compiler.currentType = type;\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  var arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.CONV_IMPLICIT\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.ISIZE:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2, type.toRef());\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var usizeType = compiler.options.usizeType;\n  var offset: i64;\n  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType, elementExpression);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i31ref;\n  return module.i31_new(arg0);\n}\nbuiltins.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.CONV_IMPLICIT);\n  if (ctx.contextualType.is(TypeFlags.UNSIGNED)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltins.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var toType = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.auto);\n  var fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            arg0\n          ),\n          abort\n        );\n      }\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: return module.if(module.ref_is(RefIsOp.RefIsNull, arg0), abort);\n\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is(RefIsOp.RefIsNull,\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var flow = compiler.currentFlow;\n  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n  flow.set(FlowFlags.UNCHECKED_CONTEXT);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length - 1;\n  var operandExprs = new Array<ExpressionRef>(numOperands);\n  var paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var typeArgument = typeArguments[0];\n  var classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  checkTypeAbsent(ctx);\n  var operands = ctx.operands;\n  var reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.ERROR\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.CLASS);\n  var classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  var typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  var ftype = typeArguments[0];\n  var signature = assert(ftype.getSignature());\n  var returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  var functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);\n  var thisOperand = assert(ctx.operands.shift());\n  var thisType = signature.thisType;\n  var thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);\n  } else if (thisOperand.kind != NodeKind.NULL) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.String_raw, builtin_string_raw);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  var compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp), bytes, off);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  compiler.currentType = type;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_load(compiler.options.isWasm64 ? SIMDLoadOp.Load64Zero : SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\n  var idx = 0;\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Load64Lane : SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\n  var idx = 0;\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Store64Lane : SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.ISIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.ISIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(compiler.options.isWasm64 ? UnaryOp.AllTrueI64x2 : UnaryOp.AllTrueI32x4, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.BitmaskI64x2 : UnaryOp.BitmaskI32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments ? typeArguments[0] : Type.f64;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments ? typeArguments[0] : Type.f32;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  var module = compiler.module;\n  var exprs = new Array<ExpressionRef>();\n  var sizeTypeRef = compiler.options.sizeTypeRef;\n  var visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.GLOBAL) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference !== null &&\n      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&\n      global.is(CommonFlags.COMPILED)\n    ) {\n      if (global.is(CommonFlags.INLINED)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var sizeTypeRef = usizeType.toRef();\n  var sizeTypeSize = usizeType.byteSize;\n  var visitInstance = assert(program.visitInstance);\n  var body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  var base = instance.base;\n  if (base) {\n    body.push(\n      module.call(base.internalName + \"~visit\", [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  var hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  var needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind == ElementKind.FIELD) {\n          if ((<Field>member).parent === instance) {\n            let fieldType = (<Field>member).type;\n            if (fieldType.isManaged) {\n              let fieldOffset = (<Field>member).memoryOffset;\n              assert(fieldOffset >= 0);\n              needsTempValue = true;\n              body.push(\n                // if ($2 = value) __visit($2, $1)\n                module.if(\n                  module.local_tee(2,\n                    module.load(sizeTypeSize, false,\n                      module.local_get(0, sizeTypeRef),\n                      sizeTypeRef, fieldOffset\n                    ),\n                    false // internal\n                  ),\n                  module.call(visitInstance.internalName, [\n                    module.local_get(2, sizeTypeRef), // value\n                    module.local_get(1, TypeRef.I32)  // cookie\n                  ], TypeRef.None)\n                )\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(instance.internalName + \"~visit\",\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var sizeTypeRef = usizeType.toRef();\n  var managedClasses = program.managedClasses;\n  var visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  var names = new Array<string>();\n  var cases = new Array<ExpressionRef>();\n  var nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(instance.internalName + \"~visit\", [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  var current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var managedClasses = program.managedClasses;\n  var count = managedClasses.size;\n  var size = 4 + 8 * count;\n  var data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  var off = 4;\n  var abvInstance = program.arrayBufferViewInstance;\n  var abvPrototype = abvInstance.prototype;\n  var arrayPrototype = program.arrayPrototype;\n  var setPrototype = program.setPrototype;\n  var mapPrototype = program.mapPrototype;\n  var staticArrayPrototype = program.staticArrayPrototype;\n  var lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance !== abvInstance && instance.extends(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extends(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extends(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n    let base = instance.base;\n    writeI32(base ? base.id : 0, data, off); off += 4;\n  }\n  assert(off == size);\n  var usizeType = program.options.usizeType;\n  var segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\n  var module = compiler.module;\n  var sizeTypeRef = compiler.options.sizeTypeRef;\n  var instanceofInstance = assert(prototype.program.instanceofInstance);\n  compiler.compileFunction(instanceofInstance);\n\n  var stmts = new Array<ExpressionRef>();\n\n  // if (!ref) return false\n  stmts.push(\n    module.if(\n      module.unary(\n        sizeTypeRef == TypeRef.I64\n          ? UnaryOp.EqzI64\n          : UnaryOp.EqzI32,\n        module.local_get(0, sizeTypeRef)\n      ),\n      module.return(\n        module.i32(0)\n      )\n    )\n  );\n\n  // if (__instanceof(ref, ID[i])) return true\n  var instances = prototype.instances;\n  if (instances !== null && instances.size > 0) {\n    // TODO: for (let instance of instances.values()) {\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      stmts.push(\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(0, sizeTypeRef),\n            module.i32(instance.id)\n          ], TypeRef.I32),\n          module.return(\n            module.i32(1)\n          )\n        )\n      );\n    }\n  }\n\n  // return false\n  stmts.push(\n    module.return(\n      module.i32(0)\n    )\n  );\n\n  module.addFunction(prototype.internalName + \"~instanceof\", sizeTypeRef, TypeRef.I32, null, module.flatten(stmts));\n}\n\n// Helpers\n\n/** Evaluates the constant type of a type argument *or* expression. */\nfunction evaluateConstantType(ctx: BuiltinContext): Type | null {\n  var compiler = ctx.compiler;\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments !== null && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);\n    } else {\n      compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments !== null && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  var module = compiler.module;\n  var value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  var align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  var compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var compiler = ctx.compiler;\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  var operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  var module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n","/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport enum CommonFlags {\n  /** No flags set. */\n  NONE = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  IMPORT = 1 << 0,\n  /** Has an `export` modifier. */\n  EXPORT = 1 << 1,\n  /** Has a `declare` modifier. */\n  DECLARE = 1 << 2,\n  /** Has a `const` modifier. */\n  CONST = 1 << 3,\n  /** Has a `let` modifier. */\n  LET = 1 << 4,\n  /** Has a `static` modifier. */\n  STATIC = 1 << 5,\n  /** Has a `readonly` modifier. */\n  READONLY = 1 << 6,\n  /** Has an `abstract` modifier. */\n  ABSTRACT = 1 << 7,\n  /** Has a `public` modifier. */\n  PUBLIC = 1 << 8,\n  /** Has a `private` modifier. */\n  PRIVATE = 1 << 9,\n  /** Has a `protected` modifier. */\n  PROTECTED = 1 << 10,\n  /** Has a `get` modifier. */\n  GET = 1 << 11,\n  /** Has a `set` modifier. */\n  SET = 1 << 12,\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DEFINITELY_ASSIGNED = 1 << 13,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  AMBIENT = 1 << 14,\n  /** Is generic. */\n  GENERIC = 1 << 15,\n  /** Is part of a generic context. */\n  GENERIC_CONTEXT = 1 << 16,\n  /** Is an instance member. */\n  INSTANCE = 1 << 17,\n  /** Is a constructor. */\n  CONSTRUCTOR = 1 << 18,\n  /** Is a module export. */\n  MODULE_EXPORT = 1 << 19,\n  /** Is a module import. */\n  MODULE_IMPORT = 1 << 20,\n\n  // Compilation states\n\n  /** Is resolved. */\n  RESOLVED = 1 << 21,\n  /** Is compiled. */\n  COMPILED = 1 << 22,\n  /** Did error. */\n  ERRORED = 1 << 23,\n  /** Has a constant value and is therefore inlined. */\n  INLINED = 1 << 24,\n  /** Is scoped. */\n  SCOPED = 1 << 25,\n  /** Is a stub. */\n  STUB = 1 << 26,\n  /** Is a virtual method. */\n  VIRTUAL = 1 << 27,\n  /** Is (part of) a closure. */\n  CLOSURE = 1 << 28,\n\n  // Other\n\n  /** Is quoted. */\n  QUOTED = 1 << 29\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const EMPTY = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const anyref = \"anyref\";\n  export const eqref = \"eqref\";\n  export const i31ref = \"i31ref\";\n  export const dataref = \"dataref\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_WASI = \"ASC_WASI\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Anyref = \"Anyref\";\n  export const Eqref = \"Eqref\";\n  export const I31ref = \"I31ref\";\n  export const Dataref = \"Dataref\";\n  export const String = \"String\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const typeinfo = \"__typeinfo\";\n  export const instanceof_ = \"__instanceof\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n","/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI,\n  compileClassInstanceOf\n} from \"./builtins\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  RefIsOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  needsExplicitUnreachable,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  createType,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstZero\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  INSTANCE_DELIMITER,\n  STATIC_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime,\n  featureToString\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  Enum,\n  Field,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind,\n  findUsedLocals\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  Range,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  uniqueMap,\n  isPowerOf2,\n  v128_zero,\n  readI32\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\n/** Compiler options. */\nexport class Options {\n\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\n  target: Target = Target.WASM32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** If true, generates an explicit start function. */\n  explicitStart: bool = false;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MUTABLE_GLOBALS | Feature.SIGN_EXTENSION;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.WASM64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.WASM64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  NONE = 0,\n\n  /** Must implicitly convert to the target type. */\n  CONV_IMPLICIT = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  CONV_EXPLICIT = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MUST_WRAP = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WILL_DROP = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PREFER_STATIC = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IS_THIS = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  NONE = 0,\n  /** Requires data setup. */\n  DATA = 1 << 0,\n  /** Requires a stack. */\n  STACK = 1 << 1,\n  /** Requires heap setup. */\n  HEAP = 1 << 2,\n  /** Requires runtime type information setup. */\n  RTTI = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the explicit start function, if applicable. */\n  export const start = \"_start\"; // match WASI\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n  /** Name of the memory instance, if exported. */\n  export const memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const table = \"table\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nconst runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Module instance being compiled. */\n  module: Module;\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending class-specific instanceof helpers. */\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\n  /** Virtually called stubs that may have overloads. */\n  virtualStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    var options = program.options;\n    var module = Module.create(options.stackSize > 0, options.sizeTypeRef);\n    this.module = module;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    var featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;\n    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    var options = this.options;\n    var module = this.module;\n    var program = this.program;\n    var resolver = this.resolver;\n    var hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    var startFunctionInstance = this.currentFlow.actualFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    var startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable data, heap and rtti offset dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    var files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.compileFile(file);\n        this.compileExports(file);\n      }\n    }\n\n    // set up module exports\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);\n    }\n\n    // compile and export runtime if requested\n    if (this.options.exportRuntime) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // compile lazy functions\n    var lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending class-specific instanceof helpers\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\n      let prototype = unchecked(_values[i]);\n      compileClassInstanceOf(this, prototype);\n    }\n\n    // set up virtual stubs\n    var functionTable = this.functionTable;\n    var virtualStubs = this.virtualStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.VIRTUAL)) {\n        assert(instance.is(CommonFlags.INSTANCE));\n        functionTable[i] = this.ensureVirtualStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    var virtualStubsSeen = new Set<Function>();\n    do {\n      // virtual stubs and overloads have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverload = false;\n      for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overloadInstances = resolver.resolveOverloads(instance);\n        if (overloadInstances) {\n          for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n            this.compileFunction(overloadInstances[i]);\n          }\n        }\n        virtualStubsSeen.add(instance);\n      }\n    } while (virtualStubs.size > virtualStubsSeen.size || resolver.discoveredOverload);\n    virtualStubsSeen.clear();\n    for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeVirtualStub(_values[i]);\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    var memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.DATA) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.STACK) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.HEAP) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    this.memoryOffset = memoryOffset;\n\n    // check that we didn't exceed lowMemoryLimit already\n    var lowMemoryLimit32 = this.options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // set up memory\n    var initialPages: u32 = 0;\n    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n    var maximumPages = Module.UNLIMITED_MEMORY;\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n    var isSharedMemory = false;\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.THREADS)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      this.memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.memory : null,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) module.addMemoryImport(\"0\", \"env\", \"memory\", isSharedMemory);\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\"0\", \"env\", \"table\");\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(\"0\", ExportNames.table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    var tableBase = this.options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    var functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n    module.addFunctionTable(\"0\", tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    var startIsEmpty = !startFunctionBody.length;\n    var explicitStart = program.isWasi || options.explicitStart;\n    if (!startIsEmpty || explicitStart) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && explicitStart) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.additionalLocals),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (!explicitStart) module.setStart(funcRef);\n      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  // === Exports ==================================================================================\n\n  /** Applies the respective module exports for the specified file. */\n  private ensureModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.ensureModuleExport(elementName, element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.ensureModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Applies the respective module export(s) for the specified element. */\n  private ensureModuleExport(name: string, element: Element, prefix: string = \"\"): void {\n    var module = this.module;\n    switch (element.kind) {\n\n      // traverse instances\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>element;\n        let functionInstances = functionPrototype.instances;\n        if (functionInstances !== null && functionInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (functionPrototype.is(CommonFlags.GENERIC)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n              functionPrototype.identifierNode.range\n            );\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        let classPrototype = <ClassPrototype>element;\n        let classInstances = classPrototype.instances;\n        if (classInstances !== null && classInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (classPrototype.is(CommonFlags.GENERIC)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n              classPrototype.identifierNode.range\n            );\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);\n        break;\n      }\n\n      // export concrete elements\n      case ElementKind.GLOBAL: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            global.identifierNode.range\n          );\n        } else if (global.is(CommonFlags.COMPILED)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n        }\n        break;\n      }\n      case ElementKind.ENUMVALUE: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            enumValue.identifierNode.range\n          );\n        } else if (enumValue.is(CommonFlags.COMPILED)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n        }\n        break;\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          if (functionInstance.is(CommonFlags.COMPILED)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              if (signature.hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n            }\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (element.is(CommonFlags.COMPILED)) {\n          let getterExportName = prefix + GETTER_PREFIX + name;\n          if (this.compileFieldGetter(fieldInstance) && !module.hasExport(getterExportName)) {\n            module.addFunctionExport(fieldInstance.internalGetterName, getterExportName);\n            let signature = fieldInstance.internalGetterSignature;\n            if (signature.hasManagedOperands) {\n              this.shadowStack.noteExport(getterExportName, signature.getManagedOperandIndices());\n            }\n          }\n          if (!element.is(CommonFlags.READONLY)) {\n            let setterExportName = prefix + SETTER_PREFIX + name;\n            if (this.compileFieldSetter(fieldInstance) && !module.hasExport(setterExportName)) {\n              module.addFunctionExport(fieldInstance.internalSetterName, setterExportName);\n              let signature = fieldInstance.internalSetterSignature;\n              if (signature.hasManagedOperands) {\n                this.shadowStack.noteExport(setterExportName, signature.getManagedOperandIndices());\n              }\n            }\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>element;\n        // make the class name itself represent its runtime id\n        if (!classInstance.type.isUnmanaged) {\n          let module = this.module;\n          let internalName = classInstance.internalName;\n\n          if (!this.doneModuleExports.has(element)) {\n            module.addGlobal(internalName, TypeRef.I32, false, module.i32(classInstance.id));\n            this.doneModuleExports.add(element);\n          }\n\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(internalName, exportName);\n          }\n        }\n        break;\n      }\n\n      // just traverse members below\n      case ElementKind.ENUM:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.INDEXSIGNATURE: break;\n\n      default: assert(false); // unexpected module export\n    }\n\n    // traverse members\n    var members = element.members;\n    if (members) {\n      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS\n        ? INSTANCE_DELIMITER\n        : STATIC_DELIMITER\n      );\n      if (element.kind == ElementKind.NAMESPACE) {\n        let implicitExport = element.is(CommonFlags.SCOPED);\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (implicitExport || member.is(CommonFlags.EXPORT)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      } else {\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (!member.is(CommonFlags.PRIVATE)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      }\n    }\n  }\n\n  // === Elements =================================================================================\n\n  /** Compiles any element. */\n  compileElement(element: Element, compileMembers: bool = true): void {\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        this.compileGlobal(<Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        this.compileEnum(<Enum>element);\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n          if (functionInstance) this.compileFunction(functionInstance);\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);\n          if (classInstance) this.compileClass(classInstance);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n        if (propertyInstance) this.compileProperty(propertyInstance);\n        break;\n      }\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.ENUMVALUE:\n      case ElementKind.INDEXSIGNATURE: break;\n      default: assert(false);\n    }\n    if (compileMembers) {\n      let members = element.members;\n      if (members) {\n        // TODO: for (let element of members.values()) {\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let element = unchecked(_values[i]);\n          this.compileElement(element);\n        }\n      }\n    }\n  }\n\n  /** Compiles a file's exports. */\n  compileExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.compileFile(exportStar);\n        this.compileExports(exportStar);\n      }\n    }\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    var file: File;\n    var filesByName = this.program.filesByName;\n    var pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.COMPILED)) return;\n    file.set(CommonFlags.COMPILED);\n\n    // compile top-level statements within the file's start function\n    var startFunction = file.startFunction;\n    var startSignature = startFunction.signature;\n    var previousBody = this.currentBody;\n    var startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    var previousFlow = this.currentFlow;\n    var flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);\n    global.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    var module = this.module;\n    var initExpr: ExpressionRef = 0;\n    var typeNode = global.typeNode;\n    var initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.RESOLVED)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.checkTypeSupported(global.type, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MUST_WRAP | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.ERRORED);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {\n      let internalName = global.internalName;\n      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.DATA;\n      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.STACK;\n      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;\n      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    var type = global.type;\n    var typeRef = type.toRef();\n    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);\n\n    // Handle imports\n    if (global.is(CommonFlags.AMBIENT)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n        global.set(CommonFlags.MODULE_IMPORT);\n        mangleImportName(global, global.declaration);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.ERRORED);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    var initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant, attempt to precompute\n      if (getExpressionId(initExpr) != ExpressionId.Const) {\n        if (isDeclaredConstant) {\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              initializeInStart = true;\n            }\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.ERRORED);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.INLINED); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.INLINED)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC);\n      } else {\n        initExpr = this.makeZero(type, global.declaration);\n      }\n    }\n\n    var internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type, global.declaration));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);\n    element.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    var module = this.module;\n    var previousParent = this.currentParent;\n    this.currentParent = element;\n    var previousValue: EnumValue | null = null;\n    var previousValueIsMut = false;\n    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);\n\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.COMPILED);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.CONV_IMPLICIT\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;\n      if (instance.hasDecorator(DecoratorFlags.LAZY)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function hasn't duplicate parameters\n    var parameters = instance.prototype.functionTypeNode.parameters;\n    var numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.COMPILED);\n    var pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    var previousType = this.currentType;\n    var module = this.module;\n    var signature = instance.signature;\n    var bodyNode = instance.prototype.bodyNode;\n    var declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    var funcRef: FunctionRef;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.AMBIENT)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name\n      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          decorator.range, \"external\"\n        );\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.additionalLocals),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.AMBIENT)) {\n      instance.set(CommonFlags.MODULE_IMPORT);\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        instance.identifierNode.range\n      );\n      funcRef = 0; // TODO?\n      instance.set(CommonFlags.ERRORED);\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    var module = this.module;\n    var bodyNode = assert(instance.prototype.bodyNode);\n    var returnType = instance.signature.returnType;\n    var flow = this.currentFlow;\n    var thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    var bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.BLOCK) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.EXPRESSION);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      assert(instance.is(CommonFlags.INSTANCE));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        stmts.push(\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\n        );\n        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  // === Classes ==================================================================================\n\n  /** Compiles a priorly resolved class. */\n  compileClass(instance: Class): bool {\n    if (instance.is(CommonFlags.COMPILED)) return true;\n    instance.set(CommonFlags.COMPILED);\n    var prototype = instance.prototype;\n    var staticMembers = (<ClassPrototype>prototype).members;\n    if (staticMembers) {\n      // TODO: for (let element of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.GLOBAL: {\n            this.compileGlobal(<Global>element);\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    this.ensureConstructor(instance, instance.identifierNode);\n    this.checkFieldInitialization(instance);\n\n    var instanceMembers = instance.members;\n    if (instanceMembers) {\n      // TODO: for (let element of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.FIELD: {\n            this.compileField(<Field>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Compiles an instance field to a getter and a setter. */\n  compileField(instance: Field): bool {\n    this.compileFieldGetter(instance);\n    this.compileFieldSetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /** Compiles the getter of the specified instance field. */\n  compileFieldGetter(instance: Field): bool {\n    if (instance.getterRef) return true;\n    var module = this.module;\n    var valueType = instance.type;\n    var valueTypeRef = valueType.toRef();\n    var thisTypeRef = this.options.sizeTypeRef;\n    // return this.field\n    instance.getterRef = module.addFunction(instance.internalGetterName, thisTypeRef, valueTypeRef, null,\n      module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n        module.local_get(0, thisTypeRef),\n        valueTypeRef, instance.memoryOffset\n      )\n    );\n    if (instance.setterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles the setter of the specified instance field. */\n  compileFieldSetter(instance: Field): bool {\n    if (instance.setterRef) return true;\n    var type = instance.type;\n    var thisTypeRef = this.options.sizeTypeRef;\n    var valueTypeRef = type.toRef();\n    var module = this.module;\n    // void(this.field = value)\n    var bodyExpr = module.store(type.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, instance.memoryOffset\n    );\n    if (type.isManaged) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ thisTypeRef, valueTypeRef ]), TypeRef.None, null,\n      bodyExpr\n    );\n    if (instance.getterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles a property to a getter and potentially a setter. */\n  compileProperty(instance: Property): bool {\n    this.compilePropertyGetter(instance);\n    this.compilePropertySetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /* Compiles the getter of the specified property. */\n  compilePropertyGetter(instance: Property): bool {\n    var getterInstance = instance.getterInstance;\n    if (getterInstance) {\n      let ret = this.compileFunction(getterInstance);\n      let setterInstance = instance.setterInstance;\n      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  /** Compiles the setter of the specified property. */\n  compilePropertySetter(instance: Property): bool {\n    var setterInstance = instance.setterInstance;\n    if (setterInstance) {\n      let ret = this.compileFunction(setterInstance);\n      let getterInstance = instance.getterInstance;\n      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    var memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    var ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    var program = this.program;\n    var totalOverhead = program.totalOverhead;\n    var stringInstance = assert(program.stringInstance);\n    var stringSegment: MemorySegment;\n    var segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    var length = values.length;\n    var byteSize = elementType.byteSize;\n    var elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    var program = this.program;\n    var arrayBufferInstance = program.arrayBufferInstance;\n    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    var program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    var bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    var arrayLength = i32(bufferLength / elementType.byteSize);\n    var bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    var buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));\n    var program = this.program;\n    var memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.CLASSDECLARATION: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.ENUM);\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.GLOBAL);\n            if (\n              !element.is(CommonFlags.AMBIENT) && // delay imports\n              !element.hasDecorator(DecoratorFlags.LAZY)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element !== null && element.kind == ElementKind.GLOBAL) { // static\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.EXPORT: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath !== null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION:\n      case NodeKind.METHODDECLARATION:\n      case NodeKind.INTERFACEDECLARATION:\n      case NodeKind.INDEXSIGNATURE:\n      case NodeKind.TYPEDECLARATION: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement,\n    /** Whether this is the last statement of the body, if known. */\n    isLastInBody: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.BLOCK: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.BREAK: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.DO: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.FOR: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.FOROF: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.IF: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.RETURN: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.THROW: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.TRY: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.VOID: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.WHILE: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Whether this is an immediate body statement. */\n    isBody: bool = false,\n    /** Statements to append to that is also returned. Created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    var numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    var module = this.module;\n    var flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\n        break;\n      }\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    var statements = statement.statements;\n    var outerFlow = this.currentFlow;\n    var innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    var stmts = this.compileStatements(statements);\n    innerFlow.freeScopedLocals();\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    var flow = this.currentFlow;\n    var breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.freeScopedLocals();\n    flow.set(FlowFlags.BREAKS);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    var flow = this.currentFlow;\n    var continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);\n    flow.freeScopedLocals();\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement, null);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                           flow\n    //  (loop $loop                              recompile?\n    //   (?block $continue                                \n    //    (body)                                   bodyFlow \n    //   )                                                \n    //                                                   breaks or terminates?\n    //                                                    but does not continue\n    //   (br_if (cond) $loop)                     condFlow \n    //                                                   \n    //                                         condition?\n    //  )                                     \n    // )                                      \n\n    var label = outerFlow.pushBreakLabel();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"do-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"do-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"do-loop|\" + label;\n\n    // Compile the body (always executes)\n    var bodyFlow = flow.fork();\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Shortcut if body never falls through\n    var possiblyContinues = bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS) && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      flow.inherit(bodyFlow);\n\n    // Otherwise evaluate the condition\n    } else {\n      let condFlow = flow.fork();\n      this.currentFlow = condFlow;\n      let condExpr = this.makeIsTrueish(\n        this.compileExpression(statement.condition, Type.i32),\n        this.currentType,\n        statement.condition\n      );\n      let condKind = this.evaluateCondition(condExpr);\n\n      if (possiblyContinues) {\n        bodyStmts = [\n          module.block(continueLabel, bodyStmts)\n        ];\n      }\n\n      // Shortcut if condition is always false\n      if (condKind == ConditionKind.FALSE) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        flow.inherit(bodyFlow);\n\n      // Terminate if condition is always true and body never breaks\n      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        bodyStmts.push(\n          module.br(loopLabel)\n        );\n        flow.set(FlowFlags.TERMINATES);\n\n      } else {\n        bodyStmts.push(\n          module.br(loopLabel,\n            condExpr\n          )\n        );\n        flow.inherit(condFlow);\n\n        // Detect if local flags are incompatible before and after looping, and\n        // if so recompile by unifying local flags between iterations. Note that\n        // this may be necessary multiple times where locals depend on each other.\n        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n          outerFlow.popBreakLabel();\n          this.currentFlow = outerFlow;\n          return this.doCompileDoStatement(statement, flow);\n        }\n      }\n    }\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(loopLabel,\n        module.flatten(bodyStmts)\n      )\n    ]);\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement, null);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (initializer)                   flow\n    // (block $break                    \n    //  (loop $loop                      recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //                                            \n    //   (if (local.get $tcond)                    condition?\n    //    (block $continue                         \n    //     (body)                       bodyFlow \n    //                                           \n    //    )                                      breaks or terminates?\n    //    (incrementor)                 incrFlow \n    //                                           \n    //                                 \n    //    (br $loop)                  \n    //   )                              \n    //  )                               \n    // )                                \n    //                                \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    var breakLabel = \"for-break\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"for-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"for-loop|\" + label;\n\n    // Compile initializer if present\n    var initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.EXPRESSION ||\n        initializer.kind == NodeKind.VARIABLE\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr: ExpressionRef;\n    var condKind: ConditionKind;\n    var condition = statement.condition;\n    if (condition) {\n      condExpr = this.makeIsTrueish(\n        this.compileExpression(condition, Type.bool),\n        this.currentType,\n        condition\n      );\n      condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false (body never runs)\n      if (condKind == ConditionKind.FALSE) {\n        stmts.push(\n          module.drop(condExpr)\n        );\n        condFlow.freeScopedLocals();\n        flow.inherit(condFlow);\n        flow.freeScopedLocals();\n        outerFlow.inherit(flow);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condKind = ConditionKind.TRUE;\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    var tcond = flow.getTempLocal(Type.bool);\n    var loopStmts = new Array<ExpressionRef>();\n    loopStmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Check if body terminates\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(module.unreachable());\n    }\n    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n    else flow.inheritBranch(bodyFlow);\n    bodyFlow.freeScopedLocals();\n\n    var ifStmts = new Array<ExpressionRef>();\n    ifStmts.push(\n      module.block(continueLabel, bodyStmts)\n    );\n\n    // Compile the incrementor if it runs\n    // Can still fall through to here if body continues, hence is already known to terminate\n    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        let incrFlow = flow.fork();\n        this.currentFlow = incrFlow;\n        ifStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)\n        );\n        incrFlow.freeScopedLocals();\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\n        this.currentFlow = flow;\n      }\n\n      ifStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        assert(!bodyFlow.hasScopedLocals);\n        flow.freeScopedLocals();\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement, flow);\n      }\n    }\n    loopStmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(ifStmts)\n      )\n    );\n\n    stmts.push(\n      module.block(breakLabel, [\n        module.loop(loopLabel,\n          module.flatten(loopStmts)\n        )\n      ])\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    flow.freeScopedLocals();\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      stmts.push(module.unreachable());\n    }\n    this.currentFlow = outerFlow;\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var ifTrue = statement.ifTrue;\n    var ifFalse = statement.ifFalse;\n\n    // (if               flow\n    //  (condition)       condition?\n    //  (block                       \n    //   (ifTrue)         thenFlow \n    //                             \n    //  )                          \n    //  (block                      present?\n    //   (ifFalse)                   elseFlow\n    //                              \n    //  )                           \n    // )                 \n    // ...              \n\n    // Precompute the condition (always executes)\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.TRUE: {\n        return module.block(null, [\n          module.drop(condExpr),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.FALSE: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExpr),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExpr);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    var flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    var thenStmts = new Array<ExpressionRef>();\n    var thenFlow = flow.fork();\n    this.currentFlow = thenFlow;\n    thenFlow.inheritNonnullIfTrue(condExpr);\n    if (ifTrue.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n    if (thenTerminates) {\n      thenStmts.push(module.unreachable());\n    }\n    thenFlow.freeScopedLocals();\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    if (ifFalse) {\n      let elseStmts = new Array<ExpressionRef>();\n      let elseFlow = flow.fork();\n      this.currentFlow = elseFlow;\n      elseFlow.inheritNonnullIfFalse(condExpr);\n      if (ifFalse.kind == NodeKind.BLOCK) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n      if (elseTerminates) {\n        elseStmts.push(module.unreachable());\n      }\n      elseFlow.freeScopedLocals();\n      this.currentFlow = flow;\n      flow.inheritMutual(thenFlow, elseFlow);\n      return module.if(condExpr,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      flow.inheritBranch(thenFlow);\n      flow.inheritNonnullIfFalse(condExpr,\n        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)\n          ? null     // thenFlow terminates: just inherit\n          : thenFlow // must become nonnull in thenFlow otherwise\n      );\n      return module.if(condExpr,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement,\n    isLastInBody: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var expr: ExpressionRef = 0;\n    var flow = this.currentFlow;\n    var returnType = flow.returnType;\n\n    var valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.CONV_IMPLICIT;\n      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {\n        flow.set(FlowFlags.MAY_RETURN_NONTHIS);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n    flow.freeScopedLocals();\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n\n    // Handle inline return\n    if (flow.isInline) {\n      return !expr\n        ? isLastInBody\n          ? module.nop()\n          : module.br(assert(flow.inlineReturnLabel))\n        : isLastInBody\n          ? expr\n          : this.currentType == Type.void\n            ? module.block(null, [ expr, module.br(assert(flow.inlineReturnLabel)) ])\n            : module.br(assert(flow.inlineReturnLabel), 0, expr);\n    }\n\n    // Otherwise emit a normal return\n    return !expr\n      ? isLastInBody\n        ? module.nop()\n        : module.return()\n      : isLastInBody\n        ? expr\n        : this.currentType == Type.void\n          ? module.block(null, [ expr, module.return() ])\n          : module.return(expr);\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    var module = this.module;\n\n    var cases = statement.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return this.compileExpression(statement.condition, Type.void,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n\n    // Everything within a switch uses the same break context\n    var outerFlow = this.currentFlow;\n    var context = outerFlow.pushBreakLabel();\n\n    // introduce a local for evaluating the condition (exactly once)\n    var tempLocal = outerFlow.getTempLocal(Type.u32);\n    var tempLocalIndex = tempLocal.index;\n\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\n    var breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set( // initializer\n      tempLocalIndex,\n      this.compileExpression(statement.condition, Type.u32,\n        Constraints.CONV_IMPLICIT\n      ),\n      false // u32\n    );\n\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\n    var breakIndex = 1;\n    var defaultIndex = -1;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let label = case_.label;\n      if (label) {\n        breaks[breakIndex++] = module.br(\"case\" + i.toString() + \"|\" + context,\n          module.binary(BinaryOp.EqI32,\n            module.local_get(tempLocalIndex, TypeRef.I32),\n            this.compileExpression(label, Type.u32,\n              Constraints.CONV_IMPLICIT\n            )\n          )\n        );\n      } else {\n        defaultIndex = i;\n      }\n    }\n\n    outerFlow.freeTempLocal(tempLocal);\n\n    // otherwise br to default respectively out of the switch if there is no default case\n    breaks[breakIndex] = module.br((defaultIndex >= 0\n      ? \"case\" + defaultIndex.toString()\n      : \"break\"\n    ) + \"|\" + context);\n\n    // nest blocks in order\n    var currentBlock = module.block(\"case0|\" + context, breaks, TypeRef.None);\n    var commonCategorical = FlowFlags.ANY_CATEGORICAL;\n    var commonConditional = 0;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Each switch case initiates a new branch\n      let innerFlow = outerFlow.fork();\n      this.currentFlow = innerFlow;\n      let breakLabel = \"break|\" + context;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : \"case\" + (i + 1).toString() + \"|\" + context;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let terminates = false;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;\n          break;\n        }\n      }\n      stmts.length = count;\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        commonCategorical &= innerFlow.flags;\n      }\n\n      commonConditional |= innerFlow.deriveConditionalFlags();\n\n      // Switch back to the parent flow\n      innerFlow.unset(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS\n      );\n      innerFlow.freeScopedLocals();\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popBreakLabel();\n\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;\n    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;\n    // TODO: what about local states?\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    var flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);\n\n    var stmts = new Array<ExpressionRef>();\n    var value = statement.value;\n    var message: Expression | null = null;\n    if (value.kind == NodeKind.NEW) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    flow.freeScopedLocals();\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var declarations = statement.declarations;\n    var numDeclarations = declarations.length;\n    var flow = this.currentFlow;\n    var initializers = new Array<ExpressionRef>();\n    var resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.CONV_IMPLICIT\n          );\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = this.currentType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.CONST);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a virtual local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.parentFunction.addLocal(type, name, declaration);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement, null);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                   flow\n    //  (loop $continue                  recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //                                            \n    //   (if (local.get $tcond)                    condition?\n    //    (body)                        bodyFlow \n    //                                           \n    //                                           breaks or terminates?\n    //    (br $continue)               \n    //   )                            \n    //  )                               \n    // )                              \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"while-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"while-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.FALSE) {\n      stmts.push(\n        module.drop(condExpr)\n      );\n      assert(!flow.hasScopedLocals);\n      outerFlow.popBreakLabel();\n      this.currentFlow = outerFlow;\n      return module.flatten(stmts);\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    var tcond = flow.getTempLocal(Type.bool);\n    stmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Simplify if body always terminates\n    if (bodyFlow.is(FlowFlags.TERMINATES)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n    // Terminate if condition is always true and body never breaks\n    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n      bodyStmts.push(\n        module.br(continueLabel)\n      );\n      flow.set(FlowFlags.TERMINATES);\n\n    } else {\n      let breaks = bodyFlow.is(FlowFlags.BREAKS);\n      if (breaks) {\n        bodyStmts.push(\n          module.unreachable()\n        );\n      } else {\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n      }\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      // Here: Only relevant if flow does not always break.\n      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        flow.freeTempLocal(tcond);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileWhileStatement(statement, flow);\n      }\n    }\n    stmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(bodyStmts)\n      )\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(stmts)\n      )\n    ]);\n    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));\n    var type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.INTEGER\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.INTEGER\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.PARENTHESIZED) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.ASSERTION: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.BINARY: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.CALL: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMMA: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.THIS:\n      case NodeKind.SUPER:\n      case NodeKind.TRUE: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.NEW: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMPILED: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.CLASS: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    var currentType = this.currentType;\n    var wrap = (constraints & Constraints.MUST_WRAP) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.CONV_EXPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.CONV_IMPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n\n    // void to any\n    if (fromType.kind == TypeKind.VOID) {\n      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.VOID) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // downcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);\n    switch (expression.assertionKind) {\n      case AssertionKind.PREFIX:\n      case AssertionKind.AS: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);\n      }\n      case AssertionKind.NONNULL: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.CLASS) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var left = expression.left;\n    var right = expression.right;\n\n    var leftExpr: ExpressionRef;\n    var leftType: Type;\n    var rightExpr: ExpressionRef;\n    var rightType: Type;\n    var commonType: Type | null;\n\n    var expr: ExpressionRef;\n    var compound = false;\n\n    var operator = expression.operator;\n    switch (operator) {\n      case Token.LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LESSTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EQUALS_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='\n          let classReference = leftType.getClassOrWrapper(this.program);\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.EQ);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EXCLAMATION_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='\n          let classReference = leftType.getClass();\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.NE);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EQUALS: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.PLUS_EQUALS: compound = true;\n      case Token.PLUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.ADD);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.MINUS_EQUALS: compound = true;\n      case Token.MINUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.SUB);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MUL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK_ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POW);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.SLASH_EQUALS: compound = true;\n      case Token.SLASH: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.DIV);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.PERCENT_EQUALS: compound = true;\n      case Token.PERCENT: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.REM);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;\n      case Token.LESSTHAN_LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.AMPERSAND_EQUALS: compound = true;\n      case Token.AMPERSAND: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.BAR_EQUALS: compound = true;\n      case Token.BAR: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.CARET_EQUALS: compound = true;\n      case Token.CARET: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfTrue(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.FALSE) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightFlow.freeScopedLocals();\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.TRUE) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, this.currentType, left),\n              rightExpr,\n              expr\n            );\n\n          // if not possible, tee left to a temp\n          } else {\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n            flow.freeTempLocal(tempLocal);\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfFalse(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.TRUE) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightFlow.freeScopedLocals();\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.FALSE) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              expr,\n              rightExpr\n            );\n\n          // if not possible, tee left to a temp. local\n          } else {\n            let temp = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(temp.index, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(temp.index, leftType.toRef()),\n              rightExpr\n            );\n            flow.freeTempLocal(temp);\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    var targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtI64\n            : BinaryOp.LtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtU64\n            : BinaryOp.LtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtI64\n            : BinaryOp.GtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtU64\n            : BinaryOp.GtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeI64\n            : BinaryOp.LeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeU64\n            : BinaryOp.LeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeI64\n            : BinaryOp.GeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeU64\n            : BinaryOp.GeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.EqI64\n            : BinaryOp.EqI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return module.ref_eq(leftExpr, rightExpr);\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AddI64\n            : BinaryOp.AddI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.MulI64\n            : BinaryOp.MulI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr,\n          TypeRef.I32\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let isWasm64 = this.options.isWasm64;\n        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivI64\n            : BinaryOp.DivI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivU64\n            : BinaryOp.DivU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemI64\n            : BinaryOp.RemI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemU64\n            : BinaryOp.RemU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShlI64\n            : BinaryOp.ShlI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrI64\n            : BinaryOp.ShrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AndI64\n            : BinaryOp.AndI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.OrI64\n            : BinaryOp.OrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.XorI64\n            : BinaryOp.XorI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    var rightType: Type;\n    if (operatorInstance.is(CommonFlags.INSTANCE)) {\n      assert(leftType.isStrictlyAssignableTo(operatorInstance.signature.parameterTypes[0]));\n      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);\n      rightType = operatorInstance.signature.parameterTypes[0];\n    } else {\n      rightType = operatorInstance.signature.parameterTypes[1];\n    }\n    leftExpr = this.convertExpression(leftExpr, leftType, operatorInstance.signature.parameterTypes[0], false, left);\n    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    var program = this.program;\n    var resolver = program.resolver;\n    var flow = this.currentFlow;\n    var target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    var elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    var targetType: Type;\n    switch (target.kind) {\n      case ElementKind.GLOBAL: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this\n        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element\n        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    var valueExpr = this.compileExpression(valueExpression, targetType);\n    var valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let initializerNode = fieldInstance.initializerNode;\n        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);\n\n        // Cannot assign to readonly fields except in constructors if there's no initializer\n        if (fieldInstance.is(CommonFlags.READONLY)) {\n          if (!isConstructor || initializerNode !== null) {\n            this.error(\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n              valueExpression.range, fieldInstance.internalName\n            );\n            return module.unreachable();\n          }\n        }\n\n        // Mark initialized fields in constructors\n        thisExpression = assert(thisExpression);\n        if (isConstructor && thisExpression.kind == NodeKind.THIS) {\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);\n        }\n\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        return this.makeFieldAssignment(fieldInstance,\n          valueExpr,\n          valueType,\n          this.compileExpression(\n            thisExpression,\n            (<Class>fieldParent).type,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          ),\n          tee\n        );\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let returnTypeRef = returnType.toRef();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, returnTypeRef)\n            ], valueExpression)\n          ], returnTypeRef);\n          flow.freeTempLocal(tempThis);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toRef());\n        }\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.CLASS);\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          flow.freeTempLocal(tempElement);\n          flow.freeTempLocal(tempTarget);\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var type = local.type;\n    assert(type != Type.void);\n    var localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var type = global.type;\n    assert(type != Type.void);\n    var typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef)\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Makes an assignment to a field. */\n  private makeFieldAssignment(\n    /** The field to assign to. */\n    field: Field,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** The value of `this`. */\n    thisExpr: ExpressionRef,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var fieldType = field.type;\n    var fieldTypeRef = fieldType.toRef();\n    assert(field.parent.kind == ElementKind.CLASS);\n    var thisType = (<Class>field.parent).type;\n\n    if (!field.is(CommonFlags.COMPILED)) {\n      field.set(CommonFlags.COMPILED);\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\n    }\n\n    if (tee) {\n      this.compileField(field);\n      let tempThis = flow.getTempLocal(thisType);\n      let expr = module.block(null, [\n        module.call(field.internalSetterName, [ module.local_tee(tempThis.index, thisExpr, thisType.isManaged), valueExpr ], TypeRef.None),\n        module.call(field.internalGetterName, [ module.local_get(tempThis.index, thisType.toRef()) ], fieldTypeRef)\n      ], fieldTypeRef);\n      flow.freeTempLocal(tempThis);\n      this.currentType = fieldType;\n      return expr;\n    } else {\n      this.compileFieldSetter(field);\n      let expr = module.call(field.internalSetterName, [ thisExpr, valueExpr ], TypeRef.None);\n      this.currentType = Type.void;\n      return expr;\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.SUPER) {\n      let flow = this.currentFlow;\n      let actualFunction = flow.actualFunction;\n      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(actualFunction.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.ACCESSES_THIS |\n        FlowFlags.CONDITIONALLY_ACCESSES_THIS\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    var target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = this.resolver.currentThisExpression;\n\n    var signature: Signature | null;\n    var functionArg: ExpressionRef;\n    switch (target.kind) {\n\n      // direct call: concrete function\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n\n      // indirect call: first-class function (non-generic, can't be inlined)\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        signature = local.type.signatureReference;\n        if (signature) {\n          if (local.is(CommonFlags.INLINED)) {\n            let inlinedValue = local.constantIntegerValue;\n            if (this.options.isWasm64) {\n              functionArg = module.i64(i64_low(inlinedValue), i64_high(inlinedValue));\n            } else {\n              assert(!i64_high(inlinedValue));\n              functionArg = module.i32(i64_low(inlinedValue));\n            }\n          } else {\n            functionArg = module.local_get(local.index, this.options.sizeTypeRef);\n          }\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, local.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        signature = global.type.signatureReference;\n        if (signature) {\n          functionArg = module.global_get(global.internalName, global.type.toRef());\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, global.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        signature = fieldType.signatureReference;\n        if (signature) {\n          let fieldParent = fieldInstance.parent;\n          assert(fieldParent.kind == ElementKind.CLASS);\n          let usizeType = this.options.usizeType;\n          functionArg = module.load(usizeType.byteSize, false,\n            this.compileExpression(\n              assert(thisExpression),\n              (<Class>fieldParent).type,\n              Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n            ),\n            usizeType.toRef(),\n            fieldInstance.memoryOffset\n          );\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, fieldType.toString()\n        );\n        return module.unreachable();\n      }\n\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        let type = assert(this.resolver.getTypeOfElement(target));\n\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, type.toString()\n          );\n          return module.unreachable();\n        }\n\n        let thisArg: ExpressionRef = 0;\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        functionArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\n        signature = this.currentType.signatureReference;\n        if (!signature) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>target;\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          signature = ftype.getSignature();\n          functionArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);\n          break;\n        }\n        // fall-through\n      }\n\n      // not supported\n      default: {\n        let type = this.resolver.getTypeOfElement(target);\n        if (type) {\n          this.error(\n            DiagnosticCode.Type_0_has_no_call_signatures,\n            expression.range, type.toString()\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            expression.range\n          );\n        }\n        return module.unreachable();\n      }\n    }\n    return this.compileCallIndirect(\n      assert(signature), // FIXME: bootstrap can't see this yet\n      functionArg,\n      expression.args,\n      expression,\n      0,\n      contextualType == Type.void\n    );\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    var call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    var typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.actualFunction.parent,\n        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    var callee = expression.expression;\n    var ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PROPERTYACCESS\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    var internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    var parent = prototype.parent;\n    if (parent.kind == ElementKind.CLASS) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    var thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    var hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range, \"Rest parameters\"\n      );\n      return false;\n    }\n\n    var minimum = signature.requiredParameters;\n    var maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n    var signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let actualFunction = this.currentFlow.actualFunction;\n    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {\n      let parent = actualFunction.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        inlineStack.push(instance);\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.CONV_IMPLICIT);\n        }\n        // make the inlined call\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.CONV_IMPLICIT);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WILL_DROP) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var numArguments = operands ? operands.length : 0;\n    var signature = instance.signature;\n    var parameterTypes = signature.parameterTypes;\n    var numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    var previousFlow = this.currentFlow;\n    var flow = Flow.createInline(previousFlow.parentFunction, instance);\n    var body = [];\n    var usedLocals = new Set<i32>();\n\n    // Prepare compiled arguments right to left, keeping track of used locals.\n    for (let i = numArguments - 1; i >= 0; --i) {\n      // This is necessary because a later expression must not set an earlier argument local, which\n      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where\n      // the right expression would reassign the foregoing argument local. So, we iterate from right\n      // to left, remembering what's used later, and don't use these for earlier arguments, making\n      // the example above essentially `t2=1, t1=(t1 = 2)`.\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);\n      findUsedLocals(paramExpr, usedLocals);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      body.unshift(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n    }\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);\n      body.unshift(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    var isConstructor = instance.is(CommonFlags.CONSTRUCTOR);\n    if (isConstructor) flow.set(FlowFlags.CTORPARAM_CONTEXT);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.CONV_IMPLICIT\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CTORPARAM_CONTEXT);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    flow.freeScopedLocals();\n    var returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    var name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    var stub = original.varargsStub;\n    if (stub) return stub;\n\n    var originalSignature = original.signature;\n    var originalParameterTypes = originalSignature.parameterTypes;\n    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    var returnType = originalSignature.returnType;\n    var isInstance = original.is(CommonFlags.INSTANCE);\n\n    // arguments excl. `this`, operands incl. `this`\n    var minArguments = originalSignature.requiredParameters;\n    var minOperands = minArguments;\n    var maxArguments = originalParameterTypes.length;\n    var maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    var numOptional = assert(maxOperands - minOperands);\n\n    var forwardedOperands = new Array<ExpressionRef>(minOperands);\n    var operandIndex = 0;\n    var stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    var module = this.module;\n    var thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\");\n    stub.signature.requiredParameters = maxArguments;\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    var previousFlow = this.currentFlow;\n    var flow = stub.flow;\n    if (original.is(CommonFlags.CONSTRUCTOR)) flow.set(FlowFlags.CTORPARAM_CONTEXT);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    var numNames = numOptional + 1; // incl. outer block\n    var names = new Array<string>(numNames);\n    var ofN = \"of\" + numOptional.toString();\n    for (let i = 0; i < numNames; ++i) {\n      let label = i.toString() + ofN;\n      names[i] = label;\n    }\n    var argumentsLength = this.ensureArgumentsLength();\n    var table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.CONV_IMPLICIT\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    flow.freeScopedLocals();\n    this.currentFlow = previousFlow;\n\n    var funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.additionalLocals),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.COMPILED);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the virtual stub for the specified function. */\n  ensureVirtualStub(original: Function): Function {\n    // A virtual stub is a function redirecting virtual calls to the actual\n    // overload targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    var stub = original.virtualStub;\n    if (stub) return stub;\n    stub = original.newStub(\"virtual\");\n    original.virtualStub = stub;\n    var module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.virtualStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the virtual stub of the specified function. */\n  private finalizeVirtualStub(instance: Function): void {\n    var stub = this.ensureVirtualStub(instance);\n    if (stub.is(CommonFlags.COMPILED)) return;\n\n    assert(instance.parent.kind == ElementKind.CLASS || instance.parent.kind == ElementKind.INTERFACE);\n    var module = this.module;\n    var usizeType = this.options.usizeType;\n    var sizeTypeRef = usizeType.toRef();\n    var parameterTypes = instance.signature.parameterTypes;\n    var returnType = instance.signature.returnType;\n    var numParameters = parameterTypes.length;\n    var tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    var builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    var overloadInstances = this.resolver.resolveOverloads(instance);\n    if (overloadInstances) {\n      for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n        let overloadInstance = overloadInstances[i];\n        if (!overloadInstance.is(CommonFlags.COMPILED)) continue; // errored\n        let overloadType = overloadInstance.type;\n        let originalType = instance.type;\n        if (!overloadType.isAssignableTo(originalType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overloadSignature = overloadInstance.signature;\n        let overloadParameterTypes = overloadSignature.parameterTypes;\n        let overloadNumParameters = overloadParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overloadNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overloadInstance).internalName\n          : overloadInstance.internalName;\n        let returnTypeRef = overloadSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overloadInstance.getClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extendee inheriting this exact overload\n        let extendees = classInstance.getAllExtendees(instance.declaration.name.text); // without get:/set:\n        for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\n          let extendee = _values[a];\n          builder.addCase(extendee.id, stmts);\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extendees inheriting the original function.\n    var body: ExpressionRef;\n    if (instance.prototype.bodyNode) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the virtual stub function\n    var ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.COMPILED);\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    var module = this.module;\n    var operandIndex = 0;\n    var thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    var parameterIndex = 0;\n    var parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.INLINE)) {\n      if (!instance.is(CommonFlags.VIRTUAL)) {\n        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.INSTANCE)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = instance.signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = instance.signature.parameterTypes;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (instance.is(CommonFlags.INSTANCE)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    var returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.CONV_IMPLICIT\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);\n          if (resolved) {\n            if (resolved.kind == ElementKind.GLOBAL) {\n              let global = <Global>resolved;\n              if (this.compileGlobal(global)) {\n                if (global.is(CommonFlags.INLINED)) {\n                  operands.push(\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)\n                  );\n                } else {\n                  operands.push(\n                    this.convertExpression(\n                      module.global_get(global.internalName, global.type.toRef()),\n                      global.type, parameterTypes[i], false, initializer\n                    )\n                  );\n                }\n                continue;\n              }\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i], instance.declaration));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.MODULE_IMPORT)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the virtual stub with the vtable if the function has overloads\n    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureVirtualStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    var expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = signature.parameterTypes;\n    var returnType = signature.returnType;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i], reportNode));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    var argumentsLength = this.ensureArgumentsLength();\n    var sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(functionArg));\n      functionArg = module.block(null, [\n        module.local_set(temp.index, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(temp.index, sizeTypeRef)\n      ], sizeTypeRef);\n      flow.freeTempLocal(temp);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    var expr = module.call_indirect(\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    var exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var targetExpression = expression.expression;\n    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.CONV_IMPLICIT\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n    var isNamed = declaration.name.text.length > 0;\n    var isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    var prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? (isNamed ? declaration.name.text + \"|\" : \"anonymous|\") + (actualFunction.nextAnonymousId++).toString()\n        : declaration.name.text,\n      actualFunction,\n      declaration,\n      DecoratorFlags.NONE\n    );\n    var instance: Function | null;\n    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);\n    var module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    var contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            actualFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n      signature.requiredParameters = numParameters; // !\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    var offset = this.ensureRuntimeFunction(instance); // reports\n    var expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    var internalPath = expression.range.source.internalPath;\n    var filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    var enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.COMPILED)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.NULL: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType, expression);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.TRUE: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.FALSE: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.THIS: {\n        let thisType = actualFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IS_THIS)) {\n            let parent = actualFunction.parent;\n            assert(parent.kind == ElementKind.CLASS);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.ACCESSES_THIS);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.SUPER: {\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CALLS_SUPER)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (actualFunction.is(CommonFlags.INSTANCE)) {\n          let parent = assert(actualFunction.parent);\n          assert(parent.kind == ElementKind.CLASS);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    var currentParent = this.currentParent;\n    if (!currentParent) currentParent = actualFunction;\n    var target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.parentFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toRef());\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.COMPILED)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Expected_0_arguments_but_got_1,\n            expression.range, typeParameterNodes.length.toString(), \"0\"\n          );\n          return module.unreachable();\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          uniqueMap<string,Type>(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (contextualType.isExternalReference) {\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName, TypeRef.Funcref); // TODO\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var flow = this.currentFlow;\n    var isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NAMEDTYPE) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);\n        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.GENERIC)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    var expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.actualFunction,\n      uniqueMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var expr = this.compileExpression(expression.expression, expectedType);\n    var actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    var sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // downcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType, expression.expression)\n        );\n      }\n\n      // upcast - check dynamically\n      if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // downcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n\n      // upcast - check dynamically\n      } else if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          // FIXME: the temp local and the if can be removed here once flows\n          // perform null checking, which would error earlier when checking\n          // uninitialized (thus zero) `var a: A` to be an instance of something.\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    var module = this.module;\n    var expr = this.compileExpression(expression.expression, Type.auto);\n    var actualType = this.currentType;\n    var sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    var classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extends(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType, expression.expression)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        this.pendingClassInstanceOf.add(prototype);\n        return module.call(prototype.internalName + \"~instanceof\", [ expr ], TypeRef.I32);\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.ARRAY: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.FLOAT: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.INTEGER: {\n        let intValue = (<IntegerLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          intValue = i64_sub(\n            i64_new(0),\n            intValue\n          );\n        }\n        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);\n        this.currentType = type;\n        switch (type.kind) {\n          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.STRING: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.TEMPLATE: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.OBJECT: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.REGEXP: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    var tag = expression.tag;\n    var parts = expression.parts;\n    var numParts = parts.length;\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    assert(numExpressions == numParts - 1);\n\n    var module = this.module;\n    var stringInstance = this.program.stringInstance;\n    var stringType = stringInstance.type;\n\n    if (tag === null) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`\n      if (numParts == 2) {\n        let expression = expressions[0];\n        let lhsLen = parts[0].length;\n        let rhsLen = parts[1].length;\n        // Shortcut for `${expr}`  ->   expr.toString()\n        if (!lhsLen && !rhsLen) {\n          return this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n        }\n        // Shortcuts for\n        // `<prefix>${expr}`  ->  \"<prefix>\" + expr.toString()\n        // `${expr}<suffix>`  ->  expr.toString() + \"<suffix>\"\n        let hasPrefix = lhsLen != 0;\n        // @ts-ignore: cast\n        if (hasPrefix ^ (rhsLen != 0)) {\n          let lhs: ExpressionRef;\n          let rhs: ExpressionRef;\n          let expr = this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n          if (hasPrefix) {\n            lhs = this.ensureStaticString(parts[0]);\n            rhs = expr;\n          } else {\n            // suffix\n            lhs = expr;\n            rhs = this.ensureStaticString(parts[1]);\n          }\n          let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n        }\n      }\n\n      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()\n      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {\n        let exprA = expressions[0];\n        let exprB = expressions[1];\n\n        let lhs = this.makeToString(\n          this.compileExpression(exprA, stringType),\n          this.currentType, exprA\n        );\n        let rhs = this.makeToString(\n          this.compileExpression(exprB, stringType),\n          this.currentType, exprB\n        );\n        let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n      }\n\n      // Compile to a `StaticArray<string>#join(\"\") in the general case\n      let length = numParts + numExpressions;\n      let values = new Array<usize>(length);\n      values[0] = this.ensureStaticString(parts[0]);\n      for (let i = 1; i < numParts; ++i) {\n        values[2 * i - 1] = module.usize(0);\n        values[2 * i] = this.ensureStaticString(parts[i]);\n      }\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true));\n      let stmts = new Array<ExpressionRef>(2 * numExpressions + 1);\n      // Use one local per toString'ed subexpression, since otherwise recursion on the same\n      // static array would overwrite already prepared parts. Avoids a temporary array.\n      let temps = new Array<Local>(numExpressions);\n      let flow = this.currentFlow;\n      for (let i = 0; i < numExpressions; ++i) {\n        let expression = expressions[i];\n        let temp = flow.getTempLocal(stringType);\n        temps[i] = temp;\n        stmts[i] = module.local_set(temp.index,\n          this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          ),\n          true\n        );\n      }\n      // Populate the static array with the toString'ed subexpressions and call .join(\"\")\n      for (let i = 0; i < numExpressions; ++i) {\n        stmts[numExpressions + i] = this.makeCallDirect(indexedSetInstance, [\n          module.usize(offset),\n          module.i32(2 * i + 1),\n          module.local_get(temps[i].index, stringType.toRef())\n        ], expression);\n        flow.freeTempLocal(temps[i]);\n      }\n      stmts[2 * numExpressions] = this.makeCallDirect(joinInstance, [\n        module.usize(offset),\n        this.ensureStaticString(\"\")\n      ], expression);\n      return module.flatten(stmts, stringType.toRef());\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    var tsaArrayInstance = this.program.templateStringsArrayInstance;\n    var arrayInstance = tsaArrayInstance;\n    var target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            uniqueMap<string,Type>(),\n            ReportMode.SWALLOW\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.FUNCTION: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first !== null && !first.extends(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    var rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    var partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    var arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      var rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      var rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    var args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        this.program.nativeRange\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    var element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.CLASS);\n    var arrayInstance = <Class>element;\n    var arrayType = arrayInstance.type;\n    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    var arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PREFER_STATIC) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!indexedSet) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var arrayTypeRef = arrayType.toRef();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    var dataStartMember = assert(arrayInstance.getMember(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.FIELD);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, arrayTypeRef),\n          arrayTypeRef,\n          (<Field>dataStartMember).memoryOffset\n        ),\n        true // ArrayBuffer\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    flow.freeTempLocal(tempThis);\n    flow.freeTempLocal(tempDataStart);\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    assert(!arrayInstance.extends(program.staticArrayPrototype));\n    var elementType = arrayInstance.getArrayValueType(); // asserts\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    var expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    var arrayInstance = assert(contextualType.getClass());\n    var arrayType = arrayInstance.type;\n    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    var elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    var isWasm64 = this.options.isWasm64;\n    var bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PREFER_STATIC) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!indexedSet) {\n      flow.freeTempLocal(tempThis);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var arrayTypeRef = arrayType.toRef();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    flow.freeTempLocal(tempThis);\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    var module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    var classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    var classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    var ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    var isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    var names = expression.names;\n    var numNames = names.length;\n    var values = expression.values;\n    var members = classReference.members;\n    var hasErrors = false;\n    var exprs = new Array<ExpressionRef>();\n    var flow = this.currentFlow;\n    var tempLocal = flow.getTempLocal(classType);\n    var classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    var omittedFields = new Set<Field>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member !== null && member.kind == ElementKind.FIELD) {\n          omittedFields.add(<Field>member); // incl. private/protected\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.FIELD) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PRIVATE)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PROTECTED)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let fieldInstance = <Field>member;\n      let fieldType = fieldInstance.type;\n\n      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT);\n      exprs.push(\n        module.call(fieldInstance.internalSetterName, [\n          module.local_get(tempLocal.index, classTypeRef),\n          expr\n        ], TypeRef.None)\n      );\n      this.compileFieldSetter(fieldInstance);\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(fieldInstance);\n    }\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let fieldInstance = _values[j];\n      let fieldType = fieldInstance.type;\n\n      if (fieldInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (fieldType.isReference) {\n        if (!fieldType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (fieldType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.ISIZE:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.USIZE:\n        case TypeKind.BOOL:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          exprs.push(\n            module.call(fieldInstance.internalSetterName, [\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(fieldType, expression)\n            ], TypeRef.None)\n          );\n          this.compileFieldSetter(fieldInstance);\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    var ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.NONE, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    if (!isManaged) flow.freeTempLocal(tempLocal);\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.CLASS_PROTOTYPE) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    var classPrototype = <ClassPrototype>target;\n    var classInstance: Class | null = null;\n    var typeArguments = expression.typeArguments;\n    var classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) !== null &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.GENERIC)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        uniqueMap<string,Type>(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.actualFunction.parent, // relative to caller\n        uniqueMap<string,Type>(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    var instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.COMPILED)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR\n            )\n          ),\n          null,\n          new Signature(this.program, null, classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.COMPILED);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.MODULE_EXPORT)) {\n        instance.set(CommonFlags.MODULE_EXPORT);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(\"constructor\", instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      flow.freeScopedLocals();\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    var ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    var members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {\n          let field = <Field>element;\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {\n            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n              if (relatedNode) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  relatedNode.range,\n                  field.internalName\n                );\n              } else {\n                this.error(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  field.internalName\n                );\n              }\n            }\n          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n            if (field.type.isReference) {\n              this.warning( // involves a runtime check\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n                field.identifierNode.range,\n                field.internalName\n              );\n            } else {\n              this.pedantic( // is a nop anyway\n                DiagnosticCode.Unnecessary_definite_assignment,\n                field.identifierNode.range\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));\n    var parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    var classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n    var expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType, reportNode),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.GLOBAL: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.ENUMVALUE: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.ENUM);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        assert(fieldInstance.memoryOffset >= 0);\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        thisExpression = assert(thisExpression);\n        let thisExpr = this.compileExpression(\n          thisExpression,\n          (<Class>fieldParent).type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let thisType = this.currentType;\n        if (\n          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&\n          thisExpression.kind == NodeKind.THIS &&\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&\n          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)\n        ) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\n            expression.range,\n            fieldInstance.identifierNode.range,\n            fieldInstance.internalName\n          );\n        }\n        if (thisType.isNullableReference) {\n          if (!flow.isNonnull(thisExpr, thisType)) {\n            this.error(\n              DiagnosticCode.Object_is_possibly_null,\n              thisExpression.range\n            );\n          }\n        }\n        if (!fieldInstance.is(CommonFlags.COMPILED)) {\n          fieldInstance.set(CommonFlags.COMPILED);\n          let typeNode = fieldInstance.typeNode;\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\n        }\n        this.currentType = fieldType;\n        let ret = module.load(\n          fieldType.byteSize,\n          fieldType.isSignedIntegerValue,\n          thisExpr,\n          fieldType.toRef(),\n          fieldInstance.memoryOffset\n        );\n        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\n        }\n        return ret;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var ifThen = expression.ifThen;\n    var ifElse = expression.ifElse;\n\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(expression.condition, Type.bool),\n      this.currentType,\n      expression.condition\n    );\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    var condKind = this.evaluateCondition(condExpr);\n    if (condKind == ConditionKind.TRUE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.FALSE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\n    }\n\n    var outerFlow = this.currentFlow;\n    var ifThenFlow = outerFlow.fork();\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = ifThenFlow;\n    var ifThenExpr = this.compileExpression(ifThen, ctxType);\n    var ifThenType = this.currentType;\n\n    var ifElseFlow = outerFlow.fork();\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\n    this.currentFlow = ifElseFlow;\n    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);\n    var ifElseType = this.currentType;\n\n    if (ctxType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = ctxType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    ifThenFlow.freeScopedLocals();\n    ifElseFlow.freeScopedLocals();\n\n    this.currentFlow = outerFlow;\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\n\n    return module.if(condExpr, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    var getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.NONE\n    );\n\n    // shortcut if compiling the getter already failed\n    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    var tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS_PLUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      if (tempLocal) flow.freeTempLocal(tempLocal);\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    var setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    flow.freeTempLocal(tempLocal);\n    var typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var compound = false;\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PLUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.MINUS: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MINUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              this.makeZero(this.currentType, expression.operand),\n              expr\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.PLUS_PLUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.EXCLAMATION: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.TILDE: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.XorI64\n                : BinaryOp.XorI32,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TYPEOF: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.DOT_DOT_DOT: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var operand = expression.operand;\n    var expr: ExpressionRef = 0;\n    var stringInstance = this.program.stringInstance;\n    var typeString: string;\n    if (operand.kind == NodeKind.NULL) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PROPERTYACCESS:\n          case NodeKind.ELEMENTACCESS: {\n            operand = operand.kind == NodeKind.PROPERTYACCESS\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.CLASS_PROTOTYPE:\n          case ElementKind.NAMESPACE:\n          case ElementKind.ENUM: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype === stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n      case TypeKind.BOOL: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    var parentFunction = this.currentFlow.parentFunction;\n    var source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    parentFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    var supported = true;\n    var explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    var parameterTypes = signature.parameterTypes;\n    var parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.UNKNOWN;\n\n    assert(type == TypeRef.I32);\n    var module = this.module;\n    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.TRUE\n        : ConditionKind.FALSE;\n    }\n    return ConditionKind.UNKNOWN;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF: return module.ref_null(type.toRef());\n      case TypeKind.I31REF: return module.i31_new(module.i32(0));\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31REF: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.BOOL: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n        //\n        // and finally:\n        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n        return module.binary(BinaryOp.LeU32,\n          module.binary(BinaryOp.SubI32,\n            module.binary(BinaryOp.ShlI32,\n              module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n              module.i32(1)\n            ),\n            module.i32(2) // 1 << 1\n          ),\n          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n        );\n      }\n      case TypeKind.F64: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n        //\n        // and finally:\n        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n        return module.binary(BinaryOp.LeU64,\n          module.binary(BinaryOp.SubI64,\n            module.binary(BinaryOp.ShlI64,\n              module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n              module.i64(1)\n            ),\n            module.i64(2) // 1 << 1\n          ),\n          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n        );\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is(RefIsOp.RefIsNull, expr));\n\n      }\n      default: {\n        assert(false);\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    var classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          this.errorRelated(\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n            reportNode.range, toStringInstance.identifierAndSignatureRange\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return this.module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    var program = this.program;\n    assert(classInstance.program == program);\n    var module = this.module;\n    var options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    var module = this.module;\n    var classType = classInstance.type;\n    var classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    var members = classInstance.members;\n    if (!members) return stmts;\n\n    var module = this.module;\n    var flow = this.currentFlow;\n    var isInline = flow.isInline;\n    var thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    var sizeTypeRef = this.options.sizeTypeRef;\n    var nonParameterFields: Field[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (\n        member.kind != ElementKind.FIELD || // not a field\n        member.parent != classInstance      // inherited field\n      ) continue;\n      let field = <Field>member;\n      assert(!field.isAny(CommonFlags.CONST));\n      let fieldPrototype = field.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(field);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = field.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      this.compileFieldSetter(field);\n      stmts.push(\n        module.call(field.internalSetterName, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          module.local_get(\n            isInline\n              ? flow.lookupLocal(field.name)!.index\n              : 1 + parameterIndex, // `this` is local 0\n            fieldTypeRef\n          )\n        ], TypeRef.None)\n      );\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        this.compileFieldSetter(field);\n        stmts.push(\n          module.call(field.internalSetterName, [\n            module.local_get(thisLocalIndex, sizeTypeRef),\n            initializerNode // use initializer if present, otherwise initialize with zero\n              ? this.compileExpression(initializerNode, fieldType, Constraints.CONV_IMPLICIT)\n              : this.makeZero(fieldType, fieldPrototype.declaration)\n          ], TypeRef.None)\n        );\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    var stringInstance = program.stringInstance;\n    var messageArg: ExpressionRef;\n    if (message !== null) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT);\n    } else {\n      messageArg = this.makeZero(stringInstance.type, codeLocation);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    var range = codeLocation.range;\n    var source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        TypeRef.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n    expr = module.if(\n      module.local_tee(temp.index, expr, type.isManaged),\n      module.local_get(temp.index, type.toRef()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected null\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */\n  makeRuntimeUpcastCheck(\n    /** Expression being upcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    var instanceofInstance = this.program.instanceofInstance;\n    assert(this.compileFunction(instanceofInstance));\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      expr = module.if(\n        module.call(instanceofInstance.internalName, [\n          module.local_tee(temp.index, expr, type.isManaged),\n          module.i32(toType.classReference!.id)\n        ], TypeRef.I32),\n        module.local_get(temp.index, type.toRef()),\n        this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(temp.index, expr, type.isManaged),\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(temp.index, type.toRef()),\n            module.i32(toType.classReference!.id)\n          ], TypeRef.I32),\n          module.local_get(temp.index, type.toRef()),\n          this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n        ),\n        module.usize(0)\n      );\n    }\n    flow.freeTempLocal(temp);\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.INSTANCE), true\n  );\n  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;\n\n  var program = element.program;\n  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));\n  var args = decorator.args;\n  if (args !== null && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.STRING)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.STRING)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nvar mangleImportName_moduleName: string;\nvar mangleImportName_elementName: string;\n","/**\n * @fileoverview Builders for various definitions describing a module.\n *\n * - TSDBuilder: Creates a TypeScript definition file (.d.ts)\n * - IDLBuilder: Creates a WebIDL interface definition (.webidl)\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  Program,\n  Element,\n  ElementKind,\n  Global,\n  Enum,\n  EnumValue,\n  Field,\n  Function,\n  FunctionPrototype,\n  Class,\n  ClassPrototype,\n  Namespace,\n  ConstantValueKind,\n  Interface,\n  Property,\n  PropertyPrototype,\n  File\n} from \"./program\";\n\nimport {\n  Type,\n  TypeKind\n} from \"./types\";\n\nimport {\n  SourceKind\n} from \"./ast\";\n\nimport {\n  indent\n} from \"./util\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;\n    var seen = this.seen;\n    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.ENUMVALUE: break; // handled by visitEnum\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TYPEDEFINITION: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitField(name: string, element: Field): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n/** A WebIDL definitions builder. */\nexport class IDLBuilder extends ExportsWalker {\n\n  /** Builds WebIDL definitions for the specified program. */\n  static build(program: Program): string {\n    return new IDLBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (isConst) sb.push(\"const \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\" \");\n    sb.push(name);\n    if (isConst) {\n      switch (element.constantValueKind) {\n        case ConstantValueKind.INTEGER: {\n          sb.push(\" = \");\n          sb.push(i64_to_string(element.constantIntegerValue));\n          break;\n        }\n        case ConstantValueKind.FLOAT: {\n          sb.push(\" = \");\n          sb.push(element.constantFloatValue.toString());\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    sb.push(\";\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          let isConst = enumValue.is(CommonFlags.INLINED);\n          indent(sb, this.indentLevel);\n          if (isConst) sb.push(\"const \");\n          else sb.push(\"readonly \");\n          sb.push(\"unsigned long \");\n          sb.push(memberName);\n          if (isConst) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(this.typeToString(signature.returnType));\n    sb.push(\" \");\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(this.typeToString(parameters[i]));\n      sb.push(\" \");\n      sb.push(element.getParameterName(i));\n    }\n    sb.push(\");\\n\");\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      indent(sb, this.indentLevel);\n      sb.push(\"interface \");\n      sb.push(element.name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    // TODO\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    // TODO\n  }\n\n  visitNamespace(name: string, element: Namespace): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // TODO\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"byte\";\n      case TypeKind.I16: return \"short\";\n      case TypeKind.I32: return \"long\";\n      case TypeKind.I64: return \"long long\";\n      case TypeKind.ISIZE: return this.program.options.isWasm64 ? \"long long\" : \"long\";\n      case TypeKind.U8: return \"octet\";\n      case TypeKind.U16: return \"unsigned short\";\n      case TypeKind.U32: return \"unsigned long\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"unsigned long long\";\n      case TypeKind.USIZE: return this.program.options.isWasm64 ? \"unsigned long long\" : \"unsigned long\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"boolean\";\n      case TypeKind.F32: return \"unrestricted float\";\n      case TypeKind.F64: return \"unrestricted double\";\n      case TypeKind.VOID: return \"void\";\n      default: {\n        assert(false);\n        return \"\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    sb.push(\"interface ASModule {\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program): string {\n    return new TSDBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.STATIC)) {\n      if (isConst) sb.push(\"static readonly \");\n      else sb.push(\"static \");\n    } else {\n      if (isConst) sb.push(\"export const \");\n      else sb.push(\"export var \");\n    }\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (element.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    var remainingMembers = 0;\n    if (members) {\n      remainingMembers = members.size;\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          indent(sb, this.indentLevel);\n          sb.push(memberName);\n          if (member.is(CommonFlags.INLINED)) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\",\\n\");\n          --remainingMembers;\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    if (remainingMembers) this.visitNamespace(name, element);\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.isAny(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) {\n      sb.push(\"export function \");\n    } else {\n      if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n      if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n      if (element.is(CommonFlags.GET)) sb.push(\"get \");\n      else if (element.is(CommonFlags.SET)) sb.push(\"set \");\n    }\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.typeToString(parameters[i]));\n    }\n    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {\n      sb.push(\")\");\n    } else {\n      sb.push(\"): \");\n      sb.push(this.typeToString(signature.returnType));\n    }\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    var isInterface = element.kind == ElementKind.INTERFACE;\n    indent(sb, this.indentLevel++);\n    if (isInterface) {\n      sb.push(\"export interface \");\n    } else {\n      sb.push(\"export \");\n      if (element.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n      sb.push(\"class \");\n    }\n    sb.push(name);\n    var base = element.base;\n    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {\n      sb.push(\" extends \");\n      let extendsNode = assert(element.prototype.extendsNode);\n      sb.push(extendsNode.name.identifier.text); // TODO: fqn?\n    }\n    sb.push(\" {\\n\");\n    if (!isInterface) {\n      indent(sb, this.indentLevel);\n      sb.push(\"static wrap(ptr: usize): \");\n      sb.push(name);\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf(): usize;\\n\");\n    }\n    var staticMembers = element.prototype.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    var instanceMembers = element.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.parent == element) { // own member\n          this.visitElement(member.name, member);\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    if (element.is(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.READONLY)) sb.push(\"readonly \");\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      let sb = this.sb;\n      indent(sb, this.indentLevel++);\n      sb.push(\"export namespace \");\n      sb.push(name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"export const \");\n    sb.push(name);\n    sb.push(\": typeof \");\n    sb.push(originalName);\n    sb.push(\";\\n\");\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.VOID: return \"void\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      case TypeKind.EQREF: return \"eqref\";\n      case TypeKind.I31REF: return \"i31ref\";\n      case TypeKind.DATAREF: return \"dataref\";\n      default: {\n        assert(false);\n        return \"any\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    var options = this.program.options;\n    sb.push(\"type i8 = number;\\n\");\n    sb.push(\"type i16 = number;\\n\");\n    sb.push(\"type i32 = number;\\n\");\n    sb.push(\"type i64 = bigint;\\n\");\n    if (options.isWasm64) {\n      sb.push(\"type isize = bigint;\\n\");\n    } else {\n      sb.push(\"type isize = number;\\n\");\n    }\n    sb.push(\"type u8 = number;\\n\");\n    sb.push(\"type u16 = number;\\n\");\n    sb.push(\"type u32 = number;\\n\");\n    sb.push(\"type u64 = bigint;\\n\");\n    if (options.isWasm64) {\n      sb.push(\"type usize = bigint;\\n\");\n    } else {\n      sb.push(\"type usize = number;\\n\");\n    }\n    sb.push(\"type f32 = number;\\n\");\n    sb.push(\"type f64 = number;\\n\");\n    sb.push(\"type bool = boolean | number;\\n\");\n    this.walk();\n    if (options.exportMemory) {\n      sb.push(\"export const memory: WebAssembly.Memory;\\n\");\n    }\n    if (options.exportTable) {\n      sb.push(\"export const table: WebAssembly.Table;\\n\");\n    }\n    if (options.explicitStart) {\n      sb.push(\"export function _start(): void;\\n\");\n    }\n    if (options.exportRuntime) {\n      sb.push(\"export function __new(size: usize, id: u32): usize;\\n\");\n      sb.push(\"export function __pin(ptr: usize): usize;\\n\");\n      sb.push(\"export function __unpin(ptr: usize): void;\\n\");\n      sb.push(\"export function __collect(): void;\\n\");\n      sb.push(\"export const __rtti_base: usize;\\n\");\n    }\n    sb.push(\"export const __setArgumentsLength: ((n: i32) => void) | undefined;\\n\");\n    return this.sb.join(\"\");\n  }\n}\n\n// helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nfunction hasCompiledMember(element: Element): bool {\n  var members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.CLASS_PROTOTYPE: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n","/**\n * @fileoverview Generated from diagnosticsMessages.json. Do not edit.\n * @license Apache-2.0\n */\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Cannot_export_a_mutable_global = 205,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime = 234,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  Exported_generic_function_or_class_has_no_concrete_instances = 907,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 205: return \"Cannot export a mutable global.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression refers to a static element that does not compile to a value at runtime.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"Exported generic function or class has no concrete instances.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n","/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  PEDANTIC,\n  /** Informatory message. */\n  INFO,\n  /** Warning message. */\n  WARNING,\n  /** Error message. */\n  ERROR\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return \"PEDANTIC\";\n    case DiagnosticCategory.INFO: return \"INFO\";\n    case DiagnosticCategory.WARNING: return \"WARNING\";\n    case DiagnosticCategory.ERROR: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;\n    case DiagnosticCategory.INFO: return COLOR_CYAN;\n    case DiagnosticCategory.WARNING: return COLOR_YELLOW;\n    case DiagnosticCategory.ERROR: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    var message = diagnosticCodeToString(code);\n    if (arg0 !== null) message = message.replace(\"{0}\", arg0);\n    if (arg1 !== null) message = message.replace(\"{1}\", arg1);\n    if (arg2 !== null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    var thisRange = this.range;\n    var otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    var thisRelatedRange = this.relatedRange;\n    var otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    var range = this.range;\n    if (range) {\n      let source = range.source;\n      return (\n        diagnosticCategoryToString(this.category) +\n        \" \" +\n        this.code.toString() +\n        \": \\\"\" +\n        this.message +\n        \"\\\" in \" +\n        source.normalizedPath +\n        \"(\" +\n        source.lineAt(range.start).toString() +\n        \",\" +\n        source.columnAt().toString() +\n        \"+\" +\n        (range.end - range.start).toString() +\n        \")\"\n      );\n    }\n    return (\n      diagnosticCategoryToString(this.category) +\n      \" \" +\n      this.code.toString() +\n      \": \" +\n      this.message\n    );\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  var wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  var sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  var range = message.range;\n  if (range) {\n    let source = range.source;\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range));\n    }\n    sb.push(\"\\n\");\n    sb.push(\" in \");\n    sb.push(source.normalizedPath);\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    let relatedRange = message.relatedRange;\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange));\n      }\n      sb.push(\"\\n\");\n      sb.push(\" in \");\n      sb.push(relatedSource.normalizedPath);\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range): string {\n  var text = range.source.text;\n  var len = text.length;\n  var start = range.start;\n  var end = range.end;\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  var sb: string[] = [\n    \"\\n \",\n    text.substring(start, end),\n    \"\\n \"\n  ];\n  while (start < range.start) {\n    sb.push(\" \");\n    start++;\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      if (isLineBreak(text.charCodeAt(start))) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      }\n      sb.push(\"~\");\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n","/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    var builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.SOURCE: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TYPEPARAMETER: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.SUPER:\n      case NodeKind.THIS:\n      case NodeKind.TRUE:\n      case NodeKind.CONSTRUCTOR:\n      case NodeKind.IDENTIFIER: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.ASSERTION: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.BINARY: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.CALL: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.CLASS: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.COMMA: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.NEW: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.PARENTHESIZED: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.BLOCK: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.BREAK: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.DO: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.EXPORT: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTIMPORT: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.FOR: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.FOROF: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.IF: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.RETURN: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.THROW: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.TRY: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.WHILE: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMVALUEDECLARATION: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.IMPORTDECLARATION: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.METHODDECLARATION: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VARIABLEDECLARATION: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.DECORATOR: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.EXPORTMEMBER: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.PARAMETER: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SWITCHCASE: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.INDEXSIGNATURE: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    var statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    var sb = this.sb;\n    var current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    var typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    var isNullable = node.isNullable;\n    var sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    var explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    var parameters = node.parameters;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    var returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"[\");\n    var elements = node.elementExpressions;\n    var numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    var sb = this.sb;\n    var names = node.names;\n    var values = node.values;\n    var numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name === value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    var sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.PREFIX: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.AS: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NONNULL: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.CONST: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    var sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    var numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    var declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    var expressions = node.expressions;\n    var numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    var sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    var declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.FLOAT: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.INTEGER: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.STRING: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.TEMPLATE: {\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.REGEXP: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.ARRAY: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.OBJECT: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    this.sb.push(i64_to_string(node.value));\n  }\n\n  visitStringLiteral(str: string): void {\n    var sb = this.sb;\n    sb.push(\"\\\"\");\n    this.visitRawString(str, CharCode.DOUBLEQUOTE);\n    sb.push(\"\\\"\");\n  }\n\n  private visitRawString(str: string, quote: CharCode): void {\n    var sb = this.sb;\n    var off = 0;\n    var i = 0;\n    for (let k = str.length; i < k;) {\n      switch (str.charCodeAt(i)) {\n        case CharCode.NULL: {\n          if (i > off) sb.push(str.substring(off, off = i + 1));\n          sb.push(\"\\\\0\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKSPACE: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\b\");\n          break;\n        }\n        case CharCode.TAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\t\");\n          break;\n        }\n        case CharCode.LINEFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\n\");\n          break;\n        }\n        case CharCode.VERTICALTAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\v\");\n          break;\n        }\n        case CharCode.FORMFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\f\");\n          break;\n        }\n        case CharCode.CARRIAGERETURN: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\r\");\n          off = ++i;\n          break;\n        }\n        case CharCode.DOUBLEQUOTE: {\n          if (quote == CharCode.DOUBLEQUOTE) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\\\\"\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.SINGLEQUOTE: {\n          if (quote == CharCode.SINGLEQUOTE) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\'\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.BACKSLASH: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\\\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKTICK: {\n          if (quote == CharCode.BACKTICK) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\`\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        default: {\n          ++i;\n          break;\n        }\n      }\n    }\n    if (i > off) sb.push(str.substring(off, i));\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\n    var sb = this.sb;\n    var tag = node.tag;\n    var parts = node.parts;\n    var expressions = node.expressions;\n    if (tag) this.visitNode(tag);\n    sb.push(\"`\");\n    this.visitRawString(parts[0], CharCode.BACKTICK);\n    assert(parts.length == expressions.length + 1);\n    for (let i = 0, k = expressions.length; i < k; ++i) {\n      sb.push(\"${\");\n      this.visitNode(expressions[i]);\n      sb.push(\"}\");\n      this.visitRawString(parts[i + 1], CharCode.BACKTICK);\n    }\n    sb.push(\"`\");\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    var sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    var sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||\n        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    var sb = this.sb;\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    var indexSignature = node.indexSignature;\n    var members = node.members;\n    var numMembers = members.length;\n    if (indexSignature !== null || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    var sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.statement);\n    if (node.statement.kind == NodeKind.BLOCK) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    var values = node.values;\n    var numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    var sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    var members = node.members;\n    if (members == null) {\n      sb.push(\"export *\");\n    } else if (members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    var path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    var declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    var type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    var initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    var condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    var incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    var sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    var signature = node.signature;\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    var body = node.body;\n    var returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    var sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    var ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.BLOCK) {\n      sb.push(\";\\n\");\n    }\n    var ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.BLOCK) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    var externalName = node.foreignName;\n    var name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"import \");\n    var declarations = node.declarations;\n    var namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    var sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.GET)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.SET)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    var members = node.members;\n    var numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    var value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    var sb = this.sb;\n    var label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    var sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    var sb = this.sb;\n    sb.push(\"try {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var statements = node.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[i]);\n    }\n    var catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    var finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    var declarations = node.declarations;\n    var numDeclarations = assert(declarations.length);\n    var firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.CONST) ? \"const \" : firstDeclaration.is(CommonFlags.LET) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    var sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    var statement = node.statement;\n    if (statement.kind == NodeKind.EMPTY) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(node.statement);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    var sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    var args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    var sb = this.sb;\n    var kind = node.parameterKind;\n    var implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.REST) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.EXPORT)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.IMPORT)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.DECLARE)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.PUBLIC)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.PRIVATE)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.PROTECTED)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.STATIC)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.ABSTRACT)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.READONLY)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    var ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n","/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Field,\n  Class,\n  TypedElement\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getConstValueI64High,\n  getUnaryValue\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  uniqueMap\n} from \"./util\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  RETURNS = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  RETURNS_WRAPPED = 1 << 1,\n  /** This flow always returns a non-null value. */\n  RETURNS_NONNULL = 1 << 2,\n  /** This flow always throws. */\n  THROWS = 1 << 3,\n  /** This flow always breaks. */\n  BREAKS = 1 << 4,\n  /** This flow always continues. */\n  CONTINUES = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  ACCESSES_THIS = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CALLS_SUPER = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  CONDITIONALLY_RETURNS = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  CONDITIONALLY_THROWS = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  CONDITIONALLY_BREAKS = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  CONDITIONALLY_CONTINUES = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  CONDITIONALLY_ACCESSES_THIS = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MAY_RETURN_NONTHIS = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UNCHECKED_CONTEXT = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CTORPARAM_CONTEXT = 1 << 16,\n\n  // masks\n\n  /** Any categorical flag. */\n  ANY_CATEGORICAL = FlowFlags.RETURNS\n                  | FlowFlags.RETURNS_WRAPPED\n                  | FlowFlags.RETURNS_NONNULL\n                  | FlowFlags.THROWS\n                  | FlowFlags.BREAKS\n                  | FlowFlags.CONTINUES\n                  | FlowFlags.ACCESSES_THIS\n                  | FlowFlags.CALLS_SUPER\n                  | FlowFlags.TERMINATES,\n\n  /** Any conditional flag. */\n  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS\n                  | FlowFlags.CONDITIONALLY_THROWS\n                  | FlowFlags.CONDITIONALLY_BREAKS\n                  | FlowFlags.CONDITIONALLY_CONTINUES\n                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS\n}\n\n/** Flags indicating the current state of a local. */\nexport enum LocalFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  /** Local is constant. */\n  CONSTANT = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  WRAPPED = 1 << 1,\n  /** Local is non-null. */\n  NONNULL = 1 << 2,\n  /** Local is initialized. */\n  INITIALIZED = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport enum FieldFlags {\n  NONE = 0,\n  INITIALIZED = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  UNKNOWN,\n  /** Condition is always true. */\n  TRUE,\n  /** Condition is always false. */\n  FALSE\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the parent flow of the specified function. */\n  static createParent(parentFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow within `parentFunction`. */\n  static createInline(parentFunction: Function, inlineFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    flow.inlineFunction = inlineFunction;\n    flow.inlineReturnLabel = inlineFunction.internalName + \"|inlined.\" + (inlineFunction.nextInlineId++).toString();\n    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Function this flow belongs to. */\n    public parentFunction: Function\n  ) {\n    /* nop */\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.NONE;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\n  /** Function being inlined, when inlining. */\n  inlineFunction: Function | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction !== null;\n  }\n\n  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */\n  get actualFunction(): Function {\n    var inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.parentFunction;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.actualFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.actualFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.ANY_CONDITIONAL;\n    if (this.is(FlowFlags.RETURNS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    }\n    if (this.is(FlowFlags.THROWS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    }\n    if (this.is(FlowFlags.BREAKS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    }\n    if (this.is(FlowFlags.CONTINUES)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n    if (this.is(FlowFlags.ACCESSES_THIS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(resetBreakContext: bool = false): Flow {\n    var branch = new Flow(this.parentFunction);\n    branch.parent = this;\n    branch.outer = this.outer;\n    if (resetBreakContext) {\n      branch.flags = this.flags & ~(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS |\n        FlowFlags.CONTINUES |\n        FlowFlags.CONDITIONALLY_CONTINUES\n      );\n    } else {\n      branch.flags = this.flags;\n      branch.continueLabel = this.continueLabel;\n      branch.breakLabel = this.breakLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineFunction = this.inlineFunction;\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type, except: Set<i32> | null = null): Local {\n    var parentFunction = this.parentFunction;\n    var temps: Local[] | null;\n    switch (<u32>type.toRef()) {\n      case <u32>TypeRef.I32: { temps = parentFunction.tempI32s; break; }\n      case <u32>TypeRef.I64: { temps = parentFunction.tempI64s; break; }\n      case <u32>TypeRef.F32: { temps = parentFunction.tempF32s; break; }\n      case <u32>TypeRef.F64: { temps = parentFunction.tempF64s; break; }\n      case <u32>TypeRef.V128: { temps = parentFunction.tempV128s; break; }\n      case <u32>TypeRef.Funcref: { temps = parentFunction.tempFuncrefs; break; }\n      case <u32>TypeRef.Externref: { temps = parentFunction.tempExternrefs; break; }\n      case <u32>TypeRef.Anyref: { temps = parentFunction.tempAnyrefs; break; }\n      case <u32>TypeRef.Eqref: { temps = parentFunction.tempEqrefs; break; }\n      case <u32>TypeRef.I31ref: { temps = parentFunction.tempI31refs; break; }\n      case <u32>TypeRef.Dataref: { temps = parentFunction.tempDatarefs; break; }\n      default: throw new Error(\"concrete type expected\");\n    }\n    var local: Local;\n    if (except) {\n      if (temps !== null && temps.length > 0) {\n        for (let i = 0, k = temps.length; i < k; ++i) {\n          if (!except.has(temps[i].index)) {\n            local = temps[i];\n            let k = temps.length - 1;\n            while (i < k) unchecked(temps[i] = temps[i++ + 1]);\n            temps.length = k;\n            local.type = type;\n            local.flags = CommonFlags.NONE;\n            this.unsetLocalFlag(local.index, ~0);\n            return local;\n          }\n        }\n      }\n      local = parentFunction.addLocal(type);\n    } else {\n      if (temps !== null && temps.length > 0) {\n        local = assert(temps.pop());\n        local.type = type;\n        local.flags = CommonFlags.NONE;\n      } else {\n        local = parentFunction.addLocal(type);\n      }\n    }\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Frees the temporary local for reuse. */\n  freeTempLocal(local: Local): void {\n    if (local.is(CommonFlags.INLINED)) return;\n    assert(local.index >= 0);\n    var parentFunction = this.parentFunction;\n    var temps: Local[];\n    assert(local.type != null); // internal error\n    local.resetTemporaryName();\n    switch (<u32>local.type.toRef()) {\n      case <u32>TypeRef.I32: {\n        let tempI32s = parentFunction.tempI32s;\n        if (tempI32s) temps = tempI32s;\n        else parentFunction.tempI32s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        let tempI64s = parentFunction.tempI64s;\n        if (tempI64s) temps = tempI64s;\n        else parentFunction.tempI64s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        let tempF32s = parentFunction.tempF32s;\n        if (tempF32s) temps = tempF32s;\n        else parentFunction.tempF32s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        let tempF64s = parentFunction.tempF64s;\n        if (tempF64s) temps = tempF64s;\n        else parentFunction.tempF64s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        let tempV128s = parentFunction.tempV128s;\n        if (tempV128s) temps = tempV128s;\n        else parentFunction.tempV128s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Funcref: {\n        let tempFuncrefs = parentFunction.tempFuncrefs;\n        if (tempFuncrefs) temps = tempFuncrefs;\n        else parentFunction.tempFuncrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Externref: {\n        let tempExternrefs = parentFunction.tempExternrefs;\n        if (tempExternrefs) temps = tempExternrefs;\n        else parentFunction.tempExternrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Anyref: {\n        let tempAnyrefs = parentFunction.tempAnyrefs;\n        if (tempAnyrefs) temps = tempAnyrefs;\n        else parentFunction.tempAnyrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Eqref: {\n        let tempEqrefs = parentFunction.tempEqrefs;\n        if (tempEqrefs) temps = tempEqrefs;\n        else parentFunction.tempEqrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.I31ref: {\n        let tempI31refs = parentFunction.tempI31refs;\n        if (tempI31refs) temps = tempI31refs;\n        else parentFunction.tempI31refs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Dataref: {\n        let tempDatarefs = parentFunction.tempDatarefs;\n        if (tempDatarefs) temps = tempDatarefs;\n        else parentFunction.tempDatarefs = temps = [];\n        break;\n      }\n      default: throw new Error(\"concrete type expected\");\n    }\n    assert(local.index >= 0);\n    temps.push(local);\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {\n    var scopedLocal = this.getTempLocal(type, except);\n    scopedLocal.setTemporaryName(name);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    var scopedDummy = new Local(name, -1, type, this.parentFunction);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.parentFunction.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.parentFunction.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.parentFunction.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.parentFunction.localsByIndex.length);\n    var scopedAlias = new Local(name, index, type, this.parentFunction);\n    // not flagged as SCOPED as it must not be free'd when the flow is finalized\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Tests if this flow has any scoped locals that must be free'd. */\n  get hasScopedLocals(): bool {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    var scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Frees this flow's scoped variables and returns its parent flow. */\n  freeScopedLocals(): void {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          this.freeTempLocal(local);\n        }\n      }\n      this.scopedLocals = null;\n    }\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    var current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope !== null && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    var localsByName = this.parentFunction.localsByName;\n    if (localsByName.has(name)) return assert(localsByName.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    var element = this.lookupLocal(name);\n    if (element) return element;\n    return this.actualFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    var actualFunction = this.actualFunction;\n    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));\n    var actualParent = actualFunction.parent;\n    assert(actualParent.kind == ElementKind.CLASS);\n    var actualClass = <Class>actualParent;\n    this.thisFieldFlags = new Map();\n    var members = actualClass.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind == ElementKind.FIELD) {\n          let field = <Field>member;\n          if (\n            // guaranteed by super\n            field.parent != actualClass ||\n            // has field initializer\n            field.initializerNode !== null ||\n            // is initialized as a ctor parameter\n            field.prototype.parameterIndex != -1 ||\n            // is safe to initialize with zero\n            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)\n          ) {\n            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);\n          }\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n    }\n  }\n\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\n  pushBreakLabel(): string {\n    var parentFunction = this.parentFunction;\n    var id = parentFunction.nextBreakId++;\n    var stack = parentFunction.breakStack;\n    if (!stack) parentFunction.breakStack = [ id ];\n    else stack.push(id);\n    var label = id.toString();\n    parentFunction.breakLabel = label;\n    return label;\n  }\n\n  /** Pops the most recent break label from the stack. */\n  popBreakLabel(): void {\n    var parentFunction = this.parentFunction;\n    var stack = assert(parentFunction.breakStack);\n    var length = assert(stack.length);\n    stack.pop();\n    if (length > 1) {\n      parentFunction.breakLabel = stack[length - 2].toString();\n    } else {\n      parentFunction.breakLabel = null;\n      parentFunction.breakStack = null;\n    }\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.parentFunction == this.parentFunction);\n    assert(other.parent == this); // currently the case, but might change\n    var otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        otherFlags &= ~FlowFlags.TERMINATES;\n      }\n      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {\n    assert(other.parentFunction == this.parentFunction);\n    switch (conditionKind) {\n      case ConditionKind.TRUE: this.inherit(other); // always executes\n      case ConditionKind.FALSE: return;             // never executes\n    }\n\n    // Note that flags in `this` flow have already happened. For instance,\n    // a return cannot be undone no matter what'd happen in subsequent branches,\n    // but an allocation, which doesn't terminate, can become conditional. Not\n    // all flags have a corresponding conditional flag that's tracked.\n\n    var thisFlags = this.flags;\n    var otherFlags = other.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that\n      newFlags |= FlowFlags.RETURNS;\n    } else if (otherFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;\n\n    if (thisFlags & FlowFlags.THROWS) { // nothing can change that\n      newFlags |= FlowFlags.THROWS;\n    } else if (otherFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that\n      newFlags |= FlowFlags.BREAKS;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that\n      newFlags |= FlowFlags.CONTINUES;\n    } else if (other.continueLabel === this.continueLabel) {\n      if (otherFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional\n      if (otherFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;\n\n    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    var numThisLocalFlags = thisLocalFlags.length;\n    var otherLocalFlags = other.localFlags;\n    var numOtherLocalFlags = otherLocalFlags.length;\n    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.CONSTANT  |\n        LocalFlags.WRAPPED   |\n        LocalFlags.NONNULL   |\n        LocalFlags.INITIALIZED\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\n  inheritMutual(left: Flow, right: Flow): void {\n    assert(left.parentFunction == right.parentFunction);\n    assert(left.parentFunction == this.parentFunction);\n    // This differs from the previous method in that no flags are guaranteed\n    // to happen unless it is the case in both flows.\n\n    var leftFlags = left.flags;\n    var rightFlags = right.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (leftFlags & FlowFlags.RETURNS) {\n      if (rightFlags & FlowFlags.RETURNS) {\n        newFlags |= FlowFlags.RETURNS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n      }\n    } else if (rightFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {\n      newFlags |= FlowFlags.RETURNS_WRAPPED;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {\n      newFlags |= FlowFlags.RETURNS_NONNULL;\n    }\n\n    if (leftFlags & FlowFlags.THROWS) {\n      if (rightFlags & FlowFlags.THROWS) {\n        newFlags |= FlowFlags.THROWS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n      }\n    } else if (rightFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (leftFlags & FlowFlags.BREAKS) {\n      if (rightFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.BREAKS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else if (rightFlags & FlowFlags.BREAKS) {\n      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (leftFlags & FlowFlags.CONTINUES) {\n      if (rightFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONTINUES;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else if (rightFlags & FlowFlags.CONTINUES) {\n      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (leftFlags & FlowFlags.ACCESSES_THIS) {\n      if (rightFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {\n      newFlags |= FlowFlags.CALLS_SUPER;\n    }\n\n    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.TERMINATES) {\n      if (!(rightFlags & FlowFlags.TERMINATES)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.TERMINATES) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.CONSTANT  |\n          LocalFlags.WRAPPED   |\n          LocalFlags.NONNULL   |\n          LocalFlags.INITIALIZED\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    var leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Field,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)\n        ) {\n          newFieldFlags.set(key, FieldFlags.INITIALIZED);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if the specified flows have differing local states. */\n  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {\n    var numThisLocalFlags = before.localFlags.length;\n    var numOtherLocalFlags = after.localFlags.length;\n    var parentFunction = before.parentFunction;\n    assert(parentFunction === after.parentFunction);\n    var localsByIndex = parentFunction.localsByIndex;\n    assert(localsByIndex === after.parentFunction.localsByIndex);\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {\n          return true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Unifies local flags between this and the other flow. */\n  unifyLocalFlags(other: Flow): void {\n    var numThisLocalFlags = this.localFlags.length;\n    var numOtherLocalFlags = other.localFlags.length;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {\n        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped\n      }\n      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {\n        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null\n      }\n    }\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (!ifFalse) break;\n        if (getExpressionId(ifFalse) == ExpressionId.Const) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          if (\n            (getExpressionType(ifFalse) == TypeRef.I32 && getConstValueI32(ifFalse) == 0) ||\n            (getExpressionType(ifFalse) == TypeRef.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)\n          ) {\n            this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n            this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n          }\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        if (getExpressionId(ifTrue) == ExpressionId.Const) {\n          let ifFalse = getIfFalse(expr);\n          if (!ifFalse) break;\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          let exprType = getExpressionType(ifTrue);\n          if (\n            (exprType == TypeRef.I32 && getConstValueI32(ifTrue) != 0) ||\n            (exprType == TypeRef.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))\n          ) {\n            this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n            this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n          }\n\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    var operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.GLOBAL || global.kind == ElementKind.ENUMVALUE);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;\n          case TypeKind.BOOL: return (value & ~1) != 0;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.parentFunction.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.FUNCTION);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    var levels = 0;\n    var parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    var sb = new Array<string>();\n    if (this.is(FlowFlags.RETURNS)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.THROWS)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.BREAKS)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.CONTINUES)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CALLS_SUPER)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.TERMINATES)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return \"Flow(\" + this.actualFunction.toString() + \")[\" + levels.toString() + \"] \" + sb.join(\" \");\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n\nexport { findUsedLocals } from \"./passes/findusedlocals\";\n","/**\n * @fileoverview JavaScript glue code.\n * @license Apache-2.0\n */\n\nimport \"../../../std/portable/index\";\nimport \"../binaryen\";\nimport \"./float\";\nimport \"./i64\";\nimport \"./collections\";\n","/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport { Target, Runtime, Feature } from \"./common\";\nimport { Compiler, Options } from \"./compiler\";\nimport { IDLBuilder, TSDBuilder } from \"./definitions\";\nimport { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from \"./diagnostics\";\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Sets a 'globalAliases' value. */\nexport function setGlobalAlias(options: Options, alias: string, name: string): void {\n  var globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Sets the `explicitStart` option. */\nexport function setExplicitStart(options: Options, explicitStart: bool): void {\n  options.explicitStart = explicitStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 16384;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.SIMD;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.THREADS;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.MEMORY64;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.INFO;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.WARNING;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.ERROR;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds WebIDL definitions for the specified program. */\nexport function buildIDL(program: Program): string {\n  return IDLBuilder.build(program);\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program): string {\n  return TSDBuilder.build(program);\n}\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./definitions\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./extra/ast\";\nimport * as util from \"./util/index\";\nexport { util };\n","/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { Target } from \"./common\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  export const Funcref: TypeRef = 7 /* _BinaryenTypeFuncref */;\n  export const Externref: TypeRef = 8 /* _BinaryenTypeExternref */;\n  export const Anyref: TypeRef = 9 /* _BinaryenTypeAnyref */;\n  export const Eqref: TypeRef = 10 /* _BinaryenTypeEqref */;\n  export const I31ref: TypeRef = 11 /* _BinaryenTypeI31ref */;\n  export const Dataref: TypeRef = 12 /* _BinaryenTypeDataref */;\n  export const Auto: TypeRef = -1 /* _BinaryenTypeAuto */;\n}\n\n/** Binaryen feature constants. */\nexport enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  TypedFunctionReferences = 4096 /* _BinaryenFeatureTypedFunctionReferences */,\n  RelaxedSIMD = 16384 /* _BinaryenFeatureRelaxedSIMD */,\n  All = 32767 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. */\nexport enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIs = 42 /* _BinaryenRefIsId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  Try = 49 /* _BinaryenTryId */,\n  Throw = 50 /* _BinaryenThrowId */,\n  Rethrow = 51 /* _BinaryenRethrowId */,\n  TupleMake = 52 /* _BinaryenTupleMakeId */,\n  TupleExtract = 53 /* _BinaryenTupleExtractId */,\n  I31New = 54 /* _BinaryenI31NewId */,\n  I31Get = 55 /* _BinaryenI31GetId */,\n  CallRef = 56 /* _BinaryenCallRefId */,\n  RefTest = 57 /* _BinaryenRefTestId */,\n  RefCast = 58 /* _BinaryenRefCastId */,\n  BrOn = 59 /* _BinaryenBrOnId */,\n  RttCanon = 60 /* _BinaryenRttCanonId */,\n  RttSub = 61 /* _BinaryenRttSubId */,\n  StructNew = 62 /* _BinaryenStructNewId */,\n  StructGet = 63 /* _BinaryenStructGetId */,\n  StructSet = 64 /* _BinaryenStructSetId */,\n  ArrayNew = 65 /* _BinaryenArrayNewId */,\n  ArrayInit = 66 /* _BinaryenArrayInitId */,\n  ArrayGet = 67 /* _BinaryenArrayGetId */,\n  ArraySet = 68 /* _BinaryenArraySetId */,\n  ArrayLen = 69 /* _BinaryenArrayLenId */,\n  ArrayCopy = 70 /* _BinaryenArrayCopyId */,\n  RefAs = 71 /* _BinaryenRefAsId */\n}\n\n/** Binaryen external kind constants. */\nexport enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  /** f32x4.abs */\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n\n  _last = PromoteLowF32x4ToF64x2,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 124 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 125 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 126 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVec8x16 */,\n\n  _last = SwizzleI8x16,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */\n}\n\n/** Binaryen RefIs operation constants. */\nexport enum RefIsOp {\n  /** ref.is_null */\n  RefIsNull = 0 /* _BinaryenRefIsNull */,\n  /** ref.is_func */\n  RefIsFunc = 1 /* _BinaryenRefIsFunc */,\n  /** ref.is_data */\n  RefIsData = 2 /* _BinaryenRefIsData */,\n  /** ref.is_i31 */\n  RefIsI31 = 3 /* _BinaryenRefIsI31 */\n}\n\n/** Binaryen RefAs operation constants. */\nexport enum RefAsOp {\n  /** ref.as_non_null */\n  RefAsNonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** ref.as_func */\n  RefAsFunc = 1 /* _BinaryenRefAsFunc */,\n  /** ref.as_data */\n  RefAsData = 2 /* _BinaryenRefAsData */,\n  /** ref.as_i31 */\n  RefAsI31 = 3 /* _BinaryenRefAsI31 */\n}\n\n/** Binaryen BrOn operation constants. */\nexport enum BrOnOp {\n  /** br_on_null */\n  BrOnNull = 0 /* TODO_BinaryenBrOnNull */,\n  /** br_on_cast */\n  BrOnCast = 1 /* TODO_BinaryenBrOnCast */,\n  /** br_on_func */\n  BrOnFunc = 2 /* TODO_BinaryenBrOnFunc */,\n  /** br_on_data */\n  BrOnData = 3 /* TODO_BinaryenBrOnData */,\n  /** br_on_i31 */\n  BrOnI31 = 4 /* TODO_BinaryenBrOnI31 */\n}\n\n/** Binaryen expression runner flags. */\nexport enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    var cArr = allocU8Array(buffer);\n    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    var out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, bytes[i]);\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize: return this.unary(isWam64 ? UnaryOp.ClzI64 : UnaryOp.ClzI32, value);\n        case UnaryOp.CtzSize: return this.unary(isWam64 ? UnaryOp.CtzI64 : UnaryOp.CtzI32, value);\n        case UnaryOp.PopcntSize: return this.unary(isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32, value);\n        case UnaryOp.EqzSize: return this.unary(isWam64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32, value);\n      }\n      assert(false);\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize: return this.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32, left, right);\n        case BinaryOp.SubSize: return this.binary(isWasm64 ? BinaryOp.SubI64 : BinaryOp.SubI32, left, right);\n        case BinaryOp.MulSize: return this.binary(isWasm64 ? BinaryOp.MulI64 : BinaryOp.MulI32, left, right);\n        case BinaryOp.DivISize: return this.binary(isWasm64 ? BinaryOp.DivI64 : BinaryOp.DivI32, left, right);\n        case BinaryOp.DivUSize: return this.binary(isWasm64 ? BinaryOp.DivU64 : BinaryOp.DivU32, left, right);\n        case BinaryOp.RemISize: return this.binary(isWasm64 ? BinaryOp.RemI64 : BinaryOp.RemI32, left, right);\n        case BinaryOp.RemUSize: return this.binary(isWasm64 ? BinaryOp.RemU64 : BinaryOp.RemU32, left, right);\n        case BinaryOp.AndSize: return this.binary(isWasm64 ? BinaryOp.AndI64 : BinaryOp.AndI32, left, right);\n        case BinaryOp.OrSize: return this.binary(isWasm64 ? BinaryOp.OrI64 : BinaryOp.OrI32, left, right);\n        case BinaryOp.XorSize: return this.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32, left, right);\n        case BinaryOp.ShlSize: return this.binary(isWasm64 ? BinaryOp.ShlI64 : BinaryOp.ShlI32, left, right);\n        case BinaryOp.ShrISize: return this.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32, left, right);\n        case BinaryOp.ShrUSize: return this.binary(isWasm64 ? BinaryOp.ShrU64 : BinaryOp.ShrU32, left, right);\n        case BinaryOp.RotlSize: return this.binary(isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32, left, right);\n        case BinaryOp.RotrSize: return this.binary(isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32, left, right);\n        case BinaryOp.EqSize: return this.binary(isWasm64 ? BinaryOp.EqI64 : BinaryOp.EqI32, left, right);\n        case BinaryOp.NeSize: return this.binary(isWasm64 ? BinaryOp.NeI64 : BinaryOp.NeI32, left, right);\n        case BinaryOp.LtISize: return this.binary(isWasm64 ? BinaryOp.LtI64 : BinaryOp.LtI32, left, right);\n        case BinaryOp.LtUSize: return this.binary(isWasm64 ? BinaryOp.LtU64 : BinaryOp.LtU32, left, right);\n        case BinaryOp.LeISize: return this.binary(isWasm64 ? BinaryOp.LeI64 : BinaryOp.LeI32, left, right);\n        case BinaryOp.LeUSize: return this.binary(isWasm64 ? BinaryOp.LeU64 : BinaryOp.LeU32, left, right);\n        case BinaryOp.GtISize: return this.binary(isWasm64 ? BinaryOp.GtI64 : BinaryOp.GtI32, left, right);\n        case BinaryOp.GtUSize: return this.binary(isWasm64 ? BinaryOp.GtU64 : BinaryOp.GtU32, left, right);\n        case BinaryOp.GeISize: return this.binary(isWasm64 ? BinaryOp.GeI64 : BinaryOp.GeI32, left, right);\n        case BinaryOp.GeUSize: return this.binary(isWasm64 ? BinaryOp.GeU64 : BinaryOp.GeU32, left, right);\n      }\n      assert(false);\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(): ExpressionRef {\n    return binaryen._BinaryenMemorySize(this.ref);\n  }\n\n  memory_grow(delta: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenMemoryGrow(this.ref, delta);\n  }\n\n  table_size(name: string): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = TypeRef.Auto,\n  ): ExpressionRef {\n    if (type == TypeRef.Auto) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);\n  }\n\n  atomic_fence(): ExpressionRef {\n    return binaryen._BinaryenAtomicFence(this.ref);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    var cArr = allocPtrArray(children);\n    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    var length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      assert(singleType == TypeRef.Unreachable || singleType == type);\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var numNames = names.length;\n    var strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      strs[i] = this.allocStringCached(names[i]);\n    }\n    var cArr = allocPtrArray(strs);\n    var cStr = this.allocStringCached(defaultName);\n    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(\"0\"); // TODO: multiple tables\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    var numCatchTags = catchTags.length;\n    var strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    var cArr1 = allocPtrArray(strs);\n    var cArr2 = allocPtrArray(catchBodies);\n    var cStr1 = this.allocStringCached(name);\n    var cStr2 = this.allocStringCached(delegateTarget);\n    var ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(tagName);\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    var cArr = allocU8Array(mask);\n    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec);\n  }\n\n  // reference types / gc\n\n  ref_is(\n    op: RefIsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIs(this.ref, op, expr);\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenI31New(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocPtrArray(varTypes);\n    var ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    var cArr = allocPtrArray(paramTypes);\n    var ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    var cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    var cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    shared: bool = false\n  ): void {\n    var cStr = this.allocStringCached(exportName);\n    var k = segments.length;\n    var segs = new Array<usize>(k);\n    var psvs = new Uint8Array(k);\n    var offs = new Array<ExpressionRef>(k);\n    var sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = segments[i];\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      segs[i] = allocU8Array(buffer);\n      psvs[i] = 0; // no passive segments currently\n      offs[i] = target == Target.WASM64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset));\n      sizs[i] = buffer.length;\n    }\n    var cArr1 = allocPtrArray(segs);\n    var cArr2 = allocU8Array(psvs);\n    var cArr3 = allocPtrArray(offs);\n    var cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(segs[i]);\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var cStr = this.allocStringCached(name);\n    var numNames = funcs.length;\n    var names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    var tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var numNames = funcs.length;\n    var names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    var cStr = this.allocStringCached(key);\n    var ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    var cStr1 = this.allocStringCached(key);\n    var cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    var numNames = passes.length;\n    var cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    var cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n        passes.push(\"dae-optimizing\");\n        passes.push(\"code-folding\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"optimize-instructions\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    var out = this.lit; // safe to reuse as long as..\n    assert(binaryen._BinaryenSizeofLiteral() >= 12);\n    var cStr = allocString(sourceMapUrl);\n    var binaryPtr: usize = 0;\n    var sourceMapPtr: usize = 0;\n    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\n    binaryPtr = assert(binaryen.__i32_load(out));\n    var binaryLen = binaryen.__i32_load(out + 4);\n    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL\n    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));\n    if (cStr) binaryen._free(cStr);\n    binaryen._free(binaryPtr);\n    if (sourceMapPtr) binaryen._free(sourceMapPtr);\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  toAsmjs(): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str === null) return 0;\n    var cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    var ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    var cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    var str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull:\n      case ExpressionId.RttCanon: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      assert(getExpressionId(precomp) == ExpressionId.Const);\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    var cStr = allocString(name);\n    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  var cArr = allocPtrArray(types);\n  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  var arity = binaryen._BinaryenTypeArity(type);\n  var cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  var types = new Array<TypeRef>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  var type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return getConstValueI64Low(expr) == 0 && getConstValueI64High(expr) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  var count = binaryen._BinaryenFunctionGetNumVars(func);\n  var types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    types[i] = binaryen._BinaryenFunctionGetVar(func, i);\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    var cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    var cases = this.cases;\n    var index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    var cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    var module = this.module;\n    var cases = this.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    var values = this.values;\n    var numValues = values.length;\n    var indexes = this.indexes;\n    var entry = new Array<ExpressionRef>(1 + numValues + 1);\n    var labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      labels[i] = \"case\" + i.toString() + labelPostfix;\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = indexes[i];\n      entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      );\n    }\n    var defaultIndex = this.defaultIndex;\n    var defaultLabel = \"default\" + labelPostfix;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    var current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(labels[i], block);\n    }\n    var lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function hasSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return getSideEffects(expr, module) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  var len = u8s.length;\n  var ptr = binaryen._malloc(len);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU8.set(u8s, ptr);\n  } else {\n    for (let i = 0; i < len; ++i) {\n      binaryen.__i32_store8(ptr + i, u8s[i]);\n    }\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  var len = i32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAP32.set(i32s, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0; i < len; ++i) {\n      let val = i32s[i];\n      binaryen.__i32_store(idx, val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  var len = u32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU32.set(u32s, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0; i < len; ++i) {\n      let val = u32s[i];\n      binaryen.__i32_store(idx, val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.WASM64);\n  var len = ptrs.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU32.set(ptrs, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0, k = len; i < k; ++i) {\n      let val = ptrs[i];\n      binaryen.__i32_store(idx, <i32>val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  var len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      (c1 & 0xFC00) === 0xD800 && i + 1 < k &&\n      (str.charCodeAt(i + 1) & 0xFC00) === 0xDC00\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str === null) return 0;\n  var len = stringLengthUTF8(str);\n  var ptr = binaryen._malloc(len + 1) >>> 0;\n  var idx = ptr;\n  if (len === str.length) {\n    // fast path when all chars are ascii\n    if (!ASC_TARGET) {\n      for (let i = 0, k = str.length; i < k; ++i) {\n        binaryen.HEAPU8[idx++] = str.charCodeAt(i);\n      }\n    } else {\n      for (let i = 0, k = str.length; i < k; ++i) {\n        let u = str.charCodeAt(i) >>> 0;\n        binaryen.__i32_store8(idx++, u as u8);\n      }\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        (c1 & 0xFC00) === 0xD800 && i + 1 < k &&\n        ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00\n      ) {\n        c1 = 0x10000 + ((c1 & 0x3FF) << 10) | (c2 & 0x3FF);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  if (!ASC_TARGET) {\n    return binaryen.HEAPU8.slice(ptr, ptr + len);\n  } else {\n    var ret = new Uint8Array(len);\n    for (let i = 0; i < len; ++i) {\n      ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);\n    }\n    return ret;\n  }\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  var arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  var cp: u32;\n  var u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(0xD800 | (ch >>> 10));\n      arr.push(0xDC00 | (ch & 0x3FF));\n    }\n  }\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\n  // not applicable if pushing a value to the stack\n  if (binaryen._BinaryenExpressionGetType(expr) != TypeRef.Unreachable) {\n    return false;\n  }\n\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\n    case ExpressionId.Unreachable:\n    case ExpressionId.Return: return false;\n    case ExpressionId.Break: {\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\n    }\n    case ExpressionId.Block: {\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\n        return (\n          numChildren > 0 &&\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\n        );\n      }\n    }\n  }\n  return true;\n}\n","/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  Range,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] | null = null\n  ) {\n    super(diagnostics);\n    this.sources = sources ? sources : new Array<Source>();\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    var normalizedPath = normalizePath(path);\n    var internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text === null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    var source = new Source(\n      isEntry\n        ? SourceKind.USER_ENTRY\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LIBRARY_ENTRY\n            : SourceKind.LIBRARY\n          : SourceKind.USER,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n\n    // tokenize and parse\n    var tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    var statements = source.statements;\n    while (!tn.skip(Token.ENDOFFILE)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    var flags = CommonFlags.NONE;\n    var startPos = -1;\n\n    // check decorators\n    var decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.AT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    var exportStart = 0;\n    var exportEnd = 0;\n    var defaultStart = 0;\n    var defaultEnd = 0;\n    if (tn.skip(Token.EXPORT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.EXPORT;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.DEFAULT)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    var declareStart = 0;\n    var declareEnd = 0;\n    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);\n    if (tn.skip(Token.DECLARE)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.AMBIENT;\n    }\n\n    // parse the statement\n    var statement: Statement | null = null;\n\n    // handle declarations\n    var first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.CONST: {\n        tn.next();\n        flags |= CommonFlags.CONST;\n        if (tn.skip(Token.ENUM)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.LET: flags |= CommonFlags.LET;\n      case Token.VAR: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ENUM: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.FUNCTION: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ABSTRACT: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.CLASS) {\n          if (next == Token.INTERFACE) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.ABSTRACT;\n        // fall through\n      }\n      case Token.CLASS:\n      case Token.INTERFACE: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.NAMESPACE: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.IMPORT: {\n        tn.next();\n        flags |= CommonFlags.IMPORT;\n        if (flags & CommonFlags.EXPORT) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.EXPORT) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement !== null) {\n      switch (statement.kind) {\n        case NodeKind.ENUMDECLARATION:\n        case NodeKind.FUNCTIONDECLARATION:\n        case NodeKind.CLASSDECLARATION:\n        case NodeKind.INTERFACEDECLARATION:\n        case NodeKind.NAMESPACEDECLARATION: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    var backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    var dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    var current = first;\n    while (tn.skip(Token.DOT)) {\n      if (tn.skip(Token.IDENTIFIER)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    var token = tn.next();\n    var startPos = tn.tokenPos;\n\n    var type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OPENPAREN) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OPENPAREN);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.BAR)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.NULL)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.VOID) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.THIS) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.TRUE || token == Token.FALSE) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.NULL) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.STRINGLITERAL) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.IDENTIFIER) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LESSTHAN)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.COMMA));\n        if (!tn.skip(Token.GREATERTHAN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.BAR)) {\n      if (tn.skip(Token.NULL)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OPENBRACKET)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CLOSEBRACKET)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.BAR)) {\n        if (tn.skip(Token.NULL)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    var state = tn.mark();\n    var startPos = tn.tokenPos;\n    var parameters: ParameterNode[] | null = null;\n    var thisType: NamedTypeNode | null = null;\n    var isSignature: bool = false;\n    var firstParamNameNoType: IdentifierExpression | null = null;\n    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;\n\n    if (tn.skip(Token.CLOSEPAREN)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.DEFAULT;\n        if (tn.skip(Token.DOT_DOT_DOT)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.REST;\n        }\n        if (tn.skip(Token.THIS)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NAMEDTYPE) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.QUESTION)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.REST) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.OPTIONAL;\n            }\n          }\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.COMMA) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.COMMA));\n      if (!tn.skip(Token.CLOSEPAREN)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    var returnType: TypeNode | null;\n    if (tn.skip(Token.EQUALS_GREATERTHAN)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    var startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.DOT)) {\n        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OPENPAREN)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    var declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declarations.push(declaration);\n    } while (tn.skip(Token.COMMA));\n\n    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    var flags = parentFlags;\n    if (tn.skip(Token.EXCLAMATION)) {\n      flags |= CommonFlags.DEFINITELY_ASSIGNED;\n    }\n\n    var type: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      type = this.parseType(tn, true);\n    }\n\n    var initializer: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!initializer) return null;\n    } else if (!isFor) {\n      if (flags & CommonFlags.CONST) {\n        if (!(flags & CommonFlags.AMBIENT)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    var range = Range.join(identifier.range, tn.range());\n    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.IDENTIFIER) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OPENBRACE) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    var members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let member = this.parseEnumValue(tn, CommonFlags.NONE);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEBRACE)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    var ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var value: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    var startPos = tn.tokenPos;\n    var expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.SEMICOLON &&\n      tn.nextToken != Token.CLOSEBRACE &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    var typeParameters = new Array<TypeParameterNode>();\n    var seenOptional = false;\n    var start = tn.tokenPos;\n    while (!tn.skip(Token.GREATERTHAN)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType !== null) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.GREATERTHAN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.IDENTIFIER) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EXTENDS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    var parameters = new Array<ParameterNode>();\n    var seenRest: ParameterNode | null = null;\n    var seenOptional = false;\n    var reportedRest = false;\n    var thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.THIS)) {\n      if (tn.skip(Token.COLON)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NAMEDTYPE) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest !== null && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.OPTIONAL: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.REST: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    var isRest = false;\n    var isOptional = false;\n    var startRange: Range | null = null;\n    var accessFlags: CommonFlags = CommonFlags.NONE;\n    if (isConstructor) {\n      if (tn.skip(Token.PUBLIC)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PUBLIC;\n      } else if (tn.skip(Token.PROTECTED)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PROTECTED;\n      } else if (tn.skip(Token.PRIVATE)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PRIVATE;\n      }\n      if (tn.peek() == Token.READONLY) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.COLON) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.READONLY;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.DOT_DOT_DOT)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.QUESTION)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.REST\n          : isOptional\n            ? ParameterKind.OPTIONAL\n            : ParameterKind.DEFAULT,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var signatureStart = -1;\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    if (!tn.skip(Token.OPENPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    var thisType = this.parseParametersThis;\n\n    var isSetter = (flags & CommonFlags.SET) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer !== null) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.GET) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    var returnType: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (tn.skip(Token.OPENBRACE)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.AMBIENT)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    var ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.NONE,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n    var arrowKind = ArrowKind.NONE;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.FUNCTION) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OPENPAREN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.ARROW_PARENTHESIZED;\n      assert(tn.token == Token.OPENPAREN);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    var signatureStart = tn.pos;\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    var returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OPENBRACE)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OPENBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    var declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    var isInterface = tn.token == Token.INTERFACE;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    var identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    var extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.EXTENDS)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NAMEDTYPE) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    var implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.IMPLEMENTS)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.COMMA));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;\n    var startPos = 0;\n    var decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.AT)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.AT));\n      if (isInterface && decorators !== null) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    var flags = parent.flags & CommonFlags.AMBIENT;\n\n    // implemented methods are virtual\n    if (isInterface) flags |= CommonFlags.VIRTUAL;\n\n    var accessStart = 0;\n    var accessEnd = 0;\n    if (tn.skip(Token.PUBLIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.PUBLIC;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PRIVATE)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.PRIVATE;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PROTECTED)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.PROTECTED;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    var staticStart = 0;\n    var staticEnd = 0;\n    var abstractStart = 0;\n    var abstractEnd = 0;\n    if (tn.skip(Token.STATIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.STATIC;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.INSTANCE;\n      if (tn.skip(Token.ABSTRACT)) {\n        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.ABSTRACT;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;\n    }\n\n    var readonlyStart = 0;\n    var readonlyEnd = 0;\n    if (tn.peek() == Token.READONLY) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.COLON) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.READONLY;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    var state = tn.mark();\n    var isConstructor = false;\n    var isGetter = false;\n    var getStart = 0;\n    var getEnd = 0;\n    var isSetter = false;\n    var setStart = 0;\n    var setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.GET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.GET;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.SET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.SET;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.CONSTRUCTOR)) {\n        flags |= CommonFlags.CONSTRUCTOR;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.READONLY) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    var isGetterOrSetter = isGetter || isSetter;\n    var name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.PUBLIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PROTECTED) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PRIVATE) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.SEMICOLON);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.GENERIC;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OPENPAREN)) {\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.PUBLIC |\n            CommonFlags.PROTECTED |\n            CommonFlags.PRIVATE |\n            CommonFlags.READONLY\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.INSTANCE,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer !== null) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.COLON)) {\n        if (name.kind == NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OPENBRACE)) {\n        if (flags & CommonFlags.AMBIENT) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.ABSTRACT) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.GET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.SET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.QUESTION)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.EXCLAMATION)) {\n        flags |= CommonFlags.DEFINITELY_ASSIGNED;\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n      }\n      let range = tn.range(startPos, tn.pos);\n      if (\n        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&\n        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)\n      ) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators !== null && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    var start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.COLON)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NAMEDTYPE) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CLOSEBRACKET)) {\n            if (tn.skip(Token.COLON)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NAMEDTYPE) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OPENBRACE)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) members.push(member);\n          else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.ENDOFFILE)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        tn.skip(Token.SEMICOLON);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    var path: StringLiteralExpression | null = null;\n    var currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OPENBRACE)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path !== null) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else if (tn.skip(Token.ASTERISK)) {\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    var name = tn.readIdentifier();\n    var range = tn.range();\n    var ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    var startPos = tn.tokenPos;\n    var members: ImportDeclaration[] | null = null;\n    var namespaceName: IdentifierExpression | null = null;\n    var skipFrom = false;\n    if (tn.skip(Token.OPENBRACE)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.ASTERISK)) { // import * from \"file\"\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.COMMA)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.FROM)) {\n      if (tn.skip(Token.STRINGLITERAL)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.EQUALS)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    var state = tn.mark();\n    var token = tn.next();\n    var statement: Statement | null = null;\n    switch (token) {\n      case Token.BREAK: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.CONST: {\n        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);\n        break;\n      }\n      case Token.CONTINUE: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.DO: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.FOR: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.IF: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.LET: {\n        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);\n        break;\n      }\n      case Token.VAR: {\n        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);\n        break;\n      }\n      case Token.OPENBRACE: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.RETURN: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.SEMICOLON: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.SWITCH: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.THROW: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.TRY: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.VOID: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.WHILE: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    var statements = new Array<Statement>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.ENDOFFILE) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    var startPos = tn.tokenPos;\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.WHILE)) {\n\n      if (tn.skip(Token.OPENPAREN)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CLOSEPAREN)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    var expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    var ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    var startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OPENPAREN)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.CONST)) {\n        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.LET)) {\n        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.VAR)) {\n        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.SEMICOLON)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.OF)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.EXPRESSION) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.VARIABLE) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.VARIABLE) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.CONST) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.SEMICOLON) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.SEMICOLON)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.SEMICOLON) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CLOSEPAREN)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    var iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CLOSEPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.ELSE)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        if (tn.skip(Token.OPENBRACE)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CLOSEBRACE)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    var startPos = tn.tokenPos;\n    var statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.CASE)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.DEFAULT)) {\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn);\n    if (!expression) return null;\n    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    var startPos = tn.tokenPos;\n    var stmt: Statement | null;\n    if (tn.skip(Token.OPENBRACE)) {\n      let statements = new Array<Statement>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        statements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.CATCH)) {\n        if (!tn.skip(Token.OPENPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.FINALLY)) {\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        statements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LESSTHAN)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.GENERIC;\n      }\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn, Precedence.GROUPING);\n    if (!expression) return null;\n    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    var token = tn.next(IdentifierHandling.PREFER);\n    var startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.DOT_DOT_DOT:\n      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.EXCLAMATION:\n      case Token.TILDE:\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.DELETE: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER:\n          case NodeKind.ELEMENTACCESS:\n          case NodeKind.PROPERTYACCESS: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.NEW: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OPENPAREN) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.NULL: return Node.createNullExpression(tn.range());\n      case Token.TRUE: return Node.createTrueExpression(tn.range());\n      case Token.FALSE: return Node.createFalseExpression(tn.range());\n      case Token.THIS: return Node.createThisExpression(tn.range());\n      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OPENPAREN: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.ARROW_PARENTHESIZED\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.PREFER)) {\n\n            // function expression\n            case Token.DOT_DOT_DOT: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.IDENTIFIER: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CLOSEPAREN: {\n                  if (\n                    !tn.skip(Token.COLON) &&\n                    !tn.skip(Token.EQUALS_GREATERTHAN)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.COLON: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.QUESTION: {\n                  if (\n                    tn.skip(Token.COLON) ||   // optional parameter with type\n                    tn.skip(Token.COMMA) ||   // optional parameter without type\n                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.COMMA: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OPENBRACKET: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CLOSEBRACKET)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.COMMA) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACKET)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OPENBRACE: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.STRINGLITERAL)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.COLON)) {\n            let value = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACE)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LESSTHAN: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GREATERTHAN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.CALL);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.PREFIX,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.IDENTIFIER: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TEMPLATELITERAL)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.ARROW_SINGLE,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.SUPER: {\n        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.STRINGLITERAL: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TEMPLATELITERAL: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.INTEGERLITERAL: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FLOATLITERAL: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.SLASH: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.SLASH)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.FUNCTION: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.CLASS: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.ENDOFFILE) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    var state = tn.mark();\n    if (!tn.skip(Token.LESSTHAN)) return null;\n    var start = tn.tokenPos;\n    var typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() === Token.GREATERTHAN) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.COMMA));\n    if (tn.skip(Token.GREATERTHAN)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OPENPAREN)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    var args = new Array<Expression>();\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let expr = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.COMMA\n  ): Expression | null {\n    assert(precedence != Precedence.NONE);\n    var expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    var startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    var nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.AS: {\n          if (tn.skip(Token.CONST)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.CONST,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.AS,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.EXCLAMATION: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NONNULL,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.INSTANCEOF: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OPENBRACKET: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CLOSEBRACKET)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.PLUS_PLUS:\n        case Token.MINUS_MINUS: {\n          if (\n            expr.kind != NodeKind.IDENTIFIER &&\n            expr.kind != NodeKind.ELEMENTACCESS &&\n            expr.kind != NodeKind.PROPERTYACCESS\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.QUESTION: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.COLON)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA\n            ? Precedence.COMMA + 1\n            : Precedence.COMMA\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.COMMA: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.COMMA));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.DOT: {\n          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TEMPLATELITERAL)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.EQUALS:\n        case Token.PLUS_EQUALS:\n        case Token.MINUS_EQUALS:\n        case Token.ASTERISK_ASTERISK_EQUALS:\n        case Token.ASTERISK_EQUALS:\n        case Token.SLASH_EQUALS:\n        case Token.PERCENT_EQUALS:\n        case Token.LESSTHAN_LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.AMPERSAND_EQUALS:\n        case Token.CARET_EQUALS:\n        case Token.BAR_EQUALS:\n        case Token.ASTERISK_ASTERISK: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LESSTHAN:\n        case Token.GREATERTHAN:\n        case Token.LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_EQUALS:\n        case Token.EQUALS_EQUALS:\n        case Token.EQUALS_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS:\n        case Token.PLUS:\n        case Token.MINUS:\n        case Token.ASTERISK:\n        case Token.SLASH:\n        case Token.PERCENT:\n        case Token.LESSTHAN_LESSTHAN:\n        case Token.GREATERTHAN_GREATERTHAN:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n        case Token.AMPERSAND:\n        case Token.BAR:\n        case Token.CARET:\n        case Token.AMPERSAND_AMPERSAND:\n        case Token.BAR_BAR: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    var startPos = tag ? tag.range.start : tn.tokenPos;\n    var parts = new Array<string>();\n    var rawParts = new Array<string>();\n    var exprs = new Array<Expression>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.CLOSEBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.BACKTICK, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    var callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.IDENTIFIER: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.CALL: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    var typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OPENPAREN) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.ENDOFFILE ||   // next step should handle this\n        nextToken == Token.SEMICOLON      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL:\n        case Token.TEMPLATELITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OPENBRACE: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    var depth = 1;\n    var again = true;\n    do {\n      switch (tn.next()) {\n        case Token.ENDOFFILE: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OPENBRACE: {\n          ++depth;\n          break;\n        }\n        case Token.CLOSEBRACE: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL:{\n          tn.readString();\n          break;\n        }\n        case Token.TEMPLATELITERAL: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.BACKTICK);\n          }\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  NONE,\n  COMMA,\n  SPREAD,\n  YIELD,\n  ASSIGNMENT,\n  CONDITIONAL,\n  LOGICAL_OR,\n  LOGICAL_AND,\n  BITWISE_OR,\n  BITWISE_XOR,\n  BITWISE_AND,\n  EQUALITY,\n  RELATIONAL,\n  SHIFT,\n  ADDITIVE,\n  MULTIPLICATIVE,\n  EXPONENTIATED,\n  UNARY_PREFIX,\n  UNARY_POSTFIX,\n  CALL,\n  MEMBERACCESS,\n  GROUPING\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.COMMA: return Precedence.COMMA;\n    case Token.EQUALS:\n    case Token.PLUS_EQUALS:\n    case Token.MINUS_EQUALS:\n    case Token.ASTERISK_ASTERISK_EQUALS:\n    case Token.ASTERISK_EQUALS:\n    case Token.SLASH_EQUALS:\n    case Token.PERCENT_EQUALS:\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.AMPERSAND_EQUALS:\n    case Token.CARET_EQUALS:\n    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;\n    case Token.QUESTION: return Precedence.CONDITIONAL;\n    case Token.BAR_BAR: return Precedence.LOGICAL_OR;\n    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;\n    case Token.BAR: return Precedence.BITWISE_OR;\n    case Token.CARET: return Precedence.BITWISE_XOR;\n    case Token.AMPERSAND: return Precedence.BITWISE_AND;\n    case Token.EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS:\n    case Token.EQUALS_EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;\n    case Token.AS:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.LESSTHAN:\n    case Token.GREATERTHAN:\n    case Token.LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;\n    case Token.LESSTHAN_LESSTHAN:\n    case Token.GREATERTHAN_GREATERTHAN:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;\n    case Token.PLUS:\n    case Token.MINUS: return Precedence.ADDITIVE;\n    case Token.ASTERISK:\n    case Token.SLASH:\n    case Token.PERCENT: return Precedence.MULTIPLICATIVE;\n    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;\n    case Token.PLUS_PLUS:\n    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;\n    case Token.DOT:\n    case Token.OPENBRACKET:\n    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;\n  }\n  return Precedence.NONE;\n}\n","/**\n * @fileoverview Utility to find all locals used in an expression.\n * @license Apache-2.0\n */\n\nimport {\n  Visitor\n} from \"./pass\";\n\nimport {\n  ExpressionRef\n} from \"../module\";\n\nimport {\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex\n} from \"../glue/binaryen\";\n\nclass FindUsedLocalsVisitor extends Visitor {\n  used: Set<i32>;\n\n  constructor(used: Set<i32> = new Set()) {\n    super();\n    this.used = used;\n  }\n  \n  /** @override */\n  visitLocalGet(localGet: ExpressionRef): void {\n    this.used.add(<i32>_BinaryenLocalGetGetIndex(localGet));\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    this.used.add(<i32>_BinaryenLocalSetGetIndex(localSet));\n  }\n}\n\nvar singleton: FindUsedLocalsVisitor | null = null;\n\n/** Finds the indexes of all locals used in the specified expression. */\nexport function findUsedLocals(\n  expr: ExpressionRef,\n  used: Set<i32> = new Set()\n): Set<i32> {\n  var visitor = singleton;\n  if (!visitor) singleton = visitor = new FindUsedLocalsVisitor(used);\n  else visitor.used = used;\n  visitor.visit(expr);\n  return used;\n}\n","/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31NewSetValue,\n  _BinaryenI31GetSetI31\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    var currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    var stack = this.stack;\n    var length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31New(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRttCanon(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRttSub(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIs(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.I31New: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31NewGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31New(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.RttCanon: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRttCanon(expr);\n        break;\n      }\n      case ExpressionId.RttSub: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRttSub(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    var currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    var currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    var moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    var body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    var moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    var init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    var search = this.currentExpression;\n    var func = this.currentFunction;\n    var body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      var parent = assert(this.parentExpressionOrNull);\n      var replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIs: {\n      let value = _BinaryenRefIsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.I31New: {\n      let value = _BinaryenI31NewGetValue(parent);\n      if (value == search) {\n        _BinaryenI31NewSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefTest: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefCast: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.BrOn: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RttCanon: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RttSub: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructNew: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructGet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructSet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefAs: {\n      assert(false); // TODO\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n","/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    var functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    var module = this.module;\n    var ptr = _BinaryenStoreGetPtr(store);\n    var offset = _BinaryenStoreGetOffset(store);\n    var bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n","/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n * \n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n * \n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n * \n *   function foo(a: Obj, b: Obj): Obj {\n *     var c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *   \n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n * \n * At the call to `__collect()` the 32-bit stack frame of the function is:\n * \n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n * \n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n * \n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n * \n * with the callee's stack frame becoming just:\n * \n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n * \n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n * \n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     var r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n * \n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n * \n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  if (_BinaryenExpressionGetId(expr) == ExpressionId.Call && module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    return _BinaryenCallGetOperandAt(expr, 0);\n  }\n  return 0;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // already kept in another slot\n    case ExpressionId.LocalGet:\n    case ExpressionId.LocalSet: return false; // tee\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    var module = this.module;\n    var expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    var module = this.module;\n    if (this.options.hasFeature(Feature.BULK_MEMORY) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    var module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(this.compiler.ensureStaticString(\"stack overflow\"), this.compiler.program.nativeSource)\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    var module = this.module;\n    var numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(module, match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    var numOperands = _BinaryenCallGetNumOperands(call);\n    var operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(module, match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    var module = this.module;\n    var moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    var internalNameRef = _BinaryenExportGetValue(exportRef);\n    var internalName = module.readStringCached(internalNameRef)!;\n    var externalNameRef = _BinaryenExportGetName(exportRef);\n    var funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    var params = _BinaryenFunctionGetParams(funcRef);\n    var paramTypes = expandType(params);\n    var numParams = paramTypes.length;\n    var results = _BinaryenFunctionGetResults(funcRef);\n    var numLocals = numParams;\n    var vars = new Array<TypeRef>();\n    var numSlots = assert(managedOperandIndices.length);\n    var frameSize = numSlots * this.ptrSize;\n    var wrapperName = \"export:\" + internalName;\n    var wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    var module = this.module;\n    var instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n      \n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    var exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    var module = this.module;\n    var value = _BinaryenReturnGetValue(ret);\n    var stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}","/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// DeclaredElement          Base class of elements with a declaration\n//  TypedElement           Base class of elements resolving to a type\n//   TypeDefinition       Type alias declaration\n//   VariableLikeElement  Base class of all variable-like elements\n//    EnumValue          Enum value\n//    Global             File global\n//    Local              Function local\n//    Field              Class field (instance only)\n//    Property           Class property\n//   IndexSignature       Class index signature\n//   Function             Concrete function instance\n//   Class                Concrete class instance\n//  Namespace              Namespace with static members\n//  FunctionPrototype      Prototype of concrete function instances\n//  FieldPrototype         Prototype of concrete field instances\n//  PropertyPrototype      Prototype of concrete property instances\n//  ClassPrototype         Prototype of concrete classe instances\n// File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  LIBRARY_SUBST,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  INVALID,\n\n  // indexed access\n  INDEXED_GET,            // a[]\n  INDEXED_SET,            // a[]=b\n  UNCHECKED_INDEXED_GET,  // unchecked(a[])\n  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)\n\n  // binary\n  ADD,                    // a + b\n  SUB,                    // a - b\n  MUL,                    // a * b\n  DIV,                    // a / b\n  REM,                    // a % b\n  POW,                    // a ** b\n  BITWISE_AND,            // a & b\n  BITWISE_OR,             // a | b\n  BITWISE_XOR,            // a ^ b\n  BITWISE_SHL,            // a << b\n  BITWISE_SHR,            // a >> b\n  BITWISE_SHR_U,          // a >>> b\n  EQ,                     // a == b\n  NE,                     // a != b\n  GT,                     // a > b\n  GE,                     // a >= b\n  LT,                     // a < b\n  LE,                     // a <= b\n\n  // unary prefix\n  PLUS,                   // +a\n  MINUS,                  // -a\n  NOT,                    // !a\n  BITWISE_NOT,            // ~a\n  PREFIX_INC,             // ++a\n  PREFIX_DEC,             // --a\n\n  // unary postfix\n  POSTFIX_INC,            // a++\n  POSTFIX_DEC             // a--\n\n  // not overridable:\n  // IDENTITY             // a === b\n  // LOGICAL_AND          // a && b\n  // LOGICAL_OR           // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OPENBRACKET: {\n            if (arg == \"[]\") return OperatorKind.INDEXED_GET;\n            if (arg == \"[]=\") return OperatorKind.INDEXED_SET;\n            break;\n          }\n          case CharCode.OPENBRACE: {\n            if (arg == \"{}\") return OperatorKind.UNCHECKED_INDEXED_GET;\n            if (arg == \"{}=\") return OperatorKind.UNCHECKED_INDEXED_SET;\n            break;\n          }\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.ADD;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.SUB;\n            break;\n          }\n          case CharCode.ASTERISK: {\n            if (arg == \"*\") return OperatorKind.MUL;\n            if (arg == \"**\") return OperatorKind.POW;\n            break;\n          }\n          case CharCode.SLASH: {\n            if (arg == \"/\") return OperatorKind.DIV;\n            break;\n          }\n          case CharCode.PERCENT: {\n            if (arg == \"%\") return OperatorKind.REM;\n            break;\n          }\n          case CharCode.AMPERSAND: {\n            if (arg == \"&\") return OperatorKind.BITWISE_AND;\n            break;\n          }\n          case CharCode.BAR: {\n            if (arg == \"|\") return OperatorKind.BITWISE_OR;\n            break;\n          }\n          case CharCode.CARET: {\n            if (arg == \"^\") return OperatorKind.BITWISE_XOR;\n            break;\n          }\n          case CharCode.EQUALS: {\n            if (arg == \"==\") return OperatorKind.EQ;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!=\") return OperatorKind.NE;\n            break;\n          }\n          case CharCode.GREATERTHAN: {\n            if (arg == \">\") return OperatorKind.GT;\n            if (arg == \">=\") return OperatorKind.GE;\n            if (arg == \">>\") return OperatorKind.BITWISE_SHR;\n            if (arg == \">>>\") return OperatorKind.BITWISE_SHR_U;\n            break;\n          }\n          case CharCode.LESSTHAN: {\n            if (arg == \"<\") return OperatorKind.LT;\n            if (arg == \"<=\") return OperatorKind.LE;\n            if (arg == \"<<\") return OperatorKind.BITWISE_SHL;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_PREFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.PLUS;\n            if (arg == \"++\") return OperatorKind.PREFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.MINUS;\n            if (arg == \"--\") return OperatorKind.PREFIX_DEC;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!\") return OperatorKind.NOT;\n            break;\n          }\n          case CharCode.TILDE: {\n            if (arg == \"~\") return OperatorKind.BITWISE_NOT;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_POSTFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"++\") return OperatorKind.POSTFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"--\") return OperatorKind.POSTFIX_DEC;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS:\n      case Token.PLUS_EQUALS: return OperatorKind.ADD;\n      case Token.MINUS:\n      case Token.MINUS_EQUALS: return OperatorKind.SUB;\n      case Token.ASTERISK:\n      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;\n      case Token.SLASH:\n      case Token.SLASH_EQUALS: return OperatorKind.DIV;\n      case Token.PERCENT:\n      case Token.PERCENT_EQUALS: return OperatorKind.REM;\n      case Token.ASTERISK_ASTERISK:\n      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;\n      case Token.AMPERSAND:\n      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;\n      case Token.BAR:\n      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;\n      case Token.CARET:\n      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;\n      case Token.EQUALS_EQUALS: return OperatorKind.EQ;\n      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;\n      case Token.GREATERTHAN: return OperatorKind.GT;\n      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;\n      case Token.LESSTHAN: return OperatorKind.LT;\n      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS: return OperatorKind.PLUS;\n      case Token.MINUS: return OperatorKind.MINUS;\n      case Token.EXCLAMATION: return OperatorKind.NOT;\n      case Token.TILDE: return OperatorKind.BITWISE_NOT;\n      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + \".wasm\", \"[native code]\");\n    this.nativeSource = nativeSource;\n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    var nativeFile = new File(this, nativeSource);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Parser instance. */\n  parser: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code source. */\n  nativeSource: Source;\n  /** Special native code range. */\n  get nativeRange(): Range { return this.nativeSource.range; }\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    var cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    var cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    var cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    var cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    var cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    var cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    var cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    var cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    var cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    var cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    var cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    var cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    var cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    var cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    var cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    var cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    var cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    var cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    var cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    var prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    var cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    var cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    var cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    var cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    var cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    var cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    var cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    var cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\n  get typeinfoInstance(): Function {\n    var cached = this._typeinfoInstance;\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\n    return cached;\n  }\n  private _typeinfoInstance: Function | null = null;\n\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\n  get instanceofInstance(): Function {\n    var cached = this._instanceofInstance;\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\n    return cached;\n  }\n  private _instanceofInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    var cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    var cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    var cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    var cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Tests whether this is a WASI program. */\n  get isWasi(): bool {\n    return this.elementsByName.has(CommonNames.ASC_WASI);\n  }\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    var sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //         0  ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    //      = TOTAL       ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    var blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    var blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    var blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    var blockOverhead = this.blockOverhead;\n    var blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): VariableDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): TypeDeclaration {\n    var range = this.nativeSource.range;\n    var identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): FunctionDeclaration {\n    var range = this.nativeSource.range;\n    var signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.NONE, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): NamespaceDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    var elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    var options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\n    this.registerNativeType(CommonNames.dataref, Type.dataref);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));\n\n    // remember deferred elements\n    var queuedImports = new Array<QueuedImport>();\n    var queuedExports = new Map<File,Map<string,QueuedExport>>();\n    var queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    var queuedExtends = new Array<ClassPrototype>();\n    var queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.EXPORT: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.EXPORTDEFAULT: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.IMPORT: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.VARIABLE: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.CLASSDECLARATION: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.ENUMDECLARATION: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FUNCTIONDECLARATION: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.INTERFACEDECLARATION: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NAMESPACEDECLARATION: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TYPEDECLARATION: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\n    assert(this.arrayBufferInstance.id == 0);\n    assert(this.stringInstance.id == 1);\n    assert(this.arrayBufferViewInstance.id == 2);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\n        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    var resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=\n            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          thisPrototype.basePrototype = basePrototype;\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          thisPrototype.basePrototype = <InterfacePrototype>baseElement;\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // check for virtual overloads in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      let isWasi = this.isWasi;\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort,\n          isWasi\n            ? BuiltinNames.wasiAbort\n            : BuiltinNames.abort\n        );\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace,\n          isWasi\n            ? BuiltinNames.wasiTrace\n            : BuiltinNames.trace\n        );\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed,\n          isWasi\n            ? BuiltinNames.wasiSeed\n            : BuiltinNames.seed\n        );\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            throw new Error(\"no such global element: \" + name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Marks virtual members in a base class overloaded in this class. */\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\n    // TODO: make this work with interfaaces as well\n    var thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {\n            let thisMember = _values[j];\n            if (\n              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&\n              baseInstanceMembers.has(thisMember.name)\n            ) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              if (\n                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&\n                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE\n              ) {\n                let thisMethod = <FunctionPrototype>thisMember;\n                let baseMethod = <FunctionPrototype>baseMember;\n                if (!thisMethod.visibilityEquals(baseMethod)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\n                  );\n                }\n                baseMember.set(CommonFlags.VIRTUAL);\n                let overloads = baseMethod.overloads;\n                if (!overloads) baseMethod.overloads = overloads = new Set();\n                overloads.add(<FunctionPrototype>thisMember);\n                let baseMethodInstances = baseMethod.instances;\n                if (baseMethodInstances) {\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n                    let baseMethodInstance = _values[a];\n                    baseMethodInstance.set(CommonFlags.VIRTUAL);\n                  }\n                }\n              } else if (\n                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&\n                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE\n              ) {\n                let thisProperty = <PropertyPrototype>thisMember;\n                let baseProperty = <PropertyPrototype>baseMember;\n                if (!thisProperty.visibilityEquals(baseProperty)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\n                  );\n                }\n                baseProperty.set(CommonFlags.VIRTUAL);\n                let baseGetter = baseProperty.getterPrototype;\n                if (baseGetter) {\n                  baseGetter.set(CommonFlags.VIRTUAL);\n                  let thisGetter = thisProperty.getterPrototype;\n                  if (thisGetter) {\n                    let overloads = baseGetter.overloads;\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\n                    overloads.add(thisGetter);\n                  }\n                  let baseGetterInstances = baseGetter.instances;\n                  if (baseGetterInstances) {\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseGetterInstance = _values[a];\n                      baseGetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n                let baseSetter = baseProperty.setterPrototype;\n                if (baseSetter !== null && thisProperty.setterPrototype !== null) {\n                  baseSetter.set(CommonFlags.VIRTUAL);\n                  let thisSetter = thisProperty.setterPrototype;\n                  if (thisSetter) {\n                    let overloads = baseSetter.overloads;\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\n                    overloads.add(thisSetter);\n                  }\n                  let baseSetterInstances = baseSetter.instances;\n                  if (baseSetterInstances) {\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseSetterInstance = _values[a];\n                      baseSetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n              } else {\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  thisMember.identifierNode.range,\n                  baseMember.identifierNode.range,\n                  baseMember.identifierNode.text\n                );\n              }\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    var element = this.lookup(name);\n    if (!element) throw new Error(\"Missing standard library component: \" + name);\n    if (element.kind != kind) throw Error(\"Invalid standard library component kind: \" + name);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.GLOBAL);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);\n    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(\"Invalid standard library class: \" + name);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);\n    var resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(\"Invalid standard library function: \" + name);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.MODULE_EXPORT);\n    switch (element.kind) {\n      case ElementKind.CLASS_PROTOTYPE: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.PROPERTY:\n      case ElementKind.FUNCTION:\n      case ElementKind.FIELD:\n      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet\n    }\n    var staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    var element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),\n      DecoratorFlags.BUILTIN\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    var wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    var element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.CLASS_PROTOTYPE);\n    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    var elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing !== element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    var filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    var exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    var flags = DecoratorFlags.NONE;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.BUILTIN) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    var name = declaration.name.text;\n    var element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.FINAL |\n        DecoratorFlags.UNMANAGED\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    var implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    // initialize members\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.INDEXSIGNATURE: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var name = declaration.name.text;\n    var decorators = declaration.decorators;\n    var element: DeclaredElement;\n    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    if (declaration.is(CommonFlags.STATIC)) { // global variable\n      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);\n      acceptedFlags |= DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.READONLY)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));\n      element = new FieldPrototype(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var isStatic = declaration.is(CommonFlags.STATIC);\n    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE;\n    if (!declaration.is(CommonFlags.GENERIC)) {\n      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY\n                    |  DecoratorFlags.OPERATOR_PREFIX\n                    |  DecoratorFlags.OPERATOR_POSTFIX;\n    }\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.OPERATOR:\n          case DecoratorKind.OPERATOR_BINARY:\n          case DecoratorKind.OPERATOR_PREFIX:\n          case DecoratorKind.OPERATOR_POSTFIX: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.STRING)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.INVALID) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.overloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    var name = declaration.name.text;\n    if (declaration.is(CommonFlags.STATIC)) {\n      let parentMembers = parent.members;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    var name = declaration.name.text;\n    var isGetter = declaration.is(CommonFlags.GET);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    var element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    var name = declaration.name.text;\n    var element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.INLINE |\n        DecoratorFlags.LAZY\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    var values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    var name = declaration.name.text;\n    var element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.NONE\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    var members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var localName = member.localName.text;\n    var foreignName = member.exportedName.text;\n\n    // check for duplicates\n    var element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath === null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    var declaration = statement.declaration;\n    var element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    var foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      var element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN;\n    if (declaration.is(CommonFlags.AMBIENT)) {\n      validDecorators |= DecoratorFlags.EXTERNAL;\n    } else {\n      validDecorators |= DecoratorFlags.INLINE;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {\n        validDecorators |= DecoratorFlags.LAZY;\n      }\n    }\n    if (!declaration.is(CommonFlags.INSTANCE)) {\n      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {\n        validDecorators |= DecoratorFlags.GLOBAL;\n      }\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    var name = declaration.name.text;\n    var element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    var typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.GET,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.READONLY)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.SET,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    var name = declaration.name.text;\n    var original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)\n    );\n    if (!parent.add(name, original)) return null;\n    var element = assert(parent.getMember(name)); // possibly merged\n    var members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.CLASSDECLARATION: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.ENUMDECLARATION: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FUNCTIONDECLARATION: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.INTERFACEDECLARATION: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NAMESPACEDECLARATION: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TYPEDECLARATION: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.VARIABLE: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var name = declaration.name.text;\n    var element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.DECLARE)) {\n        acceptedFlags |= DecoratorFlags.EXTERNAL;\n      }\n      if (declaration.is(CommonFlags.CONST)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   var current: Class | null = target;\n  //   var arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport enum ElementKind {\n  /** A {@link Global}. */\n  GLOBAL,\n  /** A {@link Local}. */\n  LOCAL,\n  /** An {@link Enum}. */\n  ENUM,\n  /** An {@link EnumValue}. */\n  ENUMVALUE,\n  /** A {@link FunctionPrototype}. */\n  FUNCTION_PROTOTYPE,\n  /** A {@link Function}. */\n  FUNCTION,\n  /** A {@link ClassPrototype}. */\n  CLASS_PROTOTYPE,\n  /** A {@link Class}. */\n  CLASS,\n  /** An {@link InterfacePrototype}. */\n  INTERFACE_PROTOTYPE,\n  /** An {@link Interface}. */\n  INTERFACE,\n  /** A {@link FieldPrototype}. */\n  FIELD_PROTOTYPE,\n  /** A {@link Field}. */\n  FIELD,\n  /** A {@link PropertyPrototype}.  */\n  PROPERTY_PROTOTYPE,\n  /** A {@link Property}. */\n  PROPERTY,\n  /** A {@link Namespace}. */\n  NAMESPACE,\n  /** A {@link File}. */\n  FILE,\n  /** A {@link TypeDefinition}.  */\n  TYPEDEFINITION,\n  /** An {@link IndexSignature}. */\n  INDEXSIGNATURE\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  NONE = 0,\n  /** Is a program global. */\n  GLOBAL = 1 << 0,\n  /** Is a binary operator overload. */\n  OPERATOR_BINARY = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OPERATOR_PREFIX = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OPERATOR_POSTFIX = 1 << 3,\n  /** Is an unmanaged class. */\n  UNMANAGED = 1 << 4,\n  /** Is a final class. */\n  FINAL = 1 << 5,\n  /** Is always inlined. */\n  INLINE = 1 << 6,\n  /** Is using a different external name. */\n  EXTERNAL = 1 << 7,\n  /** Is a builtin. */\n  BUILTIN = 1 << 8,\n  /** Is compiled lazily. */\n  LAZY = 1 << 9,\n  /** Is considered unsafe code. */\n  UNSAFE = 1 << 10\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;\n      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;\n      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;\n      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;\n      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;\n      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;\n      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;\n      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;\n      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;\n      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;\n      default: return DecoratorFlags.NONE;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.FILE);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    var current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.FILE) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    var members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    var originalDeclaration = element.declaration;\n    var members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent !== this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    var program = this.program;\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.PUBLIC);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return this.internalName + \", kind=\" + this.kind.toString();\n  }\n}\n\n// Kinds of all declared elements\nvar declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    var declaration = this.declaration;\n    var identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      return Range.join(identifierNode.range, signatureNode.range);\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n\n  /** Checks if this element is a compatible override of the specified. */\n  isCompatibleOverride(base: DeclaredElement): bool {\n    var self: DeclaredElement = this; // TS\n    var kind = self.kind;\n    if (kind == base.kind) {\n      switch (kind) {\n        case ElementKind.FUNCTION: {\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);\n        }\n        case ElementKind.PROPERTY: {\n          let selfProperty = <Property>self;\n          let baseProperty = <Property>base;\n          let selfGetter = selfProperty.getterInstance;\n          let baseGetter = baseProperty.getterInstance;\n          if (selfGetter) {\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\n              return false;\n            }\n          } else if (baseGetter) {\n            return false;\n          }\n          let selfSetter = selfProperty.setterInstance;\n          let baseSetter = baseProperty.setterInstance;\n          if (selfSetter) {\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\n              return false;\n            }\n          } else if (baseSetter) {\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n// Kinds of all typed elements\nvar typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.RESOLVED));\n    this.type = type;\n    this.set(CommonFlags.RESOLVED);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.FILE,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    var startFunction = this.program.makeNativeFunction(\n      \"start:\" + this.internalName,\n      new Signature(program, null, Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    var element = super.getMember(name);\n    if (element) return element;\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    var exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    var exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    var exports = this.exports;\n    if (exports !== null && exports.has(name)) return assert(exports.get(name));\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    var declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    var ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.SCOPED);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    var exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.TYPEDEFINITION,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.NAMESPACE,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUM,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  NONE,\n  /** Constant integer value. */\n  INTEGER,\n  /** Constant float value. */\n  FLOAT\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.INTEGER;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.FLOAT;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUMVALUE,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.GLOBAL,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.LOCAL,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n\n  /** Sets the temporary name of this local. */\n  setTemporaryName(name: string): void {\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n\n  /** Resets the temporary name of this local. */\n  resetTemporaryName(): void {\n    var name = this.originalName;\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.INVALID;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overloading this one, if any. These are unbound. */\n  overloads: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FUNCTION_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    var parent = this.parent;\n    var parentKind = parent.kind;\n    if (parentKind == ElementKind.PROPERTY_PROTOTYPE) parentKind = parent.parent.kind;\n    return parentKind == ElementKind.CLASS || parentKind == ElementKind.INTERFACE;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var declaration = this.declaration;\n    assert(declaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new FunctionPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.overloads = this.overloads;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Map of locals by name. */\n  localsByName: Map<string,Local> = new Map();\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** List of additional non-parameter locals. */\n  additionalLocals: Type[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Virtual stub for calling overloads. */\n  virtualStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.FUNCTION,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.RESOLVED;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    var program = prototype.program;\n    this.type = signature.type;\n    if (!prototype.is(CommonFlags.AMBIENT)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        this.localsByName.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        this.localsByName.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n      }\n    }\n    this.flow = Flow.createParent(this);\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Gets the class or interface this function belongs to, if an instance method. */\n  getClassOrInterface(): Class | null {\n    var parent = this.parent;\n    if (parent.kind == ElementKind.PROPERTY) parent = parent.parent;\n    if (parent.kind == ElementKind.CLASS || parent.kind == ElementKind.INTERFACE) {\n      return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\n  newStub(postfix: string): Function {\n    var stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;\n    if (this.is(CommonFlags.INSTANCE)) ++localIndex;\n    var localName = name !== null\n      ? name\n      : \"var$\" + localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    var local = new Local(\n      localName,\n      localIndex,\n      type,\n      this,\n      declaration\n    );\n    if (name) {\n      if (this.localsByName.has(name)) throw new Error(\"duplicate local name\");\n      this.localsByName.set(name, local);\n    }\n    this.localsByIndex[local.index] = local;\n    this.additionalLocals.push(type);\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let locals = this.localsByName;\n      if (locals.has(name)) return assert(locals.get(name));\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of temporary locals\n  tempI32s: Local[] | null = null;\n  tempI64s: Local[] | null = null;\n  tempF32s: Local[] | null = null;\n  tempF64s: Local[] | null = null;\n  tempV128s: Local[] | null = null;\n  tempFuncrefs: Local[] | null = null;\n  tempExternrefs: Local[] | null = null;\n  tempAnyrefs: Local[] | null = null;\n  tempEqrefs: Local[] | null = null;\n  tempI31refs: Local[] | null = null;\n  tempDatarefs: Local[] | null = null;\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n  breakLabel: string | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    var breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // internal error\n    this.breakStack = breakStack = null;\n    this.breakLabel = null;\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n  }\n}\n\n/** A yet unresolved instance field prototype. */\nexport class FieldPrototype extends DeclaredElement {\n\n  /** Constructs a new field prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent class. */\n    parent: ClassPrototype,\n    /** Declaration reference. */\n    declaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FIELD_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    return (<FieldDeclaration>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<FieldDeclaration>this.declaration).initializer;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    return (<FieldDeclaration>this.declaration).parameterIndex;\n  }\n}\n\n/** A resolved instance field. */\nexport class Field extends VariableLikeElement {\n\n  /** Field prototype reference. */\n  prototype: FieldPrototype;\n  /** Field memory offset, if an instance field. */\n  memoryOffset: i32 = -1;\n  /** Getter function reference, if compiled. */\n  getterRef: FunctionRef = 0;\n  /** Setter function reference, if compiled. */\n  setterRef: FunctionRef = 0;\n\n  /** Constructs a new field. */\n  constructor(\n    /** Respective field prototype. */\n    prototype: FieldPrototype,\n    /** Parent class. */\n    parent: Class,\n    /** Concrete type. */\n    type: Type\n  ) {\n    super(\n      ElementKind.FIELD,\n      prototype.name,\n      parent,\n      <VariableLikeDeclarationStatement>prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    assert(type != Type.void);\n    this.setType(type);\n    registerConcreteElement(this.program, this);\n  }\n\n  /** Gets the field's `this` type. */\n  get thisType(): Type {\n    var parent = this.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    return (<Class>parent).type;\n  }\n\n  /** Gets the internal name of the respective getter function. */\n  get internalGetterName(): string {\n    var cached = this._internalGetterName;\n    if (cached === null) this._internalGetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;\n    return cached;\n  }\n  private _internalGetterName: string | null = null;\n\n  /** Gets the internal name of the respective setter function. */\n  get internalSetterName(): string {\n    var cached = this._internalSetterName;\n    if (cached === null) this._internalSetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;\n    return cached;\n  }\n  private _internalSetterName: string | null = null;\n\n  /** Gets the signature of the respective getter function. */\n  get internalGetterSignature(): Signature {\n    var cached = this._internalGetterSignature;\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, null, this.type, this.thisType);\n    return cached;\n  }\n  private _internalGetterSignature: Signature | null = null;\n\n  /** Gets the signature of the respective setter function. */\n  get internalSetterSignature(): Signature {\n    var cached = this._internalSetterSignature;\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, [ this.type ], Type.void, this.thisType);\n    return cached;\n  }\n  private _internalSetterSignature: Signature | null = null;\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PROPERTY_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    switch (this.parent.kind) {\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: return true;\n    }\n    return false;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new PropertyPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    var getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    var setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.PROPERTY,\n      prototype.name,\n      parent,\n      Node.createVariableDeclaration(\n        prototype.identifierNode,\n        null,\n        prototype.is(CommonFlags.INSTANCE)\n          ? CommonFlags.INSTANCE\n          : CommonFlags.NONE,\n        null, null,\n        prototype.identifierNode.range\n      )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.INSTANCE)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.INDEXSIGNATURE,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extendees: Set<ClassPrototype> = new Set();\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance !== null\n        && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    var current: ClassPrototype | null = this;\n    var seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current === basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    var originalDeclaration = element.declaration;\n    var instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {\n      element.set(CommonFlags.MODULE_EXPORT); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if applicable. */\n  base: Class | null = null;\n  /** Implemented interfaces, if applicable. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  overloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly extending this class. */\n  extendees: Set<Class> | null = null;\n  /** Classes implementing this interface. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    var lengthField = this.getMember(\"length\");\n    return lengthField !== null && (\n      lengthField.kind == ElementKind.FIELD ||\n      (\n        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&\n        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||\n      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null\n    );\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    var program = this.program;\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    var typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters !== null && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n    var extendees = base.extendees;\n    if (!extendees) base.extendees = extendees = new Set();\n    extendees.add(this);\n\n    // Inherit contextual type arguments from base class\n    var inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    var interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n    var implementers = iface.implementers;\n    if (!implementers) iface.implementers = implementers = new Set();\n    implementers.add(this);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    var current: Class | null = this;\n    do {\n      if (current == target) return true;\n      if (target.kind == ElementKind.INTERFACE) {\n        let interfaces = current.interfaces;\n        if (interfaces) {\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n            let iface = _values[i];\n            if (iface.isAssignableTo(target)) return true;\n          }\n        }\n      }\n      current = current.base;\n    } while (current);\n    return false;\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.INDEXED_GET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.INDEXED_SET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    var instance: Class | null = this;\n    do {\n      let overloads = instance.overloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    var member = this.getMember(name);\n    if (member && member.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    var member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.FIELD);\n    return (<Field>member).memoryOffset;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    var program = this.program;\n    var payloadSize = this.nextMemoryOffset + overhead;\n    var blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    var buffer = new Uint8Array(program.blockOverhead + blockSize);\n    var OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    var member = this.getMember(name);\n    if (member !== null && member.kind == ElementKind.FIELD) {\n      let fieldInstance = <Field>member;\n      let offset = baseOffset + fieldInstance.memoryOffset;\n      let typeKind = fieldInstance.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.ISIZE:\n        case TypeKind.USIZE: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extends(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    var current: Class | null = this;\n    do {\n      if (current.prototype === extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    var current: Class = this;\n    var program = this.program;\n    var arrayPrototype = program.arrayPrototype;\n    if (this.extends(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    var staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extends(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    var abvInstance = program.arrayBufferViewInstance;\n    while (current.base !== abvInstance) {\n      current = assert(current.base);\n    }\n    var prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    var program = this.program;\n\n    var instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.FIELD) {\n          let fieldType = (<Field>member).type;\n          if (fieldType.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Gets all extendees of this class (that do not have the specified instance member). */\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\n    var extendees = this.extendees;\n    if (extendees) {\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\n        let extendee = _values[i];\n        if (exceptIfMember) {\n          let instanceMembers = extendee.prototype.instanceMembers;\n          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;\n        }\n        out.add(extendee);\n        extendee.getAllExtendees(exceptIfMember, out);\n      }\n    }\n    return out;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program === newer.program);\n  if (newer.members) return null;\n  var merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FUNCTION_PROTOTYPE: {\n      switch (newer.kind) {\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.CLASS_PROTOTYPE:\n    case ElementKind.ENUM: {\n      if (newer.kind == ElementKind.NAMESPACE) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.NAMESPACE: {\n      switch (newer.kind) {\n        case ElementKind.ENUM:\n        case ElementKind.CLASS_PROTOTYPE:      // TS2434\n        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.GLOBAL: {\n      if (newer.kind == ElementKind.TYPEDEFINITION) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TYPEDEFINITION: {\n      switch (newer.kind) {\n        case ElementKind.GLOBAL:\n        case ElementKind.FUNCTION_PROTOTYPE:\n        case ElementKind.NAMESPACE: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);\n    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  var srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {\n  switch (parent.kind) {\n    case ElementKind.FILE: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.FUNCTION: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers\n    case ElementKind.PROPERTY: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)\n           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nvar cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(\"$\" + i.toString());\n  }\n  return cachedDefaultParameterNames[index];\n}\n","/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Field,\n  FieldPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  uniqueMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport enum ReportMode {\n  /** Report errors. */\n  REPORT,\n  /** Swallow errors. */\n  SWALLOW\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new overload has been discovered. */\n  discoveredOverload: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var nameNode = node.name;\n    var typeArgumentNodes = node.typeArguments;\n    var isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes !== null && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    var shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.ENUM) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, element.name + \"/i32\"\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.CLASS_PROTOTYPE ||\n        element.kind == ElementKind.INTERFACE_PROTOTYPE\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          uniqueMap<string,Type>(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.RESOLVED)) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull) return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = uniqueMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var explicitThisType = node.explicitThisType;\n    var thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    var parameterNodes = node.parameters;\n    var numParameters = parameterNodes.length;\n    var parameterTypes = new Array<Type>(numParameters);\n    var requiredParameters = 0;\n    var hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.DEFAULT: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.REST: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    var returnTypeNode = node.returnType;\n    var returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n    signature.hasRest = hasRest;\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return Type.u32;\n      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.F32: return Type.f32;\n      case TypeKind.F64: return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.VOID: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n    if (overload) {\n      if (overload.is(CommonFlags.STATIC)) {\n        assert(overload.signature.parameterTypes.length == 2);\n        return overload.signature.parameterTypes[1];\n      } else {\n        assert(overload.signature.parameterTypes.length == 1);\n        return overload.signature.parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    var prev = node;\n    var next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type[] | null {\n    var minParameterCount = 0;\n    var maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    var typeArguments = new Array<Type>(maxParameterCount);\n    var oldCtxTypes = uniqueMap<string,Type>(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            uniqueMap<string,Type>(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.GENERIC)) {\n      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;\n        if (!argumentExpression) { // missing initializer -> too few arguments\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);\n          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let typeParameterNode = typeParameterNodes[i];\n        let name = typeParameterNode.name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n          let defaultType = typeParameterNode.defaultType;\n          if (defaultType) {\n            let resolvedDefaultType = this.resolveType(defaultType, ctxFlow.actualFunction, contextualTypeArguments, reportMode);\n            if (!resolvedDefaultType) return null;\n            resolvedTypeArguments[i] = resolvedDefaultType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);\n          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {\n            ctxTypes.set(name, type);\n          }\n        }\n      }\n    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      if (parameterNodes !== null && parameterNodes.length > 0) {\n        let signatureReference = type.signatureReference;\n        if (signatureReference) {\n          let parameterTypes = signatureReference.parameterTypes;\n          let thisType = signatureReference.thisType;\n          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {\n            for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);\n            }\n            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);\n            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    var kind = element.kind;\n    if (kind == ElementKind.GLOBAL) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE:\n      case NodeKind.NULL: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    var name = node.text;\n    var element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    var outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return Type.bool;\n      case NodeKind.NULL: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {\n    if (global.is(CommonFlags.RESOLVED)) return true;\n    var type: Type | null;\n    var typeNode = global.typeNode;\n    if (typeNode) {\n      type = this.resolveType(typeNode, global.parent, null, reportMode);\n    } else {\n      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);\n    }\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetNode = node.expression;\n    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    var propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.ENUMVALUE:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.RESOLVED)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.GENERIC)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.CLASS_PROTOTYPE:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: {\n        do {\n          let member = target.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.STATIC)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.CLASS_PROTOTYPE ||\n            target.kind == ElementKind.INTERFACE_PROTOTYPE\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.CLASS ||\n            target.kind == ElementKind.INTERFACE\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let member = target.getMember(propertyName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetExpression = node.expression;\n    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    intValue: i64,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.BOOL: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.ISIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.USIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NONNULL: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NONNULL: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.CONST: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operand = node.operand;\n    var operator = node.operator;\n    switch (operator) {\n      case Token.MINUS: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.INTEGER)) {\n          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);\n        }\n        // fall-through\n      }\n      case Token.PLUS:\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.EXCLAMATION: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.TILDE: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.DOT_DOT_DOT: {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operator = node.operator;\n    switch (operator) {\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var left = node.left;\n    var right = node.right;\n    var operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.EQUALS:\n      case Token.PLUS_EQUALS:\n      case Token.MINUS_EQUALS:\n      case Token.ASTERISK_EQUALS:\n      case Token.ASTERISK_ASTERISK_EQUALS:\n      case Token.SLASH_EQUALS:\n      case Token.PERCENT_EQUALS:\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.AMPERSAND_EQUALS:\n      case Token.BAR_EQUALS:\n      case Token.CARET_EQUALS: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LESSTHAN:\n      case Token.GREATERTHAN:\n      case Token.LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS_EQUALS: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.ASTERISK:\n      case Token.SLASH:\n      case Token.PERCENT: // mod has special logic, but also behaves like this\n      case Token.ASTERISK_ASTERISK: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.AMPERSAND:\n      case Token.BAR:\n      case Token.CARET: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.AMPERSAND_AMPERSAND:\n      case Token.BAR_BAR: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    var parent = ctxFlow.actualFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    var parent: Element | null = ctxFlow.actualFunction.parent;\n    if (parent !== null && parent.kind == ElementKind.CLASS) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.INTEGER: {\n        let intType = this.determineIntegerLiteralType(\n          (<IntegerLiteralExpression>node).value,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.FLOAT: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.STRING:\n      case LiteralKind.TEMPLATE: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.ARRAY: {\n        let classReference = ctxType.getClass();\n        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.NULL && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            if (reportMode == ReportMode.REPORT) {\n              this.error(\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n                node.range, \"T\"\n              );\n            }\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.OBJECT: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var targetExpression = node.expression;\n    var target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!instance) return null;\n        return instance.signature.returnType;\n      }\n      case ElementKind.GLOBAL:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        let varType = (<VariableLikeElement>target).type;\n        let varElement = this.getElementOfType(varType);\n        if (!varElement || varElement.kind != ElementKind.CLASS) {\n          break;\n        }\n        target = varElement;\n        // fall-through\n      }\n      case ElementKind.CLASS: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          let signatureReference = assert(ftype.signatureReference);\n          return signatureReference.returnType;\n        }\n        break;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    var commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var classInstance: Class | null = null; // if an instance method\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.INSTANCE)) {\n      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);\n      classInstance = <Class>actualParent;\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          if (!ctxTypes.has(classTypeParameterName)) {\n            ctxTypes.set(\n              classTypeParameterName,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n    } else {\n      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    var signatureNode = prototype.functionTypeNode;\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var numFunctionTypeArguments: i32;\n    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    var thisType: Type | null = null;\n    var explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    var signatureParameters = signatureNode.parameters;\n    var numSignatureParameters = signatureParameters.length;\n    var parameterTypes = new Array<Type>(numSignatureParameters);\n    var requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    var returnType: Type;\n    if (prototype.is(CommonFlags.SET)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n\n    var nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += \"<\" + instanceKey + \">\";\n    var instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // remember discovered overloads for virtual stub finalization\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      while (baseClass) {\n        let baseMembers = baseClass.members;\n        if (baseMembers && baseMembers.has(methodOrPropertyName)) {\n          this.discoveredOverload = true;\n          break;\n        }\n        baseClass = baseClass.base;\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.INSTANCE)) {\n        assert(actualParent.kind == ElementKind.CLASS);\n        let classInstance = <Class>actualParent;\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overloads of the given instance method. */\n  resolveOverloads(instance: Function): Function[] | null {\n    var overloadPrototypes = instance.prototype.overloads;\n    if (!overloadPrototypes) return null;\n\n    var parentClassInstance = assert(instance.getClassOrInterface());\n    var overloads = new Set<Function>();\n\n    // A method's `overloads` property contains its unbound overload prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverloadPrototype = _values[i];\n      assert(!unboundOverloadPrototype.isBound);\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\n      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;\n      let classInstances: Map<string,Class> | null;\n      if (isProperty) {\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\n        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>propertyParent).instances;\n      } else {\n        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\n      }\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overloadInstance: Function | null;\n        if (isProperty) {\n          let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\n          assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundProperty);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.GET)) {\n            overloadInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.SET));\n            overloadInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\n          assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          overloadInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n        }\n        if (overloadInstance) overloads.add(overloadInstance);\n      }\n    }\n    return Set_values(overloads);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    var instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    var nameInclTypeParamters = prototype.name;\n    if (instanceKey.length) nameInclTypeParamters += \"<\" + instanceKey + \">\";\n    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParamters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    var pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    var anyPending = false;\n\n    // Resolve base class if applicable\n    var basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        uniqueMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n    }\n\n    // Resolve interfaces if applicable\n    var interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          uniqueMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.INTERFACE);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    var members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    var pendingClasses = this.resolveClassPending;\n    var unimplemented = new Map<string,DeclaredElement>();\n\n    // Alias interface members\n    var interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(ifaceMembers.get(memberName));\n            if (members.has(memberName)) {\n              let existing = assert(members.get(memberName));\n              if (!member.isCompatibleOverride(existing)) {\n                this.errorRelated(\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n                );\n                continue;\n              }\n            }\n            members.set(memberName, member);\n            unimplemented.set(memberName, member);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    var memoryOffset: u32 = 0;\n    var base = instance.base;\n    if (base) {\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(baseMembers.get(memberName));\n          if (members.has(memberName)) {\n            let existing = assert(members.get(memberName));\n            if (!member.isCompatibleOverride(existing)) {\n              this.errorRelated(\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n              );\n              continue;\n            }\n          }\n          members.set(memberName, member);\n          if (member.is(CommonFlags.ABSTRACT)) {\n            unimplemented.set(memberName, member);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    var prototype = instance.prototype;\n    var instanceMemberPrototypes = prototype.instanceMembers;\n    var properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        switch (member.kind) {\n\n          case ElementKind.FIELD_PROTOTYPE: {\n            let fieldPrototype = <FieldPrototype>member;\n            let fieldTypeNode = fieldPrototype.typeNode;\n            let fieldType: Type | null = null;\n            // TODO: handle duplicate non-private fields specifically?\n            if (!fieldTypeNode) {\n              if (base) {\n                let baseMembers = base.members;\n                if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {\n                  let baseField = assert(baseMembers.get(fieldPrototype.name));\n                  if (!baseField.is(CommonFlags.PRIVATE)) {\n                    assert(baseField.kind == ElementKind.FIELD);\n                    fieldType = (<Field>baseField).type;\n                  }\n                }\n              }\n              if (!fieldType) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldPrototype.identifierNode.range.atEnd\n                  );\n                }\n              }\n            } else {\n              fieldType = this.resolveType(\n                fieldTypeNode,\n                prototype.parent, // relative to class\n                instance.contextualTypeArguments,\n                reportMode\n              );\n              if (fieldType == Type.void) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldTypeNode.range\n                  );\n                }\n                break;\n              }\n            }\n            if (!fieldType) break; // did report above\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\n            assert(isPowerOf2(fieldType.byteSize));\n            let mask = fieldType.byteSize - 1;\n            if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n            fieldInstance.memoryOffset = memoryOffset;\n            memoryOffset += fieldType.byteSize;\n            instance.add(memberName, fieldInstance); // reports\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.ABSTRACT)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.INTERFACE) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype !== null && ctorPrototype.parent === instance) {\n          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    var overloadPrototypes = prototype.overloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.INVALID);\n      if (overloadPrototype.is(CommonFlags.GENERIC)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.INSTANCE)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.overloads;\n      if (!overloads) instance.overloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.INSTANCE)) {\n        switch (overloadKind) {\n          case OperatorKind.PREFIX_INC:\n          case OperatorKind.PREFIX_DEC:\n          case OperatorKind.POSTFIX_INC:\n          case OperatorKind.POSTFIX_DEC: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.REPORT) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.INDEXED_GET) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base === instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface === instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Property | null {\n    var instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(prototype, prototype);\n    var getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    var setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.RESOLVED)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): TypeNode | null {\n    var typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n","/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimalDigit,\n  isOctalDigit\n} from \"./util\";\n\n/** Named token types. */\nexport enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  ABSTRACT,\n  AS,\n  ASYNC,\n  AWAIT,        // ES2017\n  BREAK,        // ES2017\n  CASE,         // ES2017\n  CATCH,        // ES2017\n  CLASS,        // ES2017\n  CONST,        // ES2017\n  CONTINUE,     // ES2017\n  CONSTRUCTOR,\n  DEBUGGER,     // ES2017\n  DECLARE,\n  DEFAULT,      // ES2017\n  DELETE,       // ES2017\n  DO,           // ES2017\n  ELSE,         // ES2017\n  ENUM,         // ES2017 future\n  EXPORT,       // ES2017\n  EXTENDS,      // ES2017\n  FALSE,        // ES\n  FINALLY,      // ES2017\n  FOR,          // ES2017\n  FROM,         // AS possible identifier\n  FUNCTION,     // ES2017\n  GET,\n  IF,           // ES2017\n  IMPLEMENTS,   // ES2017 non-lexical\n  IMPORT,       // ES2017\n  IN,           // ES2017\n  INSTANCEOF,   // ES2017\n  INTERFACE,    // ES2017 non-lexical\n  IS,\n  KEYOF,\n  LET,          // ES2017 non-lexical\n  MODULE,       // AS possible identifier\n  NAMESPACE,    // AS possible identifier\n  NEW,          // ES2017\n  NULL,         // ES\n  OF,\n  PACKAGE,      // ES2017 non-lexical\n  PRIVATE,      // ES2017 non-lexical\n  PROTECTED,    // ES2017 non-lexical\n  PUBLIC,       // ES2017 non-lexical\n  READONLY,\n  RETURN,       // ES2017\n  SET,\n  STATIC,       // ES2017 non-lexical\n  SUPER,        // ES2017\n  SWITCH,       // ES2017\n  THIS,         // ES2017\n  THROW,        // ES2017\n  TRUE,         // ES\n  TRY,          // ES2017\n  TYPE,         // AS possible identifier\n  TYPEOF,       // ES2017\n  VAR,          // ES2017\n  VOID,         // ES2017\n  WHILE,        // ES2017\n  WITH,         // ES2017\n  YIELD,        // ES2017\n\n  // punctuation\n\n  OPENBRACE,\n  CLOSEBRACE,\n  OPENPAREN,\n  CLOSEPAREN,\n  OPENBRACKET,\n  CLOSEBRACKET,\n  DOT,\n  DOT_DOT_DOT,\n  SEMICOLON,\n  COMMA,\n  LESSTHAN,\n  GREATERTHAN,\n  LESSTHAN_EQUALS,\n  GREATERTHAN_EQUALS,\n  EQUALS_EQUALS,\n  EXCLAMATION_EQUALS,\n  EQUALS_EQUALS_EQUALS,\n  EXCLAMATION_EQUALS_EQUALS,\n  EQUALS_GREATERTHAN,\n  PLUS,\n  MINUS,\n  ASTERISK_ASTERISK,\n  ASTERISK,\n  SLASH,\n  PERCENT,\n  PLUS_PLUS,\n  MINUS_MINUS,\n  LESSTHAN_LESSTHAN,\n  GREATERTHAN_GREATERTHAN,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\n  AMPERSAND,\n  BAR,\n  CARET,\n  EXCLAMATION,\n  TILDE,\n  AMPERSAND_AMPERSAND,\n  BAR_BAR,\n  QUESTION,\n  COLON,\n  EQUALS,\n  PLUS_EQUALS,\n  MINUS_EQUALS,\n  ASTERISK_EQUALS,\n  ASTERISK_ASTERISK_EQUALS,\n  SLASH_EQUALS,\n  PERCENT_EQUALS,\n  LESSTHAN_LESSTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\n  AMPERSAND_EQUALS,\n  BAR_EQUALS,\n  CARET_EQUALS,\n  AT,\n\n  // literals\n\n  IDENTIFIER,\n  STRINGLITERAL,\n  INTEGERLITERAL,\n  FLOATLITERAL,\n  TEMPLATELITERAL,\n\n  // meta\n\n  INVALID,\n  ENDOFFILE\n}\n\nexport enum IdentifierHandling {\n  DEFAULT,\n  PREFER,\n  ALWAYS\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.ASYNC;\n        if (text == \"await\") return Token.AWAIT;\n        break;\n      }\n      if (text == \"as\") return Token.AS;\n      if (text == \"abstract\") return Token.ABSTRACT;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.BREAK;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.CONST;\n        if (text == \"class\") return Token.CLASS;\n        if (text == \"catch\") return Token.CATCH;\n        break;\n      }\n      if (text == \"case\") return Token.CASE;\n      if (text == \"continue\") return Token.CONTINUE;\n      if (text == \"constructor\") return Token.CONSTRUCTOR;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.DEFAULT;\n        if (text == \"declare\") return Token.DECLARE;\n        break;\n      }\n      if (text == \"do\") return Token.DO;\n      if (text == \"delete\") return Token.DELETE;\n      if (text == \"debugger\") return Token.DEBUGGER;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.ELSE;\n        if (text == \"enum\") return Token.ENUM;\n        break;\n      }\n      if (text == \"export\") return Token.EXPORT;\n      if (text == \"extends\") return Token.EXTENDS;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.FALSE;\n        if (text == \"for\") return Token.FOR;\n        if (text == \"from\") return Token.FROM;\n        break;\n      }\n      if (text == \"function\") return Token.FUNCTION;\n      if (text == \"finally\") return Token.FINALLY;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.GET;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.IF;\n        if (text == \"in\") return Token.IN;\n        if (text == \"is\") return Token.IS;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.IMPLEMENTS;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.IMPORT;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.INSTANCEOF;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.INTERFACE;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KEYOF;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.LET;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.MODULE;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.NEW;\n      if (text == \"null\") return Token.NULL;\n      if (text == \"namespace\") return Token.NAMESPACE;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.OF;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.PRIVATE;\n        if (text == \"package\") return Token.PACKAGE;\n        break;\n      }\n      if (text == \"public\") return Token.PUBLIC;\n      if (text == \"protected\") return Token.PROTECTED;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.RETURN;\n      if (text == \"readonly\") return Token.READONLY;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.SWITCH;\n        if (text == \"static\") return Token.STATIC;\n        break;\n      }\n      if (text == \"set\") return Token.SET;\n      if (text == \"super\") return Token.SUPER;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.TRUE;\n        if (text == \"this\") return Token.THIS;\n        if (text == \"type\") return Token.TYPE;\n        break;\n      }\n      if (text == \"try\") return Token.TRY;\n      if (text == \"throw\") return Token.THROW;\n      if (text == \"typeof\") return Token.TYPEOF;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.VAR;\n      if (text == \"void\") return Token.VOID;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.WHILE;\n      if (text == \"with\") return Token.WITH;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.YIELD;\n      break;\n    }\n  }\n  return Token.INVALID;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.ABSTRACT:\n    case Token.AS:\n    case Token.CONSTRUCTOR:\n    case Token.DECLARE:\n    case Token.DELETE:\n    case Token.FROM:\n    case Token.FOR:\n    case Token.GET:\n    case Token.INSTANCEOF:\n    case Token.IS:\n    case Token.KEYOF:\n    case Token.MODULE:\n    case Token.NAMESPACE:\n    case Token.NULL:\n    case Token.READONLY:\n    case Token.SET:\n    case Token.TYPE:\n    case Token.VOID: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.DELETE: return \"delete\";\n    case Token.IN: return \"in\";\n    case Token.INSTANCEOF: return \"instanceof\";\n    case Token.NEW: return \"new\";\n    case Token.TYPEOF: return \"typeof\";\n    case Token.VOID: return \"void\";\n    case Token.YIELD: return \"yield\";\n    case Token.DOT_DOT_DOT: return \"...\";\n    case Token.COMMA: return \",\";\n    case Token.LESSTHAN: return \"<\";\n    case Token.GREATERTHAN: return \">\";\n    case Token.LESSTHAN_EQUALS: return \"<=\";\n    case Token.GREATERTHAN_EQUALS: return \">=\";\n    case Token.EQUALS_EQUALS: return \"==\";\n    case Token.EXCLAMATION_EQUALS: return \"!=\";\n    case Token.EQUALS_EQUALS_EQUALS: return \"===\";\n    case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\n    case Token.PLUS: return \"+\";\n    case Token.MINUS: return \"-\";\n    case Token.ASTERISK_ASTERISK: return \"**\";\n    case Token.ASTERISK: return \"*\";\n    case Token.SLASH: return \"/\";\n    case Token.PERCENT: return \"%\";\n    case Token.PLUS_PLUS: return \"++\";\n    case Token.MINUS_MINUS: return \"--\";\n    case Token.LESSTHAN_LESSTHAN: return \"<<\";\n    case Token.GREATERTHAN_GREATERTHAN: return \">>\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\n    case Token.AMPERSAND: return \"&\";\n    case Token.BAR: return \"|\";\n    case Token.CARET: return \"^\";\n    case Token.EXCLAMATION: return \"!\";\n    case Token.TILDE: return \"~\";\n    case Token.AMPERSAND_AMPERSAND: return \"&&\";\n    case Token.BAR_BAR: return \"||\";\n    case Token.EQUALS: return \"=\";\n    case Token.PLUS_EQUALS: return \"+=\";\n    case Token.MINUS_EQUALS: return \"-=\";\n    case Token.ASTERISK_EQUALS: return \"*=\";\n    case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\n    case Token.SLASH_EQUALS: return \"/=\";\n    case Token.PERCENT_EQUALS: return \"%=\";\n    case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\n    case Token.AMPERSAND_EQUALS: return \"&=\";\n    case Token.BAR_EQUALS: return \"|=\";\n    case Token.CARET_EQUALS: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\nexport class Range {\n\n  start: i32;\n  end: i32;\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(start: i32, end: i32) {\n    this.start = start;\n    this.end = end;\n  }\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return this.source == other.source && this.start == other.start && this.end == other.end;\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    var text = source.text;\n    var end = text.length;\n    var pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.BYTEORDERMARK\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.HASH &&\n      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LINEFEED\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {\n    this.nextToken = -1;\n    var token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.INVALID);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CARRIAGERETURN: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LINEFEED\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LINEFEED:\n        case CharCode.TAB:\n        case CharCode.VERTICALTAB:\n        case CharCode.FORMFEED:\n        case CharCode.SPACE: {\n          ++pos;\n          break;\n        }\n        case CharCode.EXCLAMATION: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.EQUALS\n            ) {\n              this.pos = pos + 1;\n              return Token.EXCLAMATION_EQUALS_EQUALS;\n            }\n            this.pos = pos;\n            return Token.EXCLAMATION_EQUALS;\n          }\n          this.pos = pos;\n          return Token.EXCLAMATION;\n        }\n        case CharCode.DOUBLEQUOTE:\n        case CharCode.SINGLEQUOTE: {\n          this.pos = pos;\n          return Token.STRINGLITERAL;\n        }\n        case CharCode.BACKTICK: {\n          this.pos = pos;\n          return Token.TEMPLATELITERAL;\n        }\n        case CharCode.PERCENT: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.PERCENT_EQUALS;\n          }\n          this.pos = pos;\n          return Token.PERCENT;\n        }\n        case CharCode.AMPERSAND: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.AMPERSAND) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_AMPERSAND;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.AMPERSAND;\n        }\n        case CharCode.OPENPAREN: {\n          this.pos = pos + 1;\n          return Token.OPENPAREN;\n        }\n        case CharCode.CLOSEPAREN: {\n          this.pos = pos + 1;\n          return Token.CLOSEPAREN;\n        }\n        case CharCode.ASTERISK: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.ASTERISK_EQUALS;\n            }\n            if (chr == CharCode.ASTERISK) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.ASTERISK_ASTERISK_EQUALS;\n              }\n              this.pos = pos;\n              return Token.ASTERISK_ASTERISK;\n            }\n          }\n          this.pos = pos;\n          return Token.ASTERISK;\n        }\n        case CharCode.PLUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.PLUS) {\n              this.pos = pos + 1;\n              return Token.PLUS_PLUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.PLUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.PLUS;\n        }\n        case CharCode.COMMA: {\n          this.pos = pos + 1;\n          return Token.COMMA;\n        }\n        case CharCode.MINUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.MINUS) {\n              this.pos = pos + 1;\n              return Token.MINUS_MINUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.MINUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.MINUS;\n        }\n        case CharCode.DOT: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimalDigit(chr)) {\n              this.pos = pos - 1;\n              return Token.FLOATLITERAL; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.DOT &&\n              text.charCodeAt(pos + 1) == CharCode.DOT\n            ) {\n              this.pos = pos + 2;\n              return Token.DOT_DOT_DOT;\n            }\n          }\n          this.pos = pos;\n          return Token.DOT;\n        }\n        case CharCode.SLASH: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.SLASH) { // single-line\n              let commentKind = CommentKind.LINE;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.SLASH\n              ) {\n                ++pos;\n                commentKind = CommentKind.TRIPLE;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LINEFEED) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.ASTERISK) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.ASTERISK &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.SLASH\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.BLOCK,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.SLASH_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.SLASH;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.INTEGERLITERAL // expects a call to readInteger\n            : Token.FLOATLITERAL;  // expects a call to readFloat\n        }\n        case CharCode.COLON: {\n          this.pos = pos + 1;\n          return Token.COLON;\n        }\n        case CharCode.SEMICOLON: {\n          this.pos = pos + 1;\n          return Token.SEMICOLON;\n        }\n        case CharCode.LESSTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LESSTHAN) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\n              }\n              this.pos = pos;\n              return Token.LESSTHAN_LESSTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.LESSTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.LESSTHAN;\n        }\n        case CharCode.EQUALS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.EQUALS_EQUALS_EQUALS;\n              }\n              this.pos = pos;\n              return Token.EQUALS_EQUALS;\n            }\n            if (chr == CharCode.GREATERTHAN) {\n              this.pos = pos + 1;\n              return Token.EQUALS_GREATERTHAN;\n            }\n          }\n          this.pos = pos;\n          return Token.EQUALS;\n        }\n        case CharCode.GREATERTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GREATERTHAN) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GREATERTHAN) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.EQUALS\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\n                  }\n                  this.pos = pos;\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\n                }\n                if (chr == CharCode.EQUALS) {\n                  this.pos = pos + 1;\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\n                }\n              }\n              this.pos = pos;\n              return Token.GREATERTHAN_GREATERTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.GREATERTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.GREATERTHAN;\n        }\n        case CharCode.QUESTION: {\n          this.pos = pos + 1;\n          return Token.QUESTION;\n        }\n        case CharCode.OPENBRACKET: {\n          this.pos = pos + 1;\n          return Token.OPENBRACKET;\n        }\n        case CharCode.CLOSEBRACKET: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACKET;\n        }\n        case CharCode.CARET: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.CARET_EQUALS;\n          }\n          this.pos = pos;\n          return Token.CARET;\n        }\n        case CharCode.OPENBRACE: {\n          this.pos = pos + 1;\n          return Token.OPENBRACE;\n        }\n        case CharCode.BAR: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.BAR) {\n              this.pos = pos + 1;\n              return Token.BAR_BAR;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.BAR_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.BAR;\n        }\n        case CharCode.CLOSEBRACE: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACE;\n        }\n        case CharCode.TILDE: {\n          this.pos = pos + 1;\n          return Token.TILDE;\n        }\n        case CharCode.AT: {\n          this.pos = pos + 1;\n          return Token.AT;\n        }\n        default: {\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              ++pos < end &&\n              isIdentifierPart(c = text.charCodeAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.ALWAYS) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.INVALID &&\n                !(\n                  identifierHandling == IdentifierHandling.PREFER &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.IDENTIFIER;\n          } else if (isWhiteSpace(c)) {\n            ++pos;\n            break;\n          }\n          let start = pos++;\n          if ( // surrogate pair?\n            (c & 0xFC00) == 0xD800 && pos < end &&\n            ((text.charCodeAt(pos)) & 0xFC00) == 0xDC00\n          ) ++pos;\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.INVALID;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.ENDOFFILE;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.INVALID);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {\n    return this.skip(Token.IDENTIFIER, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {\n    var posBefore = this.pos;\n    var tokenBefore = this.token;\n    var tokenPosBefore = this.tokenPos;\n    var maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GREATERTHAN) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    var nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.INVALID);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    var state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var start = pos;\n    while (\n      ++pos < end &&\n      isIdentifierPart(text.charCodeAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    var start = pos;\n    this.readStringStart = start;\n    var result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.BACKSLASH) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.BACKTICK) {\n        if (c == CharCode.DOLLAR && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OPENBRACE) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    var start = this.pos;\n    var end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    var text = this.source.text;\n    var c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimalDigit(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SINGLEQUOTE: return \"'\";\n      case CharCode.DOUBLEQUOTE: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CARRIAGERETURN: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LINEFEED:\n      case CharCode.LINESEPARATOR:\n      case CharCode.PARAGRAPHSEPARATOR: return \"\";\n      default: return String.fromCharCode(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.SLASH) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctalDigit(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    var text = this.source.text;\n    let pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_4 = i64_new(4);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = (value << 4) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        // value = (value << 4) + 10 + c - CharCode.A;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.A)\n        );\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        // value = (value << 4) + 10 + c - CharCode.a;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.a)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_10 = i64_new(10);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = value * 10 + c - CharCode._0;\n        value = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_3 = i64_new(3);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._7) {\n        // value = (value << 3) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_1 = i64_new(1);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value = (value << 1);\n        value = i64_shl(value, i64_1);\n      } else if (c == CharCode._1) {\n        // value = (value << 1) + 1;\n        value = i64_add(\n          i64_shl(value, i64_1),\n          i64_1\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // var text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    var text = this.source.text;\n    var end = this.end;\n    var start = this.pos;\n    var sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&\n          isDecimalDigit(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var start = pos;\n    var end = this.end;\n    var sepEnd = start;\n    var sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimalDigit(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    var value = 0;\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        value = (value << 4) + c + (10 - CharCode.A);\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        value = (value << 4) + c + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCharCode(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    var pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    var start = this.pos;\n    var value = this.readHexInteger();\n    var value32 = i64_low(value);\n    var invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    var end = this.end;\n    var text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return value32 < 0x10000\n      ? String.fromCharCode(value32)\n      : String.fromCharCode(\n        ((value32 - 0x10000) >>> 10) | 0xD800,\n        ((value32 - 0x10000) & 1023) | 0xDC00\n      );\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nvar reusableState: State | null = null;\n","/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType\n} from \"./module\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  ISIZE,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  USIZE,\n  /** A 1-bit unsigned integer. */\n  BOOL, // sic\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  FUNCREF,\n  /** External reference. */\n  EXTERNREF,\n  /** Any reference. */\n  ANYREF,\n  /** Equatable reference. */\n  EQREF,\n  /** 31-bit integer reference. */\n  I31REF,\n  /** Data reference. */\n  DATAREF,\n\n  // other\n\n  /** No return type. */\n  VOID\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  NONE = 0,\n  /** Is a signed type that can represent negative values. */\n  SIGNED = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  UNSIGNED = 1 << 1,\n  /** Is an integer type. */\n  INTEGER = 1 << 2,\n  /** Is a floating point type. */\n  FLOAT = 1 << 3,\n  /** Is a varying (in size) type. */\n  VARYING = 1 << 4,\n  /** Is smaller than 32-bits. */\n  SHORT = 1 << 5,\n  /** Is larger than 32-bits. */\n  LONG = 1 << 6,\n  /** Is a value type. */\n  VALUE = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  REFERENCE = 1 << 8,\n  /** Is a nullable type. */\n  NULLABLE = 1 << 9,\n  /** Is a vector type. */\n  VECTOR = 1 << 10,\n  /** Is an external type. */\n  EXTERNAL = 1 << 11,\n  /** Is a class. */\n  CLASS = 1 << 12,\n  /** Is a function. */\n  FUNCTION = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Size in bytes. */\n  byteSize: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\n    this.classReference = null;\n    this.signatureReference = null;\n    if (!(flags & TypeFlags.NULLABLE)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.I8: return Type.i8;\n      case TypeKind.I16: return Type.i16;\n      case TypeKind.F32:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.F64:\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8: return Type.u8;\n      case TypeKind.U16: return Type.u16;\n      case TypeKind.U32: return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;\n      case TypeKind.BOOL:\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    if (this.kind == TypeKind.VOID) return Type.auto;\n    return this;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.INTEGER);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.isInternalReference\n      ? this.classReference !== null\n      : false;\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.isInternalReference\n      ? this.signatureReference !== null\n      : false;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n      return this.signatureReference !== null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    var classReference = this.classReference;\n    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    var nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) return false;\n    if (this.isReference) {\n      return (\n        this.classReference == other.classReference &&\n        this.signatureReference == other.signatureReference &&\n        this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    var currentClass: Class | null;\n    var targetClass: Class | null;\n    var currentFunction: Signature | null;\n    var targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference && (this.kind == target.kind || (target.kind == TypeKind.ANYREF && this.kind != TypeKind.EXTERNREF))) {\n            return true;\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {\n      let size = this.size;\n      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat\n      ? \"|null\"\n      : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? \"(\" + signatureReference.toString(validWat) + \")\" + nullablePostfix\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      case TypeKind.EQREF: return \"eqref\";\n      case TypeKind.I31REF: return \"i31ref\";\n      case TypeKind.DATAREF: return \"dataref\";\n      default: assert(false);\n      case TypeKind.VOID: return \"void\";\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return TypeRef.I32;\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64: return TypeRef.I64;\n      case TypeKind.F32: return TypeRef.F32;\n      case TypeKind.F64: return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      // TODO: nullable/non-nullable refs have different type refs\n      case TypeKind.FUNCREF: return TypeRef.Funcref;\n      case TypeKind.EXTERNREF: return TypeRef.Externref;\n      case TypeKind.ANYREF: return TypeRef.Anyref;\n      case TypeKind.EQREF: return TypeRef.Eqref;\n      case TypeKind.I31REF: return TypeRef.I31ref;\n      case TypeKind.DATAREF: return TypeRef.Dataref;\n      case TypeKind.VOID: return TypeRef.None;\n    }\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.BOOL,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.SIGNED   |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.VECTOR   |\n    TypeFlags.VALUE, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.FUNCREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.EXTERNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.ANYREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Equatable reference. */\n  static readonly eqref: Type = new Type(TypeKind.EQREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** 31-bit integer reference. */\n  static readonly i31ref: Type = new Type(TypeKind.I31REF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Data reference. */\n  static readonly dataref: Type = new Type(TypeKind.DATAREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  var numTypes = types.length;\n  var ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toRef();\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  var numTypes = types.length;\n  if (!numTypes) return \"\";\n  var sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Unique id representing this signature. */\n  id: u32 = 0;\n  /** Parameter types, if any, excluding `this`. */\n  parameterTypes: Type[];\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n  requiredParameters: i32;\n  /** Return type. */\n  returnType: Type;\n  /** This type, if an instance signature. */\n  thisType: Type | null;\n  /** Whether the last parameter is a rest parameter. */\n  hasRest: bool;\n  /** Respective function type. */\n  type: Type;\n  /** The program that created this signature. */\n  program: Program;\n\n  /** Constructs a new signature. */\n  constructor(\n    program: Program,\n    parameterTypes: Type[] | null = null,\n    returnType: Type | null = null,\n    thisType: Type | null = null\n  ) {\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\n    this.requiredParameters = 0;\n    this.returnType = returnType ? returnType : Type.void;\n    this.thisType = thisType;\n    this.program = program;\n    this.hasRest = false;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    this.type = type;\n    type.signatureReference = this;\n\n    var signatureTypes = program.uniqueSignatures;\n    var length = signatureTypes.length;\n    for (let i = 0; i < length; i++) {\n      let compare = signatureTypes[i];\n      if (this.equals(compare)) {\n        this.id = compare.id;\n        return this;\n      }\n    }\n    this.id = program.nextSignatureId++;\n    program.uniqueSignatures.push(this);\n  }\n\n  get paramRefs(): TypeRef {\n    var thisType = this.thisType;\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      if (!thisType) return TypeRef.None;\n      return thisType.toRef();\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      typeRefs[0] = thisType.toRef();\n      for (let i = 0; i < numParameterTypes; ++i) {\n        typeRefs[i + 1] = parameterTypes[i].toRef();\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var otherThisType = other.thisType;\n    if (thisThisType !== null) {\n      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var otherParameterTypes = other.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != otherParameterTypes.length) return false;\n    for (let i = 0; i < numParameters; ++i) {\n      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;\n    }\n\n    // check return type\n    return this.returnType.equals(other.returnType);\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var targetThisType = target.thisType;\n    if (thisThisType !== null) {\n      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;\n    } else if (targetThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var targetParameterTypes = target.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = thisParameterTypes[i];\n      let targetParameterType = targetParameterTypes[i];\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\n    }\n\n    // check return type\n    var thisReturnType = this.returnType;\n    var targetReturnType = target.returnType;\n    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    var thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) return true;\n    }\n    var parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (parameterTypes[i].isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    var indices = new Array<i32>();\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    var parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (parameterTypes[i].isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    var sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      assert(!thisType.signatureReference);\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    var parameters = this.parameterTypes;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(): Signature {\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    var cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      cloneParameterTypes[i] = parameterTypes[i];\n    }\n    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);\n  }\n}\n","/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  var lo = readI32(buffer, offset);\n  var hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  var valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n","/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Makes a unique map. Typically used to track contextual type arguemnts. */\nexport function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {\n  var cloned = new Map<K,V>();\n  if (original) {\n    // TODO: for (let [k, v] of original) {\n    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(original.get(k));\n      cloned.set(k, v);\n    }\n  }\n  if (overrides) {\n    // TODO: for (let [k, v] of overrides) {\n    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(overrides.get(k));\n      cloned.set(k, v);\n    }\n  }\n  return cloned;\n}\n","/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./binary\";\nexport * from \"./collections\";\nexport * from \"./math\";\nexport * from \"./path\";\nexport * from \"./terminal\";\nexport * from \"./text\";\nexport * from \"./vector\";\n","/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n","/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.SLASH;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  var pos = 0;\n  var len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.DOT &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  var atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.DOT\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\n              path.charCodeAt(ipos + 2) != CharCode.DOT\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.DOT ||\n            path.charCodeAt(1) != CharCode.DOT\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  var pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n","/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nvar colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  var wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n","/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  NULL = 0,\n  LINEFEED = 0x0A,\n  CARRIAGERETURN = 0x0D,\n  LINESEPARATOR = 0x2028,\n  PARAGRAPHSEPARATOR = 0x2029,\n  NEXTLINE = 0x0085,\n\n  SPACE = 0x20,\n  NONBREAKINGSPACE = 0xA0,\n  ENQUAD = 0x2000,\n  EMQUAD = 0x2001,\n  ENSPACE = 0x2002,\n  EMSPACE = 0x2003,\n  THREEPEREMSPACE = 0x2004,\n  FOURPEREMSPACE = 0x2005,\n  SIXPEREMSPACE = 0x2006,\n  FIGURESPACE = 0x2007,\n  PUNCTUATIONSPACE = 0x2008,\n  THINSPACE = 0x2009,\n  HAIRSPACE = 0x200A,\n  ZEROWIDTHSPACE = 0x200B,\n  NARROWNOBREAKSPACE = 0x202F,\n  IDEOGRAPHICSPACE = 0x3000,\n  MATHEMATICALSPACE = 0x205F,\n  OGHAM = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  AMPERSAND = 0x26,\n  ASTERISK = 0x2A,\n  AT = 0x40,\n  BACKSLASH = 0x5C,\n  BACKTICK = 0x60,\n  BAR = 0x7C,\n  CARET = 0x5E,\n  CLOSEBRACE = 0x7D,\n  CLOSEBRACKET = 0x5D,\n  CLOSEPAREN = 0x29,\n  COLON = 0x3A,\n  COMMA = 0x2C,\n  DOLLAR = 0x24,\n  DOT = 0x2E,\n  DOUBLEQUOTE = 0x22,\n  EQUALS = 0x3D,\n  EXCLAMATION = 0x21,\n  GREATERTHAN = 0x3E,\n  HASH = 0x23,\n  LESSTHAN = 0x3C,\n  MINUS = 0x2D,\n  OPENBRACE = 0x7B,\n  OPENBRACKET = 0x5B,\n  OPENPAREN = 0x28,\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  QUESTION = 0x3F,\n  SEMICOLON = 0x3B,\n  SINGLEQUOTE = 0x27,\n  SLASH = 0x2F,\n  TILDE = 0x7E,\n\n  BACKSPACE = 0x08,\n  FORMFEED = 0x0C,\n  BYTEORDERMARK = 0xFEFF,\n  TAB = 0x09,\n  VERTICALTAB = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: CharCode): bool {\n  switch (c) {\n    case CharCode.LINEFEED:\n    case CharCode.CARRIAGERETURN:\n    case CharCode.LINESEPARATOR:\n    case CharCode.PARAGRAPHSEPARATOR: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  switch (c) {\n    case CharCode.SPACE:\n    case CharCode.TAB:\n    case CharCode.VERTICALTAB:\n    case CharCode.FORMFEED:\n    case CharCode.NONBREAKINGSPACE:\n    case CharCode.NEXTLINE:\n    case CharCode.OGHAM:\n    case CharCode.NARROWNOBREAKSPACE:\n    case CharCode.MATHEMATICALSPACE:\n    case CharCode.IDEOGRAPHICSPACE:\n    case CharCode.BYTEORDERMARK: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\n    }\n  }\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHexDigit(c: i32): bool {\n  return isDecimalDigit(c) || ((c | 32) >= CharCode.a && (c | 32) <= CharCode.f);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isTrivialAlphanum(code: i32): bool {\n  return code >= CharCode.a && code <= CharCode.z\n      || code >= CharCode.A && code <= CharCode.Z\n      || code >= CharCode._0 && code <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid start of an identifier. */\nexport function isIdentifierStart(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierStart(c);\n}\n\n/** Tests if the specified character code is a valid part of an identifier. */\nexport function isIdentifierPart(c: i32): bool {\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c >= CharCode._0 && c <= CharCode._9\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierPart(c);\n}\n\n// storing as u16 to save memory\nconst unicodeIdentifierStart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\nconst unicodeIdentifierPart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\n  8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\n\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\n  if (code < map[0]) return false;\n\n  var lo = 0;\n  var hi = map.length;\n  var mid: i32;\n  var midVal: u16;\n\n  while (lo + 1 < hi) {\n    mid = lo + ((hi - lo) >> 1);\n    mid -= (mid & 1);\n    midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\nfunction isUnicodeIdentifierStart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierStart);\n}\n\nfunction isUnicodeIdentifierPart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierPart);\n}\n\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX4 = \"        \";\n\n/** Creates an indentation matching the number of specified levels. */\nexport function indent(sb: string[], level: i32): void {\n  while (level >= 4) {\n    sb.push(indentX4);\n    level -= 4;\n  }\n  if (level >= 2) {\n    sb.push(indentX2);\n    level -= 2;\n  }\n  if (level) {\n    sb.push(indentX1);\n  }\n}\n","/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n","// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  NONE = 0,\n  /** Sign extension operations. */\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SIGN_EXTENSION: return \"sign-extension\";\n    case Feature.MUTABLE_GLOBALS: return \"mutable-globals\";\n    case Feature.NONTRAPPING_F2I: return \"nontrapping-f2i\";\n    case Feature.BULK_MEMORY: return \"bulk-memory\";\n    case Feature.SIMD: return \"simd\";\n    case Feature.THREADS: return \"threads\";\n    case Feature.EXCEPTION_HANDLING: return \"exception-handling\";\n    case Feature.TAIL_CALLS: return \"tail-calls\";\n    case Feature.REFERENCE_TYPES: return \"reference-types\";\n    case Feature.MULTI_VALUE: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.MEMORY64: return \"memory64\";\n  }\n  assert(false);\n  return \"\";\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  JS = 0,\n  /** WebAssembly with 32-bit pointers. */\n  WASM32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  WASM64 = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__725__;","// GENERATED FILE. DO NOT EDIT.\nvar Long = (function(exports) {\n  \"use strict\";\n  \n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = void 0;\n  \n  /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   * \n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */\n  // WebAssembly optimizations to do native i64 multiplication and divide\n  var wasm = null;\n  \n  try {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  } catch (e) {// no wasm support :(\n  }\n  /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */\n  \n  \n  function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n  \n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n  \n    this.unsigned = !!unsigned;\n  } // The internal representation of a long is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // Javascript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within Javascript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n  \n  /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */\n  \n  \n  Long.prototype.__isLong__;\n  Object.defineProperty(Long.prototype, \"__isLong__\", {\n    value: true\n  });\n  /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */\n  \n  function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n  }\n  /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */\n  \n  \n  Long.isLong = isLong;\n  /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var INT_CACHE = {};\n  /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var UINT_CACHE = {};\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n  \n    if (unsigned) {\n      value >>>= 0;\n  \n      if (cache = 0 <= value && value < 256) {\n        cachedObj = UINT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, 0, true);\n      if (cache) UINT_CACHE[value] = obj;\n      return obj;\n    } else {\n      value |= 0;\n  \n      if (cache = -128 <= value && value < 128) {\n        cachedObj = INT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, value < 0 ? -1 : 0, false);\n      if (cache) INT_CACHE[value] = obj;\n      return obj;\n    }\n  }\n  /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromInt = fromInt;\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  \n    if (unsigned) {\n      if (value < 0) return UZERO;\n      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    } else {\n      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n    }\n  \n    if (value < 0) return fromNumber(-value, unsigned).neg();\n    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n  }\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromNumber = fromNumber;\n  /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n  }\n  /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBits = fromBits;\n  /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */\n  \n  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n  \n  /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromString(str, unsigned, radix) {\n    if (str.length === 0) throw Error('empty string');\n  \n    if (typeof unsigned === 'number') {\n      // For goog.math.long compatibility\n      radix = unsigned;\n      unsigned = false;\n    } else {\n      unsigned = !!unsigned;\n    }\n  \n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    var p;\n    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {\n      return fromString(str.substring(1), unsigned, radix).neg();\n    } // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n  \n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i),\n          value = parseInt(str.substring(i, i + size), radix);\n  \n      if (size < 8) {\n        var power = fromNumber(pow_dbl(radix, size));\n        result = result.mul(power).add(fromNumber(value));\n      } else {\n        result = result.mul(radixToPower);\n        result = result.add(fromNumber(value));\n      }\n    }\n  \n    result.unsigned = unsigned;\n    return result;\n  }\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromString = fromString;\n  /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromValue(val, unsigned) {\n    if (typeof val === 'number') return fromNumber(val, unsigned);\n    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n  \n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n  }\n  /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */\n  \n  \n  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n  // no runtime penalty for these.\n  \n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_16_DBL = 1 << 16;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24_DBL = 1 << 24;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n  /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ZERO = fromInt(0);\n  /**\n   * Signed zero.\n   * @type {!Long}\n   */\n  \n  Long.ZERO = ZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UZERO = fromInt(0, true);\n  /**\n   * Unsigned zero.\n   * @type {!Long}\n   */\n  \n  Long.UZERO = UZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ONE = fromInt(1);\n  /**\n   * Signed one.\n   * @type {!Long}\n   */\n  \n  Long.ONE = ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UONE = fromInt(1, true);\n  /**\n   * Unsigned one.\n   * @type {!Long}\n   */\n  \n  Long.UONE = UONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var NEG_ONE = fromInt(-1);\n  /**\n   * Signed negative one.\n   * @type {!Long}\n   */\n  \n  Long.NEG_ONE = NEG_ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n  /**\n   * Maximum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_VALUE = MAX_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n  /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n  /**\n   * Minimum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MIN_VALUE = MIN_VALUE;\n  /**\n   * @alias Long.prototype\n   * @inner\n   */\n  \n  var LongPrototype = Long.prototype;\n  /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  LongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n  };\n  /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.toNumber = function toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  };\n  /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */\n  \n  \n  LongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    if (this.isZero()) return '0';\n  \n    if (this.isNegative()) {\n      // Unsigned Longs are never negative\n      if (this.eq(MIN_VALUE)) {\n        // We need to change the Long value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixLong = fromNumber(radix),\n            div = this.div(radixLong),\n            rem1 = div.mul(radixLong).sub(this);\n        return div.toString(radix) + rem1.toInt().toString(radix);\n      } else return '-' + this.neg().toString(radix);\n    } // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n  \n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n  \n    while (true) {\n      var remDiv = rem.div(radixToPower),\n          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n          digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) return digits + result;else {\n        while (digits.length < 6) digits = '0' + digits;\n  \n        result = '' + digits + result;\n      }\n    }\n  };\n  /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */\n  \n  \n  LongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n  };\n  /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */\n  \n  \n  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n  };\n  /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */\n  \n  \n  LongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n  };\n  /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */\n  \n  \n  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n  };\n  /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n  \n    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n  \n    return this.high != 0 ? bit + 33 : bit + 1;\n  };\n  /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n  };\n  /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eqz = LongPrototype.isZero;\n  /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  LongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n  };\n  /**\n   * Tests if this Long's value is positive.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n  };\n  /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n  };\n  /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n  };\n  /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.equals = function equals(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  };\n  /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eq = LongPrototype.equals;\n  /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(\n    /* validates */\n    other);\n  };\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.neq = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ne = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThan = function lessThan(other) {\n    return this.comp(\n    /* validates */\n    other) < 0;\n  };\n  /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lt = LongPrototype.lessThan;\n  /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) <= 0;\n  };\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lte = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.le = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(\n    /* validates */\n    other) > 0;\n  };\n  /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gt = LongPrototype.greaterThan;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) >= 0;\n  };\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n  /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  LongPrototype.compare = function compare(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.eq(other)) return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n  \n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n  \n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  };\n  /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  \n  LongPrototype.comp = LongPrototype.compare;\n  /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */\n  \n  LongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n    return this.not().add(ONE);\n  };\n  /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */\n  \n  \n  LongPrototype.neg = LongPrototype.negate;\n  /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */\n  \n  LongPrototype.add = function add(addend) {\n    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n  };\n  /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.sub = LongPrototype.subtract;\n  /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  LongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero()) return this;\n    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n  \n    if (wasm) {\n      var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n  \n    if (this.isNegative()) {\n      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n  \n  \n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  \n  LongPrototype.mul = LongPrototype.multiply;\n  /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  LongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present\n  \n    if (wasm) {\n      // guard against signed division overflow: the largest\n      // negative number / -1 would be 1 larger than the largest\n      // positive number, due to two's complement.\n      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n        // be consistent with non-wasm code path\n        return this;\n      }\n  \n      var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n  \n    if (!this.unsigned) {\n      // This section is only relevant for signed longs and is derived from the\n      // closure library as a whole.\n      if (this.eq(MIN_VALUE)) {\n        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n        else if (divisor.eq(MIN_VALUE)) return ONE;else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shr(1);\n          approx = halfThis.div(divisor).shl(1);\n  \n          if (approx.eq(ZERO)) {\n            return divisor.isNegative() ? ONE : NEG_ONE;\n          } else {\n            rem = this.sub(divisor.mul(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n  \n      if (this.isNegative()) {\n        if (divisor.isNegative()) return this.neg().div(divisor.neg());\n        return this.neg().div(divisor).neg();\n      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n  \n      res = ZERO;\n    } else {\n      // The algorithm below has not been made for unsigned longs. It's therefore\n      // required to take special care of the MSB prior to running it.\n      if (!divisor.unsigned) divisor = divisor.toUnsigned();\n      if (divisor.gt(this)) return UZERO;\n      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n        return UONE;\n      res = UZERO;\n    } // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n  \n  \n    rem = this;\n  \n    while (rem.gte(divisor)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n  \n      var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n          // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n          approxRem = approxRes.mul(divisor);\n  \n      while (approxRem.isNegative() || approxRem.gt(rem)) {\n        approx -= delta;\n        approxRes = fromNumber(approx, this.unsigned);\n        approxRem = approxRes.mul(divisor);\n      } // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n  \n  \n      if (approxRes.isZero()) approxRes = ONE;\n      res = res.add(approxRes);\n      rem = rem.sub(approxRem);\n    }\n  \n    return res;\n  };\n  /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  \n  LongPrototype.div = LongPrototype.divide;\n  /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n  \n    if (wasm) {\n      var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    return this.sub(this.div(divisor).mul(divisor));\n  };\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  \n  LongPrototype.mod = LongPrototype.modulo;\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.rem = LongPrototype.modulo;\n  /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */\n  \n  LongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.and = function and(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.or = function or(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.xor = function xor(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shl = LongPrototype.shiftLeft;\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shr = LongPrototype.shiftRight;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotl = LongPrototype.rotateLeft;\n  /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotr = LongPrototype.rotateRight;\n  /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */\n  \n  LongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned) return this;\n    return fromBits(this.low, this.high, false);\n  };\n  /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */\n  \n  \n  LongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned) return this;\n    return fromBits(this.low, this.high, true);\n  };\n  /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */\n  \n  \n  LongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  };\n  /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n  };\n  /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n  };\n  /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n  };\n  /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n  };\n  /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n  };\n  \n  var _default = Long;\n  exports.default = _default;\n  return \"default\" in exports ? exports.default : exports;\n})({});\nif (typeof define === 'function' && define.amd) define([], function() { return Long; });\nelse if (typeof module === 'object' && typeof exports==='object') module.exports = Long;\n","/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\n\nmodule.exports = binaryen;\n\nconst { Module } = require(\"../module\");\n\nModule.prototype.toText = function toText(watFormat = true) {\n  if (watFormat) {\n    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences\n    // of unreachable statements not actually emitted by the compiler. Optimizing\n    // StackIR removes these again, but may also suppress useless code emitted by\n    // the compiler that's then no longer visible in tests. Both not ideal.\n    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);\n  } else {\n    return binaryen.wrapModule(this.ref).emitText();\n  }\n};\n\nModule.prototype.toAsmjs = function toAsmjs() {\n  return binaryen.wrapModule(this.ref).emitAsmjs();\n};\n","/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobal.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobal.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobal.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n","/**\n * @fileoverview Floating point glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobal.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobal.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobal.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobal.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n","/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst Long = global.Long || require(\"long\");\n\nglobal.i64_zero    = Long.ZERO;\nglobal.i64_one     = Long.ONE;\nglobal.i64_neg_one = Long.fromInt(-1);\n\nglobal.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobal.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobal.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobal.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobal.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobal.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobal.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobal.i64_pow = function i64_pow(left, right) {\n  var rightLo = right.low;\n  var rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(global.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  var result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobal.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobal.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobal.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobal.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobal.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobal.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobal.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobal.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobal.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobal.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobal.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobal.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobal.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  var mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobal.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobal.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobal.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobal.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobal.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobal.i64_to_f32 = function i64_to_f32(value) {\n  return global.Math.fround(value.toNumber());\n};\n\nglobal.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobal.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n","/** @module std/portable *//***/\n\nvar globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\nif (typeof globalScope.ASC_TARGET === \"undefined\") {\n\n  globalScope.ASC_TARGET = 0; // Target.JS\n  globalScope.ASC_RUNTIME = 0; // Runtime.Stub\n  globalScope.ASC_NO_ASSERT = false;\n  globalScope.ASC_MEMORY_BASE = 0;\n  globalScope.ASC_OPTIMIZE_LEVEL = 3;\n  globalScope.ASC_SHRINK_LEVEL = 0;\n  globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\n  globalScope.ASC_FEATURE_SIGN_EXTENSION = false;\n  globalScope.ASC_FEATURE_BULK_MEMORY = false;\n  globalScope.ASC_FEATURE_SIMD = false;\n  globalScope.ASC_FEATURE_THREADS = false;\n\n  var F64 = new Float64Array(1);\n  var U64 = new Uint32Array(F64.buffer);\n\n  Object.defineProperties(\n    globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n    {\n      \"MIN_VALUE\": { value: -128, writable: false },\n      \"MAX_VALUE\": { value:  127, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n    {\n      \"MIN_VALUE\": { value: -32768, writable: false },\n      \"MAX_VALUE\": { value:  32767, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n    {\n      \"MIN_VALUE\": { value: -2147483648, writable: false },\n      \"MAX_VALUE\": { value:  2147483647, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n    {\n      \"MIN_VALUE\": { value:   0, writable: false },\n      \"MAX_VALUE\": { value: 255, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n    {\n      \"MIN_VALUE\": { value:     0, writable: false },\n      \"MAX_VALUE\": { value: 65535, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n    {\n      \"MIN_VALUE\": { value:          0, writable: false },\n      \"MAX_VALUE\": { value: 4294967295, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"bool\"] = function bool(value) { return !!value; },\n    {\n      \"MIN_VALUE\": { value: false, writable: false },\n      \"MAX_VALUE\": { value: true,  writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n    {\n      \"EPSILON\":   { value: 1.1920928955078125e-07, writable: false },\n      \"MIN_VALUE\": { value: 1.401298464324817e-45, writable: false },\n      \"MAX_VALUE\": { value: 3.4028234663852886e+38, writable: false },\n      \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38, writable: false },\n      \"MIN_SAFE_INTEGER\":  { value: -16777215, writable: false },\n      \"MAX_SAFE_INTEGER\":  { value:  16777215, writable: false },\n      \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n      \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n      \"NaN\": { value: NaN, writable: false }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f64\"] = function f64(value) { return +value; },\n    {\n      \"EPSILON\":   { value: 2.2204460492503131e-016, writable: false },\n      \"MIN_VALUE\": { value:                  5e-324, writable: false },\n      \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\n      \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308, writable: false },\n      \"MIN_SAFE_INTEGER\":  { value: -9007199254740991, writable: false },\n      \"MAX_SAFE_INTEGER\":  { value:  9007199254740991, writable: false },\n      \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n      \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n      \"NaN\": { value: NaN, writable: false }\n    }\n  );\n\n  globalScope[\"clz\"] = Math.clz32;\n\n  globalScope[\"ctz\"] = function ctz(value) {\n    var c = Math.clz32(value & -value);\n    return value ? 31 - c : c;\n  };\n\n  globalScope[\"popcnt\"] = function popcnt(value) {\n    value -= value >>> 1 & 0x55555555;\n    value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n    return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n  };\n\n  globalScope[\"rotl\"] = function rotl(value, shift) {\n    shift &= 31;\n    return (value << shift) | (value >>> (32 - shift));\n  };\n\n  globalScope[\"rotr\"] = function rotr(value, shift) {\n    shift &= 31;\n    return (value >>> shift) | (value << (32 - shift));\n  };\n\n  globalScope[\"abs\"] = Math.abs;\n\n  globalScope[\"max\"] = Math.max;\n\n  globalScope[\"min\"] = Math.min;\n\n  globalScope[\"ceil\"] = Math.ceil;\n\n  globalScope[\"floor\"] = Math.floor;\n\n  globalScope[\"nearest\"] = function nearest(value) {\n    const INV_EPS64 = 4503599627370496.0;\n    const y = Math.abs(value);\n    return y < INV_EPS64\n      ? Math.abs(y + INV_EPS64 - INV_EPS64) * Math.sign(value)\n      : value;\n  };\n\n  globalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n    return condition ? ifTrue : ifFalse;\n  };\n\n  globalScope[\"sqrt\"] = Math.sqrt;\n\n  globalScope[\"trunc\"] = Math.trunc;\n\n  globalScope[\"copysign\"] = function copysign(x, y) {\n    return Math.abs(x) * Math.sign(y);\n  };\n\n  globalScope[\"bswap\"] = function bswap(value) {\n    var a = value >> 8 & 0x00FF00FF;\n    var b = (value & 0x00FF00FF) << 8;\n    value = a | b;\n    a = value >> 16 & 0x0000FFFF;\n    b = (value & 0x0000FFFF) << 16;\n    return a | b;\n  };\n\n  globalScope[\"bswap16\"] = function bswap16(value) {\n    return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\n  };\n\n  function UnreachableError() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnreachableError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  UnreachableError.prototype = Object.create(Error.prototype);\n  UnreachableError.prototype.name = \"UnreachableError\";\n  UnreachableError.prototype.message = \"unreachable\";\n\n  globalScope[\"unreachable\"] = function unreachable() {\n    throw new UnreachableError();\n  };\n\n  function AssertionError(message) {\n    this.message = message || \"assertion failed\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  AssertionError.prototype = Object.create(Error.prototype);\n  AssertionError.prototype.name = \"AssertionError\";\n\n  globalScope[\"assert\"] = function assert(isTrueish, message) {\n    if (isTrueish) return isTrueish;\n    throw new AssertionError(message);\n  };\n\n  globalScope[\"changetype\"] = function changetype(value) {\n    return value;\n  };\n\n  String[\"fromCharCodes\"] = function fromCharCodes(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCharCode.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCharCode.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  String[\"fromCodePoints\"] = function fromCodePoints(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCodePoint.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCodePoint.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  if (!String.prototype.at) {\n    Object.defineProperty(String.prototype, \"at\", {\n      value: function at(index) {\n        return this.charAt(index >= 0 ? index : index + this.length);\n      },\n      configurable: true\n    });\n  }\n\n  if (!String.prototype.replaceAll) {\n    Object.defineProperty(String.prototype, \"replaceAll\", {\n      value: function replaceAll(search, replacment) {\n        var res = this.split(search).join(replacment);\n        if (!search.length) res = replacment + res + replacment;\n        return res;\n      },\n      configurable: true\n    });\n  }\n\n  function defaultComparator(a, b) {\n    if (a === b) {\n      if (a !== 0) return 0;\n      a = 1 / a, b = 1 / b;\n    } else {\n      var nanA = a != a, nanB = b != b;\n      if (nanA | nanB) return nanA - nanB;\n      if (a == null) a = String(a);\n      if (b == null) b = String(b);\n    }\n    return a > b ? 1 : -1;\n  }\n\n  const arraySort = Array.prototype.sort;\n  Array.prototype.sort = function sort(comparator) {\n    return arraySort.call(this, comparator || defaultComparator);\n  };\n\n  [ Array,\n    Uint8ClampedArray,\n    Uint8Array, Int8Array,\n    Uint16Array, Int16Array,\n    Uint32Array, Int32Array,\n    Float32Array, Float64Array\n  ].forEach(Ctr => {\n    if (!Ctr.prototype.at) {\n      Object.defineProperty(Ctr.prototype, \"at\", {\n        value: function at(index) {\n          return this[index >= 0 ? index : index + this.length];\n        },\n        configurable: true\n      });\n    }\n\n    if (!Ctr.prototype.findLastIndex) {\n      Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\n        value: function findLastIndex(fn) {\n          for (let i = this.length - 1; i >= 0; --i) {\n            if (fn(this[i], i, this)) return i;\n          }\n          return -1;\n        },\n        configurable: true\n      });\n    }\n  });\n\n  globalScope[\"isInteger\"] = Number.isInteger;\n\n  globalScope[\"isFloat\"] = function isFloat(arg) {\n    return typeof arg === \"number\";\n  };\n\n  globalScope[\"isNullable\"] = function isNullable(arg) {\n    return true;\n  };\n\n  globalScope[\"isReference\"] = function isReference(arg) {\n    return typeof arg === \"object\" || typeof arg === \"string\";\n  };\n\n  globalScope[\"isFunction\"] = function isFunction(arg) {\n    return typeof arg === \"function\";\n  };\n\n  globalScope[\"isString\"] = function isString(arg) {\n    return typeof arg === \"string\" || arg instanceof String;\n  };\n\n  globalScope[\"isArray\"] = Array.isArray;\n  globalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n    return expr\n      && typeof expr === 'object'\n      && typeof expr.length === 'number'\n      && expr.length >= 0\n      && Math.trunc(expr.length) === expr.length;\n  };\n\n  globalScope[\"isDefined\"] = function isDefined(expr) {\n    return typeof expr !== \"undefined\";\n  };\n\n  globalScope[\"isConstant\"] = function isConstant(expr) {\n    return false;\n  };\n\n  globalScope[\"unchecked\"] = function unchecked(expr) {\n    return expr;\n  };\n\n  globalScope[\"fmod\"] = function fmod(x, y) {\n    return x % y;\n  };\n\n  globalScope[\"fmodf\"] = function fmodf(x, y) {\n    return Math.fround(x % y);\n  };\n\n  globalScope[\"JSMath\"] = Math;\n\n  Object.defineProperties(globalScope[\"JSMath\"], {\n    sincos_sin: { value: 0.0, writable: true },\n    sincos_cos: { value: 0.0, writable: true },\n    signbit: {\n      value: function signbit(x) {\n        F64[0] = x; return Boolean(U64[1] >>> 31);\n      }\n    },\n    sincos: {\n      value: function sincos(x) {\n        this.sincos_sin = Math.sin(x);\n        this.sincos_cos = Math.cos(x);\n      }\n    },\n    exp2: {\n      value: function exp2(x) {\n        return Math.pow(2, x);\n      }\n    }\n  });\n\n  globalScope[\"unmanaged\"] = function() { /* nop */ };\n\n  globalScope[\"trace\"] = function(message, n) {\n    if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n    console.error(\"trace: \" + message);\n  };\n\n  Object.defineProperty(Int8Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Int8Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Uint8Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Uint8Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Uint8ClampedArray, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Uint8ClampedArray(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Int16Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Int16Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Uint16Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Uint16Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Int32Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Int32Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Uint32Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Uint32Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Float32Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Float32Array(buffer, byteOffset, length);\n    }\n  });\n\n  Object.defineProperty(Float64Array, \"wrap\", {\n    value: function wrap(buffer, byteOffset, length) {\n      return new Float64Array(buffer, byteOffset, length);\n    }\n  });\n} else {\n  console.warn(\"compiler mismatch: std/portable included twice\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n__webpack_require__(308);\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(780);\n"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__725__","NodeKind","DecoratorKind","LiteralKind","SourceKind","Node","kind","range","constructor","static","name","TypeName","createIdentifierExpression","typeArguments","isNullable","NamedTypeNode","parameters","returnType","explicitThisType","FunctionTypeNode","createSimpleTypeName","extendsType","defaultType","TypeParameterNode","parameterKind","type","initializer","ParameterNode","args","DecoratorNode","fromNode","commentKind","text","CommentNode","isQuoted","IdentifierExpression","elementExpressions","ArrayLiteralExpression","assertionKind","expression","toType","AssertionExpression","operator","left","right","BinaryExpression","CallExpression","declaration","ClassExpression","expressions","CommaExpression","ConstructorExpression","elementExpression","ElementAccessExpression","FalseExpression","value","FloatLiteralExpression","FunctionExpression","isType","InstanceOfExpression","IntegerLiteralExpression","typeName","NewExpression","NullExpression","names","values","ObjectLiteralExpression","OmittedExpression","ParenthesizedExpression","property","PropertyAccessExpression","pattern","patternFlags","RegexpLiteralExpression","condition","ifThen","ifElse","TernaryExpression","StringLiteralExpression","SuperExpression","tag","parts","rawParts","TemplateLiteralExpression","ThisExpression","TrueExpression","operand","UnaryPostfixExpression","UnaryPrefixExpression","expr","CompiledExpression","statements","BlockStatement","label","BreakStatement","decorators","flags","typeParameters","implementsTypes","members","ClassDeclaration","ContinueStatement","statement","DoStatement","EmptyStatement","EnumDeclaration","EnumValueDeclaration","path","isDeclare","ExportStatement","ExportDefaultStatement","externalName","ExportImportStatement","localName","exportedName","ExportMember","ExpressionStatement","ifTrue","ifFalse","IfStatement","declarations","ImportStatement","namespaceName","foreignName","ImportDeclaration","InterfaceDeclaration","FieldDeclaration","incrementor","ForStatement","variable","iterable","ForOfStatement","signature","body","arrowKind","FunctionDeclaration","keyType","valueType","IndexSignatureNode","MethodDeclaration","NamespaceDeclaration","ReturnStatement","cases","SwitchStatement","SwitchCase","ThrowStatement","catchVariable","catchStatements","finallyStatements","TryStatement","TypeDeclaration","VariableStatement","VariableDeclaration","VoidStatement","WhileStatement","isLiteralKind","literalKind","LITERAL","changetype","isNumericLiteral","FLOAT","INTEGER","compilesToConst","STRING","NULL","TRUE","FALSE","isAccessOn","node","CALL","PROPERTYACCESS","isAccessOnThis","THIS","isAccessOnSuper","SUPER","TypeNode","super","hasGenericComponent","typeParameterNodes","NAMEDTYPE","namedTypeNode","next","typeArgumentNodes","length","i","k","identifier","FUNCTIONTYPE","functionTypeNode","parameterNodes","assert","TYPENAME","hasTypeArguments","TYPEPARAMETER","ParameterKind","PARAMETER","implicitFieldDeclaration","CommonFlags","NONE","is","flag","isAny","set","nameNode","IDENTIFIER","nameStr","charCodeAt","BUILTIN","EXTERNAL","FINAL","GLOBAL","INLINE","LAZY","OPERATOR","UNMANAGED","UNSAFE","propertyAccessNode","propStr","OPERATOR_BINARY","OPERATOR_PREFIX","OPERATOR_POSTFIX","CUSTOM","decoratorKind","DECORATOR","CommentKind","COMMENT","Expression","LiteralExpression","ARRAY","AssertionKind","ASSERTION","BINARY","typeArgumentsRange","numTypeArguments","Range","join","argumentsRange","numArguments","CLASS","COMMA","CONSTRUCTOR","ELEMENTACCESS","FUNCTION","INSTANCEOF","NEW","OBJECT","OMITTED","PARENTHESIZED","REGEXP","TERNARY","TEMPLATE","UnaryExpression","UNARYPOSTFIX","UNARYPREFIX","COMPILED","Statement","sourceKind","normalizedPath","SOURCE","internalPath","mangleInternalPath","pos","lastIndexOf","PATH_DELIMITER","simplePath","substring","source","Array","debugInfoIndex","exportPaths","isNative","LIBRARY_SUBST","isLibrary","LIBRARY","LIBRARY_ENTRY","lineCache","lineColumn","lineAt","off","end","push","l","r","m","s","unchecked","columnAt","DeclarationStatement","INDEXSIGNATURE","VariableLikeDeclarationStatement","BLOCK","BREAK","CLASSDECLARATION","indexSignature","isGeneric","CONTINUE","DO","EMPTY","ENUMDECLARATION","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","EXPORT","normalizePath","startsWith","resolvePath","LIBRARY_PREFIX","EXPORTDEFAULT","EXPRESSION","parameterIndex","FIELDDECLARATION","FOR","FOROF","ArrowKind","FUNCTIONDECLARATION","clone","IF","IMPORTDECLARATION","IMPORT","INTERFACEDECLARATION","METHODDECLARATION","NAMESPACEDECLARATION","RETURN","SWITCHCASE","SWITCH","THROW","TRY","TYPEDECLARATION","VARIABLEDECLARATION","VARIABLE","VOID","WHILE","len","cur","isTrivialAlphanum","decorator","BuiltinNames","start","started","argumentsLength","setArgumentsLength","abort","trace","seed","isInteger","isFloat","isBoolean","isSigned","isReference","isString","isArray","isArrayLike","isFunction","isDefined","isConstant","isManaged","isVoid","add","sub","mul","div","clz","ctz","popcnt","rotl","rotr","abs","max","min","ceil","floor","copysign","nearest","reinterpret","sqrt","trunc","load","store","atomic_load","atomic_store","atomic_add","atomic_sub","atomic_and","atomic_or","atomic_xor","atomic_xchg","atomic_cmpxchg","atomic_wait","atomic_notify","atomic_fence","sizeof","alignof","offsetof","nameof","lengthof","select","unreachable","call_indirect","instantiate","idof","i8","i16","i32","i64","isize","u8","u16","u32","u64","usize","bool","f32","f64","v128","i32_clz","i64_clz","i32_ctz","i64_ctz","i32_popcnt","i64_popcnt","i32_rotl","i64_rotl","i32_rotr","i64_rotr","f32_abs","f64_abs","f32_max","f64_max","f32_min","f64_min","f32_ceil","f64_ceil","f32_floor","f64_floor","f32_copysign","f64_copysign","f32_nearest","f64_nearest","i32_reinterpret_f32","i64_reinterpret_f64","f32_reinterpret_i32","f64_reinterpret_i64","f32_sqrt","f64_sqrt","f32_trunc","f64_trunc","i32_add","i64_add","f32_add","f64_add","i32_sub","i64_sub","f32_sub","f64_sub","i32_mul","i64_mul","f32_mul","f64_mul","i32_div_s","i32_div_u","i64_div_s","i64_div_u","f32_div","f64_div","i32_load8_s","i32_load8_u","i32_load16_s","i32_load16_u","i32_load","i64_load8_s","i64_load8_u","i64_load16_s","i64_load16_u","i64_load32_s","i64_load32_u","i64_load","f32_load","f64_load","i32_store8","i32_store16","i32_store","i64_store8","i64_store16","i64_store32","i64_store","f32_store","f64_store","i32_atomic_load8_u","i32_atomic_load16_u","i32_atomic_load","i64_atomic_load8_u","i64_atomic_load16_u","i64_atomic_load32_u","i64_atomic_load","i32_atomic_store8","i32_atomic_store16","i32_atomic_store","i64_atomic_store8","i64_atomic_store16","i64_atomic_store32","i64_atomic_store","i32_atomic_rmw8_add_u","i32_atomic_rmw16_add_u","i32_atomic_rmw_add","i64_atomic_rmw8_add_u","i64_atomic_rmw16_add_u","i64_atomic_rmw32_add_u","i64_atomic_rmw_add","i32_atomic_rmw8_sub_u","i32_atomic_rmw16_sub_u","i32_atomic_rmw_sub","i64_atomic_rmw8_sub_u","i64_atomic_rmw16_sub_u","i64_atomic_rmw32_sub_u","i64_atomic_rmw_sub","i32_atomic_rmw8_and_u","i32_atomic_rmw16_and_u","i32_atomic_rmw_and","i64_atomic_rmw8_and_u","i64_atomic_rmw16_and_u","i64_atomic_rmw32_and_u","i64_atomic_rmw_and","i32_atomic_rmw8_or_u","i32_atomic_rmw16_or_u","i32_atomic_rmw_or","i64_atomic_rmw8_or_u","i64_atomic_rmw16_or_u","i64_atomic_rmw32_or_u","i64_atomic_rmw_or","i32_atomic_rmw8_xor_u","i32_atomic_rmw16_xor_u","i32_atomic_rmw_xor","i64_atomic_rmw8_xor_u","i64_atomic_rmw16_xor_u","i64_atomic_rmw32_xor_u","i64_atomic_rmw_xor","i32_atomic_rmw8_xchg_u","i32_atomic_rmw16_xchg_u","i32_atomic_rmw_xchg","i64_atomic_rmw8_xchg_u","i64_atomic_rmw16_xchg_u","i64_atomic_rmw32_xchg_u","i64_atomic_rmw_xchg","i32_atomic_rmw8_cmpxchg_u","i32_atomic_rmw16_cmpxchg_u","i32_atomic_rmw_cmpxchg","i64_atomic_rmw8_cmpxchg_u","i64_atomic_rmw16_cmpxchg_u","i64_atomic_rmw32_cmpxchg_u","i64_atomic_rmw_cmpxchg","i32_wait","i64_wait","v128_splat","v128_extract_lane","v128_replace_lane","v128_shuffle","v128_swizzle","v128_load_splat","v128_load_ext","v128_load_zero","v128_load_lane","v128_store_lane","v128_load","v128_load8x8_s","v128_load8x8_u","v128_load16x4_s","v128_load16x4_u","v128_load32x2_s","v128_load32x2_u","v128_load8_splat","v128_load16_splat","v128_load32_splat","v128_load64_splat","v128_load32_zero","v128_load64_zero","v128_load8_lane","v128_load16_lane","v128_load32_lane","v128_load64_lane","v128_store8_lane","v128_store16_lane","v128_store32_lane","v128_store64_lane","v128_store","v128_add","v128_sub","v128_mul","v128_div","v128_neg","v128_add_sat","v128_sub_sat","v128_shl","v128_shr","v128_and","v128_or","v128_xor","v128_andnot","v128_not","v128_bitselect","v128_any_true","v128_all_true","v128_bitmask","v128_popcnt","v128_min","v128_max","v128_pmin","v128_pmax","v128_dot","v128_avgr","v128_abs","v128_sqrt","v128_ceil","v128_floor","v128_trunc","v128_nearest","v128_eq","v128_ne","v128_lt","v128_le","v128_gt","v128_ge","v128_convert","v128_convert_low","v128_trunc_sat","v128_trunc_sat_zero","v128_narrow","v128_extend_low","v128_extend_high","v128_extadd_pairwise","v128_demote_zero","v128_promote_low","v128_q15mulr_sat","v128_extmul_low","v128_extmul_high","i8x16","i16x8","i32x4","i64x2","f32x4","f64x2","i8x16_splat","i8x16_extract_lane_s","i8x16_extract_lane_u","i8x16_replace_lane","i8x16_add","i8x16_sub","i8x16_mul","i8x16_min_s","i8x16_min_u","i8x16_max_s","i8x16_max_u","i8x16_avgr_u","i8x16_abs","i8x16_neg","i8x16_add_sat_s","i8x16_add_sat_u","i8x16_sub_sat_s","i8x16_sub_sat_u","i8x16_shl","i8x16_shr_s","i8x16_shr_u","i8x16_all_true","i8x16_bitmask","i8x16_popcnt","i8x16_eq","i8x16_ne","i8x16_lt_s","i8x16_lt_u","i8x16_le_s","i8x16_le_u","i8x16_gt_s","i8x16_gt_u","i8x16_ge_s","i8x16_ge_u","i8x16_narrow_i16x8_s","i8x16_narrow_i16x8_u","i8x16_shuffle","i8x16_swizzle","i16x8_splat","i16x8_extract_lane_s","i16x8_extract_lane_u","i16x8_replace_lane","i16x8_add","i16x8_sub","i16x8_mul","i16x8_min_s","i16x8_min_u","i16x8_max_s","i16x8_max_u","i16x8_avgr_u","i16x8_abs","i16x8_neg","i16x8_add_sat_s","i16x8_add_sat_u","i16x8_sub_sat_s","i16x8_sub_sat_u","i16x8_shl","i16x8_shr_s","i16x8_shr_u","i16x8_all_true","i16x8_bitmask","i16x8_eq","i16x8_ne","i16x8_lt_s","i16x8_lt_u","i16x8_le_s","i16x8_le_u","i16x8_gt_s","i16x8_gt_u","i16x8_ge_s","i16x8_ge_u","i16x8_narrow_i32x4_s","i16x8_narrow_i32x4_u","i16x8_extend_low_i8x16_s","i16x8_extend_low_i8x16_u","i16x8_extend_high_i8x16_s","i16x8_extend_high_i8x16_u","i16x8_extadd_pairwise_i8x16_s","i16x8_extadd_pairwise_i8x16_u","i16x8_q15mulr_sat_s","i16x8_extmul_low_i8x16_s","i16x8_extmul_low_i8x16_u","i16x8_extmul_high_i8x16_s","i16x8_extmul_high_i8x16_u","i32x4_splat","i32x4_extract_lane","i32x4_replace_lane","i32x4_add","i32x4_sub","i32x4_mul","i32x4_min_s","i32x4_min_u","i32x4_max_s","i32x4_max_u","i32x4_dot_i16x8_s","i32x4_abs","i32x4_neg","i32x4_shl","i32x4_shr_s","i32x4_shr_u","i32x4_all_true","i32x4_bitmask","i32x4_eq","i32x4_ne","i32x4_lt_s","i32x4_lt_u","i32x4_le_s","i32x4_le_u","i32x4_gt_s","i32x4_gt_u","i32x4_ge_s","i32x4_ge_u","i32x4_trunc_sat_f32x4_s","i32x4_trunc_sat_f32x4_u","i32x4_trunc_sat_f64x2_s_zero","i32x4_trunc_sat_f64x2_u_zero","i32x4_extend_low_i16x8_s","i32x4_extend_low_i16x8_u","i32x4_extend_high_i16x8_s","i32x4_extend_high_i16x8_u","i32x4_extadd_pairwise_i16x8_s","i32x4_extadd_pairwise_i16x8_u","i32x4_extmul_low_i16x8_s","i32x4_extmul_low_i16x8_u","i32x4_extmul_high_i16x8_s","i32x4_extmul_high_i16x8_u","i64x2_splat","i64x2_extract_lane","i64x2_replace_lane","i64x2_add","i64x2_sub","i64x2_mul","i64x2_abs","i64x2_neg","i64x2_shl","i64x2_shr_s","i64x2_shr_u","i64x2_all_true","i64x2_bitmask","i64x2_eq","i64x2_ne","i64x2_lt_s","i64x2_lt_u","i64x2_le_s","i64x2_le_u","i64x2_gt_s","i64x2_gt_u","i64x2_ge_s","i64x2_ge_u","i64x2_extend_low_i32x4_s","i64x2_extend_low_i32x4_u","i64x2_extend_high_i32x4_s","i64x2_extend_high_i32x4_u","i64x2_extmul_low_i32x4_s","i64x2_extmul_low_i32x4_u","i64x2_extmul_high_i32x4_s","i64x2_extmul_high_i32x4_u","f32x4_splat","f32x4_extract_lane","f32x4_replace_lane","f32x4_add","f32x4_sub","f32x4_mul","f32x4_div","f32x4_neg","f32x4_min","f32x4_max","f32x4_pmin","f32x4_pmax","f32x4_abs","f32x4_sqrt","f32x4_ceil","f32x4_floor","f32x4_trunc","f32x4_nearest","f32x4_eq","f32x4_ne","f32x4_lt","f32x4_le","f32x4_gt","f32x4_ge","f32x4_convert_i32x4_s","f32x4_convert_i32x4_u","f32x4_demote_f64x2_zero","f64x2_splat","f64x2_extract_lane","f64x2_replace_lane","f64x2_add","f64x2_sub","f64x2_mul","f64x2_div","f64x2_neg","f64x2_min","f64x2_max","f64x2_pmin","f64x2_pmax","f64x2_abs","f64x2_sqrt","f64x2_ceil","f64x2_floor","f64x2_trunc","f64x2_nearest","f64x2_eq","f64x2_ne","f64x2_lt","f64x2_le","f64x2_gt","f64x2_ge","f64x2_convert_low_i32x4_s","f64x2_convert_low_i32x4_u","f64x2_promote_low_f32x4","i31_new","i31_get","data_end","stack_pointer","heap_base","rtti_base","visit_globals","visit_members","tostack","isNaN","isFinite","ERROR","WARNING","INFO","Function","memory_size","memory_grow","memory_copy","memory_fill","memory_data","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Int64Array","Uint64Array","Float32Array","Float64Array","String_raw","wasiAbort","wasiTrace","wasiSeed","builtin_clz","ctx","compiler","checkTypeOptional","checkArgsRequired","arg0","compileExpression","operands","Type","currentType","isValue","unary","UnaryOp","ClzI32","options","isWasm64","ClzI64","error","DiagnosticCode","Operation_0_cannot_be_applied_to_type_1","reportNode","toString","builtin_ctz","CtzI32","CtzI64","builtin_popcnt","PopcntI32","PopcntI64","builtin_rotl","arg1","flow","currentFlow","temp1","getTempLocal","findUsedLocals","setLocalFlag","index","LocalFlags","WRAPPED","temp2","ret","binary","BinaryOp","OrI32","ShlI32","local_tee","AndI32","size","ShrU32","local_get","TypeRef","I32","SubI32","freeTempLocal","RotlI32","RotlI64","builtin_rotr","RotrI32","RotrI64","builtin_abs","auto","XorI32","AddI32","ShrI32","usizeType","XorI64","AddI64","ShrI64","sizeTypeRef","I64","AbsF32","AbsF64","builtin_max","op","GtI32","GtU32","GtI64","GtU64","MaxF32","MaxF64","typeRef","toRef","builtin_min","LtI32","LtU32","LtI64","LtU64","MinF32","MinF64","builtin_ceil","CeilF32","CeilF64","builtin_floor","FloorF32","FloorF64","builtin_copysign","CopysignF32","CopysignF64","builtin_nearest","NearestF32","NearestF64","builtin_reinterpret","checkTypeRequired","ReinterpretF32ToI32","ReinterpretF64ToI64","ReinterpretI32ToF32","ReinterpretI64ToF64","builtin_sqrt","SqrtF32","SqrtF64","builtin_trunc","TruncF32","TruncF64","builtin_load","checkArgsOptional","contextualType","outType","isIntegerValue","numOperands","immOffset","immAlign","byteSize","evaluateImmediateOffset","evaluateImmediateAlign","isSignedIntegerValue","builtin_store","void","contextIsExact","inType","convertExpression","builtin_add","isNumericValue","makeAdd","builtin_sub","makeSub","builtin_mul","makeMul","builtin_div","makeDiv","builtin_atomic_load","checkFeatureEnabled","builtin_atomic_store","builtin_atomic_binary","opName","atomic_rmw","builtin_atomic_add","AtomicRMWOp","Add","builtin_atomic_sub","Sub","builtin_atomic_and","And","builtin_atomic_or","Or","builtin_atomic_xor","Xor","builtin_atomic_xchg","Xchg","builtin_atomic_cmpxchg","arg2","builtin_atomic_wait","builtin_diagnostic","category","checkTypeAbsent","emitDiagnostic","User_defined_0","DiagnosticCategory","nop","builtin_conversion","builtin_i8x16","bytes","precomp","runExpression","ExpressionRunnerFlags","PreserveSideeffects","writeI8","getConstValueI32","Expression_must_be_a_compile_time_constant","builtin_v128_splat","SplatI8x16","SplatI16x8","SplatI32x4","SplatI64x2","SplatF32x4","SplatF64x2","builtin_v128_extract_lane","idx","maxIdx","_0_must_be_a_value_between_1_and_2_inclusive","simd_extract","SIMDExtractOp","ExtractLaneI8x16","ExtractLaneU8x16","ExtractLaneI16x8","ExtractLaneU16x8","ExtractLaneI32x4","ExtractLaneI64x2","ExtractLaneF32x4","ExtractLaneF64x2","builtin_v128_replace_lane","simd_replace","SIMDReplaceOp","ReplaceLaneI8x16","ReplaceLaneI16x8","ReplaceLaneI32x4","ReplaceLaneI64x2","ReplaceLaneF32x4","ReplaceLaneF64x2","builtin_v128_shuffle","laneWidth","laneCount","isPowerOf2","mask","argN","off8","idx8","simd_shuffle","builtin_v128_swizzle","SwizzleI8x16","builtin_v128_load_splat","simd_load","SIMDLoadOp","Load8Splat","Load16Splat","Load32Splat","Load64Splat","builtin_v128_load_ext","Load8x8S","Load8x8U","Load16x4S","Load16x4U","Load32x2S","Load32x2U","builtin_v128_load_zero","Load32Zero","Load64Zero","builtin_v128_load_lane","simd_loadstorelane","SIMDLoadStoreLaneOp","Load8Lane","Load16Lane","Load32Lane","Load64Lane","builtin_v128_store_lane","Store8Lane","Store16Lane","Store32Lane","Store64Lane","builtin_v128_add","AddI8x16","AddI16x8","AddI32x4","AddI64x2","AddF32x4","AddF64x2","builtin_v128_sub","SubI8x16","SubI16x8","SubI32x4","SubI64x2","SubF32x4","SubF64x2","builtin_v128_mul","MulI16x8","MulI32x4","MulI64x2","MulF32x4","MulF64x2","builtin_v128_div","DivF32x4","DivF64x2","builtin_v128_add_sat","AddSatI8x16","AddSatU8x16","AddSatI16x8","AddSatU16x8","builtin_v128_sub_sat","SubSatI8x16","SubSatU8x16","SubSatI16x8","SubSatU16x8","builtin_v128_min","MinI8x16","MinU8x16","MinI16x8","MinU16x8","MinI32x4","MinU32x4","MinF32x4","MinF64x2","builtin_v128_max","MaxI8x16","MaxU8x16","MaxI16x8","MaxU16x8","MaxI32x4","MaxU32x4","MaxF32x4","MaxF64x2","builtin_v128_pmin","PminF32x4","PminF64x2","builtin_v128_pmax","PmaxF32x4","PmaxF64x2","builtin_v128_dot","DotI16x8","builtin_v128_avgr","AvgrU8x16","AvgrU16x8","builtin_v128_eq","EqI8x16","EqI16x8","EqI32x4","EqI64x2","EqF32x4","EqF64x2","builtin_v128_ne","NeI8x16","NeI16x8","NeI32x4","NeI64x2","NeF32x4","NeF64x2","builtin_v128_lt","LtI8x16","LtU8x16","LtI16x8","LtU16x8","LtI32x4","LtU32x4","LtI64x2","LtF32x4","LtF64x2","builtin_v128_le","LeI8x16","LeU8x16","LeI16x8","LeU16x8","LeI32x4","LeU32x4","LeI64x2","LeF32x4","LeF64x2","builtin_v128_gt","GtI8x16","GtU8x16","GtI16x8","GtU16x8","GtI32x4","GtU32x4","GtI64x2","GtF32x4","GtF64x2","builtin_v128_ge","GeI8x16","GeU8x16","GeI16x8","GeU16x8","GeI32x4","GeU32x4","GeI64x2","GeF32x4","GeF64x2","builtin_v128_narrow","NarrowI16x8ToI8x16","NarrowU16x8ToU8x16","NarrowI32x4ToI16x8","NarrowU32x4ToU16x8","builtin_v128_neg","NegI8x16","NegI16x8","NegI32x4","NegI64x2","NegF32x4","NegF64x2","builtin_v128_abs","AbsI8x16","AbsI16x8","AbsI32x4","AbsI64x2","AbsF32x4","AbsF64x2","builtin_v128_sqrt","SqrtF32x4","SqrtF64x2","builtin_v128_ceil","CeilF32x4","CeilF64x2","builtin_v128_floor","FloorF32x4","FloorF64x2","builtin_v128_trunc","TruncF32x4","TruncF64x2","builtin_v128_nearest","NearestF32x4","NearestF64x2","builtin_v128_convert","ConvertI32x4ToF32x4","ConvertU32x4ToF32x4","builtin_v128_convert_low","ConvertLowI32x4ToF64x2","ConvertLowU32x4ToF64x2","builtin_v128_trunc_sat","TruncSatF32x4ToI32x4","TruncSatF32x4ToU32x4","builtin_v128_trunc_sat_zero","TruncSatF64x2ToI32x4Zero","TruncSatF64x2ToU32x4Zero","builtin_v128_extend_low","ExtendLowI8x16ToI16x8","ExtendLowU8x16ToU16x8","ExtendLowI16x8ToI32x4","ExtendLowU16x8ToU32x4","ExtendLowI32x4ToI64x2","ExtendLowU32x4ToU64x2","builtin_v128_extend_high","ExtendHighI8x16ToI16x8","ExtendHighU8x16ToU16x8","ExtendHighI16x8ToI32x4","ExtendHighU16x8ToU32x4","ExtendHighI32x4ToI64x2","ExtendHighU32x4ToU64x2","builtin_v128_shl","simd_shift","SIMDShiftOp","ShlI8x16","ShlI16x8","ShlI32x4","ShlI64x2","builtin_v128_shr","ShrI8x16","ShrU8x16","ShrI16x8","ShrU16x8","ShrI32x4","ShrU32x4","ShrI64x2","ShrU64x2","builtin_v128_bitwise_binary","builtin_v128_all_true","AllTrueI8x16","AllTrueI16x8","AllTrueI32x4","AllTrueI64x2","builtin_v128_bitmask","BitmaskI8x16","BitmaskI16x8","BitmaskI32x4","BitmaskI64x2","builtin_v128_popcnt","PopcntI8x16","builtin_v128_extadd_pairwise","ExtaddPairwiseI8x16ToI16x8","ExtaddPairwiseU8x16ToU16x8","ExtaddPairwiseI16x8ToI32x4","ExtaddPairwiseU16x8ToU32x4","builtin_v128_demote_zero","DemoteZeroF64x2ToF32x4","builtin_v128_promote_low","PromoteLowF32x4ToF64x2","builtin_v128_q15mulr_sat","Q15mulrSatI16x8","builtin_v128_extmul_low","ExtmulLowI16x8","ExtmulLowU16x8","ExtmulLowI32x4","ExtmulLowU32x4","ExtmulLowI64x2","ExtmulLowU64x2","builtin_v128_extmul_high","ExtmulHighI16x8","ExtmulHighU16x8","ExtmulHighI32x4","ExtmulHighU32x4","ExtmulHighI64x2","ExtmulHighU64x2","ensureVisitMembersOf","instance","visitRef","program","sizeTypeSize","visitInstance","base","call","internalName","None","hasVisitImpl","isDeclaredInLibrary","visitPrototype","getMember","ElementKind","FUNCTION_PROTOTYPE","resolver","resolveFunction","compileFunction","visitSignature","visitThisType","thisType","parameterTypes","isStrictlyAssignableTo","needsTempValue","_values","Map_values","j","member","FIELD","parent","fieldOffset","memoryOffset","if","addFunction","createType","flatten","typeToRuntimeFlags","alignLog2","evaluateConstantType","Expected_0_type_arguments_but_got_1","Expected_0_arguments_but_got_1","usize64","getConstValueI64High","getConstValueI64Low","usize32","naturalAlign","align","_0_must_be_a_power_of_two","feature","hasFeature","Feature_0_is_not_enabled","featureToString","setCurrentTypeOnError","prototype","Type_0_is_not_generic","expected","expectedMinimum","expectedMaximum","Expected_at_least_0_arguments_but_got_1","contextualUsize","i64_is_i32","i64_low","i64_is_u32","i64_high","thisOperand","builtins","Map","function_builtins","isFloatValue","isBooleanValue","classReference","getClass","isAssignableTo","stringInstance","extends","arrayPrototype","isNullableReference","element","lookupExpression","ReportMode","SWALLOW","getExpressionId","ExpressionId","Const","signatureReference","Type_0_has_no_call_signatures","i64_new","getClassOrWrapper","firstOperand","String_literal_expected","fieldName","classMembers","has","get","Type_0_has_no_property_1","nextMemoryOffset","resultType","isInternalReference","getSignature","ensureStaticString","id","hasDecorator","DecoratorFlags","maybeDropCondition","LocalGet","NeF32","getLocalGetIndex","F32","temp","NeF64","F64","EqF32","SubF32","EqF64","SubF64","makeIsTrueish","compileCallDirect","offset","elementType","valuesOperand","Array_literal_expected","numElements","exprs","isStatic","makeZero","buf","writeStaticBuffer","byteLength","addAlignedMemorySegment","MAX_VALUE","i31ref","fromType","isChangeableTo","Type_0_cannot_be_changed_to_type_1","nonNullableType","noAssert","evaled","Default","getExpressionType","getConstValueF32","getConstValueF64","makeAbort","EqzI32","EqzI64","ref_is","RefIsOp","RefIsNull","alreadyUnchecked","unset","indexArg","operandExprs","paramTypeRefs","classInstance","This_expression_is_not_constructable","ctor","ensureConstructor","checkFieldInitialization","compileInstantiate","functionPrototype","ftype","requiredParameters","functionArg","shift","thisArg","_this_cannot_be_referenced_in_current_location","compileCallIndirect","Not_implemented_0","isizeType","writeI16","writeI32","writeF32","writeF64","AndV128","OrV128","XorV128","AndnotV128","builtin_v128_bitwise_unary","NotV128","simd_ternary","builtin_v128_bitwise_ternary","SIMDTernaryOp","Bitselect","AnyTrueV128","runtimeFeatures","elementsByName","global","INLINED","constantIntegerValue","global_get","block","managedClasses","nextId","_keys","Map_keys","instanceId","isPointerfree","return","current","switch","SubI64","count","data","abvInstance","arrayBufferViewInstance","abvPrototype","setPrototype","mapPrototype","staticArrayPrototype","lastId","getArrayValueType","getTypeArgumentsTo","rttiFlags","segment","addGlobal","instanceofInstance","stmts","instances","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","INNER_DELIMITER","INDEX_SUFFIX","STUB_DELIMITER","CommonNames","funcref","externref","anyref","eqref","dataref","u8x16","u16x8","u32x4","u64x2","void_","number","boolean","string","native","indexof","valueof","returnof","nonnull","null_","true_","false_","this_","super_","ASC_TARGET","ASC_RUNTIME","ASC_NO_ASSERT","ASC_MEMORY_BASE","ASC_TABLE_BASE","ASC_OPTIMIZE_LEVEL","ASC_SHRINK_LEVEL","ASC_LOW_MEMORY_LIMIT","ASC_EXPORT_RUNTIME","ASC_WASI","ASC_FEATURE_SIGN_EXTENSION","ASC_FEATURE_MUTABLE_GLOBALS","ASC_FEATURE_NONTRAPPING_F2I","ASC_FEATURE_BULK_MEMORY","ASC_FEATURE_SIMD","ASC_FEATURE_THREADS","ASC_FEATURE_EXCEPTION_HANDLING","ASC_FEATURE_TAIL_CALLS","ASC_FEATURE_REFERENCE_TYPES","ASC_FEATURE_MULTI_VALUE","ASC_FEATURE_GC","ASC_FEATURE_MEMORY64","ASC_VERSION_MAJOR","ASC_VERSION_MINOR","ASC_VERSION_PATCH","I8","I16","Isize","U8","U16","U32","U64","Usize","Bool","V128","Funcref","Externref","Anyref","Eqref","I31ref","Dataref","String","Object","StaticArray","Set","ArrayBufferView","ArrayBuffer","Math","Mathf","NativeMath","NativeMathf","TemplateStringsArray","Error","pow","ipow32","ipow64","mod","alloc","realloc","free","new_","renew","link","collect","typeinfo","instanceof_","visit","newBuffer","newArray","Feature","Target","Runtime","Typeinfo","TypeinfoFlags","ExportNames","target","WASM32","runtime","Incremental","exportMemory","importMemory","initialMemory","maximumMemory","sharedMemory","zeroFilledMemory","importTable","exportTable","sourceMap","explicitStart","memoryBase","tableBase","globalAliases","features","noUnsafe","pedantic","lowMemoryLimit","exportRuntime","stackSize","bundleMajorVersion","bundleMinorVersion","bundlePatchVersion","optimizeLevelHint","shrinkLevelHint","WASM64","isize64","isize32","willOptimize","Constraints","RuntimeFeatures","memory","table","runtimeFunctions","runtimeGlobals","Compiler","DiagnosticEmitter","currentParent","currentBody","memorySegments","stringSegments","functionTable","builtinArgumentsLength","inlineStack","lazyFunctions","pendingClassInstanceOf","virtualStubs","pendingElements","doneModuleExports","shadowStack","compile","diagnostics","Module","create","setLowMemoryUnused","featureFlags","FeatureFlags","SignExt","MutableGloabls","TruncSat","BulkMemory","SIMD","Atomics","ExceptionHandling","TailCall","ReferenceTypes","MultiValue","GC","Memory64","setFeatures","startFunctionInstance","makeNativeFunction","Signature","ShadowStackPass","hasShadowStack","initialize","actualFunction","startFunctionBody","files","filesByName","file","USER_ENTRY","compileFile","compileExports","ensureModuleExports","requireFunction","hasExport","addFunctionExport","requireGlobal","compileGlobal","addGlobalExport","functionsToCompile","Set_values","clear","compileClassInstanceOf","VIRTUAL","INSTANCE","ensureVirtualStub","ensureVarargsStub","virtualStubsSeen","discoveredOverload","overloadInstances","resolveOverloads","finalizeVirtualStub","removeGlobal","compileRTTI","compileVisitGlobals","compileVisitMembers","i64_align","lowMemoryLimit32","i64_gt","Low_memory_limit_exceeded_by_static_data_0_1","i64_to_string","initialPages","i64_shr_u","Module_requires_at_least_0_pages_of_initial_memory","maximumPages","UNLIMITED_MEMORY","Module_requires_at_least_0_pages_of_maximum_memory","isSharedMemory","Shared_memory_requires_maximum_memory_to_be_defined","Shared_memory_requires_feature_threads_to_be_enabled","setMemory","addMemoryImport","addTableImport","Importing_the_table_disables_some_indirect_call_optimizations","addTableExport","Exporting_the_table_disables_some_indirect_call_optimizations","functionTableNames","addFunctionTable","UNLIMITED_TABLE","global_set","ensureArgumentsLength","startIsEmpty","isWasi","unshift","funcRef","paramRefs","resultRefs","typesToRefs","additionalLocals","finalize","setStart","walkModule","lookup","RtraceMemory","elementName","ensureModuleExport","exportsStar","prefix","functionInstances","instanceName","GENERIC","fullName","Exported_generic_function_or_class_has_no_concrete_instances","identifierNode","CLASS_PROTOTYPE","classPrototype","classInstances","PROPERTY_PROTOTYPE","propertyInstance","CONST","STATIC","READONLY","exportName","Cannot_export_a_mutable_global","ENUMVALUE","enumValue","isImmutable","functionInstance","hasManagedOperands","noteExport","getManagedOperandIndices","PROPERTY","getterInstance","setterInstance","fieldInstance","getterExportName","compileFieldGetter","internalGetterName","internalGetterSignature","setterExportName","compileFieldSetter","internalSetterName","internalSetterSignature","isUnmanaged","ENUM","INTERFACE_PROTOTYPE","NAMESPACE","TYPEDEFINITION","subPrefix","implicitExport","SCOPED","memberName","PRIVATE","compileElement","compileMembers","compileEnum","resolveClass","compileClass","resolveProperty","compileProperty","exportStar","compileFileByPath","normalizedPathWithoutExtension","pathWithIndex","File_0_not_found","startFunction","startSignature","previousBody","previousFlow","compileTopLevelStatement","locals","localsByIndex","numLocals","varTypes","ERRORED","initExpr","typeNode","initializerNode","RESOLVED","resolvedType","resolveType","delete","Type_expected","setType","checkTypeSupported","atEnd","Type_0_is_not_assignable_to_type_1","AMBIENT","isDeclaredConstant","isDeclaredInline","MODULE_IMPORT","mangleImportName","addGlobalImport","mangleImportName_moduleName","mangleImportName_elementName","initializeInStart","GlobalGet","fromName","getGlobalGetName","isGlobalMutable","getGlobal","warning","Mutable_value_cannot_be_inlined","constantValueKind","constantFloatValue","compileInlineConstant","Decorator_0_is_not_valid_here","findDecorator","decoratorNodes","previousParent","previousValue","previousValueIsMut","isInline","initInStart","valueNode","In_const_enum_declarations_member_initializer_must_be_constant_expression","Enum_member_must_have_initializer","makeGlobalAssignment","setConstantIntegerValue","MODULE_EXPORT","forceStdAlternative","numParameters","visited","paramIdentifier","paramName","Duplicate_identifier_0","previousType","bodyNode","declarationNode","checkSignatureSupported","An_implementation_cannot_be_declared_in_ambient_contexts","compileFunctionBody","addFunctionImport","getFunction","ABSTRACT","INTERFACE","Function_implementation_is_missing_or_not_immediately_following_the_declaration","thisLocal","lookupLocal","bodyStartIndex","compileStatements","GET","SET","canOverflow","isNonnull","allocStmts","makeConditionalAllocation","makeFieldInitializationInConstructor","Explicitly_returning_constructor_drops_this_allocation","A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final","Constructors_for_derived_classes_must_contain_a_super_call","A_function_whose_declared_type_is_not_void_must_return_a_value","staticMembers","instanceMembers","compileField","getterRef","valueTypeRef","thisTypeRef","setterRef","bodyExpr","linkInstance","compilePropertyGetter","compilePropertySetter","buffer","alignment","MemorySegment","addRuntimeMemorySegment","computeBlockStart64","stringValue","ptr","ensureStaticStringPtr","stringSegment","totalOverhead","segments","createBuffer","elementTypeRef","writeI64","addStaticBuffer","arrayBufferInstance","OBJECTInstance","writeField","addStaticArrayHeader","bufferSegment","arrayInstance","bufferLength","readI32","arrayLength","bufferAddress","ensureRuntimeFunction","STUB","memorySegment","rtInstance","memberStatements","getElementByDeclaration","exportStatement","importStatement","stmt","compileStatement","Nop","isLastInBody","compileBlockStatement","compileBreakStatement","compileContinueStatement","compileDoStatement","compileEmptyStatement","compileExpressionStatement","compileForStatement","compileForOfStatement","compileIfStatement","compileReturnStatement","compileSwitchStatement","compileThrowStatement","compileTryStatement","compileVariableStatement","compileVoidStatement","compileWhileStatement","addDebugLocation","isBody","numStatements","Block","getBlockName","getBlockChildCount","getBlockChildAt","needsExplicitUnreachable","outerFlow","innerFlow","fork","freeScopedLocals","inherit","labelNode","breakLabel","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","br","continueLabel","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","doCompileDoStatement","flowAfter","pushBreakLabel","unifyLocalFlags","flowBefore","loopLabel","bodyFlow","bodyStmts","possiblyContinues","condFlow","condExpr","condKind","evaluateCondition","drop","Flow","hasIncompatibleLocalStates","popBreakLabel","hasScopedLocals","loop","doCompileForStatement","tcond","loopStmts","local_set","inheritNonnullIfTrue","inheritBranch","ifStmts","incrFlow","thenStmts","thenFlow","elseStmts","elseFlow","inheritNonnullIfFalse","inheritMutual","valueExpression","constraints","inlineReturnLabel","numCases","context","tempLocal","tempLocalIndex","breaks","breakIndex","defaultIndex","EqI32","currentBlock","commonCategorical","commonConditional","isLast","nextLabel","terminates","deriveConditionalFlags","message","newArgs","numDeclarations","initializers","uniqueMap","contextualTypeArguments","dummy","addScopedDummyLocal","freeScopedDummyLocal","isConst","local","Local","parentFunction","setConstantFloatValue","scopedLocals","existing","errorRelated","_const_declarations_must_be_initialized","LET","existingLocal","getScopedLocal","addScopedLocal","CONSTANT","addLocal","makeLocalAssignment","isShortIntegerValue","doCompileWhileStatement","i64_ne","i64_zero","computeSmallIntegerShift","computeSmallIntegerMask","compileAssertionExpression","compileBinaryExpression","compileCallExpression","compileCommaExpression","compileElementAccessExpression","compileFunctionExpression","compileIdentifierExpression","compileInstanceOfExpression","compileLiteralExpression","compileNewExpression","compilePropertyAccessExpression","compileTernaryExpression","compileUnaryPostfixExpression","compileUnaryPrefixExpression","compiled","wrap","ensureSmallIntegerWrap","explicit","makeRuntimeNonNullCheck","isExternalReference","makeRuntimeUpcastCheck","Conversion_from_type_0_to_1_requires_an_explicit_cast","PromoteF32ToF64","DemoteF64ToF32","saturating","isLongIntegerValue","TruncSatF32ToI64","TruncF32ToI64","TruncSatF32ToI32","TruncF32ToI32","TruncSatF32ToU64","TruncF32ToU64","TruncSatF32ToU32","TruncF32ToU32","TruncSatF64ToI64","TruncF64ToI64","TruncSatF64ToI32","TruncF64ToI32","TruncSatF64ToU64","TruncF64ToU64","TruncSatF64ToU32","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","NeI64","WrapI64ToI32","ExtendI32ToI64","ExtendU32ToU64","isVaryingIntegerValue","Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit","inheritedConstraints","PREFIX","AS","NONNULL","exceptVoid","info","Expression_is_never_null","f32ModInstance","f64ModInstance","f32PowInstance","f64PowInstance","i32PowInstance","i64PowInstance","leftExpr","leftType","rightExpr","rightType","commonType","compound","Token","LESSTHAN","overload","lookupOverload","OperatorKind","LT","compileBinaryOverload","commonDenominator","Operator_0_cannot_be_applied_to_types_1_and_2","makeLt","GREATERTHAN","GT","makeGt","LESSTHAN_EQUALS","LE","makeLe","GREATERTHAN_EQUALS","GE","makeGe","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EQ","operatorTokenToString","makeEq","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NE","makeNe","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","ADD","The_0_operator_cannot_be_applied_to_type_1","MINUS_EQUALS","MINUS","SUB","ASTERISK_EQUALS","ASTERISK","MUL","ASTERISK_ASTERISK_EQUALS","ASTERISK_ASTERISK","POW","makePow","SLASH_EQUALS","SLASH","DIV","PERCENT_EQUALS","PERCENT","REM","makeRem","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","intType","BITWISE_SHL","makeShl","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","BITWISE_SHR","makeShr","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","BITWISE_SHR_U","makeShru","AMPERSAND_EQUALS","AMPERSAND","BITWISE_AND","makeAnd","BAR_EQUALS","BAR","BITWISE_OR","makeOr","CARET_EQUALS","CARET","BITWISE_XOR","makeXor","AMPERSAND_AMPERSAND","rightFlow","tryCopyTrivialExpression","BAR_BAR","targetType","getTypeOfElement","makeAssignment","currentThisExpression","currentElementExpression","LtF32","LtF64","GtF32","GtF64","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EqI64","ref_eq","NeI32","AddF32","AddF64","MulI32","MulI64","MulF32","MulF64","Cannot_find_name_0","makeCallDirect","namespace","namespaceMembers","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","RemI32","RemI64","RemU32","RemU64","ShlI64","ShrU64","AndI64","OrI64","compileUnaryOverload","operatorInstance","valueExpr","thisExpression","LOCAL","Variable_0_used_before_its_declaration","checkUnsafe","propertyPrototype","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","isUnchecked","indexedSet","INDEXED_SET","INDEXED_GET","Index_signature_in_type_0_only_permits_reading","Index_signature_is_missing_in_type_0","Indexed_access_may_involve_bounds_checking","indexExpression","tee","isLocalFlag","isConstructor","setThisFieldFlag","FieldFlags","INITIALIZED","fieldParent","makeFieldAssignment","thisExpr","returnTypeRef","tempThis","elementExpr","tempTarget","tempElement","localIndex","unsetLocalFlag","field","fieldType","fieldTypeRef","Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors","baseClassInstance","_super_can_only_be_referenced_in_a_derived_class","baseCtorInstance","superCall","_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class","compileCallExpressionBuiltin","maybeInferCall","inlinedValue","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","Expression_cannot_be_represented_by_a_type","compileCallExpressionLike","_reusableCallExpression","createCallExpression","resolveTypeArguments","callee","BuiltinContext","fn","methodName","checkCallSignature","hasThis","The_this_types_of_each_signature_are_incompatible","hasRest","minimum","maximum","relatedReportNode","Operation_is_unsafe","argumentExpressions","includes","makeCallInline","pop","Function_0_cannot_be_inlined_into_itself","numArgumentsInclThis","paramType","paramExpr","immediatelyDropped","createInline","usedLocals","argumentLocal","getParameterName","addScopedAlias","initType","checkFieldInitializationInFlow","original","stub","varargsStub","originalSignature","originalParameterTypes","originalParameterDeclarations","isInstance","minArguments","minOperands","maxArguments","maxOperands","numOptional","forwardedOperands","operandIndex","newStub","numNames","ofN","Optional_parameter_must_have_an_initializer","virtualStub","ref","tempIndex","builder","SwitchBuilder","overloadInstance","overloadType","originalType","overloadSignature","overloadParameterTypes","overloadNumParameters","paramExprs","n","needsVarargsStub","calledName","getClassOrInterface","addCase","extendees","getAllExtendees","a","b","extendee","removeFunction","render","operandsTostack","isConstZero","Function_0_is_virtual_and_will_not_be_inlined","theOperands","slice","allOptionalsAreConstant","resolved","lastOperand","getSideEffects","SideEffects","WritesGlobal","lastOperandType","makeCallIndirect","numExpressions","targetExpression","resolveExpression","indexedGet","isNamed","isSemanticallyAnonymous","FunctionPrototype","nextAnonymousId","contextualSignature","signatureNode","numPresentParameters","parameterNode","isTypeOmitted","thisTypeNode","outer","worked","fname","maybeCompileEnclosingSource","asNullable","Expression_resolves_to_unusual_type_0","_this_cannot_be_referenced_in_constructor_arguments","_super_cannot_be_referenced_in_constructor_arguments","_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class","scopedThis","superType","lookupIdentifierExpression","localType","globalType","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","ref_func","Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime","namedType","resolveTypeName","makeInstanceofClass","expectedType","makeInstanceofType","actualType","Expression_compiles_to_a_dynamic_check_at_runtime","implicitlyNegate","compileArrayLiteral","floatValue","intValue","determineIntegerLiteralType","i64_to_f32","i64_to_f64","compileStringLiteral","compileTemplateLiteral","compileObjectLiteral","numParts","stringType","lhsLen","rhsLen","makeToString","hasPrefix","lhs","rhs","concatMethod","getMethod","exprA","exprB","joinInstance","indexedSetInstance","temps","tsaArrayInstance","templateStringsArrayInstance","first","arraySegment","partExprs","rawExprs","rawHeaderSegment","createCompiledExpression","nativeRange","contextualClass","compileStaticArrayLiteral","arrayType","tempDataStart","arrayAddress","makeNewArray","arrayTypeRef","dataStartMember","newArrayInstance","bufferSize","newBufferInstance","classType","Cannot_create_an_instance_of_an_abstract_class","ctorPrototype","constructorPrototype","Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal","hasErrors","classTypeRef","omittedFields","memberKey","Property_0_does_not_exist_on_type_1","Property_0_is_private_and_only_accessible_within_class_1","PROTECTED","Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses","Property_0_is_missing_in_type_1_but_required_in_type_2","resolveClassInclTypeArguments","constructorInstance","baseClass","baseCtor","makeNativeFunctionDeclaration","setResolvedInstance","relatedNode","didCheckFieldInitialization","isThisFieldFlag","DEFINITELY_ASSIGNED","Property_0_is_always_assigned_before_being_used","Unnecessary_definite_assignment","Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned","ctorInstance","ctxType","parentEnum","Property_0_is_used_before_being_assigned","Object_is_possibly_null","ifThenFlow","ifThenExpr","ifThenType","ifElseFlow","ifElseExpr","ifElseType","getValue","Unreachable","PLUS_PLUS","POSTFIX_INC","getLocalSetValue","makeOne","MINUS_MINUS","POSTFIX_DEC","setValue","NegF32","NegF64","PREFIX_INC","PREFIX_DEC","EXCLAMATION","NOT","TILDE","BITWISE_NOT","makeNegOne","TYPEOF","compileTypeof","DOT_DOT_DOT","typeString","REPORT","Extend8I32","Extend16I32","addDebugInfoFile","debugInfoRef","debugLocations","supported","parameterReportNode","v128_zero","ref_null","toStringInstance","toStringSignature","identifierAndSignatureRange","toStringReturnType","makeAllocation","allocInstance","newInstance","thisIndex","thisLocalIndex","nonParameterFields","fieldPrototype","codeLocation","abortInstance","messageArg","makeStaticAbort","messageExpr","filenameExpr","mangleInternalName","arg","ExportsWalker","includePrivate","seen","walk","visitFile","visitElement","visitGlobal","visitEnum","visitFunctionInstances","visitClassInstances","visitField","visitFunction","hasCompiledMember","visitNamespace","visitAlias","visitClass","IDLBuilder","build","sb","indentLevel","indent","typeToString","visitInterface","originalName","TSDBuilder","remainingMembers","isInterface","extendsNode","code","diagnosticCategoryToString","PEDANTIC","diagnosticCategoryToColor","COLOR_MAGENTA","COLOR_CYAN","COLOR_YELLOW","COLOR_RED","diagnosticCodeToString","DiagnosticMessage","relatedRange","replace","equals","other","thisRange","otherRange","thisRelatedRange","otherRelatedRange","withRange","withRelatedRange","formatDiagnosticContext","isLineBreak","isColorsEnabled","COLOR_RESET","useColors","showContext","wasColorsEnabled","setColorsEnabled","relatedSource","seenInSource","seenMessagesAtPos","pedanticRelated","infoRelated","warningRelated","ASTBuilder","visitNode","finish","visitSource","visitNamedTypeNode","visitFunctionTypeNode","visitTypeParameter","visitIdentifierExpression","visitAssertionExpression","visitBinaryExpression","visitCallExpression","visitClassExpression","visitCommaExpression","visitElementAccessExpression","visitFunctionExpression","visitInstanceOfExpression","visitLiteralExpression","visitNewExpression","visitParenthesizedExpression","visitPropertyAccessExpression","visitTernaryExpression","visitUnaryPostfixExpression","visitUnaryPrefixExpression","visitBlockStatement","visitBreakStatement","visitContinueStatement","visitDoStatement","visitEmptyStatement","visitExportStatement","visitExportDefaultStatement","visitExportImportStatement","visitExpressionStatement","visitForStatement","visitForOfStatement","visitIfStatement","visitImportStatement","visitReturnStatement","visitSwitchStatement","visitThrowStatement","visitTryStatement","visitVariableStatement","visitWhileStatement","visitClassDeclaration","visitEnumDeclaration","visitEnumValueDeclaration","visitFieldDeclaration","visitFunctionDeclaration","visitImportDeclaration","visitInterfaceDeclaration","visitMethodDeclaration","visitNamespaceDeclaration","visitTypeDeclaration","visitVariableDeclaration","serializeDecorator","visitExportMember","serializeParameter","visitSwitchCase","visitIndexSignature","visitNodeAndTerminate","visitTypeNode","visitTypeName","visitStringLiteral","visitArrayLiteralExpression","elements","visitObjectLiteralExpression","visitArguments","numArgs","visitFunctionCommon","visitFloatLiteralExpression","visitIntegerLiteralExpression","visitStringLiteralExpression","visitTemplateLiteralExpression","visitRegexpLiteralExpression","str","visitRawString","quote","visitUnaryExpression","last","lastCharPos","isDefault","serializeExternalModifiers","numImplementsTypes","numMembers","numValues","serializeAccessModifiers","numTypeParameters","firstDeclaration","REST","OPTIONAL","DECLARE","PUBLIC","FlowFlags","ConditionKind","initThisFieldFlags","inlineFunction","nextInlineId","localFlags","thisFieldFlags","condiFlags","resetBreakContext","branch","except","tempI32s","tempI64s","tempF32s","tempF64s","tempV128s","tempFuncrefs","tempExternrefs","tempAnyrefs","tempEqrefs","tempI31refs","tempDatarefs","resetTemporaryName","scopedLocal","setTemporaryName","scopedDummy","Cannot_redeclare_block_scoped_variable_0","scopedAlias","scope","localsByName","defaultIfInlined","isAnyLocalFlag","actualParent","actualClass","fieldFlags","nextBreakId","stack","breakStack","otherFlags","conditionKind","thisFlags","newFlags","thisLocalFlags","numThisLocalFlags","otherLocalFlags","numOtherLocalFlags","maxLocalFlags","leftFlags","rightFlags","rightLocalFlags","leftLocalFlags","numLeftLocalFlags","numRightLocalFlags","leftFieldFlags","newFieldFlags","rightFieldFlags","key","before","after","LocalSet","isLocalTee","getLocalSetIndex","iff","If","getIfFalse","getIfCondition","getIfTrue","Unary","getUnaryOp","getUnaryValue","Binary","getBinaryOp","getBinaryLeft","getBinaryRight","exprType","canConversionOverflow","isUnsignedIntegerValue","Extend8I64","Extend16I64","Extend32I64","MIN_VALUE","Load","signed","isLoadSigned","getLoadBytes","Select","getSelectThen","getSelectElse","Call","instancesByName","getCallTarget","levels","formatDiagnosticMessage","Options","alias","DEFAULT_STACK_SIZE","FEATURE_SIGN_EXTENSION","FEATURE_MUTABLE_GLOBALS","FEATURE_NONTRAPPING_F2I","FEATURE_BULK_MEMORY","FEATURE_SIMD","FEATURE_THREADS","FEATURE_EXCEPTION_HANDLING","FEATURE_TAIL_CALLS","FEATURE_REFERENCE_TYPES","FEATURE_MULTI_VALUE","FEATURE_GC","FEATURE_MEMORY64","optimizeLevel","shrinkLevel","Program","diagnosticsOffset","getSource","isEntry","parser","parseFile","nextFile","getDependee","util","Auto","ExternalKind","RefAsOp","BrOnOp","useShadowStack","sizeType","lit","binaryen","_malloc","_BinaryenSizeofLiteral","_BinaryenModuleCreate","cArr","allocU8Array","_BinaryenModuleRead","_free","out","_BinaryenLiteralInt32","_BinaryenConst","valueLow","valueHigh","_BinaryenLiteralInt64","i64_is","_BinaryenLiteralFloat32","_BinaryenLiteralFloat64","__i32_store8","_BinaryenLiteralVec128","_BinaryenRefNull","_BinaryenRefEq","_last","isWam64","ClzSize","CtzSize","PopcntSize","EqzSize","_BinaryenUnary","AddSize","SubSize","MulSize","DivISize","DivUSize","RemISize","RemUSize","AndSize","OrSize","XorSize","ShlSize","ShrISize","ShrUSize","RotlSize","RotrSize","EqSize","NeSize","LtISize","LtUSize","LeISize","LeUSize","GtISize","GtUSize","GeISize","GeUSize","_BinaryenBinary","_BinaryenMemorySize","delta","_BinaryenMemoryGrow","table_size","cStr","allocStringCached","_BinaryenTableSize","table_grow","_BinaryenTableGrow","_BinaryenLocalGet","_BinaryenExpressionGetType","_BinaryenLocalTee","_BinaryenGlobalGet","table_get","_BinaryenTableGet","_BinaryenLoad","_BinaryenStore","_BinaryenAtomicLoad","_BinaryenAtomicStore","_BinaryenAtomicRMW","replacement","_BinaryenAtomicCmpxchg","timeout","_BinaryenAtomicWait","notifyCount","_BinaryenAtomicNotify","_BinaryenAtomicFence","_BinaryenLocalSet","_BinaryenGlobalSet","table_set","_BinaryenTableSet","children","allocPtrArray","_BinaryenBlock","single","Return","Throw","singleType","_BinaryenBreak","_BinaryenDrop","result","ReadsLocal","ReadsGlobal","_BinaryenLoop","_BinaryenIf","_BinaryenNop","_BinaryenReturn","_BinaryenSelect","defaultName","strs","_BinaryenSwitch","isReturn","_BinaryenReturnCall","_BinaryenCall","return_call","params","results","_BinaryenReturnCallIndirect","_BinaryenCallIndirect","return_call_indirect","tableName","_BinaryenUnreachable","dest","_BinaryenMemoryCopy","_BinaryenMemoryFill","try","catchTags","catchBodies","delegateTarget","numCatchTags","cArr1","cArr2","cStr1","cStr2","_BinaryenTry","throw","tagName","_BinaryenThrow","rethrow","_BinaryenRethrow","_BinaryenPop","tuple_make","_BinaryenTupleMake","tuple_extract","tuple","_BinaryenTupleExtract","vec","_BinaryenSIMDExtract","_BinaryenSIMDReplace","vec1","vec2","_BinaryenSIMDShuffle","c","_BinaryenSIMDTernary","_BinaryenSIMDShift","_BinaryenSIMDLoad","_BinaryenSIMDLoadStoreLane","_BinaryenRefIs","ref_as","_BinaryenRefAs","_BinaryenRefFunc","_BinaryenI31New","_BinaryenI31Get","mutable","_BinaryenAddGlobal","_BinaryenGetGlobal","_BinaryenRemoveGlobal","addTag","_BinaryenAddTag","getTag","_BinaryenGetTag","removeTag","_BinaryenRemoveTag","_BinaryenAddFunction","_BinaryenGetFunction","_BinaryenRemoveFunction","hasFunction","hasTemporaryFunction","addTemporaryFunction","paramTypes","tempName","removeTemporaryFunction","func","_BinaryenSetStart","_BinaryenAddFunctionExport","_BinaryenAddTableExport","addMemoryExport","_BinaryenAddMemoryExport","_BinaryenAddGlobalExport","addTagExport","_BinaryenAddTagExport","removeExport","_BinaryenRemoveExport","_BinaryenGetExport","externalModuleName","externalBaseName","cStr3","_BinaryenAddFunctionImport","_BinaryenAddTableImport","shared","_BinaryenAddMemoryImport","_BinaryenAddGlobalImport","addTagImport","_BinaryenAddTagImport","initial","segs","psvs","offs","sizs","cArr3","cArr4","u32s","val","__i32_store","HEAPU32","allocU32Array","_BinaryenSetMemory","funcs","tableRef","_BinaryenGetTable","_BinaryenTableSetInitial","_BinaryenTableSetMax","_BinaryenAddTable","_BinaryenAddActiveElementSegment","addCustomSection","contents","_BinaryenAddCustomSection","getOptimizeLevel","_BinaryenGetOptimizeLevel","setOptimizeLevel","level","_BinaryenSetOptimizeLevel","getShrinkLevel","_BinaryenGetShrinkLevel","setShrinkLevel","_BinaryenSetShrinkLevel","getDebugInfo","_BinaryenGetDebugInfo","setDebugInfo","on","_BinaryenSetDebugInfo","getLowMemoryUnused","_BinaryenGetLowMemoryUnused","_BinaryenSetLowMemoryUnused","getZeroFilledMemory","_BinaryenGetZeroFilledMemory","setZeroFilledMemory","_BinaryenSetZeroFilledMemory","getFastMath","_BinaryenGetFastMath","setFastMath","_BinaryenSetFastMath","getPassArgument","_BinaryenGetPassArgument","readString","setPassArgument","_BinaryenSetPassArgument","clearPassArguments","_BinaryenClearPassArguments","getAlwaysInlineMaxSize","_BinaryenGetAlwaysInlineMaxSize","setAlwaysInlineMaxSize","_BinaryenSetAlwaysInlineMaxSize","getFlexibleInlineMaxSize","_BinaryenGetFlexibleInlineMaxSize","setFlexibleInlineMaxSize","_BinaryenSetFlexibleInlineMaxSize","getOneCallerInlineMaxSize","_BinaryenGetOneCallerInlineMaxSize","setOneCallerInlineMaxSize","_BinaryenSetOneCallerInlineMaxSize","getAllowInliningFunctionsWithLoops","_BinaryenGetAllowInliningFunctionsWithLoops","setAllowInliningFunctionsWithLoops","enabled","_BinaryenSetAllowInliningFunctionsWithLoops","getFeatures","_BinaryenModuleGetFeatures","_BinaryenModuleSetFeatures","runPasses","passes","cStrs","allocString","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","optimize","debugInfo","validate","_BinaryenModuleValidate","interpret","_BinaryenModuleInterpret","toBinary","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","__i32_load","binaryLen","BinaryModule","__i32_load8_u","HEAPU8","readBuffer","toText","watFormat","toAsmjs","cachedStringsToPointers","cachedPointersToStrings","cached","readStringCached","dispose","_BinaryenModuleDispose","createRelooper","Relooper","_BinaryenExpressionGetId","MemorySize","DataDrop","RefNull","RttCanon","copyExpression","_BinaryenExpressionCopy","maxDepth","maxLoopIterations","runner","_ExpressionRunnerCreate","_ExpressionRunnerRunAndDispose","_BinaryenModuleAddDebugInfoFileName","getDebugInfoFile","_BinaryenModuleGetDebugInfoFileName","setDebugLocation","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","types","_BinaryenTypeCreate","_BinaryenConstGetValueI32","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","_BinaryenConstGetValueF32","_BinaryenConstGetValueF64","arity","_BinaryenTypeArity","_BinaryenTypeExpand","_BinaryenLocalGetGetIndex","_BinaryenLocalSetGetIndex","_BinaryenLocalSetGetValue","_BinaryenLocalSetIsTee","_BinaryenGlobalGetGetName","_BinaryenBinaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenUnaryGetOp","_BinaryenUnaryGetValue","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadGetPtr","_BinaryenLoadIsSigned","_BinaryenStoreGetBytes","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChildAt","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","_BinaryenLoopGetName","_BinaryenLoopGetBody","_BinaryenBreakGetName","_BinaryenBreakGetCondition","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","_BinaryenDropGetValue","_BinaryenReturnGetValue","_BinaryenCallGetTarget","_BinaryenCallGetNumOperands","_BinaryenCallGetOperandAt","_BinaryenMemoryGrowGetDelta","_BinaryenFunctionGetBody","_BinaryenFunctionGetName","_BinaryenFunctionGetParams","_BinaryenFunctionGetResults","_BinaryenFunctionGetNumVars","_BinaryenFunctionGetVar","_BinaryenGlobalGetName","_BinaryenGlobalGetType","_BinaryenGlobalIsMutable","_BinaryenGlobalGetInitExpr","_BinaryenTagGetName","_BinaryenTagGetParams","_BinaryenTagGetResults","_RelooperCreate","addBlock","_RelooperAddBlock","addBranch","from","to","_RelooperAddBranch","addBlockWithSwitch","_RelooperAddBlockWithSwitch","addBranchForSwitch","indexes","i32s","HEAP32","allocI32Array","_RelooperAddBranchForSwitch","renderAndDispose","entry","labelHelper","_RelooperRenderAndDispose","_BinaryenExpressionGetSideEffects","u8s","ptrs","c1","stringLengthUTF8","u","c2","cp","u1","u2","u3","arr","ch","fromCharCodes","indexOf","addDefault","labelPostfix","labels","defaultLabel","lastCase","output","Break","numChildren","Dependee","Parser","backlog","seenlog","donelog","onComment","currentSource","dependees","sources","dependee","Source","USER","tn","Tokenizer","skip","ENDOFFILE","parseTopLevelStatement","skipStatement","startPos","AT","tokenPos","parseDecorator","exportStart","exportEnd","defaultStart","defaultEnd","DEFAULT","declareStart","declareEnd","contextIsAmbient","A_declare_modifier_cannot_be_used_in_an_already_ambient_context","peek","nextTokenPos","parseEnum","parseVariable","VAR","parseFunction","state","mark","abstractStart","abstractEnd","nextTokenOnNewLine","reset","parseStatement","_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration","discard","parseClassOrInterface","IdentifierHandling","PREFER","parseNamespace","parseExportImport","parseImport","TYPE","parseTypeDeclaration","skipIdentifier","An_export_assignment_cannot_have_modifiers","parseExportDefaultAlias","parseExport","_0_modifier_cannot_be_used_here","Decorators_are_not_valid_here","createExportDefaultStatement","dependent","parseTypeName","readIdentifier","DOT","Identifier_expected","parseType","acceptParenthesized","suppressErrors","token","OPENPAREN","isNullableSignature","tryParseFunctionType","CLOSEPAREN","_0_expected","tryParseSignatureIsSignature","Unexpected_token","innerType","createNamedType","STRINGLITERAL","parameter","notNullStart","notNull","OPENBRACKET","bracketStart","CLOSEBRACKET","bracketRange","nullable","isSignature","firstParamNameNoType","firstParamKind","paramStart","COLON","QUESTION","A_rest_parameter_cannot_be_optional","param","createParameter","createOmittedType","EQUALS_GREATERTHAN","createFunctionType","createPropertyAccessExpression","createDecorator","parseArguments","isFor","parseVariableDeclaration","createVariableStatement","SEMICOLON","parentFlags","parentDecorators","isIllegalVariableIdentifier","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","A_definite_assignment_assertion_is_not_permitted_in_this_context","createVariableDeclaration","OPENBRACE","CLOSEBRACE","parseEnumValue","createEnumDeclaration","createEnumValueDeclaration","parseReturn","nextToken","createReturnStatement","parseTypeParameters","seenOptional","typeParameter","parseTypeParameter","Required_type_parameters_may_not_follow_optional_type_parameters","Type_parameter_list_cannot_be_empty","EXTENDS","createTypeParameter","parseParametersThis","parseParameters","seenRest","reportedRest","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","isRest","isOptional","startRange","accessFlags","A_parameter_property_cannot_be_declared_using_a_rest_parameter","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","signatureStart","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","createFunctionDeclaration","parseFunctionExpression","createEmptyIdentifierExpression","parseFunctionExpressionCommon","explicitThis","bodyExpression","createExpressionStatement","createFunctionExpression","IMPLEMENTS","Interface_declaration_cannot_have_implements_clause","createInterfaceDeclaration","createClassDeclaration","parseClassMember","parseClassExpression","createClassExpression","accessStart","accessEnd","staticStart","staticEnd","GENERIC_CONTEXT","readonlyStart","readonlyEnd","isGetter","getStart","getEnd","setEnd","isGetterOrSetter","createConstructorExpression","retIndex","parseIndexSignature","ALWAYS","typeParametersStart","Type_parameters_cannot_appear_on_a_constructor_declaration","An_accessor_cannot_have_type_parameters","createFieldDeclaration","_0_keyword_cannot_be_used_here","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","Method_0_cannot_have_an_implementation_because_it_is_marked_abstract","retMethod","createMethodDeclaration","Constructor_implementation_is_missing","Optional_properties_are_not_supported","retField","createIndexSignature","createNamespaceDeclaration","parseExportMember","FROM","createStringLiteralExpression","createExportStatement","asIdentifier","createExportMember","skipFrom","parseImportDeclaration","createImportDeclaration","createWildcardImportStatement","createImportStatement","createExportImportStatement","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","createEmptyStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVoidStatement","parseWhileStatement","parseExpressionStatement","createBlockStatement","createBreakStatement","createContinueStatement","createDoStatement","OF","parseForOfStatement","The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer","createForStatement","createForOfStatement","elseStatement","ELSE","createIfStatement","switchCases","switchCase","parseSwitchCase","createSwitchStatement","CASE","createSwitchCase","_case_or_default_expected","createThrowStatement","CATCH","FINALLY","createTryStatement","createTypeDeclaration","createVoidStatement","createWhileStatement","parseExpressionStart","YIELD","DELETE","createUnaryPrefixExpression","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","arguments_","tryParseTypeArgumentsBeforeArguments","createNewExpression","createNullExpression","createTrueExpression","createFalseExpression","createThisExpression","again","inner","createParenthesizedExpression","maybeParseCallExpression","createOmittedExpression","createArrayLiteralExpression","createObjectLiteralExpression","createAssertionExpression","identifierText","TEMPLATELITERAL","parseTemplateLiteral","_super_must_be_followed_by_an_argument_list_or_member_access","createSuperExpression","INTEGERLITERAL","readInteger","checkForIdentifierStartAfterNumericLiteral","createIntegerLiteralExpression","FLOATLITERAL","readFloat","createFloatLiteralExpression","regexpPattern","readRegexpPattern","createRegexpLiteralExpression","readRegexpFlags","Unexpected_end_of_text","Expression_expected","Type_argument_list_cannot_be_empty","precedence","nextPrecedence","determinePrecedence","createInstanceOfExpression","createElementAccessExpression","createUnaryPostfixExpression","createTernaryExpression","commaExprs","createCommaExpression","joinPropertyCall","createBinaryExpression","readStringStart","readStringEnd","readingTemplateString","createTemplateLiteralExpression","potentiallyGeneric","skipBlock","depth","IN","Precedence","FindUsedLocalsVisitor","Visitor","used","visitLocalGet","localGet","visitLocalSet","localSet","singleton","visitor","currentExpression","_currentExpression","parentExpressionOrNull","visitBlock","visitIf","visitLoop","visitBreak","visitSwitch","visitCallPre","visitCall","visitCallIndirectPre","visitCallIndirect","visitGlobalGet","visitGlobalSet","visitLoad","visitStore","visitConst","visitUnary","visitBinary","visitSelect","visitDrop","visitReturn","visitMemorySize","visitMemoryGrow","visitNop","visitUnreachable","visitAtomicRMW","visitAtomicCmpxchg","visitAtomicWait","visitAtomicNotify","visitAtomicFence","visitSIMDExtract","visitSIMDReplace","visitSIMDShuffle","visitSIMDTernary","visitSIMDShift","visitSIMDLoad","visitSIMDLoadStoreLane","visitMemoryInit","visitDataDrop","visitMemoryCopy","visitMemoryFill","visitPop","visitRefNull","visitRefIs","visitRefFunc","visitRefEq","visitTry","visitThrow","visitRethrow","visitTupleMake","visitTupleExtract","visitI31New","visitI31Get","visitCallRef","visitRefTest","visitRefCast","visitBrOn","visitRttCanon","visitRttSub","visitStructNew","visitStructGet","visitStructSet","visitArrayNew","visitArrayGet","visitArraySet","visitArrayLen","visitRefAs","visitName","visitLabel","visitIndex","visitTag","previousExpression","Loop","_BinaryenBreakGetValue","Switch","_BinaryenSwitchGetDefaultName","_BinaryenSwitchGetNumNames","_BinaryenSwitchGetNameAt","_BinaryenSwitchGetCondition","_BinaryenSwitchGetValue","CallIndirect","_BinaryenCallIndirectGetTarget","_BinaryenCallIndirectGetNumOperands","_BinaryenCallIndirectGetOperandAt","GlobalSet","_BinaryenGlobalSetGetName","_BinaryenGlobalSetGetValue","Store","Drop","MemoryGrow","AtomicRMW","_BinaryenAtomicRMWGetPtr","_BinaryenAtomicRMWGetValue","AtomicCmpxchg","_BinaryenAtomicCmpxchgGetPtr","_BinaryenAtomicCmpxchgGetExpected","_BinaryenAtomicCmpxchgGetReplacement","AtomicWait","_BinaryenAtomicWaitGetPtr","_BinaryenAtomicWaitGetExpected","_BinaryenAtomicWaitGetTimeout","AtomicNotify","_BinaryenAtomicNotifyGetPtr","_BinaryenAtomicNotifyGetNotifyCount","AtomicFence","SIMDExtract","_BinaryenSIMDExtractGetVec","SIMDReplace","_BinaryenSIMDReplaceGetVec","_BinaryenSIMDReplaceGetValue","SIMDShuffle","_BinaryenSIMDShuffleGetLeft","_BinaryenSIMDShuffleGetRight","SIMDTernary","_BinaryenSIMDTernaryGetA","_BinaryenSIMDTernaryGetB","_BinaryenSIMDTernaryGetC","SIMDShift","_BinaryenSIMDShiftGetVec","_BinaryenSIMDShiftGetShift","SIMDLoad","_BinaryenSIMDLoadGetPtr","SIMDLoadStoreLane","_BinaryenSIMDLoadStoreLaneGetPtr","_BinaryenSIMDLoadStoreLaneGetVec","MemoryInit","_BinaryenMemoryInitGetDest","_BinaryenMemoryInitGetOffset","_BinaryenMemoryInitGetSize","MemoryCopy","_BinaryenMemoryCopyGetDest","_BinaryenMemoryCopyGetSource","_BinaryenMemoryCopyGetSize","MemoryFill","_BinaryenMemoryFillGetDest","_BinaryenMemoryFillGetValue","_BinaryenMemoryFillGetSize","Pop","RefIs","_BinaryenRefIsGetValue","RefFunc","_BinaryenRefFuncGetFunc","RefEq","_BinaryenRefEqGetLeft","_BinaryenRefEqGetRight","Try","_BinaryenTryGetBody","numCatchBodies","_BinaryenTryGetNumCatchBodies","_BinaryenTryGetCatchBodyAt","_BinaryenThrowGetTag","_BinaryenThrowGetNumOperands","_BinaryenThrowGetOperandAt","Rethrow","TupleMake","_BinaryenTupleMakeGetNumOperands","_BinaryenTupleMakeGetOperandAt","TupleExtract","_BinaryenTupleExtractGetTuple","I31New","_BinaryenI31NewGetValue","I31Get","_BinaryenI31GetGetI31","CallRef","RefTest","RefCast","BrOn","RttSub","StructNew","StructGet","StructSet","ArrayNew","ArrayGet","ArraySet","ArrayLen","RefAs","replaceChild","search","child","_BinaryenBlockSetChildAt","_BinaryenIfSetCondition","_BinaryenIfSetIfTrue","_BinaryenIfSetIfFalse","_BinaryenLoopSetBody","_BinaryenBreakSetCondition","_BinaryenBreakSetValue","_BinaryenSwitchSetCondition","_BinaryenSwitchSetValue","_BinaryenCallSetOperandAt","_BinaryenCallIndirectSetTarget","_BinaryenCallIndirectSetOperandAt","_BinaryenLocalSetSetValue","_BinaryenGlobalSetSetValue","_BinaryenLoadSetPtr","_BinaryenStoreSetPtr","_BinaryenStoreSetValue","_BinaryenUnarySetValue","_BinaryenBinarySetLeft","_BinaryenBinarySetRight","_BinaryenSelectSetIfTrue","_BinaryenSelectSetIfFalse","_BinaryenSelectSetCondition","_BinaryenDropSetValue","_BinaryenReturnSetValue","_BinaryenMemoryGrowSetDelta","_BinaryenAtomicRMWSetPtr","_BinaryenAtomicRMWSetValue","_BinaryenAtomicCmpxchgSetPtr","_BinaryenAtomicCmpxchgSetExpected","repl","_BinaryenAtomicCmpxchgSetReplacement","_BinaryenAtomicWaitSetPtr","_BinaryenAtomicWaitSetExpected","_BinaryenAtomicWaitSetTimeout","_BinaryenAtomicNotifySetPtr","_BinaryenAtomicNotifySetNotifyCount","_BinaryenSIMDExtractSetVec","_BinaryenSIMDReplaceSetVec","_BinaryenSIMDReplaceSetValue","_BinaryenSIMDShuffleSetLeft","_BinaryenSIMDShuffleSetRight","_BinaryenSIMDTernarySetA","_BinaryenSIMDTernarySetB","_BinaryenSIMDTernarySetC","_BinaryenSIMDShiftSetVec","_BinaryenSIMDShiftSetShift","_BinaryenSIMDLoadSetPtr","_BinaryenSIMDLoadStoreLaneSetPtr","_BinaryenSIMDLoadStoreLaneSetVec","_BinaryenMemoryInitSetDest","_BinaryenMemoryInitSetOffset","_BinaryenMemoryInitSetSize","_BinaryenMemoryCopySetDest","_BinaryenMemoryCopySetSource","_BinaryenMemoryCopySetSize","_BinaryenMemoryFillSetDest","_BinaryenMemoryFillSetValue","_BinaryenMemoryFillSetSize","_BinaryenRefIsSetValue","_BinaryenRefEqSetLeft","_BinaryenRefEqSetRight","_BinaryenTrySetBody","catchBody","_BinaryenTrySetCatchBodyAt","_BinaryenThrowSetOperandAt","_BinaryenTupleMakeSetOperandAt","_BinaryenTupleExtractSetTuple","_BinaryenI31NewSetValue","i31Expr","_BinaryenI31GetSetI31","currentFunction","_currentFunction","currentGlobal","_currentGlobal","walkFunctions","walkGlobals","moduleRef","_BinaryenGetNumFunctions","walkFunction","_BinaryenGetFunctionByIndex","_BinaryenGetNumGlobals","walkGlobal","_BinaryenGetGlobalByIndex","init","replaceCurrent","_BinaryenFunctionSetBody","_BinaryenExpressionFinalize","Pass","seenStores","ptrType","checkRT","matchPattern","needsSlot","slotMaps","tempMaps","exportMap","ptrSize","ptrBinaryAdd","ptrBinarySub","ptrConst","noteSlot","slotMap","slotIndex","managedOperandIndices","getSharedTemp","tempMap","_BinaryenFunctionGetNumLocals","makeStackOffset","makeStackCheck","makeStackFill","frameSize","remain","hasStackCheckFunction","nativeSource","updateCallOperands","numSlots","match","callSlotOffset","callSlotStack","callIndirect","updateFunction","numVars","vars","updateExport","exportRef","_BinaryenExportGetKind","internalNameRef","_BinaryenExportGetValue","externalNameRef","_BinaryenExportGetName","expandType","numParams","wrapperName","wrapperNameRef","instrumentReturns","InstrumentReturns","bodyType","parentPass","AL_MASK","AL_SIZE","QueuedImport","localFile","localIdentifier","foreignIdentifier","foreignPath","foreignPathAlt","QueuedExport","QueuedExportStar","pathLiteral","fromDecorator","UNCHECKED_INDEXED_GET","UNCHECKED_INDEXED_SET","INVALID","fromBinaryToken","fromUnaryPrefixToken","fromUnaryPostfixToken","Resolver","nativeFile","File","nextClassId","nextSignatureId","initialized","elementsByDeclaration","wrapperClasses","uniqueSignatures","_arrayBufferViewInstance","requireClass","_arrayBufferInstance","_arrayPrototype","_staticArrayPrototype","_setPrototype","_mapPrototype","_functionPrototype","int8ArrayPrototype","_int8ArrayPrototype","int16ArrayPrototype","_int16ArrayPrototype","int32ArrayPrototype","_int32ArrayPrototype","int64ArrayPrototype","_int64ArrayPrototype","uint8ArrayPrototype","_uint8ArrayPrototype","uint8ClampedArrayPrototype","_uint8ClampedArrayPrototype","uint16ArrayPrototype","_uint16ArrayPrototype","uint32ArrayPrototype","_uint32ArrayPrototype","uint64ArrayPrototype","_uint64ArrayPrototype","float32ArrayPrototype","_float32ArrayPrototype","float64ArrayPrototype","_float64ArrayPrototype","_stringInstance","objectInstance","_objectInstance","_templateStringsArrayInstance","_allocInstance","reallocInstance","_reallocInstance","freeInstance","_freeInstance","_newInstance","renewInstance","_renewInstance","_linkInstance","collectInstance","_collectInstance","_visitInstance","typeinfoInstance","_typeinfoInstance","_instanceofInstance","_newBufferInstance","_newArrayInstance","BLOCKInstance","_BLOCKInstance","_OBJECTInstance","blockOverhead","objectOverhead","computeBlockStart","currentOffset","computeBlockSize","payloadSize","blockSize","blockMinsize","makeNativeVariableDeclaration","makeNativeTypeDeclaration","nativeDummySignature","makeNativeNamespaceDeclaration","decoratorFlags","registerNativeType","TypeDefinition","registerConstantInteger","queuedImports","queuedExports","queuedExportsStar","queuedExtends","queuedImplements","initializeExports","initializeExportDefault","initializeImports","initializeVariables","initializeClass","initializeEnum","initializeFunction","initializeInterface","initializeNamespace","initializeTypeDefinition","starExports","foreignFile","lookupForeignFile","ensureExportStar","madeProgress","queuedImport","lookupForeign","splice","asAliasNamespace","Module_0_has_no_exported_member_1","exportNames","queuedExport","ensureExport","globalElement","isDeclaredElement","registerWrapperClass","thisPrototype","baseElement","basePrototype","Class_0_is_final_and_cannot_be_extended","Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa","A_class_may_only_extend_another_class","An_interface_can_only_extend_an_interface","implementsNodes","implementsNode","interfaceElement","interfacePrototype","interfacePrototypes","A_class_can_only_implement_an_interface","markVirtuals","firstChar","parseInt","markModuleExports","thisInstanceMembers","baseInstanceMembers","thisMember","baseMember","thisMethod","baseMethod","visibilityEquals","Overload_signatures_must_all_be_public_private_or_protected","overloads","baseMethodInstances","thisProperty","baseProperty","baseGetter","getterPrototype","thisGetter","baseGetterInstances","baseSetter","setterPrototype","thisSetter","baseSetterInstances","nextPrototype","markModuleExport","className","classElement","wrappedType","isIntegerInclReference","Global","registerConstantFloat","ensureGlobal","merged","tryMerge","lookupExport","fileQueuedExports","queuedExportForeignPath","otherFile","checkDecorators","acceptedFlags","fromKind","Duplicate_decorator","ClassPrototype","Unmanaged_classes_cannot_implement_interfaces","memberDeclarations","memberDeclaration","initializeField","methodDeclaration","initializeProperty","method","initializeMethod","FieldPrototype","addInstance","checkOperatorOverloads","firstArg","_0_is_not_a_valid_operator","overloadPrototypes","Duplicate_function_implementation","operatorKind","ensureProperty","parentMembers","PropertyPrototype","Duplicate_property_0","Enum","initializeEnumValue","EnumValue","initializeExport","queued","endsWith","Export_declaration_conflicts_with_exported_declaration_of_0","initializeImport","validDecorators","InterfacePrototype","initializeFieldAsProperty","Namespace","copyMembers","Element","shadowType","FILE","localIdentifierIfImport","originalDeclaration","reportedIdentifier","isBound","isPublic","isImplicitlyPublic","vis","declaredElements","DeclaredElement","isCompatibleOverride","selfProperty","selfGetter","selfSetter","typedElements","TypedElement","aliasNamespaces","ns","copyExportsToNamespace","ConstantValueKind","VariableLikeElement","boundPrototypes","parentKind","toBound","bound","getResolvedInstance","instanceKey","nameInclTypeParameters","parameterType","parameterName","createParent","registerConcreteElement","getDefaultParameterName","postfix","FIELD_PROTOTYPE","_internalGetterName","_internalSetterName","_internalGetterSignature","_internalSetterSignature","getGetterInstance","getSetterInstance","_isInterface","isBuiltinArray","basePtototype","Class","interfaces","_id","implementers","lengthField","setBase","inheritedTypeArguments","baseName","baseType","addInterface","iface","uncheckedOverload","overhead","baseOffset","typeKind","writeI32AsI64","writeI64AsI32","extendedPrototype","exceptIfMember","older","newer","Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local","src","srcMembers","destMembers","asGlobal","cachedDefaultParameterNames","ctxElement","ctxTypes","reportMode","resolveNamedType","resolveFunctionType","isSimpleType","simpleName","Type_0_cannot_be_nullable","typeDefinition","resolveBuiltinNativeType","resolveBuiltinIndexofType","resolveBuiltinValueofType","resolveBuiltinReturnTypeType","resolveBuiltinNotNullableType","parameterTypeNode","returnTypeNode","typeArgumentNode","ensureOneTypeArgument","typeArgument","prev","alternativeReportNode","minParameterCount","maxParameterCount","argumentCount","oldCtxTypes","ctxFlow","resolveFunctionInclTypeArguments","typeParameterNames","argumentNodes","argumentExpression","propagateInferredGenericTypes","resolvedTypeArguments","typeParameterNode","inferredType","resolvedDefaultType","Type_argument_expected","ensureResolvedLazyGlobal","isTypedElement","getElementOfType","lookupAssertionExpression","lookupBinaryExpression","lookupCallExpression","lookupCommaExpression","lookupElementAccessExpression","lookupFunctionExpression","lookupThisExpression","lookupSuperExpression","lookupInstanceOfExpression","lookupLiteralExpression","lookupNewExpression","lookupPropertyAccessExpression","lookupTernaryExpression","lookupUnaryPostfixExpression","lookupUnaryPrefixExpression","resolveAssertionExpression","resolveBinaryExpression","resolveCallExpression","resolveCommaExpression","resolveElementAccessExpression","resolveFunctionExpression","resolveIdentifierExpression","resolveThisExpression","resolveSuperExpression","resolveInstanceOfExpression","resolveLiteralExpression","resolveNewExpression","resolvePropertyAccessExpression","resolveTernaryExpression","resolveUnaryPostfixExpression","resolveUnaryPrefixExpression","targetNode","propertyName","variableLikeElement","wrapper","baseInstance","i64_is_i8","i64_is_u8","i64_is_i16","i64_is_u16","i64_is_bool","Type_0_is_illegal_in_this_context","superLocal","fltType","numNullLiterals","The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly","isClass","varType","varElement","thenType","elseType","typesToString","resolvedInstance","classTypeArguments","classTypeParameters","numClassTypeArguments","classTypeParameterName","numFunctionTypeArguments","signatureParameters","numSignatureParameters","parameterDeclaration","methodOrPropertyName","baseMembers","parentClassInstance","unboundOverloadPrototype","unboundOverloadParent","isProperty","propertyParent","boundProperty","boundPropertyInstance","boundPrototype","resolveClassPending","nameInclTypeParamters","Interface","pendingClasses","anyPending","_0_is_referenced_directly_or_indirectly_in_its_own_base_expression","finishResolveClass","unimplemented","ifaceMembers","This_overload_signature_is_not_compatible_with_its_implementation_signature","instanceMemberPrototypes","properties","fieldTypeNode","baseField","Field","propertyGetter","propertySetter","Getter_and_setter_accessors_do_not_agree_in_visibility","Property_0_only_has_a_setter_and_is_missing_a_getter","Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2","overloadKind","overloadPrototype","IndexSignature","pending","dependsOnInstance","_values2","Property","tokenFromKeyword","ASYNC","AWAIT","DEBUGGER","IS","KEYOF","MODULE","PACKAGE","WITH","tokenIsAlsoIdentifier","atStart","identifierHandling","unsafeNext","maxTokenLength","chr","isDecimalDigit","commentStartPos","LINE","TRIPLE","closed","testInteger","isIdentifierStart","posBefore","isIdentifierPart","maybeKeywordToken","isWhiteSpace","Invalid_character","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","reusableState","State","isTaggedTemplate","Unterminated_string_literal","readEscapeSequence","readExtendedUnicodeEscape","readUnicodeEscape","readHexadecimalEscape","fromCharCode","escaped","Unterminated_regular_expression_literal","Invalid_regular_expression_flags","readHexInteger","readBinaryInteger","readOctalInteger","isOctalDigit","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","sepEnd","i64_4","i64_shl","Numeric_separators_are_not_allowed_here","Multiple_consecutive_numeric_separators_are_not_permitted","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_3","Octal_digit_expected","i64_1","Binary_digit_expected","readDecimalFloat","sepCount","readDecimalFloatPartial","replaceAll","parseFloat","allowLeadingZeroSep","readHexFloat","startIfTaggedTemplate","An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","TypeKind","TypeFlags","_nonNullableType","_nullableType","isVectorValue","nullableType","signednessIsRelevant","currentClass","targetClass","targetFunction","signednessIsImportant","validWat","nullablePostfix","numTypes","signatureTypes","compare","numParameterTypes","typeRefs","thisThisType","otherThisType","thisParameterTypes","otherParameterTypes","requireSameSize","targetThisType","targetParameterTypes","thisParameterType","targetParameterType","thisReturnType","targetReturnType","indices","optionalStart","restIndex","cloneParameterTypes","readI64","lo","hi","unsigned","i32_as_f32","f32_as_i32","i64_as_f64","valueI64","f64_as_i64","overrides","cloned","v","x","separator","ipos","dirname","origin","COLOR_GRAY","COLOR_GREEN","COLOR_BLUE","COLOR_WHITE","colorsEnabled","isEnabled","color","CharCode","c0","lookupInUnicodeMap","unicodeIdentifierStart","unicodeIdentifierPart","map","mid","midVal","unmanaged","Long","defineProperty","default","wasm","WebAssembly","Instance","e","low","high","isLong","obj","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","fromString","radix","RangeError","p","radixToPower","power","fromValue","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","isZero","isNegative","eq","radixLong","rem1","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","b00","divide","divisor","approx","res","toUnsigned","shru","shr","shl","log2","log","LN2","approxRes","approxRem","modulo","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","rotateLeft","rotateRight","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","_default","g","wrapModule","emitStackIR","emitText","emitAsmjs","keys","i64_one","i64_neg_one","i64_pow","rightLo","rightHi","i64_div","i64_rem","i64_rem_u","i64_and","i64_or","i64_xor","i64_shr","i64_not","i64_eq","minSafeF32","MIN_SAFE_INTEGER","maxSafeF32","MAX_SAFE_INTEGER","i64_is_f32","minSafeF64","maxSafeF64","i64_is_f64","fround","globalScope","window","ASC_FEATURE_MUTABLE_GLOBAL","UnreachableError","captureStackTrace","AssertionError","defaultComparator","nanA","nanB","defineProperties","writable","Infinity","NaN","clz32","INV_EPS64","y","sign","isTrueish","CHUNKSIZE","apply","fromCodePoint","at","charAt","configurable","replacment","split","arraySort","sort","comparator","forEach","Ctr","findLastIndex","Number","sincos_sin","sincos_cos","signbit","Boolean","sincos","sin","cos","exp2","arguments","console","byteOffset","warn","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis"],"sourceRoot":""}